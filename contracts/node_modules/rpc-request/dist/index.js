export class UnsuccessfulFetch extends Error {
    #response;
    #data;
    constructor(response, data) {
        super(response.statusText);
        this.name = "UnsuccessfulFetch";
        this.#response = response;
        this.#data = data;
    }
    get data() {
        return this.#data;
    }
    get response() {
        return this.#response;
    }
}
export class Fetch {
    #transform;
    #base_url;
    #reject;
    #init;
    constructor({ transform = null, base_url = null, reject = true, ...init } = {}) {
        this.#init = init;
        this.#reject = reject;
        this.#transform = transform;
        this.#base_url = base_url === null ? null : new URL(base_url.toString());
    }
    get reject() {
        return this.#reject;
    }
    get transform() {
        return this.#transform;
    }
    get base_url() {
        return this.#base_url ? new URL(this.#base_url) : null;
    }
    get init() {
        return this.#init;
    }
    get(path = "", init = {}) {
        return this.fetch(path, { ...init, method: "GET" });
    }
    head(path = "", init = {}) {
        return this.fetch(path, { ...init, method: "HEAD" });
    }
    post(path = "", init = {}) {
        return this.fetch(path, { ...init, method: "POST" });
    }
    put(path = "", init = {}) {
        return this.fetch(path, { ...init, method: "PUT" });
    }
    delete(path = "", init = {}) {
        return this.fetch(path, { ...init, method: "DELETE" });
    }
    options(path = "", init = {}) {
        return this.fetch(path, { ...init, method: "OPTIONS" });
    }
    patch(path = "", init = {}) {
        return this.fetch(path, { ...init, method: "PATCH" });
    }
    async fetch(path = "", { base_url = this.#base_url, transform = this.#transform, reject = this.#reject, ...init } = {}) {
        const url = typeof base_url === "string" || base_url instanceof URL
            ? new URL(path, base_url)
            : new URL(path);
        const headers = Fetch.#mergeHeaders(this.#init.headers, init.headers);
        const response = await fetch(url, { ...this.#init, ...init, headers });
        if (transform === null) {
            return response;
        }
        // eslint-disable-next-line init-declarations
        let body;
        if (init.method === "HEAD") {
            body = (await response.text());
        }
        else if (transform === "buffer" || transform === "arrayBuffer") {
            const arrayBuffer = await response.arrayBuffer();
            const output = transform === "arrayBuffer" ? arrayBuffer : Buffer.from(arrayBuffer);
            body = output;
        }
        else {
            body = (await response[transform]());
        }
        if (reject && !response.ok) {
            throw new UnsuccessfulFetch(response, body);
        }
        else if (init.method === "HEAD") {
            return response;
        }
        return body;
    }
    static #mergeHeaders(...headersInit) {
        const out = new Headers();
        for (const init of headersInit) {
            const headers = new Headers(init);
            for (const [key, value] of headers) {
                out.set(key, value);
            }
        }
        return out;
    }
}
export default Fetch;
