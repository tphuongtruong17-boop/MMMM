import { g as getDefaultExportFromCjs$1, r as requireSecp256k1, a as requireUtils$1, b as requireModular, c as getAugmentedNamespace, F as FFTCore, d as reverseBits, e as abool, s as secp256k1, m as mod$1, f as bytesToNumberBE } from './noble-curves.js';
import { l as sha256$2, m as sha256$3, n as ripemd160$1, o as sha1$2, p as requireRipemd160, q as requireSha256$1, a as requireHmac, t as requireSha512$1, u as abytes$2, v as randomBytes$2, w as concatBytes$1, x as isBytes$2, y as shake128, z as shake256, A as sha512$1, B as sha1$3, k as hmac, C as pbkdf2, D as utf8ToBytes, s as sha256$4, j as randomBytes$3, e as concatBytes$2, E as requirePbkdf2, r as requireUtils$2 } from './noble-hashes.js';
import { r as requireDist$3 } from './valibot.js';

function _mergeNamespaces(n, m) {
	for (var i = 0; i < m.length; i++) {
		const e = m[i];
		if (typeof e !== 'string' && !Array.isArray(e)) { for (const k in e) {
			if (k !== 'default' && !(k in n)) {
				const d = Object.getOwnPropertyDescriptor(e, k);
				if (d) {
					Object.defineProperty(n, k, d.get ? d : {
						enumerable: true,
						get: () => e[k]
					});
				}
			}
		} }
	}
	return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }));
}

var buffer = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(
      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(
      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
    );
  }
  return parts.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer2[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d, nBits -= 8) {
  }
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer2[offset + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
  }
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer2[offset + i - d] |= s * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports$1) {
  const base64 = base64Js;
  const ieee754$1 = ieee754;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports$1.Buffer = Buffer2;
  exports$1.SlowBuffer = SlowBuffer2;
  exports$1.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports$1.kMaxLength = K_MAX_LENGTH;
  const { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      const arr = new GlobalUint8Array(1);
      const proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, GlobalUint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this)) return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this)) return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new GlobalUint8Array(length);
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function Buffer2(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer2.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (GlobalArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof GlobalSharedArrayBuffer !== "undefined" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer2.from(valueOf, encodingOrOffset, length);
    }
    const b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
    );
  }
  Buffer2.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer2.prototype, GlobalUint8Array.prototype);
  Object.setPrototypeOf(Buffer2, GlobalUint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer2.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer2.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer2.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength2(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for (let i = 0; i < length; i += 1) {
      buf[i] = array[i] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, GlobalUint8Array)) {
      const copy = new GlobalUint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new GlobalUint8Array(array);
    } else if (length === void 0) {
      buf = new GlobalUint8Array(array, byteOffset);
    } else {
      buf = new GlobalUint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer2(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer2.alloc(+length);
  }
  Buffer2.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer2.prototype;
  };
  Buffer2.compare = function compare(a, b) {
    if (isInstance(a, GlobalUint8Array)) a = Buffer2.from(a, a.offset, a.byteLength);
    if (isInstance(b, GlobalUint8Array)) b = Buffer2.from(b, b.offset, b.byteLength);
    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a === b) return 0;
    let x = a.length;
    let y = b.length;
    for (let i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
      }
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    let i;
    if (length === void 0) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }
    const buffer2 = Buffer2.allocUnsafe(length);
    let pos = 0;
    for (i = 0; i < list.length; ++i) {
      let buf = list[i];
      if (isInstance(buf, GlobalUint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer2.isBuffer(buf)) buf = Buffer2.from(buf);
          buf.copy(buffer2, pos);
        } else {
          GlobalUint8Array.prototype.set.call(
            buffer2,
            buf,
            pos
          );
        }
      } else if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string, encoding) {
    if (Buffer2.isBuffer(string)) {
      return string.length;
    }
    if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
      );
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding) encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
  }
  Buffer2.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals(b) {
    if (!Buffer2.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return Buffer2.compare(this, b) === 0;
  };
  Buffer2.prototype.inspect = function inspect() {
    let str = "";
    const max = exports$1.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, GlobalUint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      );
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
      }
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0) return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir) return -1;
      else byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof GlobalUint8Array.prototype.indexOf === "function") {
        if (dir) {
          return GlobalUint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return GlobalUint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    let i;
    if (dir) {
      let foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        let found = true;
        for (let j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break;
          }
        }
        if (found) return i;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i;
    for (i = 0; i < length; ++i) {
      const parsed = parseInt(string.substr(i * 2, 2), 16);
      if (numberIsNaN(parsed)) return i;
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer2.prototype.write = function write(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0) encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    const remaining = this.length - offset;
    if (length === void 0 || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding) encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while (i < end) {
      const firstByte = buf[i];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = "";
    for (let i = start; i < end; ++i) {
      out += hexSliceLookupTable[buf[i]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    for (let i = 0; i < bytes.length - 1; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    let val = this[offset + --byteLength3];
    let mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength3] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    let i = byteLength3;
    let mul = 1;
    let val = this[offset + --i];
    while (i > 0 && (mul *= 256)) {
      val += this[offset + --i] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128)) return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
  });
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer2.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
  }
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
    if (value < 0) value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0) value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof GlobalUint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      GlobalUint8Array.prototype.set.call(
        target,
        this.subarray(start, end),
        targetStart
      );
    }
    return len;
  };
  Buffer2.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === "number") {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
      const len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }
    return this;
  };
  const errors = {};
  function E(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(name) {
      if (name) {
        return `${name} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  E(
    "ERR_INVALID_ARG_TYPE",
    function(name, actual) {
      return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
    },
    TypeError
  );
  E(
    "ERR_OUT_OF_RANGE",
    function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    },
    RangeError
  );
  function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i >= start + 4; i -= 3) {
      res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
  }
  function checkBounds(buf, offset, byteLength3) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
      boundsError(offset, buf.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value, min, max, buf, offset, byteLength3) {
    if (value > max || value < min) {
      const n = typeof min === "bigint" ? "n" : "";
      let range;
      {
        if (min === 0 || min === BigInt(0)) {
          range = `>= 0${n} and < 2${n} ** ${(byteLength3 + 1) * 8}${n}`;
        } else {
          range = `>= -(2${n} ** ${(byteLength3 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n}`;
        }
      }
      throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength3);
  }
  function validateNumber(value, name) {
    if (typeof value !== "number") {
      throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
  }
  function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type);
      throw new errors.ERR_OUT_OF_RANGE("offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(
      "offset",
      `>= ${0} and <= ${length}`,
      value
    );
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2) return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1) bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0) break;
        bytes.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0) break;
        bytes.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0) break;
        bytes.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    let i;
    for (i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length) break;
      dst[i + offset] = src[i];
    }
    return i;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = (function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for (let i = 0; i < 16; ++i) {
      const i16 = i * 16;
      for (let j = 0; j < 16; ++j) {
        table[i16 + j] = alphabet[i] + alphabet[j];
      }
    }
    return table;
  })();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(buffer);
const Buffer$1 = buffer.Buffer;
const Buffer$1$1 = buffer.Buffer;

/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
const Z_FIXED$1 = 4;
const Z_BINARY = 0;
const Z_TEXT = 1;
const Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
const STORED_BLOCK = 0;
const STATIC_TREES = 1;
const DYN_TREES = 2;
const MIN_MATCH$1 = 3;
const MAX_MATCH$1 = 258;
const LENGTH_CODES$1 = 29;
const LITERALS$1 = 256;
const L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
const D_CODES$1 = 30;
const BL_CODES$1 = 19;
const HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
const MAX_BITS$1 = 15;
const Buf_size = 16;
const MAX_BL_BITS = 7;
const END_BLOCK = 256;
const REP_3_6 = 16;
const REPZ_3_10 = 17;
const REPZ_11_138 = 18;
const extra_lbits = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
);
const extra_dbits = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
);
const extra_blbits = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
);
const bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
const DIST_CODE_LEN = 512;
const static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
const static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
const _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
const _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
const base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
const base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
let static_l_desc;
let static_d_desc;
let static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
const d_code = (dist) => {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
const put_short = (s, w) => {
  s.pending_buf[s.pending++] = w & 255;
  s.pending_buf[s.pending++] = w >>> 8 & 255;
};
const send_bits = (s, value, length) => {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
const send_code = (s, c, tree) => {
  send_bits(
    s,
    tree[c * 2],
    tree[c * 2 + 1]
    /*.Len*/
  );
};
const bi_reverse = (code, len) => {
  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};
const bi_flush = (s) => {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};
const gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m;
  let bits;
  let xbits;
  let f;
  let overflow = 0;
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
};
const gen_codes = (tree, max_code, bl_count) => {
  const next_code = new Array(MAX_BITS$1 + 1);
  let code = 0;
  let bits;
  let n;
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    code = code + bl_count[bits - 1] << 1;
    next_code[bits] = code;
  }
  for (n = 0; n <= max_code; n++) {
    let len = tree[n * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n * 2] = bi_reverse(next_code[len]++, len);
  }
};
const tr_static_init = () => {
  let n;
  let bits;
  let length;
  let code;
  let dist;
  const bl_count = new Array(MAX_BITS$1 + 1);
  length = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < 1 << extra_lbits[code]; n++) {
      _length_code[length++] = code;
    }
  }
  _length_code[length - 1] = code;
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < 1 << extra_dbits[code]; n++) {
      _dist_code[dist++] = code;
    }
  }
  dist >>= 7;
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1] = 5;
    static_dtree[n * 2] = bi_reverse(n, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
const init_block = (s) => {
  let n;
  for (n = 0; n < L_CODES$1; n++) {
    s.dyn_ltree[n * 2] = 0;
  }
  for (n = 0; n < D_CODES$1; n++) {
    s.dyn_dtree[n * 2] = 0;
  }
  for (n = 0; n < BL_CODES$1; n++) {
    s.bl_tree[n * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.sym_next = s.matches = 0;
};
const bi_windup = (s) => {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};
const smaller = (tree, n, m, depth) => {
  const _n2 = n * 2;
  const _m2 = m * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
};
const pqdownheap = (s, tree, k) => {
  const v = s.heap[k];
  let j = k << 1;
  while (j <= s.heap_len) {
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }
    s.heap[k] = s.heap[j];
    k = j;
    j <<= 1;
  }
  s.heap[k] = v;
};
const compress_block = (s, ltree, dtree) => {
  let dist;
  let lc;
  let sx = 0;
  let code;
  let extra;
  if (s.sym_next !== 0) {
    do {
      dist = s.pending_buf[s.sym_buf + sx++] & 255;
      dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
      lc = s.pending_buf[s.sym_buf + sx++];
      if (dist === 0) {
        send_code(s, lc, ltree);
      } else {
        code = _length_code[lc];
        send_code(s, code + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);
        }
        dist--;
        code = d_code(dist);
        send_code(s, code, dtree);
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);
        }
      }
    } while (sx < s.sym_next);
  }
  send_code(s, END_BLOCK, ltree);
};
const build_tree = (s, desc) => {
  const tree = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n, m;
  let max_code = -1;
  let node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;
  for (n = 0; n < elems; n++) {
    if (tree[n * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n = s.heap_len >> 1; n >= 1; n--) {
    pqdownheap(s, tree, n);
  }
  node = elems;
  do {
    n = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[
      1
      /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
    m = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[--s.heap_max] = n;
    s.heap[--s.heap_max] = m;
    tree[node * 2] = tree[n * 2] + tree[m * 2];
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1] = tree[m * 2 + 1] = node;
    s.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s, desc);
  gen_codes(tree, max_code, s.bl_count);
};
const scan_tree = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
const send_tree = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
const build_bl_tree = (s) => {
  let max_blindex;
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree(s, s.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
};
const send_all_trees = (s, lcodes, dcodes, blcodes) => {
  let rank2;
  send_bits(s, lcodes - 257, 5);
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s, s.dyn_ltree, lcodes - 1);
  send_tree(s, s.dyn_dtree, dcodes - 1);
};
const detect_data_type = (s) => {
  let block_mask = 4093624447;
  let n;
  for (n = 0; n <= 31; n++, block_mask >>>= 1) {
    if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s.dyn_ltree[n * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
};
let static_init_done = false;
const _tr_init$1 = (s) => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block(s);
};
const _tr_stored_block$1 = (s, buf, stored_len, last) => {
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
  bi_windup(s);
  put_short(s, stored_len);
  put_short(s, ~stored_len);
  if (stored_len) {
    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
  }
  s.pending += stored_len;
};
const _tr_align$1 = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};
const _tr_flush_block$1 = (s, buf, stored_len, last) => {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }
    build_tree(s, s.l_desc);
    build_tree(s, s.d_desc);
    max_blindex = build_bl_tree(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block$1(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block(s);
  if (last) {
    bi_windup(s);
  }
};
const _tr_tally$1 = (s, dist, lc) => {
  s.pending_buf[s.sym_buf + s.sym_next++] = dist;
  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
  s.pending_buf[s.sym_buf + s.sym_next++] = lc;
  if (dist === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist--;
    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s.dyn_dtree[d_code(dist) * 2]++;
  }
  return s.sym_next === s.sym_end;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};
const adler32 = (adler, buf, len, pos) => {
  let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
  while (len !== 0) {
    n = len > 2e3 ? 2e3 : len;
    len -= n;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32;
const makeTable = () => {
  let c, table = [];
  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table[n] = c;
  }
  return table;
};
const crcTable = new Uint32Array(makeTable());
const crc32 = (crc, buf, len, pos) => {
  const t = crcTable;
  const end = pos + len;
  crc ^= -1;
  for (let i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
  }
  return crc ^ -1;
};
var crc32_1 = crc32;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var constants$2 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
const {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;
const MAX_MEM_LEVEL = 9;
const MAX_WBITS$1 = 15;
const DEF_MEM_LEVEL = 8;
const LENGTH_CODES = 29;
const LITERALS = 256;
const L_CODES = LITERALS + 1 + LENGTH_CODES;
const D_CODES = 30;
const BL_CODES = 19;
const HEAP_SIZE = 2 * L_CODES + 1;
const MAX_BITS = 15;
const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
const PRESET_DICT = 32;
const INIT_STATE = 42;
const GZIP_STATE = 57;
const EXTRA_STATE = 69;
const NAME_STATE = 73;
const COMMENT_STATE = 91;
const HCRC_STATE = 103;
const BUSY_STATE = 113;
const FINISH_STATE = 666;
const BS_NEED_MORE = 1;
const BS_BLOCK_DONE = 2;
const BS_FINISH_STARTED = 3;
const BS_FINISH_DONE = 4;
const OS_CODE = 3;
const err$1 = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};
const rank = (f) => {
  return f * 2 - (f > 4 ? 9 : 0);
};
const zero = (buf) => {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
};
const slide_hash = (s) => {
  let n, m;
  let p;
  let wsize = s.w_size;
  n = s.hash_size;
  p = n;
  do {
    m = s.head[--p];
    s.head[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
  n = wsize;
  p = n;
  do {
    m = s.prev[--p];
    s.prev[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
};
let HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
let HASH = HASH_ZLIB;
const flush_pending = (strm) => {
  const s = strm.state;
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};
const flush_block_only = (s, last) => {
  _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};
const put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};
const putShortMSB = (s, b) => {
  s.pending_buf[s.pending++] = b >>> 8 & 255;
  s.pending_buf[s.pending++] = b & 255;
};
const read_buf = (strm, buf, start, size) => {
  let len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
};
const longest_match = (s, cur_match) => {
  let chain_length = s.max_chain_length;
  let scan = s.strstart;
  let match;
  let len;
  let best_len = s.prev_length;
  let nice_match = s.nice_match;
  const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
  const _win = s.window;
  const wmask = s.w_mask;
  const prev = s.prev;
  const strend = s.strstart + MAX_MATCH;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};
const fill_window = (s) => {
  const _w_size = s.w_size;
  let n, more, str;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      if (s.insert > s.strstart) {
        s.insert = s.strstart;
      }
      slide_hash(s);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
      while (s.insert) {
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
};
const deflate_stored = (s, flush) => {
  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
  let len, left, have, last = 0;
  let used = s.strm.avail_in;
  do {
    len = 65535;
    have = s.bi_valid + 42 >> 3;
    if (s.strm.avail_out < have) {
      break;
    }
    have = s.strm.avail_out - have;
    left = s.strstart - s.block_start;
    if (len > left + s.strm.avail_in) {
      len = left + s.strm.avail_in;
    }
    if (len > have) {
      len = have;
    }
    if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left + s.strm.avail_in)) {
      break;
    }
    last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
    _tr_stored_block(s, 0, 0, last);
    s.pending_buf[s.pending - 4] = len;
    s.pending_buf[s.pending - 3] = len >> 8;
    s.pending_buf[s.pending - 2] = ~len;
    s.pending_buf[s.pending - 1] = ~len >> 8;
    flush_pending(s.strm);
    if (left) {
      if (left > len) {
        left = len;
      }
      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
      s.strm.next_out += left;
      s.strm.avail_out -= left;
      s.strm.total_out += left;
      s.block_start += left;
      len -= left;
    }
    if (len) {
      read_buf(s.strm, s.strm.output, s.strm.next_out, len);
      s.strm.next_out += len;
      s.strm.avail_out -= len;
      s.strm.total_out += len;
    }
  } while (last === 0);
  used -= s.strm.avail_in;
  if (used) {
    if (used >= s.w_size) {
      s.matches = 2;
      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
      s.strstart = s.w_size;
      s.insert = s.strstart;
    } else {
      if (s.window_size - s.strstart <= used) {
        s.strstart -= s.w_size;
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;
        }
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
      s.strstart += used;
      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
    }
    s.block_start = s.strstart;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  if (last) {
    return BS_FINISH_DONE;
  }
  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start) {
    return BS_BLOCK_DONE;
  }
  have = s.window_size - s.strstart;
  if (s.strm.avail_in > have && s.block_start >= s.w_size) {
    s.block_start -= s.w_size;
    s.strstart -= s.w_size;
    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
    if (s.matches < 2) {
      s.matches++;
    }
    have += s.w_size;
    if (s.insert > s.strstart) {
      s.insert = s.strstart;
    }
  }
  if (have > s.strm.avail_in) {
    have = s.strm.avail_in;
  }
  if (have) {
    read_buf(s.strm, s.window, s.strstart, have);
    s.strstart += have;
    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  have = s.bi_valid + 42 >> 3;
  have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
  min_block = have > s.w_size ? s.w_size : have;
  left = s.strstart - s.block_start;
  if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && left <= have) {
    len = left > have ? have : left;
    last = flush === Z_FINISH$3 && s.strm.avail_in === 0 && len === left ? 1 : 0;
    _tr_stored_block(s, s.block_start, len, last);
    s.block_start += len;
    flush_pending(s.strm);
  }
  return last ? BS_FINISH_STARTED : BS_NEED_MORE;
};
const deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_slow = (s, flush) => {
  let hash_head;
  let bflush;
  let max_insert;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s.match_available) {
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_rle = (s, flush) => {
  let bflush;
  let prev;
  let scan, strend;
  const _win = s.window;
  for (; ; ) {
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_huff = (s, flush) => {
  let bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
const configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
];
const lm_init = (s) => {
  s.window_size = 2 * s.w_size;
  zero(s.head);
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero(this.depth);
  this.sym_buf = 0;
  this.lit_bufsize = 0;
  this.sym_next = 0;
  this.sym_end = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
const deflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const s = strm.state;
  if (!s || s.strm !== strm || s.status !== INIT_STATE && //#ifdef GZIP
  s.status !== GZIP_STATE && //#endif
  s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
    return 1;
  }
  return 0;
};
const deflateResetKeep = (strm) => {
  if (deflateStateCheck(strm)) {
    return err$1(strm, Z_STREAM_ERROR$2);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = //#ifdef GZIP
  s.wrap === 2 ? GZIP_STATE : (
    //#endif
    s.wrap ? INIT_STATE : BUSY_STATE
  );
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = -2;
  _tr_init(s);
  return Z_OK$3;
};
const deflateReset = (strm) => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};
const deflateSetHeader = (strm, head) => {
  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};
const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
  if (!strm) {
    return Z_STREAM_ERROR$2;
  }
  let wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
    return err$1(strm, Z_STREAM_ERROR$2);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.status = INIT_STATE;
  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);
  s.sym_buf = s.lit_bufsize;
  s.sym_end = (s.lit_bufsize - 1) * 3;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
};
const deflateInit = (strm, level) => {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};
const deflate$2 = (strm, flush) => {
  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err$1(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH$3) {
    return err$1(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }
  const old_flush = s.last_flush;
  s.last_flush = flush;
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
    return err$1(strm, Z_BUF_ERROR$1);
  }
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err$1(strm, Z_BUF_ERROR$1);
  }
  if (s.status === INIT_STATE && s.wrap === 0) {
    s.status = BUSY_STATE;
  }
  if (s.status === INIT_STATE) {
    let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
    let level_flags = -1;
    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
      level_flags = 0;
    } else if (s.level < 6) {
      level_flags = 1;
    } else if (s.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= level_flags << 6;
    if (s.strstart !== 0) {
      header |= PRESET_DICT;
    }
    header += 31 - header % 31;
    putShortMSB(s, header);
    if (s.strstart !== 0) {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    strm.adler = 1;
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (s.status === GZIP_STATE) {
    strm.adler = 0;
    put_byte(s, 31);
    put_byte(s, 139);
    put_byte(s, 8);
    if (!s.gzhead) {
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, OS_CODE);
      s.status = BUSY_STATE;
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    } else {
      put_byte(
        s,
        (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
      );
      put_byte(s, s.gzhead.time & 255);
      put_byte(s, s.gzhead.time >> 8 & 255);
      put_byte(s, s.gzhead.time >> 16 & 255);
      put_byte(s, s.gzhead.time >> 24 & 255);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, s.gzhead.os & 255);
      if (s.gzhead.extra && s.gzhead.extra.length) {
        put_byte(s, s.gzhead.extra.length & 255);
        put_byte(s, s.gzhead.extra.length >> 8 & 255);
      }
      if (s.gzhead.hcrc) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
      }
      s.gzindex = 0;
      s.status = EXTRA_STATE;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra) {
      let beg = s.pending;
      let left = (s.gzhead.extra.length & 65535) - s.gzindex;
      while (s.pending + left > s.pending_buf_size) {
        let copy = s.pending_buf_size - s.pending;
        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
        s.pending = s.pending_buf_size;
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        s.gzindex += copy;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left -= copy;
      }
      let gzhead_extra = new Uint8Array(s.gzhead.extra);
      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
      s.pending += left;
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = NAME_STATE;
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = COMMENT_STATE;
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
    }
    s.status = HCRC_STATE;
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      strm.adler = 0;
    }
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
    let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK$3;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      } else if (flush !== Z_BLOCK$1) {
        _tr_stored_block(s, 0, 0, false);
        if (flush === Z_FULL_FLUSH$1) {
          zero(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
  }
  if (flush !== Z_FINISH$3) {
    return Z_OK$3;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END$3;
  }
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 255);
    put_byte(s, strm.adler >> 8 & 255);
    put_byte(s, strm.adler >> 16 & 255);
    put_byte(s, strm.adler >> 24 & 255);
    put_byte(s, strm.total_in & 255);
    put_byte(s, strm.total_in >> 8 & 255);
    put_byte(s, strm.total_in >> 16 & 255);
    put_byte(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
const deflateEnd = (strm) => {
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const status = strm.state.status;
  strm.state = null;
  return status === BUSY_STATE ? err$1(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
const deflateSetDictionary = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  const wrap = s.wrap;
  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }
  if (wrap === 1) {
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      zero(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH - 1);
    do {
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1$2 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2$1,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo
};
const _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }
  return obj;
};
var flattenChunks = (chunks) => {
  let len = 0;
  for (let i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }
  const result = new Uint8Array(len);
  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common = {
  assign,
  flattenChunks
};
let STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
const _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }
  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf[i++] = c;
    } else if (c < 2048) {
      buf[i++] = 192 | c >>> 6;
      buf[i++] = 128 | c & 63;
    } else if (c < 65536) {
      buf[i++] = 224 | c >>> 12;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    } else {
      buf[i++] = 240 | c >>> 18;
      buf[i++] = 128 | c >>> 12 & 63;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    }
  }
  return buf;
};
const buf2binstring = (buf, len) => {
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }
  let result = "";
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};
var buf2string = (buf, max) => {
  const len = max || buf.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }
  let i, out;
  const utf16buf = new Array(len * 2);
  for (out = 0, i = 0; i < len; ) {
    let c = buf[i++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    let c_len = _utf8len[c];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i < len) {
      c = c << 6 | buf[i++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
var utf8border = (buf, max) => {
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len[buf[pos]] > max ? pos : max;
};
var strings = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
const toString$1 = Object.prototype.toString;
const {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
Deflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
  if (typeof data === "string") {
    strm.input = strings.string2buf(data);
  } else if (toString$1.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1$2.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};
Deflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$1(input, options) {
  const deflator = new Deflate$1(options);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || messages[deflator.err];
  }
  return deflator.result;
}
function deflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}
function gzip$1(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}
var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var deflate_1$1 = {
  Deflate: Deflate_1$1,
  deflate: deflate_2,
  deflateRaw: deflateRaw_1$1,
  gzip: gzip_1$1};
const BAD$1 = 16209;
const TYPE$1 = 16191;
var inffast = function inflate_fast(strm, start) {
  let _in;
  let last;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len;
  let dist;
  let from;
  let from_source;
  let input, output;
  const state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    }
                    while (len > 2) {
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output[_out++] = from_source[from++];
                      if (len > 1) {
                        output[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output[_out++] = output[from++];
                      if (len > 1) {
                        output[_out++] = output[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last && _out < end);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};
const MAXBITS = 15;
const ENOUGH_LENS$1 = 852;
const ENOUGH_DISTS$1 = 592;
const CODES$1 = 0;
const LENS$1 = 1;
const DISTS$1 = 2;
const lbase = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
const lext = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
const dbase = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
const dext = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
  const bits = opts.bits;
  let len = 0;
  let sym = 0;
  let min = 0, max = 0;
  let root = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask;
  let next;
  let base = null;
  let match;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES$1 || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES$1) {
    base = extra = work;
    match = 20;
  } else if (type === LENS$1) {
    base = lbase;
    extra = lext;
    match = 257;
  } else {
    base = dbase;
    extra = dext;
    match = 0;
  }
  huff = 0;
  sym = 0;
  len = min;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask = used - 1;
  if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base[work[sym] - match];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
};
var inftrees = inflate_table;
const CODES = 0;
const LENS = 1;
const DISTS = 2;
const {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;
const HEAD = 16180;
const FLAGS = 16181;
const TIME = 16182;
const OS = 16183;
const EXLEN = 16184;
const EXTRA = 16185;
const NAME = 16186;
const COMMENT = 16187;
const HCRC = 16188;
const DICTID = 16189;
const DICT = 16190;
const TYPE = 16191;
const TYPEDO = 16192;
const STORED = 16193;
const COPY_ = 16194;
const COPY = 16195;
const TABLE = 16196;
const LENLENS = 16197;
const CODELENS = 16198;
const LEN_ = 16199;
const LEN = 16200;
const LENEXT = 16201;
const DIST = 16202;
const DISTEXT = 16203;
const MATCH = 16204;
const LIT = 16205;
const CHECK = 16206;
const LENGTH = 16207;
const DONE = 16208;
const BAD = 16209;
const MEM = 16210;
const SYNC = 16211;
const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
const MAX_WBITS = 15;
const DEF_WBITS = MAX_WBITS;
const zswap32 = (q) => {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
};
function InflateState() {
  this.strm = null;
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
const inflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};
const inflateResetKeep = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1;
};
const inflateReset = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
const inflateReset2 = (strm, windowBits) => {
  let wrap;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};
const inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state = new InflateState();
  strm.state = state;
  state.strm = strm;
  state.window = null;
  state.mode = HEAD;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
};
const inflateInit = (strm) => {
  return inflateInit2(strm, DEF_WBITS);
};
let virgin = true;
let lenfix, distfix;
const fixedtables = (state) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};
const updatewindow = (strm, src, end, copy) => {
  let dist;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
};
const inflate$2 = (strm, flush) => {
  let state;
  let input, output;
  let next;
  let put;
  let have, left;
  let hold;
  let bits;
  let _in, _out;
  let copy;
  let from;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n;
  const order = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            if (state.wbits === 0) {
              state.wbits = 15;
            }
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS;
            break;
          }
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          }
          if (len > 15 || len > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD;
            break;
          }
          state.dmax = 1 << state.wbits;
          state.flags = 0;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = TIME;
        /* falls through */
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32_1(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = OS;
        /* falls through */
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = EXLEN;
        /* falls through */
        case EXLEN:
          if (state.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        /* falls through */
        case EXTRA:
          if (state.flags & 1024) {
            copy = state.length;
            if (copy > have) {
              copy = have;
            }
            if (copy) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(
                  input.subarray(
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    next + copy
                  ),
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state.flags & 512 && state.wrap & 4) {
                state.check = crc32_1(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              state.length -= copy;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        /* falls through */
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        /* falls through */
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        /* falls through */
        case HCRC:
          if (state.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT;
        /* falls through */
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE;
        /* falls through */
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case TYPEDO:
          if (state.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits = 0;
          state.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case COPY_:
          state.mode = COPY;
        /* falls through */
        case COPY:
          copy = state.length;
          if (copy) {
            if (copy > have) {
              copy = have;
            }
            if (copy > left) {
              copy = left;
            }
            if (copy === 0) {
              break inf_leave;
            }
            output.set(input.subarray(next, next + copy), put);
            have -= copy;
            next += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          }
          state.mode = TYPE;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        /* falls through */
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        /* falls through */
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n = here_bits + 2;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                len = state.lens[state.have - 1];
                copy = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n = here_bits + 3;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n = here_bits + 7;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state.have + copy > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD;
                break;
              }
              while (copy--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD;
            break;
          }
          state.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case LEN_:
          state.mode = LEN;
        /* falls through */
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inffast(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        /* falls through */
        case LENEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        /* falls through */
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        /* falls through */
        case DISTEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD;
            break;
          }
          state.mode = MATCH;
        /* falls through */
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy = _out - left;
          if (state.offset > copy) {
            copy = state.offset - copy;
            if (copy > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
            }
            if (copy > state.wnext) {
              copy -= state.wnext;
              from = state.wsize - copy;
            } else {
              from = state.wnext - copy;
            }
            if (copy > state.length) {
              copy = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output;
            from = put - state.offset;
            copy = state.length;
          }
          if (copy > left) {
            copy = left;
          }
          left -= copy;
          state.length -= copy;
          do {
            output[put++] = from_source[from++];
          } while (--copy);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (state.wrap & 4 && _out) {
              strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
              state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
            }
            _out = left;
            if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = LENGTH;
        /* falls through */
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = DONE;
        /* falls through */
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        /* falls through */
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap & 4 && _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
const inflateEnd = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
const inflateGetHeader = (strm, head) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head;
  head.done = false;
  return Z_OK$1;
};
const inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader;
const toString = Object.prototype.toString;
const {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2;
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
Inflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended) return false;
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (toString.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        status = Z_NEED_DICT;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK && last_avail_out === 0) continue;
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);
  inflator.push(input);
  if (inflator.err) throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}
var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var inflate_1$1 = {
  Inflate: Inflate_1$1,
  inflate: inflate_2,
  inflateRaw: inflateRaw_1$1,
  ungzip: ungzip$1};
const { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;
const { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
var Deflate_1 = Deflate;
var deflate_1 = deflate;
var deflateRaw_1 = deflateRaw;
var gzip_1 = gzip;
var Inflate_1 = Inflate;
var inflate_1 = inflate;
var inflateRaw_1 = inflateRaw;
var ungzip_1 = ungzip;
var constants_1 = constants$2;
var pako = {
  Deflate: Deflate_1,
  deflate: deflate_1,
  deflateRaw: deflateRaw_1,
  gzip: gzip_1,
  Inflate: Inflate_1,
  inflate: inflate_1,
  inflateRaw: inflateRaw_1,
  ungzip: ungzip_1,
  constants: constants_1
};

function gzipSync(data, options = {}) {
    return Buffer$1.from(pako.gzip(data, { level: options.level || 6 }));
}

function gunzipSync(data) {
    return Buffer$1.from(pako.ungzip(data));
}

const zlib = {
    gzipSync,
    gunzipSync,
};

class Compressor {
    static compress(data) {
        return zlib.gzipSync(data, Compressor.zlibOptions);
    }
    static decompress(data) {
        return zlib.gunzipSync(data, Compressor.zlibOptions);
    }
}
Compressor.zlibOptions = {
    level: 9,
    maxOutputLength: 1024 * 1024 * 16,
};

const bitcoin$1 = {
    messagePrefix: '\x18Bitcoin Signed Message:\n',
    bech32: 'bc',
    bech32Opnet: 'op',
    bip32: {
        public: 0x0488b21e,
        private: 0x0488ade4,
    },
    pubKeyHash: 0x00,
    scriptHash: 0x05,
    wif: 0x80,
};
const regtest = {
    messagePrefix: '\x18Bitcoin Signed Message:\n',
    bech32: 'bcrt',
    bech32Opnet: 'opr',
    bip32: {
        public: 0x043587cf,
        private: 0x04358394,
    },
    pubKeyHash: 0x6f,
    scriptHash: 0xc4,
    wif: 0xef,
};
const testnet = {
    messagePrefix: '\x18Bitcoin Signed Message:\n',
    bech32: 'tb',
    bech32Opnet: 'opt',
    bip32: {
        public: 0x043587cf,
        private: 0x04358394,
    },
    pubKeyHash: 0x6f,
    scriptHash: 0xc4,
    wif: 0xef,
};

var dist$2 = {};

var hasRequiredDist$2;

function requireDist$2 () {
	if (hasRequiredDist$2) return dist$2;
	hasRequiredDist$2 = 1;
	Object.defineProperty(dist$2, "__esModule", { value: true });
	dist$2.bech32m = dist$2.bech32 = void 0;
	const ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
	const ALPHABET_MAP = {};
	for (let z = 0; z < ALPHABET.length; z++) {
	    const x = ALPHABET.charAt(z);
	    ALPHABET_MAP[x] = z;
	}
	function polymodStep(pre) {
	    const b = pre >> 25;
	    return (((pre & 0x1ffffff) << 5) ^
	        (-((b >> 0) & 1) & 0x3b6a57b2) ^
	        (-((b >> 1) & 1) & 0x26508e6d) ^
	        (-((b >> 2) & 1) & 0x1ea119fa) ^
	        (-((b >> 3) & 1) & 0x3d4233dd) ^
	        (-((b >> 4) & 1) & 0x2a1462b3));
	}
	function prefixChk(prefix) {
	    let chk = 1;
	    for (let i = 0; i < prefix.length; ++i) {
	        const c = prefix.charCodeAt(i);
	        if (c < 33 || c > 126)
	            return 'Invalid prefix (' + prefix + ')';
	        chk = polymodStep(chk) ^ (c >> 5);
	    }
	    chk = polymodStep(chk);
	    for (let i = 0; i < prefix.length; ++i) {
	        const v = prefix.charCodeAt(i);
	        chk = polymodStep(chk) ^ (v & 0x1f);
	    }
	    return chk;
	}
	function convert(data, inBits, outBits, pad) {
	    let value = 0;
	    let bits = 0;
	    const maxV = (1 << outBits) - 1;
	    const result = [];
	    for (let i = 0; i < data.length; ++i) {
	        value = (value << inBits) | data[i];
	        bits += inBits;
	        while (bits >= outBits) {
	            bits -= outBits;
	            result.push((value >> bits) & maxV);
	        }
	    }
	    if (pad) {
	        if (bits > 0) {
	            result.push((value << (outBits - bits)) & maxV);
	        }
	    }
	    else {
	        if (bits >= inBits)
	            return 'Excess padding';
	        if ((value << (outBits - bits)) & maxV)
	            return 'Non-zero padding';
	    }
	    return result;
	}
	function toWords(bytes) {
	    return convert(bytes, 8, 5, true);
	}
	function fromWordsUnsafe(words) {
	    const res = convert(words, 5, 8, false);
	    if (Array.isArray(res))
	        return res;
	}
	function fromWords(words) {
	    const res = convert(words, 5, 8, false);
	    if (Array.isArray(res))
	        return res;
	    throw new Error(res);
	}
	function getLibraryFromEncoding(encoding) {
	    let ENCODING_CONST;
	    if (encoding === 'bech32') {
	        ENCODING_CONST = 1;
	    }
	    else {
	        ENCODING_CONST = 0x2bc830a3;
	    }
	    function encode(prefix, words, LIMIT) {
	        LIMIT = LIMIT || 90;
	        if (prefix.length + 7 + words.length > LIMIT)
	            throw new TypeError('Exceeds length limit');
	        prefix = prefix.toLowerCase();
	        // determine chk mod
	        let chk = prefixChk(prefix);
	        if (typeof chk === 'string')
	            throw new Error(chk);
	        let result = prefix + '1';
	        for (let i = 0; i < words.length; ++i) {
	            const x = words[i];
	            if (x >> 5 !== 0)
	                throw new Error('Non 5-bit word');
	            chk = polymodStep(chk) ^ x;
	            result += ALPHABET.charAt(x);
	        }
	        for (let i = 0; i < 6; ++i) {
	            chk = polymodStep(chk);
	        }
	        chk ^= ENCODING_CONST;
	        for (let i = 0; i < 6; ++i) {
	            const v = (chk >> ((5 - i) * 5)) & 0x1f;
	            result += ALPHABET.charAt(v);
	        }
	        return result;
	    }
	    function __decode(str, LIMIT) {
	        LIMIT = LIMIT || 90;
	        if (str.length < 8)
	            return str + ' too short';
	        if (str.length > LIMIT)
	            return 'Exceeds length limit';
	        // don't allow mixed case
	        const lowered = str.toLowerCase();
	        const uppered = str.toUpperCase();
	        if (str !== lowered && str !== uppered)
	            return 'Mixed-case string ' + str;
	        str = lowered;
	        const split = str.lastIndexOf('1');
	        if (split === -1)
	            return 'No separator character for ' + str;
	        if (split === 0)
	            return 'Missing prefix for ' + str;
	        const prefix = str.slice(0, split);
	        const wordChars = str.slice(split + 1);
	        if (wordChars.length < 6)
	            return 'Data too short';
	        let chk = prefixChk(prefix);
	        if (typeof chk === 'string')
	            return chk;
	        const words = [];
	        for (let i = 0; i < wordChars.length; ++i) {
	            const c = wordChars.charAt(i);
	            const v = ALPHABET_MAP[c];
	            if (v === undefined)
	                return 'Unknown character ' + c;
	            chk = polymodStep(chk) ^ v;
	            // not in the checksum?
	            if (i + 6 >= wordChars.length)
	                continue;
	            words.push(v);
	        }
	        if (chk !== ENCODING_CONST)
	            return 'Invalid checksum for ' + str;
	        return { prefix, words };
	    }
	    function decodeUnsafe(str, LIMIT) {
	        const res = __decode(str, LIMIT);
	        if (typeof res === 'object')
	            return res;
	    }
	    function decode(str, LIMIT) {
	        const res = __decode(str, LIMIT);
	        if (typeof res === 'object')
	            return res;
	        throw new Error(res);
	    }
	    return {
	        decodeUnsafe,
	        decode,
	        encode,
	        toWords,
	        fromWordsUnsafe,
	        fromWords,
	    };
	}
	dist$2.bech32 = getLibraryFromEncoding('bech32');
	dist$2.bech32m = getLibraryFromEncoding('bech32m');
	return dist$2;
}

var distExports$1 = requireDist$2();

// base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
function base$3 (ALPHABET) {
  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }
  const BASE_MAP = new Uint8Array(256);
  for (let j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (let i = 0; i < ALPHABET.length; i++) {
    const x = ALPHABET.charAt(i);
    const xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }
    BASE_MAP[xc] = i;
  }
  const BASE = ALPHABET.length;
  const LEADER = ALPHABET.charAt(0);
  const FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up
  const iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up
  function encode (source) {
    // eslint-disable-next-line no-empty
    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }
    if (source.length === 0) { return '' }
    // Skip & count leading zeroes.
    let zeroes = 0;
    let length = 0;
    let pbegin = 0;
    const pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    // Allocate enough space in big-endian base58 representation.
    const size = ((pend - pbegin) * iFACTOR + 1) >>> 0;
    const b58 = new Uint8Array(size);
    // Process the bytes.
    while (pbegin !== pend) {
      let carry = source[pbegin];
      // Apply "b58 = b58 * 256 + ch".
      let i = 0;
      for (let it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
        carry += (256 * b58[it1]) >>> 0;
        b58[it1] = (carry % BASE) >>> 0;
        carry = (carry / BASE) >>> 0;
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i;
      pbegin++;
    }
    // Skip leading zeroes in base58 result.
    let it2 = size - length;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    // Translate the result into a string.
    let str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }
    return str
  }
  function decodeUnsafe (source) {
    if (typeof source !== 'string') { throw new TypeError('Expected String') }
    if (source.length === 0) { return new Uint8Array() }
    let psz = 0;
    // Skip and count leading '1's.
    let zeroes = 0;
    let length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    // Allocate enough space in big-endian base256 representation.
    const size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.
    const b256 = new Uint8Array(size);
    // Process the characters.
    while (psz < source.length) {
      // Find code of next character
      const charCode = source.charCodeAt(psz);
      // Base map can not be indexed using char code
      if (charCode > 255) { return }
      // Decode character
      let carry = BASE_MAP[charCode];
      // Invalid character
      if (carry === 255) { return }
      let i = 0;
      for (let it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
        carry += (BASE * b256[it3]) >>> 0;
        b256[it3] = (carry % 256) >>> 0;
        carry = (carry / 256) >>> 0;
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i;
      psz++;
    }
    // Skip leading zeroes in b256.
    let it4 = size - length;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    const vch = new Uint8Array(zeroes + (size - it4));
    let j = zeroes;
    while (it4 !== size) {
      vch[j++] = b256[it4++];
    }
    return vch
  }
  function decode (string) {
    const buffer = decodeUnsafe(string);
    if (buffer) { return buffer }
    throw new Error('Non-base' + BASE + ' character')
  }
  return {
    encode,
    decodeUnsafe,
    decode
  }
}

var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
const base58$1 = base$3(ALPHABET);

function bs58checkBase (checksumFn) {
    // Encode a buffer as a base58-check encoded string
    function encode(payload) {
        var payloadU8 = Uint8Array.from(payload);
        var checksum = checksumFn(payloadU8);
        var length = payloadU8.length + 4;
        var both = new Uint8Array(length);
        both.set(payloadU8, 0);
        both.set(checksum.subarray(0, 4), payloadU8.length);
        return base58$1.encode(both);
    }
    function decodeRaw(buffer) {
        var payload = buffer.slice(0, -4);
        var checksum = buffer.slice(-4);
        var newChecksum = checksumFn(payload);
        // eslint-disable-next-line
        if (checksum[0] ^ newChecksum[0] |
            checksum[1] ^ newChecksum[1] |
            checksum[2] ^ newChecksum[2] |
            checksum[3] ^ newChecksum[3])
            return;
        return payload;
    }
    // Decode a base58-check encoded string to a buffer, no result if checksum is wrong
    function decodeUnsafe(str) {
        var buffer = base58$1.decodeUnsafe(str);
        if (buffer == null)
            return;
        return decodeRaw(buffer);
    }
    function decode(str) {
        var buffer = base58$1.decode(str);
        var payload = decodeRaw(buffer);
        if (payload == null)
            throw new Error('Invalid checksum');
        return payload;
    }
    return {
        encode: encode,
        decode: decode,
        decodeUnsafe: decodeUnsafe
    };
}

// SHA256(SHA256(buffer))
function sha256x2(buffer) {
    return sha256$2(sha256$2(buffer));
}
const index$1 = bs58checkBase(sha256x2);

function fromBech32(address) {
    let result;
    let version;
    try {
        result = distExports$1.bech32.decode(address);
    }
    catch (e) { }
    if (result) {
        version = result.words[0];
        if (version !== 0)
            throw new TypeError(address + ' uses wrong encoding');
    }
    else {
        result = distExports$1.bech32m.decode(address);
        version = result.words[0];
        if (version === 0)
            throw new TypeError(address + ' uses wrong encoding');
    }
    const data = distExports$1.bech32.fromWords(result.words.slice(1));
    return {
        version,
        prefix: result.prefix,
        data: Buffer$1.from(data),
    };
}

function check(buffer) {
    if (buffer.length < 8)
        return false;
    if (buffer.length > 72)
        return false;
    if (buffer[0] !== 0x30)
        return false;
    if (buffer[1] !== buffer.length - 2)
        return false;
    if (buffer[2] !== 0x02)
        return false;
    const lenR = buffer[3];
    if (lenR === 0)
        return false;
    if (5 + lenR >= buffer.length)
        return false;
    if (buffer[4 + lenR] !== 0x02)
        return false;
    const lenS = buffer[5 + lenR];
    if (lenS === 0)
        return false;
    if (6 + lenR + lenS !== buffer.length)
        return false;
    if (buffer[4] & 0x80)
        return false;
    if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80))
        return false;
    if (buffer[lenR + 6] & 0x80)
        return false;
    if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80))
        return false;
    return true;
}
function decode$4(buffer) {
    if (buffer.length < 8)
        throw new Error('DER sequence length is too short');
    if (buffer.length > 72)
        throw new Error('DER sequence length is too long');
    if (buffer[0] !== 0x30)
        throw new Error('Expected DER sequence');
    if (buffer[1] !== buffer.length - 2)
        throw new Error('DER sequence length is invalid');
    if (buffer[2] !== 0x02)
        throw new Error('Expected DER integer');
    const lenR = buffer[3];
    if (lenR === 0)
        throw new Error('R length is zero');
    if (5 + lenR >= buffer.length)
        throw new Error('R length is too long');
    if (buffer[4 + lenR] !== 0x02)
        throw new Error('Expected DER integer (2)');
    const lenS = buffer[5 + lenR];
    if (lenS === 0)
        throw new Error('S length is zero');
    if (6 + lenR + lenS !== buffer.length)
        throw new Error('S length is invalid');
    if (buffer[4] & 0x80)
        throw new Error('R value is negative');
    if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80))
        throw new Error('R value excessively padded');
    if (buffer[lenR + 6] & 0x80)
        throw new Error('S value is negative');
    if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80))
        throw new Error('S value excessively padded');
    return {
        r: buffer.subarray(4, 4 + lenR),
        s: buffer.subarray(6 + lenR),
    };
}
function encode$4(r, s) {
    const lenR = r.length;
    const lenS = s.length;
    if (lenR === 0)
        throw new Error('R length is zero');
    if (lenS === 0)
        throw new Error('S length is zero');
    if (lenR > 33)
        throw new Error('R length is too long');
    if (lenS > 33)
        throw new Error('S length is too long');
    if (r[0] & 0x80)
        throw new Error('R value is negative');
    if (s[0] & 0x80)
        throw new Error('S value is negative');
    if (lenR > 1 && r[0] === 0x00 && !(r[1] & 0x80))
        throw new Error('R value excessively padded');
    if (lenS > 1 && s[0] === 0x00 && !(s[1] & 0x80))
        throw new Error('S value excessively padded');
    const signature = Buffer$1.allocUnsafe(6 + lenR + lenS);
    signature[0] = 0x30;
    signature[1] = signature.length - 2;
    signature[2] = 0x02;
    signature[3] = r.length;
    r.copy(signature, 4);
    signature[4 + lenR] = 0x02;
    signature[5 + lenR] = s.length;
    s.copy(signature, 6 + lenR);
    return signature;
}

const opcodes = {
    OP_FALSE: 0,
    OP_0: 0,
    OP_PUSHDATA1: 76,
    OP_PUSHDATA2: 77,
    OP_PUSHDATA4: 78,
    OP_1NEGATE: 79,
    OP_RESERVED: 80,
    OP_TRUE: 81,
    OP_1: 81,
    OP_2: 82,
    OP_3: 83,
    OP_4: 84,
    OP_5: 85,
    OP_6: 86,
    OP_7: 87,
    OP_8: 88,
    OP_9: 89,
    OP_10: 90,
    OP_11: 91,
    OP_12: 92,
    OP_13: 93,
    OP_14: 94,
    OP_15: 95,
    OP_16: 96,
    OP_NOP: 97,
    OP_VER: 98,
    OP_IF: 99,
    OP_NOTIF: 100,
    OP_VERIF: 101,
    OP_VERNOTIF: 102,
    OP_ELSE: 103,
    OP_ENDIF: 104,
    OP_VERIFY: 105,
    OP_RETURN: 106,
    OP_TOALTSTACK: 107,
    OP_FROMALTSTACK: 108,
    OP_2DROP: 109,
    OP_2DUP: 110,
    OP_3DUP: 111,
    OP_2OVER: 112,
    OP_2ROT: 113,
    OP_2SWAP: 114,
    OP_IFDUP: 115,
    OP_DEPTH: 116,
    OP_DROP: 117,
    OP_DUP: 118,
    OP_NIP: 119,
    OP_OVER: 120,
    OP_PICK: 121,
    OP_ROLL: 122,
    OP_ROT: 123,
    OP_SWAP: 124,
    OP_TUCK: 125,
    OP_CAT: 126,
    OP_SUBSTR: 127,
    OP_LEFT: 128,
    OP_RIGHT: 129,
    OP_SIZE: 130,
    OP_INVERT: 131,
    OP_AND: 132,
    OP_OR: 133,
    OP_XOR: 134,
    OP_EQUAL: 135,
    OP_EQUALVERIFY: 136,
    OP_RESERVED1: 137,
    OP_RESERVED2: 138,
    OP_1ADD: 139,
    OP_1SUB: 140,
    OP_2MUL: 141,
    OP_2DIV: 142,
    OP_NEGATE: 143,
    OP_ABS: 144,
    OP_NOT: 145,
    OP_0NOTEQUAL: 146,
    OP_ADD: 147,
    OP_SUB: 148,
    OP_MUL: 149,
    OP_DIV: 150,
    OP_MOD: 151,
    OP_LSHIFT: 152,
    OP_RSHIFT: 153,
    OP_BOOLAND: 154,
    OP_BOOLOR: 155,
    OP_NUMEQUAL: 156,
    OP_NUMEQUALVERIFY: 157,
    OP_NUMNOTEQUAL: 158,
    OP_LESSTHAN: 159,
    OP_GREATERTHAN: 160,
    OP_LESSTHANOREQUAL: 161,
    OP_GREATERTHANOREQUAL: 162,
    OP_MIN: 163,
    OP_MAX: 164,
    OP_WITHIN: 165,
    OP_RIPEMD160: 166,
    OP_SHA1: 167,
    OP_SHA256: 168,
    OP_HASH160: 169,
    OP_HASH256: 170,
    OP_CODESEPARATOR: 171,
    OP_CHECKSIG: 172,
    OP_CHECKSIGVERIFY: 173,
    OP_CHECKMULTISIG: 174,
    OP_CHECKMULTISIGVERIFY: 175,
    OP_NOP1: 176,
    OP_NOP2: 177,
    OP_CHECKLOCKTIMEVERIFY: 177,
    OP_NOP3: 178,
    OP_CHECKSEQUENCEVERIFY: 178,
    OP_NOP4: 179,
    OP_NOP5: 180,
    OP_NOP6: 181,
    OP_NOP7: 182,
    OP_NOP8: 183,
    OP_NOP9: 184,
    OP_NOP10: 185,
    OP_CHECKSIGADD: 186,
    OP_PUBKEYHASH: 253,
    OP_PUBKEY: 254,
    OP_INVALIDOPCODE: 255,
};
const REVERSE_OPS = {};
for (const op of Object.keys(opcodes)) {
    const code = opcodes[op];
    REVERSE_OPS[code] = op;
}

function encodingLength$1(i) {
    return i < opcodes.OP_PUSHDATA1 ? 1 : i <= 0xff ? 2 : i <= 0xffff ? 3 : 5;
}
function encode$3(buffer, num, offset) {
    const size = encodingLength$1(num);
    if (size === 1) {
        buffer.writeUInt8(num, offset);
    }
    else if (size === 2) {
        buffer.writeUInt8(opcodes.OP_PUSHDATA1, offset);
        buffer.writeUInt8(num, offset + 1);
    }
    else if (size === 3) {
        buffer.writeUInt8(opcodes.OP_PUSHDATA2, offset);
        buffer.writeUInt16LE(num, offset + 1);
    }
    else {
        buffer.writeUInt8(opcodes.OP_PUSHDATA4, offset);
        buffer.writeUInt32LE(num, offset + 1);
    }
    return size;
}
function decode$3(buffer, offset) {
    const opcode = buffer.readUInt8(offset);
    let num;
    let size;
    if (opcode < opcodes.OP_PUSHDATA1) {
        num = opcode;
        size = 1;
    }
    else if (opcode === opcodes.OP_PUSHDATA1) {
        if (offset + 2 > buffer.length)
            return null;
        num = buffer.readUInt8(offset + 1);
        size = 2;
    }
    else if (opcode === opcodes.OP_PUSHDATA2) {
        if (offset + 3 > buffer.length)
            return null;
        num = buffer.readUInt16LE(offset + 1);
        size = 3;
    }
    else {
        if (offset + 5 > buffer.length)
            return null;
        if (opcode !== opcodes.OP_PUSHDATA4)
            throw new Error('Unexpected opcode');
        num = buffer.readUInt32LE(offset + 1);
        size = 5;
    }
    return {
        opcode,
        number: num,
        size,
    };
}

function decode$2(buffer, maxLength, minimal) {
    maxLength = maxLength || 4;
    minimal = minimal === undefined ? true : minimal;
    const length = buffer.length;
    if (length === 0)
        return 0;
    if (length > maxLength)
        throw new TypeError('Script number overflow');
    if (minimal) {
        if ((buffer[length - 1] & 0x7f) === 0) {
            if (length <= 1 || (buffer[length - 2] & 0x80) === 0)
                throw new Error('Non-minimally encoded script number');
        }
    }
    if (length === 5) {
        const a = buffer.readUInt32LE(0);
        const b = buffer.readUInt8(4);
        if (b & 0x80)
            return -((b & -129) * 0x100000000 + a);
        return b * 0x100000000 + a;
    }
    let result = 0;
    for (let i = 0; i < length; ++i) {
        result |= buffer[i] << (8 * i);
    }
    if (buffer[length - 1] & 0x80)
        return -(result & ~(0x80 << (8 * (length - 1))));
    return result;
}
function scriptNumSize(i) {
    return i > 0x7fffffff ? 5 : i > 0x7fffff ? 4 : i > 0x7fff ? 3 : i > 0x7f ? 2 : i > 0x00 ? 1 : 0;
}
function encode$2(_number) {
    let value = Math.abs(_number);
    const size = scriptNumSize(value);
    const buffer = Buffer$1.allocUnsafe(size);
    const negative = _number < 0;
    for (let i = 0; i < size; ++i) {
        buffer.writeUInt8(value & 0xff, i);
        value >>= 8;
    }
    if (buffer[size - 1] & 0x80) {
        buffer.writeUInt8(negative ? 0x80 : 0x00, size - 1);
    }
    else if (negative) {
        buffer[size - 1] |= 0x80;
    }
    return buffer;
}

const scriptNumber = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	decode: decode$2,
	encode: encode$2
}, Symbol.toStringTag, { value: 'Module' }));

var native;
var hasRequiredNative;

function requireNative () {
	if (hasRequiredNative) return native;
	hasRequiredNative = 1;
	var types = {
	  Array: function (value) { return value !== null && value !== undefined && value.constructor === Array },
	  Boolean: function (value) { return typeof value === 'boolean' },
	  Function: function (value) { return typeof value === 'function' },
	  Nil: function (value) { return value === undefined || value === null },
	  Number: function (value) { return typeof value === 'number' },
	  Object: function (value) { return typeof value === 'object' },
	  String: function (value) { return typeof value === 'string' },
	  '': function () { return true }
	};

	// TODO: deprecate
	types.Null = types.Nil;

	for (var typeName in types) {
	  types[typeName].toJSON = function (t) {
	    return t
	  }.bind(null, typeName);
	}

	native = types;
	return native;
}

var errors;
var hasRequiredErrors;

function requireErrors () {
	if (hasRequiredErrors) return errors;
	hasRequiredErrors = 1;
	var native = requireNative();

	function getTypeName (fn) {
	  return fn.name || fn.toString().match(/function (.*?)\s*\(/)[1]
	}

	function getValueTypeName (value) {
	  return native.Nil(value) ? '' : getTypeName(value.constructor)
	}

	function getValue (value) {
	  if (native.Function(value)) return ''
	  if (native.String(value)) return JSON.stringify(value)
	  if (value && native.Object(value)) return ''
	  return value
	}

	function captureStackTrace (e, t) {
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(e, t);
	  }
	}

	function tfJSON (type) {
	  if (native.Function(type)) return type.toJSON ? type.toJSON() : getTypeName(type)
	  if (native.Array(type)) return 'Array'
	  if (type && native.Object(type)) return 'Object'

	  return type !== undefined ? type : ''
	}

	function tfErrorString (type, value, valueTypeName) {
	  var valueJson = getValue(value);

	  return 'Expected ' + tfJSON(type) + ', got' +
	    (valueTypeName !== '' ? ' ' + valueTypeName : '') +
	    (valueJson !== '' ? ' ' + valueJson : '')
	}

	function TfTypeError (type, value, valueTypeName) {
	  valueTypeName = valueTypeName || getValueTypeName(value);
	  this.message = tfErrorString(type, value, valueTypeName);

	  captureStackTrace(this, TfTypeError);
	  this.__type = type;
	  this.__value = value;
	  this.__valueTypeName = valueTypeName;
	}

	TfTypeError.prototype = Object.create(Error.prototype);
	TfTypeError.prototype.constructor = TfTypeError;

	function tfPropertyErrorString (type, label, name, value, valueTypeName) {
	  var description = '" of type ';
	  if (label === 'key') description = '" with key type ';

	  return tfErrorString('property "' + tfJSON(name) + description + tfJSON(type), value, valueTypeName)
	}

	function TfPropertyTypeError (type, property, label, value, valueTypeName) {
	  if (type) {
	    valueTypeName = valueTypeName || getValueTypeName(value);
	    this.message = tfPropertyErrorString(type, label, property, value, valueTypeName);
	  } else {
	    this.message = 'Unexpected property "' + property + '"';
	  }

	  captureStackTrace(this, TfTypeError);
	  this.__label = label;
	  this.__property = property;
	  this.__type = type;
	  this.__value = value;
	  this.__valueTypeName = valueTypeName;
	}

	TfPropertyTypeError.prototype = Object.create(Error.prototype);
	TfPropertyTypeError.prototype.constructor = TfTypeError;

	function tfCustomError (expected, actual) {
	  return new TfTypeError(expected, {}, actual)
	}

	function tfSubError (e, property, label) {
	  // sub child?
	  if (e instanceof TfPropertyTypeError) {
	    property = property + '.' + e.__property;

	    e = new TfPropertyTypeError(
	      e.__type, property, e.__label, e.__value, e.__valueTypeName
	    );

	  // child?
	  } else if (e instanceof TfTypeError) {
	    e = new TfPropertyTypeError(
	      e.__type, property, label, e.__value, e.__valueTypeName
	    );
	  }

	  captureStackTrace(e);
	  return e
	}

	errors = {
	  TfTypeError: TfTypeError,
	  TfPropertyTypeError: TfPropertyTypeError,
	  tfCustomError: tfCustomError,
	  tfSubError: tfSubError,
	  tfJSON: tfJSON,
	  getValueTypeName: getValueTypeName
	};
	return errors;
}

var extra;
var hasRequiredExtra;

function requireExtra () {
	if (hasRequiredExtra) return extra;
	hasRequiredExtra = 1;
	var NATIVE = requireNative();
	var ERRORS = requireErrors();

	function _Buffer (value) {
	  return Buffer$1.isBuffer(value)
	}

	function Hex (value) {
	  return typeof value === 'string' && /^([0-9a-f]{2})+$/i.test(value)
	}

	function _LengthN (type, length) {
	  var name = type.toJSON();

	  function Length (value) {
	    if (!type(value)) return false
	    if (value.length === length) return true

	    throw ERRORS.tfCustomError(name + '(Length: ' + length + ')', name + '(Length: ' + value.length + ')')
	  }
	  Length.toJSON = function () { return name };

	  return Length
	}

	var _ArrayN = _LengthN.bind(null, NATIVE.Array);
	var _BufferN = _LengthN.bind(null, _Buffer);
	var _HexN = _LengthN.bind(null, Hex);
	var _StringN = _LengthN.bind(null, NATIVE.String);

	function Range (a, b, f) {
	  f = f || NATIVE.Number;
	  function _range (value, strict) {
	    return f(value, strict) && (value > a) && (value < b)
	  }
	  _range.toJSON = function () {
	    return `${f.toJSON()} between [${a}, ${b}]`
	  };
	  return _range
	}

	var INT53_MAX = Math.pow(2, 53) - 1;

	function Finite (value) {
	  return typeof value === 'number' && isFinite(value)
	}
	function Int8 (value) { return ((value << 24) >> 24) === value }
	function Int16 (value) { return ((value << 16) >> 16) === value }
	function Int32 (value) { return (value | 0) === value }
	function Int53 (value) {
	  return typeof value === 'number' &&
	    value >= -INT53_MAX &&
	    value <= INT53_MAX &&
	    Math.floor(value) === value
	}
	function UInt8 (value) { return (value & 0xff) === value }
	function UInt16 (value) { return (value & 0xffff) === value }
	function UInt32 (value) { return (value >>> 0) === value }
	function UInt53 (value) {
	  return typeof value === 'number' &&
	    value >= 0 &&
	    value <= INT53_MAX &&
	    Math.floor(value) === value
	}

	var types = {
	  ArrayN: _ArrayN,
	  Buffer: _Buffer,
	  BufferN: _BufferN,
	  Finite: Finite,
	  Hex: Hex,
	  HexN: _HexN,
	  Int8: Int8,
	  Int16: Int16,
	  Int32: Int32,
	  Int53: Int53,
	  Range: Range,
	  StringN: _StringN,
	  UInt8: UInt8,
	  UInt16: UInt16,
	  UInt32: UInt32,
	  UInt53: UInt53
	};

	for (var typeName in types) {
	  types[typeName].toJSON = function (t) {
	    return t
	  }.bind(null, typeName);
	}

	extra = types;
	return extra;
}

var typeforce_1;
var hasRequiredTypeforce;

function requireTypeforce () {
	if (hasRequiredTypeforce) return typeforce_1;
	hasRequiredTypeforce = 1;
	var ERRORS = requireErrors();
	var NATIVE = requireNative();

	// short-hand
	var tfJSON = ERRORS.tfJSON;
	var TfTypeError = ERRORS.TfTypeError;
	var TfPropertyTypeError = ERRORS.TfPropertyTypeError;
	var tfSubError = ERRORS.tfSubError;
	var getValueTypeName = ERRORS.getValueTypeName;

	var TYPES = {
	  arrayOf: function arrayOf (type, options) {
	    type = compile(type);
	    options = options || {};

	    function _arrayOf (array, strict) {
	      if (!NATIVE.Array(array)) return false
	      if (NATIVE.Nil(array)) return false
	      if (options.minLength !== undefined && array.length < options.minLength) return false
	      if (options.maxLength !== undefined && array.length > options.maxLength) return false
	      if (options.length !== undefined && array.length !== options.length) return false

	      return array.every(function (value, i) {
	        try {
	          return typeforce(type, value, strict)
	        } catch (e) {
	          throw tfSubError(e, i)
	        }
	      })
	    }
	    _arrayOf.toJSON = function () {
	      var str = '[' + tfJSON(type) + ']';
	      if (options.length !== undefined) {
	        str += '{' + options.length + '}';
	      } else if (options.minLength !== undefined || options.maxLength !== undefined) {
	        str += '{' +
	          (options.minLength === undefined ? 0 : options.minLength) + ',' +
	          (options.maxLength === undefined ? Infinity : options.maxLength) + '}';
	      }
	      return str
	    };

	    return _arrayOf
	  },

	  maybe: function maybe (type) {
	    type = compile(type);

	    function _maybe (value, strict) {
	      return NATIVE.Nil(value) || type(value, strict, maybe)
	    }
	    _maybe.toJSON = function () { return '?' + tfJSON(type) };

	    return _maybe
	  },

	  map: function map (propertyType, propertyKeyType) {
	    propertyType = compile(propertyType);
	    if (propertyKeyType) propertyKeyType = compile(propertyKeyType);

	    function _map (value, strict) {
	      if (!NATIVE.Object(value)) return false
	      if (NATIVE.Nil(value)) return false

	      for (var propertyName in value) {
	        try {
	          if (propertyKeyType) {
	            typeforce(propertyKeyType, propertyName, strict);
	          }
	        } catch (e) {
	          throw tfSubError(e, propertyName, 'key')
	        }

	        try {
	          var propertyValue = value[propertyName];
	          typeforce(propertyType, propertyValue, strict);
	        } catch (e) {
	          throw tfSubError(e, propertyName)
	        }
	      }

	      return true
	    }

	    if (propertyKeyType) {
	      _map.toJSON = function () {
	        return '{' + tfJSON(propertyKeyType) + ': ' + tfJSON(propertyType) + '}'
	      };
	    } else {
	      _map.toJSON = function () { return '{' + tfJSON(propertyType) + '}' };
	    }

	    return _map
	  },

	  object: function object (uncompiled) {
	    var type = {};

	    for (var typePropertyName in uncompiled) {
	      type[typePropertyName] = compile(uncompiled[typePropertyName]);
	    }

	    function _object (value, strict) {
	      if (!NATIVE.Object(value)) return false
	      if (NATIVE.Nil(value)) return false

	      var propertyName;

	      try {
	        for (propertyName in type) {
	          var propertyType = type[propertyName];
	          var propertyValue = value[propertyName];

	          typeforce(propertyType, propertyValue, strict);
	        }
	      } catch (e) {
	        throw tfSubError(e, propertyName)
	      }

	      if (strict) {
	        for (propertyName in value) {
	          if (type[propertyName]) continue

	          throw new TfPropertyTypeError(undefined, propertyName)
	        }
	      }

	      return true
	    }
	    _object.toJSON = function () { return tfJSON(type) };

	    return _object
	  },

	  anyOf: function anyOf () {
	    var types = [].slice.call(arguments).map(compile);

	    function _anyOf (value, strict) {
	      return types.some(function (type) {
	        try {
	          return typeforce(type, value, strict)
	        } catch (e) {
	          return false
	        }
	      })
	    }
	    _anyOf.toJSON = function () { return types.map(tfJSON).join('|') };

	    return _anyOf
	  },

	  allOf: function allOf () {
	    var types = [].slice.call(arguments).map(compile);

	    function _allOf (value, strict) {
	      return types.every(function (type) {
	        try {
	          return typeforce(type, value, strict)
	        } catch (e) {
	          return false
	        }
	      })
	    }
	    _allOf.toJSON = function () { return types.map(tfJSON).join(' & ') };

	    return _allOf
	  },

	  quacksLike: function quacksLike (type) {
	    function _quacksLike (value) {
	      return type === getValueTypeName(value)
	    }
	    _quacksLike.toJSON = function () { return type };

	    return _quacksLike
	  },

	  tuple: function tuple () {
	    var types = [].slice.call(arguments).map(compile);

	    function _tuple (values, strict) {
	      if (NATIVE.Nil(values)) return false
	      if (NATIVE.Nil(values.length)) return false
	      if (strict && (values.length !== types.length)) return false

	      return types.every(function (type, i) {
	        try {
	          return typeforce(type, values[i], strict)
	        } catch (e) {
	          throw tfSubError(e, i)
	        }
	      })
	    }
	    _tuple.toJSON = function () { return '(' + types.map(tfJSON).join(', ') + ')' };

	    return _tuple
	  },

	  value: function value (expected) {
	    function _value (actual) {
	      return actual === expected
	    }
	    _value.toJSON = function () { return expected };

	    return _value
	  }
	};

	// TODO: deprecate
	TYPES.oneOf = TYPES.anyOf;

	function compile (type) {
	  if (NATIVE.String(type)) {
	    if (type[0] === '?') return TYPES.maybe(type.slice(1))

	    return NATIVE[type] || TYPES.quacksLike(type)
	  } else if (type && NATIVE.Object(type)) {
	    if (NATIVE.Array(type)) {
	      if (type.length !== 1) throw new TypeError('Expected compile() parameter of type Array of length 1')
	      return TYPES.arrayOf(type[0])
	    }

	    return TYPES.object(type)
	  } else if (NATIVE.Function(type)) {
	    return type
	  }

	  return TYPES.value(type)
	}

	function typeforce (type, value, strict, surrogate) {
	  if (NATIVE.Function(type)) {
	    if (type(value, strict)) return true

	    throw new TfTypeError(surrogate || type, value)
	  }

	  // JIT
	  return typeforce(compile(type), value, strict)
	}

	// assign types to typeforce function
	for (var typeName in NATIVE) {
	  typeforce[typeName] = NATIVE[typeName];
	}

	for (typeName in TYPES) {
	  typeforce[typeName] = TYPES[typeName];
	}

	var EXTRA = requireExtra();
	for (typeName in EXTRA) {
	  typeforce[typeName] = EXTRA[typeName];
	}

	typeforce.compile = compile;
	typeforce.TfTypeError = TfTypeError;
	typeforce.TfPropertyTypeError = TfPropertyTypeError;

	typeforce_1 = typeforce;
	return typeforce_1;
}

var typeforceExports = requireTypeforce();
const typef = /*@__PURE__*/getDefaultExportFromCjs$1(typeforceExports);

const ZERO32 = Buffer$1$1.alloc(32, 0);
const EC_P = Buffer$1$1.from("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f", "hex");
function stacksEqual(a, b) {
  if (a.length !== b.length)
    return false;
  return a.every((x, i) => {
    return x.equals(b[i]);
  });
}
function isPoint(p) {
  if (!Buffer$1$1.isBuffer(p))
    return false;
  if (p.length < 33)
    return false;
  const t = p[0];
  const x = p.subarray(1, 33);
  if (x.compare(ZERO32) === 0)
    return false;
  if (x.compare(EC_P) >= 0)
    return false;
  if ((t === 2 || t === 3) && p.length === 33) {
    return true;
  }
  if (p.length !== 65)
    return false;
  const y = p.subarray(33);
  if (y.compare(ZERO32) === 0)
    return false;
  if (y.compare(EC_P) >= 0)
    return false;
  return t === 4 || t === 6 || t === 7;
}
const SATOSHI_MAX = 21 * 1e14;
function Satoshi(value) {
  return typef.UInt53(value) && value <= SATOSHI_MAX;
}
const TAPLEAF_VERSION_MASK = 254;
function isTapleaf(o) {
  if (!o || typeof o !== "object" || !("output" in o))
    return false;
  const obj = o;
  if (!Buffer$1$1.isBuffer(obj.output))
    return false;
  if (obj.version !== void 0)
    return (obj.version & TAPLEAF_VERSION_MASK) === obj.version;
  return true;
}
function isTaptree(scriptTree) {
  if (!globalThis.Array.isArray(scriptTree))
    return isTapleaf(scriptTree);
  if (scriptTree.length !== 2)
    return false;
  return scriptTree.every((t) => isTaptree(t));
}
const Buffer256bit = typef.BufferN(32);
const Hash160bit = typef.BufferN(20);
const Hash256bit = typef.BufferN(32);
const Number$1 = typef.Number;
const Array$1 = typef.Array;
const Boolean$1 = typef.Boolean;
const String$1 = typef.String;
const Buffer = typef.Buffer;
const Hex = typef.Hex;
const maybe = typef.maybe;
const tuple = typef.tuple;
const UInt8 = typef.UInt8;
const UInt32 = typef.UInt32;
const Function$1 = typef.Function;
const BufferN = typef.BufferN;
const Null = typef.Null;
const oneOf = typef.oneOf;

const types$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	Array: Array$1,
	Boolean: Boolean$1,
	Buffer,
	Buffer256bit,
	BufferN,
	Function: Function$1,
	Hash160bit,
	Hash256bit,
	Hex,
	Null,
	Number: Number$1,
	Satoshi,
	String: String$1,
	TAPLEAF_VERSION_MASK,
	UInt32,
	UInt8,
	isPoint,
	isTapleaf,
	isTaptree,
	maybe,
	oneOf,
	stacksEqual,
	tuple,
	typeforce: typef
}, Symbol.toStringTag, { value: 'Module' }));

const { typeforce: typeforce$3 } = types$3;
const ZERO$2 = Buffer$1.alloc(1, 0);
function isDefinedHashType(hashType) {
    const hashTypeMod = hashType & -129;
    return hashTypeMod > 0x00 && hashTypeMod < 0x04;
}
function toDER(x) {
    let i = 0;
    while (x[i] === 0)
        ++i;
    if (i === x.length)
        return ZERO$2;
    x = x.subarray(i);
    if (x[0] & 0x80)
        return Buffer$1.concat([ZERO$2, x], 1 + x.length);
    return x;
}
function fromDER(x) {
    if (x[0] === 0x00)
        x = x.subarray(1);
    const buffer = Buffer$1.alloc(32, 0);
    const bstart = Math.max(0, 32 - x.length);
    x.copy(buffer, bstart);
    return buffer;
}
function decode$1(buffer) {
    const hashType = buffer.readUInt8(buffer.length - 1);
    if (!isDefinedHashType(hashType)) {
        throw new Error(`Invalid hashType ${hashType}`);
    }
    const decoded = decode$4(buffer.subarray(0, -1));
    const r = fromDER(decoded.r);
    const s = fromDER(decoded.s);
    const signature = Buffer$1.concat([r, s], 64);
    return { signature, hashType };
}
function encode$1(signature, hashType) {
    typeforce$3({
        signature: BufferN(64),
        hashType: UInt8,
    }, { signature, hashType });
    if (!isDefinedHashType(hashType)) {
        throw new Error(`Invalid hashType ${hashType}`);
    }
    const hashTypeBuffer = Buffer$1.allocUnsafe(1);
    hashTypeBuffer.writeUInt8(hashType, 0);
    const r = toDER(signature.subarray(0, 32));
    const s = toDER(signature.subarray(32, 64));
    return Buffer$1.concat([encode$4(r, s), hashTypeBuffer]);
}

const scriptSignature = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	decode: decode$1,
	encode: encode$1,
	isDefinedHashType
}, Symbol.toStringTag, { value: 'Module' }));

const { typeforce: typeforce$2 } = types$3;
const OP_INT_BASE$1 = opcodes.OP_RESERVED;
function isOPInt(value) {
    return (Number$1(value) &&
        (value === opcodes.OP_0 ||
            (value >= opcodes.OP_1 && value <= opcodes.OP_16) ||
            value === opcodes.OP_1NEGATE));
}
function isPushOnlyChunk(value) {
    return Buffer(value) || isOPInt(value);
}
function isPushOnly(value) {
    return Array$1(value) && value.every(isPushOnlyChunk);
}
function countNonPushOnlyOPs(value) {
    return value.length - value.filter(isPushOnlyChunk).length;
}
function asMinimalOP(buffer) {
    if (buffer.length === 0)
        return opcodes.OP_0;
    if (buffer.length !== 1)
        return;
    if (buffer[0] >= 1 && buffer[0] <= 16)
        return OP_INT_BASE$1 + buffer[0];
    if (buffer[0] === 0x81)
        return opcodes.OP_1NEGATE;
}
function chunksIsBuffer(buf) {
    return Buffer$1.isBuffer(buf);
}
function chunksIsArray(buf) {
    return Array$1(buf);
}
function singleChunkIsBuffer(buf) {
    return Buffer$1.isBuffer(buf);
}
function compile(chunks) {
    if (chunksIsBuffer(chunks))
        return chunks;
    typeforce$2(Array$1, chunks);
    const bufferSize = chunks.reduce((accum, chunk) => {
        if (singleChunkIsBuffer(chunk)) {
            if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {
                return accum + 1;
            }
            return accum + encodingLength$1(chunk.length) + chunk.length;
        }
        return accum + 1;
    }, 0.0);
    const buffer = Buffer$1.allocUnsafe(bufferSize);
    let offset = 0;
    chunks.forEach((chunk) => {
        if (singleChunkIsBuffer(chunk)) {
            const opcode = asMinimalOP(chunk);
            if (opcode !== undefined) {
                buffer.writeUInt8(opcode, offset);
                offset += 1;
                return;
            }
            offset += encode$3(buffer, chunk.length, offset);
            chunk.copy(buffer, offset);
            offset += chunk.length;
        }
        else {
            buffer.writeUInt8(chunk, offset);
            offset += 1;
        }
    });
    if (offset !== buffer.length)
        throw new Error('Could not decode chunks');
    return buffer;
}
function decompile(buffer) {
    if (chunksIsArray(buffer))
        return buffer;
    typeforce$2(Buffer, buffer);
    const chunks = [];
    let i = 0;
    while (i < buffer.length) {
        const opcode = buffer[i];
        if (opcode > opcodes.OP_0 && opcode <= opcodes.OP_PUSHDATA4) {
            const d = decode$3(buffer, i);
            if (d === null)
                return null;
            i += d.size;
            if (i + d.number > buffer.length)
                return null;
            const data = buffer.subarray(i, i + d.number);
            i += d.number;
            const op = asMinimalOP(data);
            if (op !== undefined) {
                chunks.push(op);
            }
            else {
                chunks.push(data);
            }
        }
        else {
            chunks.push(opcode);
            i += 1;
        }
    }
    return chunks;
}
function toASM(chunks) {
    if (chunksIsBuffer(chunks)) {
        chunks = decompile(chunks);
    }
    if (!chunks) {
        throw new Error('Could not convert invalid chunks to ASM');
    }
    return chunks
        .map((chunk) => {
        if (singleChunkIsBuffer(chunk)) {
            const op = asMinimalOP(chunk);
            if (op === undefined)
                return chunk.toString('hex');
            chunk = op;
        }
        return REVERSE_OPS[chunk];
    })
        .join(' ');
}
function fromASM(asm) {
    typeforce$2(String$1, asm);
    return compile(asm.split(' ').map((chunkStr) => {
        if (opcodes[chunkStr] !== undefined) {
            return opcodes[chunkStr];
        }
        typeforce$2(Hex, chunkStr);
        return Buffer$1.from(chunkStr, 'hex');
    }));
}
function toStack(chunks) {
    chunks = decompile(chunks);
    typeforce$2(isPushOnly, chunks);
    return chunks.map((op) => {
        if (singleChunkIsBuffer(op))
            return op;
        if (op === opcodes.OP_0)
            return Buffer$1.allocUnsafe(0);
        return encode$2(op - OP_INT_BASE$1);
    });
}
function isCanonicalPubKey(buffer) {
    return isPoint(buffer);
}
function isCanonicalScriptSignature(buffer) {
    if (!Buffer$1.isBuffer(buffer))
        return false;
    if (!isDefinedHashType(buffer[buffer.length - 1]))
        return false;
    return check(buffer.subarray(0, -1));
}
const number = scriptNumber;
const signature = scriptSignature;

const script = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	compile,
	countNonPushOnlyOPs,
	decompile,
	fromASM,
	isCanonicalPubKey,
	isCanonicalScriptSignature,
	isPushOnly,
	number,
	opcodes,
	signature,
	toASM,
	toStack
}, Symbol.toStringTag, { value: 'Module' }));

var PaymentType;
(function (PaymentType) {
    PaymentType["P2PK"] = "p2pk";
    PaymentType["P2PKH"] = "p2pkh";
    PaymentType["P2SH"] = "p2sh";
    PaymentType["P2MS"] = "p2ms";
    PaymentType["P2WPKH"] = "p2wpkh";
    PaymentType["P2WSH"] = "p2wsh";
    PaymentType["P2TR"] = "p2tr";
    PaymentType["P2OP"] = "p2op";
    PaymentType["Embed"] = "embed";
    PaymentType["ScriptRedeem"] = "scriptRedeem";
})(PaymentType || (PaymentType = {}));

function prop(object, name, f) {
    Object.defineProperty(object, name, {
        configurable: true,
        enumerable: true,
        get() {
            const _value = f.call(this);
            this[name] = _value;
            return _value;
        },
        set(_value) {
            Object.defineProperty(this, name, {
                configurable: true,
                enumerable: true,
                value: _value,
                writable: true,
            });
        },
    });
}
function value(f) {
    let _value;
    return () => {
        if (_value !== undefined)
            return _value;
        _value = f();
        return _value;
    };
}

const OPS$8 = opcodes;
const P2OP_WITNESS_VERSION = 0x10;
const MIN_SIZE = 2;
const MAX_SIZE = 40;
function p2op(a, opts) {
    if (!a.address &&
        !a.output &&
        !a.program &&
        (typeof a.deploymentVersion === 'undefined' || !a.hash160)) {
        throw new TypeError('At least one of address, output or program must be provided');
    }
    opts = Object.assign({ validate: true }, opts || {});
    typef({
        address: typef.maybe(typef.String),
        output: typef.maybe(typef.Buffer),
        program: typef.maybe(typef.Buffer),
        network: typef.maybe(typef.Object),
        deploymentVersion: typef.maybe(typef.Number),
        hash160: typef.maybe(typef.BufferN(20)),
    }, a);
    const makeProgramFromParts = () => {
        if (typeof a.deploymentVersion !== 'undefined' && typeof a.hash160 !== 'undefined') {
            if (a.hash160.length !== 20)
                throw new TypeError('hash160 must be exactly 20 bytes');
            if (a.deploymentVersion < 0 || a.deploymentVersion > 0xff)
                throw new TypeError('deploymentVersion must fit in one byte');
            return Buffer$1.concat([Buffer$1.of(a.deploymentVersion), a.hash160]);
        }
        return undefined;
    };
    const _address = value(() => fromBech32(a.address));
    const network = a.network || bitcoin$1;
    const o = {
        name: PaymentType.P2OP,
        network,
        deploymentVersion: 0,
    };
    prop(o, 'program', () => {
        if (a.program)
            return a.program;
        const fromParts = makeProgramFromParts();
        if (fromParts)
            return fromParts;
        if (a.output) {
            if (a.output[0] !== OPS$8.OP_16)
                throw new TypeError('Invalid P2OP script');
            let pushPos = 1, progLen;
            if (a.output[1] < 0x4c) {
                progLen = a.output[1];
                pushPos = 2;
            }
            else if (a.output[1] === 0x4c) {
                progLen = a.output[2];
                pushPos = 3;
            }
            else {
                throw new TypeError('Unsupported push opcode in P2OP script');
            }
            return a.output.subarray(pushPos, pushPos + progLen);
        }
        if (a.address) {
            const dec = _address();
            return dec.data;
        }
    });
    prop(o, 'deploymentVersion', () => {
        if (!o.program)
            return;
        return o.program[0];
    });
    prop(o, 'hash160', () => {
        if (!o.program)
            return;
        return o.program.subarray(1);
    });
    prop(o, 'output', () => {
        if (!o.program)
            return;
        return compile([OPS$8.OP_16, o.program]);
    });
    prop(o, 'address', () => {
        if (!o.program)
            return;
        if (!network.bech32Opnet) {
            throw new TypeError('Network does not support opnet');
        }
        const words = distExports$1.bech32m.toWords(o.program);
        words.unshift(P2OP_WITNESS_VERSION);
        return distExports$1.bech32m.encode(network.bech32Opnet, words);
    });
    if (opts.validate) {
        let prog = Buffer$1$1.alloc(0);
        if (a.address) {
            const dec = _address();
            if (network.bech32Opnet !== dec.prefix)
                throw new TypeError('Invalid prefix or network mismatch');
            if (dec.version !== P2OP_WITNESS_VERSION)
                throw new TypeError('Invalid witness version for p2op');
            if (dec.data.length < MIN_SIZE || dec.data.length > MAX_SIZE)
                throw new TypeError('Invalid witness program length');
            prog = dec.data;
        }
        if (a.program) {
            if (prog.length && !prog.equals(a.program))
                throw new TypeError('Program mismatch');
            prog = a.program;
        }
        if (!prog.length && a.deploymentVersion !== undefined && a.hash160) {
            prog = makeProgramFromParts();
        }
        if (a.output) {
            const outProg = o.program;
            if (prog.length && !prog.equals(outProg))
                throw new TypeError('Program mismatch (output vs other source)');
            prog = outProg;
        }
        if (prog.length < MIN_SIZE || prog.length > MAX_SIZE)
            throw new TypeError(`Witness program must be 240 bytes. Was ${prog.length} bytes`);
        if (a.deploymentVersion !== undefined && a.deploymentVersion !== prog[0])
            throw new TypeError('deploymentVersion mismatch');
        if (a.hash160 && !a.hash160.equals(prog.subarray(1)))
            throw new TypeError('hash160 mismatch');
    }
    return Object.assign(o, a);
}

function ripemd160(buffer) {
    return Buffer$1.from(ripemd160$1(Uint8Array.from(buffer)));
}
function sha1$1(buffer) {
    return Buffer$1.from(sha1$2(Uint8Array.from(buffer)));
}
function sha256$1(buffer) {
    return Buffer$1.from(sha256$3(Uint8Array.from(buffer)));
}
function hash160(buffer) {
    return Buffer$1.from(ripemd160$1(sha256$3(Uint8Array.from(buffer))));
}
function hash256(buffer) {
    return Buffer$1.from(sha256$3(sha256$3(Uint8Array.from(buffer))));
}
const TAGS = [
    'BIP0340/challenge',
    'BIP0340/aux',
    'BIP0340/nonce',
    'TapLeaf',
    'TapBranch',
    'TapSighash',
    'TapTweak',
    'KeyAgg list',
    'KeyAgg coefficient',
];
const TAGGED_HASH_PREFIXES = {
    'BIP0340/challenge': Buffer$1.from([
        123, 181, 45, 122, 159, 239, 88, 50, 62, 177, 191, 122, 64, 125, 179, 130, 210, 243, 242,
        216, 27, 177, 34, 79, 73, 254, 81, 143, 109, 72, 211, 124, 123, 181, 45, 122, 159, 239, 88,
        50, 62, 177, 191, 122, 64, 125, 179, 130, 210, 243, 242, 216, 27, 177, 34, 79, 73, 254, 81,
        143, 109, 72, 211, 124,
    ]),
    'BIP0340/aux': Buffer$1.from([
        241, 239, 78, 94, 192, 99, 202, 218, 109, 148, 202, 250, 157, 152, 126, 160, 105, 38, 88,
        57, 236, 193, 31, 151, 45, 119, 165, 46, 216, 193, 204, 144, 241, 239, 78, 94, 192, 99, 202,
        218, 109, 148, 202, 250, 157, 152, 126, 160, 105, 38, 88, 57, 236, 193, 31, 151, 45, 119,
        165, 46, 216, 193, 204, 144,
    ]),
    'BIP0340/nonce': Buffer$1.from([
        7, 73, 119, 52, 167, 155, 203, 53, 91, 155, 140, 125, 3, 79, 18, 28, 244, 52, 215, 62, 247,
        45, 218, 25, 135, 0, 97, 251, 82, 191, 235, 47, 7, 73, 119, 52, 167, 155, 203, 53, 91, 155,
        140, 125, 3, 79, 18, 28, 244, 52, 215, 62, 247, 45, 218, 25, 135, 0, 97, 251, 82, 191, 235,
        47,
    ]),
    TapLeaf: Buffer$1.from([
        174, 234, 143, 220, 66, 8, 152, 49, 5, 115, 75, 88, 8, 29, 30, 38, 56, 211, 95, 28, 181, 64,
        8, 212, 211, 87, 202, 3, 190, 120, 233, 238, 174, 234, 143, 220, 66, 8, 152, 49, 5, 115, 75,
        88, 8, 29, 30, 38, 56, 211, 95, 28, 181, 64, 8, 212, 211, 87, 202, 3, 190, 120, 233, 238,
    ]),
    TapBranch: Buffer$1.from([
        25, 65, 161, 242, 229, 110, 185, 95, 162, 169, 241, 148, 190, 92, 1, 247, 33, 111, 51, 237,
        130, 176, 145, 70, 52, 144, 208, 91, 245, 22, 160, 21, 25, 65, 161, 242, 229, 110, 185, 95,
        162, 169, 241, 148, 190, 92, 1, 247, 33, 111, 51, 237, 130, 176, 145, 70, 52, 144, 208, 91,
        245, 22, 160, 21,
    ]),
    TapSighash: Buffer$1.from([
        244, 10, 72, 223, 75, 42, 112, 200, 180, 146, 75, 242, 101, 70, 97, 237, 61, 149, 253, 102,
        163, 19, 235, 135, 35, 117, 151, 198, 40, 228, 160, 49, 244, 10, 72, 223, 75, 42, 112, 200,
        180, 146, 75, 242, 101, 70, 97, 237, 61, 149, 253, 102, 163, 19, 235, 135, 35, 117, 151,
        198, 40, 228, 160, 49,
    ]),
    TapTweak: Buffer$1.from([
        232, 15, 225, 99, 156, 156, 160, 80, 227, 175, 27, 57, 193, 67, 198, 62, 66, 156, 188, 235,
        21, 217, 64, 251, 181, 197, 161, 244, 175, 87, 197, 233, 232, 15, 225, 99, 156, 156, 160,
        80, 227, 175, 27, 57, 193, 67, 198, 62, 66, 156, 188, 235, 21, 217, 64, 251, 181, 197, 161,
        244, 175, 87, 197, 233,
    ]),
    'KeyAgg list': Buffer$1.from([
        72, 28, 151, 28, 60, 11, 70, 215, 240, 178, 117, 174, 89, 141, 78, 44, 126, 215, 49, 156,
        89, 74, 92, 110, 199, 158, 160, 212, 153, 2, 148, 240, 72, 28, 151, 28, 60, 11, 70, 215,
        240, 178, 117, 174, 89, 141, 78, 44, 126, 215, 49, 156, 89, 74, 92, 110, 199, 158, 160, 212,
        153, 2, 148, 240,
    ]),
    'KeyAgg coefficient': Buffer$1.from([
        191, 201, 4, 3, 77, 28, 136, 232, 200, 14, 34, 229, 61, 36, 86, 109, 100, 130, 78, 214, 66,
        114, 129, 192, 145, 0, 249, 77, 205, 82, 201, 129, 191, 201, 4, 3, 77, 28, 136, 232, 200,
        14, 34, 229, 61, 36, 86, 109, 100, 130, 78, 214, 66, 114, 129, 192, 145, 0, 249, 77, 205,
        82, 201, 129,
    ]),
};
function taggedHash(prefix, data) {
    return sha256$1(Buffer$1.concat([TAGGED_HASH_PREFIXES[prefix], data]));
}

const crypto$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	TAGGED_HASH_PREFIXES,
	TAGS,
	hash160,
	hash256,
	ripemd160,
	sha1: sha1$1,
	sha256: sha256$1,
	taggedHash
}, Symbol.toStringTag, { value: 'Module' }));

/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
const secp256k1_CURVE = {
  p: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn,
  n: 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n,
  b: 7n,
  Gx: 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,
  Gy: 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n
};
const { p: P$1, n: N$1, Gx, Gy, b: _b } = secp256k1_CURVE;
const L = 32;
const L2 = 64;
const err = (m = "") => {
  throw new Error(m);
};
const isBig = (n) => typeof n === "bigint";
const isStr = (s) => typeof s === "string";
const isBytes$1 = (a) => a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
const abytes$1 = (a, l) => !isBytes$1(a) || typeof l === "number" && l > 0 && a.length !== l ? err("Uint8Array expected") : a;
const u8n = (len) => new Uint8Array(len);
const u8fr = (buf) => Uint8Array.from(buf);
const padh = (n, pad) => n.toString(16).padStart(pad, "0");
const bytesToHex = (b) => Array.from(abytes$1(b)).map((e) => padh(e, 2)).join("");
const C = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
const _ch = (ch) => {
  if (ch >= C._0 && ch <= C._9)
    return ch - C._0;
  if (ch >= C.A && ch <= C.F)
    return ch - (C.A - 10);
  if (ch >= C.a && ch <= C.f)
    return ch - (C.a - 10);
  return;
};
const hexToBytes = (hex) => {
  const e = "hex invalid";
  if (!isStr(hex))
    return err(e);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    return err(e);
  const array = u8n(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = _ch(hex.charCodeAt(hi));
    const n2 = _ch(hex.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0)
      return err(e);
    array[ai] = n1 * 16 + n2;
  }
  return array;
};
const toU8 = (a, len) => abytes$1(isStr(a) ? hexToBytes(a) : u8fr(abytes$1(a)), len);
const concatBytes = (...arrs) => {
  const r = u8n(arrs.reduce((sum, a) => sum + abytes$1(a).length, 0));
  let pad = 0;
  arrs.forEach((a) => {
    r.set(a, pad);
    pad += a.length;
  });
  return r;
};
const big = BigInt;
const arange = (n, min, max, msg = "bad number: out of range") => isBig(n) && min <= n && n < max ? n : err(msg);
const M = (a, b = P$1) => {
  const r = a % b;
  return r >= 0n ? r : b + r;
};
const invert = (num, md) => {
  if (num === 0n || md <= 0n)
    err("no inverse n=" + num + " mod=" + md);
  let a = M(num, md), b = md, x = 0n, u = 1n;
  while (a !== 0n) {
    const q = b / a, r = b % a;
    const m = x - u * q;
    b = a, a = r, x = u, u = m;
  }
  return b === 1n ? M(x, md) : err("no inverse");
};
const apoint = (p) => p instanceof Point$1 ? p : err("Point expected");
const koblitz = (x) => M(M(x * x) * x + _b);
const afield0 = (n) => arange(n, 0n, P$1);
const afield = (n) => arange(n, 1n, P$1);
const agroup = (n) => arange(n, 1n, N$1);
const isEven = (y) => (y & 1n) === 0n;
const u8of = (n) => Uint8Array.of(n);
const getPrefix = (y) => u8of(isEven(y) ? 2 : 3);
const lift_x = (x) => {
  const c = koblitz(afield(x));
  let r = 1n;
  for (let num = c, e = (P$1 + 1n) / 4n; e > 0n; e >>= 1n) {
    if (e & 1n)
      r = r * num % P$1;
    num = num * num % P$1;
  }
  return M(r * r) === c ? r : err("sqrt invalid");
};
let Point$1 = class Point {
  static BASE;
  static ZERO;
  px;
  py;
  pz;
  constructor(px, py, pz) {
    this.px = afield0(px);
    this.py = afield(py);
    this.pz = afield0(pz);
    Object.freeze(this);
  }
  /** Convert Uint8Array or hex string to Point. */
  static fromBytes(bytes) {
    abytes$1(bytes);
    let p = void 0;
    const head = bytes[0];
    const tail = bytes.subarray(1);
    const x = sliceBytesNumBE(tail, 0, L);
    const len = bytes.length;
    if (len === L + 1 && [2, 3].includes(head)) {
      let y = lift_x(x);
      const evenY = isEven(y);
      const evenH = isEven(big(head));
      if (evenH !== evenY)
        y = M(-y);
      p = new Point(x, y, 1n);
    }
    if (len === L2 + 1 && head === 4)
      p = new Point(x, sliceBytesNumBE(tail, L, L2), 1n);
    return p ? p.assertValidity() : err("bad point: not on curve");
  }
  /** Equality check: compare points P&Q. */
  equals(other) {
    const { px: X1, py: Y1, pz: Z1 } = this;
    const { px: X2, py: Y2, pz: Z2 } = apoint(other);
    const X1Z2 = M(X1 * Z2);
    const X2Z1 = M(X2 * Z1);
    const Y1Z2 = M(Y1 * Z2);
    const Y2Z1 = M(Y2 * Z1);
    return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
  }
  is0() {
    return this.equals(I);
  }
  /** Flip point over y coordinate. */
  negate() {
    return new Point(this.px, M(-this.py), this.pz);
  }
  /** Point doubling: P+P, complete formula. */
  double() {
    return this.add(this);
  }
  /**
   * Point addition: P+Q, complete, exception-free formula
   * (Renes-Costello-Batina, algo 1 of [2015/1060](https://eprint.iacr.org/2015/1060)).
   * Cost: `12M + 0S + 3*a + 3*b3 + 23add`.
   */
  // prettier-ignore
  add(other) {
    const { px: X1, py: Y1, pz: Z1 } = this;
    const { px: X2, py: Y2, pz: Z2 } = apoint(other);
    const a = 0n;
    const b = _b;
    let X3 = 0n, Y3 = 0n, Z3 = 0n;
    const b3 = M(b * 3n);
    let t0 = M(X1 * X2), t1 = M(Y1 * Y2), t2 = M(Z1 * Z2), t3 = M(X1 + Y1);
    let t4 = M(X2 + Y2);
    t3 = M(t3 * t4);
    t4 = M(t0 + t1);
    t3 = M(t3 - t4);
    t4 = M(X1 + Z1);
    let t5 = M(X2 + Z2);
    t4 = M(t4 * t5);
    t5 = M(t0 + t2);
    t4 = M(t4 - t5);
    t5 = M(Y1 + Z1);
    X3 = M(Y2 + Z2);
    t5 = M(t5 * X3);
    X3 = M(t1 + t2);
    t5 = M(t5 - X3);
    Z3 = M(a * t4);
    X3 = M(b3 * t2);
    Z3 = M(X3 + Z3);
    X3 = M(t1 - Z3);
    Z3 = M(t1 + Z3);
    Y3 = M(X3 * Z3);
    t1 = M(t0 + t0);
    t1 = M(t1 + t0);
    t2 = M(a * t2);
    t4 = M(b3 * t4);
    t1 = M(t1 + t2);
    t2 = M(t0 - t2);
    t2 = M(a * t2);
    t4 = M(t4 + t2);
    t0 = M(t1 * t4);
    Y3 = M(Y3 + t0);
    t0 = M(t5 * t4);
    X3 = M(t3 * X3);
    X3 = M(X3 - t0);
    t0 = M(t3 * t1);
    Z3 = M(t5 * Z3);
    Z3 = M(Z3 + t0);
    return new Point(X3, Y3, Z3);
  }
  /**
   * Point-by-scalar multiplication. Scalar must be in range 1 <= n < CURVE.n.
   * Uses {@link wNAF} for base point.
   * Uses fake point to mitigate side-channel leakage.
   * @param n scalar by which point is multiplied
   * @param safe safe mode guards against timing attacks; unsafe mode is faster
   */
  multiply(n, safe = true) {
    if (!safe && n === 0n)
      return I;
    agroup(n);
    if (n === 1n)
      return this;
    if (this.equals(G))
      return wNAF(n).p;
    let p = I;
    let f = G;
    for (let d = this; n > 0n; d = d.double(), n >>= 1n) {
      if (n & 1n)
        p = p.add(d);
      else if (safe)
        f = f.add(d);
    }
    return p;
  }
  /** Convert point to 2d xy affine point. (X, Y, Z)  (x=X/Z, y=Y/Z) */
  toAffine() {
    const { px: x, py: y, pz: z } = this;
    if (this.equals(I))
      return { x: 0n, y: 0n };
    if (z === 1n)
      return { x, y };
    const iz = invert(z, P$1);
    if (M(z * iz) !== 1n)
      err("inverse invalid");
    return { x: M(x * iz), y: M(y * iz) };
  }
  /** Checks if the point is valid and on-curve. */
  assertValidity() {
    const { x, y } = this.toAffine();
    afield(x);
    afield(y);
    return M(y * y) === koblitz(x) ? this : err("bad point: not on curve");
  }
  /** Converts point to 33/65-byte Uint8Array. */
  toBytes(isCompressed = true) {
    const { x, y } = this.assertValidity().toAffine();
    const x32b = numTo32b(x);
    if (isCompressed)
      return concatBytes(getPrefix(y), x32b);
    return concatBytes(u8of(4), x32b, numTo32b(y));
  }
  /** Create 3d xyz point from 2d xy. (0, 0) => (0, 1, 0), not (0, 0, 1) */
  static fromAffine(ap) {
    const { x, y } = ap;
    return x === 0n && y === 0n ? I : new Point(x, y, 1n);
  }
  toHex(isCompressed) {
    return bytesToHex(this.toBytes(isCompressed));
  }
  static fromPrivateKey(k) {
    return G.multiply(toPrivScalar(k));
  }
  static fromHex(hex) {
    return Point.fromBytes(toU8(hex));
  }
  get x() {
    return this.toAffine().x;
  }
  get y() {
    return this.toAffine().y;
  }
  toRawBytes(isCompressed) {
    return this.toBytes(isCompressed);
  }
};
const G = new Point$1(Gx, Gy, 1n);
const I = new Point$1(0n, 1n, 0n);
Point$1.BASE = G;
Point$1.ZERO = I;
const bytesToNumBE = (b) => big("0x" + (bytesToHex(b) || "0"));
const sliceBytesNumBE = (b, from, to) => bytesToNumBE(b.subarray(from, to));
const B256 = 2n ** 256n;
const numTo32b = (num) => hexToBytes(padh(arange(num, 0n, B256), L2));
const toPrivScalar = (pr) => {
  const num = isBig(pr) ? pr : bytesToNumBE(toU8(pr, L));
  return arange(num, 1n, N$1, "private key invalid 3");
};
const W = 8;
const scalarBits = 256;
const pwindows = Math.ceil(scalarBits / W) + 1;
const pwindowSize = 2 ** (W - 1);
const precompute = () => {
  const points = [];
  let p = G;
  let b = p;
  for (let w = 0; w < pwindows; w++) {
    b = p;
    points.push(b);
    for (let i = 1; i < pwindowSize; i++) {
      b = b.add(p);
      points.push(b);
    }
    p = b.double();
  }
  return points;
};
let Gpows = void 0;
const ctneg = (cnd, p) => {
  const n = p.negate();
  return cnd ? n : p;
};
const wNAF = (n) => {
  const comp = Gpows || (Gpows = precompute());
  let p = I;
  let f = G;
  const pow_2_w = 2 ** W;
  const maxNum = pow_2_w;
  const mask = big(pow_2_w - 1);
  const shiftBy = big(W);
  for (let w = 0; w < pwindows; w++) {
    let wbits = Number(n & mask);
    n >>= shiftBy;
    if (wbits > pwindowSize) {
      wbits -= maxNum;
      n += 1n;
    }
    const off = w * pwindowSize;
    const offF = off;
    const offP = off + Math.abs(wbits) - 1;
    const isEven2 = w % 2 !== 0;
    const isNeg = wbits < 0;
    if (wbits === 0) {
      f = f.add(ctneg(isEven2, comp[offF]));
    } else {
      p = p.add(ctneg(isNeg, comp[offP]));
    }
  }
  return { p, f };
};

const toXOnly = (pubKey) => {
    const buffer = pubKey.length === 32 ? pubKey : pubKey.subarray(1, 33);
    return Buffer$1.isBuffer(buffer) ? buffer : Buffer$1.from(buffer);
};
function bigIntTo32Bytes(num) {
    let hex = num.toString(16);
    hex = hex.padStart(64, '0');
    if (hex.length > 64) {
        hex = hex.slice(-64);
    }
    return Buffer$1.from(hex, 'hex');
}
function decompressPublicKey(realPubKey) {
    if (realPubKey.length === 32) {
        return;
    }
    if (![33, 65].includes(realPubKey.length)) {
        console.warn(`Unsupported key length=${realPubKey.length}. Must be 33 (compressed) or 65 (uncompressed).`);
        return;
    }
    let point;
    try {
        point = Point$1.fromHex(realPubKey);
    }
    catch (err) {
        throw new Error('Invalid secp256k1 public key bytes. Cannot parse.');
    }
    const xBuf = bigIntTo32Bytes(point.x);
    const yBuf = bigIntTo32Bytes(point.y);
    const isEven = point.y % 2n === 0n;
    const prefix = isEven ? 0x06 : 0x07;
    const hybridPubKey = Buffer$1.alloc(65);
    hybridPubKey[0] = prefix;
    xBuf.copy(hybridPubKey, 1);
    yBuf.copy(hybridPubKey, 33);
    const uncompressedPubKey = Buffer$1.concat([Buffer$1.from([0x04]), xBuf, yBuf]);
    return {
        hybrid: hybridPubKey,
        uncompressed: uncompressedPubKey,
    };
}
function pubkeysMatch(a, b) {
    if (a.equals(b))
        return true;
    if (a.length === 65 && b.length === 65) {
        const aCopy = Buffer$1.from(a);
        const bCopy = Buffer$1.from(b);
        if (aCopy[0] === 0x06 || aCopy[0] === 0x07)
            aCopy[0] = 0x04;
        if (bCopy[0] === 0x06 || bCopy[0] === 0x07)
            bCopy[0] = 0x04;
        return aCopy.equals(bCopy);
    }
    return false;
}

const OPS$7 = opcodes;
function p2pkh(a, opts) {
    if (!a.address && !a.hash && !a.output && !a.pubkey && !a.input) {
        throw new TypeError('Not enough data');
    }
    opts = Object.assign({ validate: true }, opts || {});
    typef({
        network: typef.maybe(typef.Object),
        address: typef.maybe(typef.String),
        hash: typef.maybe(typef.BufferN(20)),
        output: typef.maybe(typef.BufferN(25)),
        pubkey: typef.maybe(isPoint),
        signature: typef.maybe(isCanonicalScriptSignature),
        input: typef.maybe(typef.Buffer),
    }, a);
    const _address = value(() => {
        const payload = Buffer$1.from(index$1.decode(a.address));
        const version = payload.readUInt8(0);
        const hash = payload.subarray(1);
        return { version, hash };
    });
    const _chunks = value(() => {
        return decompile(a.input);
    });
    const network = a.network || bitcoin$1;
    const o = {
        name: PaymentType.P2PKH,
        network,
        hash: undefined,
    };
    prop(o, 'address', () => {
        if (!o.hash)
            return;
        const payload = Buffer$1.allocUnsafe(21);
        payload.writeUInt8(network.pubKeyHash, 0);
        o.hash.copy(payload, 1);
        return index$1.encode(payload);
    });
    prop(o, 'hash', () => {
        if (a.output)
            return a.output.subarray(3, 23);
        if (a.address)
            return _address().hash;
        if (a.pubkey || o.pubkey)
            return hash160(a.pubkey || o.pubkey);
    });
    prop(o, 'output', () => {
        if (!o.hash)
            return;
        return compile([
            OPS$7.OP_DUP,
            OPS$7.OP_HASH160,
            o.hash,
            OPS$7.OP_EQUALVERIFY,
            OPS$7.OP_CHECKSIG,
        ]);
    });
    prop(o, 'pubkey', () => {
        if (!a.input)
            return;
        return _chunks()[1];
    });
    prop(o, 'signature', () => {
        if (!a.input)
            return;
        return _chunks()[0];
    });
    prop(o, 'input', () => {
        if (!a.pubkey)
            return;
        if (!a.signature)
            return;
        let pubKey = a.pubkey;
        if (a.useHybrid || a.useUncompressed) {
            const decompressed = decompressPublicKey(a.pubkey);
            if (decompressed) {
                if (a.useUncompressed) {
                    pubKey = decompressed.uncompressed;
                }
                else {
                    pubKey = decompressed.hybrid;
                }
            }
        }
        return compile([a.signature, pubKey]);
    });
    prop(o, 'witness', () => {
        if (!o.input)
            return;
        return [];
    });
    if (opts.validate) {
        let hash = Buffer$1.from([]);
        if (a.address) {
            if (_address().version !== network.pubKeyHash) {
                throw new TypeError('Invalid version or Network mismatch');
            }
            if (_address().hash.length !== 20) {
                throw new TypeError('Invalid address');
            }
            hash = _address().hash;
        }
        if (a.hash) {
            if (hash.length > 0 && !hash.equals(a.hash)) {
                throw new TypeError('Hash mismatch');
            }
            else {
                hash = a.hash;
            }
        }
        if (a.output) {
            if (a.output.length !== 25 ||
                a.output[0] !== OPS$7.OP_DUP ||
                a.output[1] !== OPS$7.OP_HASH160 ||
                a.output[2] !== 0x14 ||
                a.output[23] !== OPS$7.OP_EQUALVERIFY ||
                a.output[24] !== OPS$7.OP_CHECKSIG) {
                throw new TypeError('Output is invalid');
            }
            const hash2 = a.output.subarray(3, 23);
            if (hash.length > 0 && !hash.equals(hash2))
                throw new TypeError('Hash mismatch');
            else
                hash = hash2;
        }
        if (a.pubkey) {
            const pkh = hash160(a.pubkey);
            let badHash = hash.length > 0 && !hash.equals(pkh);
            if (badHash) {
                if ((a.pubkey.length === 33 && (a.pubkey[0] === 0x02 || a.pubkey[0] === 0x03)) ||
                    (a.pubkey.length === 65 && a.pubkey[0] === 0x04)) {
                    const uncompressed = decompressPublicKey(a.pubkey);
                    if (uncompressed) {
                        const pkh2 = hash160(uncompressed.uncompressed);
                        if (!hash.equals(pkh2)) {
                            const pkh3 = hash160(uncompressed.hybrid);
                            badHash = !hash.equals(pkh3);
                            if (!badHash) {
                                a.useHybrid = true;
                            }
                        }
                        else {
                            badHash = false;
                            a.useUncompressed = true;
                        }
                    }
                }
            }
            if (badHash) {
                throw new TypeError('Hash mismatch');
            }
            else {
                hash = pkh;
            }
        }
        if (a.input) {
            const chunks = _chunks();
            if (chunks.length !== 2)
                throw new TypeError('Input is invalid');
            if (!isCanonicalScriptSignature(chunks[0]))
                throw new TypeError('Input has invalid signature');
            if (!isPoint(chunks[1]))
                throw new TypeError('Input has invalid pubkey');
            if (a.signature && !a.signature.equals(chunks[0]))
                throw new TypeError('Signature mismatch');
            if (a.pubkey && !a.pubkey.equals(chunks[1]))
                throw new TypeError('Pubkey mismatch');
            const pkh = hash160(chunks[1]);
            if (hash.length > 0 && !hash.equals(pkh))
                throw new TypeError('Hash mismatch (input)');
        }
    }
    return Object.assign(o, a);
}

const OPS$6 = opcodes;
function p2sh(a, opts) {
    if (!a.address && !a.hash && !a.output && !a.redeem && !a.input) {
        throw new TypeError('Not enough data');
    }
    opts = Object.assign({ validate: true }, opts || {});
    typef({
        network: typef.maybe(typef.Object),
        address: typef.maybe(typef.String),
        hash: typef.maybe(typef.BufferN(20)),
        output: typef.maybe(typef.BufferN(23)),
        redeem: typef.maybe({
            network: typef.maybe(typef.Object),
            output: typef.maybe(typef.Buffer),
            input: typef.maybe(typef.Buffer),
            witness: typef.maybe(typef.arrayOf(typef.Buffer)),
        }),
        input: typef.maybe(typef.Buffer),
        witness: typef.maybe(typef.arrayOf(typef.Buffer)),
    }, a);
    let network = a.network;
    if (!network) {
        network = (a.redeem && a.redeem.network) || bitcoin$1;
    }
    const o = {
        network,
        name: PaymentType.P2SH,
    };
    const _address = value(() => {
        const payload = Buffer$1.from(index$1.decode(a.address));
        const version = payload.readUInt8(0);
        const hash = payload.subarray(1);
        return { version, hash };
    });
    const _chunks = value(() => {
        return decompile(a.input);
    });
    const _redeem = value(() => {
        const chunks = _chunks();
        const lastChunk = chunks[chunks.length - 1];
        return {
            network,
            output: lastChunk === OPS$6.OP_FALSE ? Buffer$1.from([]) : lastChunk,
            input: compile(chunks.slice(0, -1)),
            witness: a.witness || [],
        };
    });
    prop(o, 'address', () => {
        if (!o.hash)
            return;
        const payload = Buffer$1.allocUnsafe(21);
        payload.writeUInt8(o.network.scriptHash, 0);
        o.hash.copy(payload, 1);
        return index$1.encode(payload);
    });
    prop(o, 'hash', () => {
        if (a.output)
            return a.output.subarray(2, 22);
        if (a.address)
            return _address().hash;
        if (o.redeem && o.redeem.output)
            return hash160(o.redeem.output);
    });
    prop(o, 'output', () => {
        if (!o.hash)
            return;
        return compile([OPS$6.OP_HASH160, o.hash, OPS$6.OP_EQUAL]);
    });
    prop(o, 'redeem', () => {
        if (!a.input)
            return;
        return _redeem();
    });
    prop(o, 'input', () => {
        if (!a.redeem || !a.redeem.input || !a.redeem.output)
            return;
        return compile([].concat(decompile(a.redeem.input), a.redeem.output));
    });
    prop(o, 'witness', () => {
        if (o.redeem && o.redeem.witness)
            return o.redeem.witness;
        if (o.input)
            return [];
    });
    prop(o, 'name', () => {
        const nameParts = ['p2sh'];
        if (o.redeem !== undefined && o.redeem.name !== undefined)
            nameParts.push(o.redeem.name);
        return nameParts.join('-');
    });
    if (opts.validate) {
        let hash = Buffer$1.from([]);
        if (a.address) {
            if (_address().version !== network.scriptHash)
                throw new TypeError('Invalid version or Network mismatch');
            if (_address().hash.length !== 20)
                throw new TypeError('Invalid address');
            hash = _address().hash;
        }
        if (a.hash) {
            if (hash.length > 0 && !hash.equals(a.hash))
                throw new TypeError('Hash mismatch');
            else
                hash = a.hash;
        }
        if (a.output) {
            if (a.output.length !== 23 ||
                a.output[0] !== OPS$6.OP_HASH160 ||
                a.output[1] !== 0x14 ||
                a.output[22] !== OPS$6.OP_EQUAL)
                throw new TypeError('Output is invalid');
            const hash2 = a.output.subarray(2, 22);
            if (hash.length > 0 && !hash.equals(hash2))
                throw new TypeError('Hash mismatch');
            else
                hash = hash2;
        }
        const checkRedeem = (redeem) => {
            if (redeem.output) {
                const decompile$1 = decompile(redeem.output);
                if (!decompile$1 || decompile$1.length < 1)
                    throw new TypeError('Redeem.output too short');
                if (redeem.output.byteLength > 520)
                    throw new TypeError('Redeem.output unspendable if larger than 520 bytes');
                if (countNonPushOnlyOPs(decompile$1) > 201)
                    throw new TypeError('Redeem.output unspendable with more than 201 non-push ops');
                const hash2 = hash160(redeem.output);
                if (hash.length > 0 && !hash.equals(hash2))
                    throw new TypeError('Hash mismatch');
                else
                    hash = hash2;
            }
            if (redeem.input) {
                const hasInput = redeem.input.length > 0;
                const hasWitness = redeem.witness && redeem.witness.length > 0;
                if (!hasInput && !hasWitness)
                    throw new TypeError('Empty input');
                if (hasInput && hasWitness)
                    throw new TypeError('Input and witness provided');
                if (hasInput) {
                    const richunks = decompile(redeem.input);
                    if (!isPushOnly(richunks))
                        throw new TypeError('Non push-only scriptSig');
                }
            }
        };
        if (a.input) {
            const chunks = _chunks();
            if (!chunks || chunks.length < 1)
                throw new TypeError('Input too short');
            if (!Buffer$1.isBuffer(_redeem().output))
                throw new TypeError('Input is invalid');
            checkRedeem(_redeem());
        }
        if (a.redeem) {
            if (a.redeem.network && a.redeem.network !== network)
                throw new TypeError('Network mismatch');
            if (a.input) {
                const redeem = _redeem();
                if (a.redeem.output && !a.redeem.output.equals(redeem.output))
                    throw new TypeError('Redeem.output mismatch');
                if (a.redeem.input && !a.redeem.input.equals(redeem.input))
                    throw new TypeError('Redeem.input mismatch');
            }
            checkRedeem(a.redeem);
        }
        if (a.witness) {
            if (a.redeem && a.redeem.witness && !stacksEqual(a.redeem.witness, a.witness))
                throw new TypeError('Witness and redeem.witness mismatch');
        }
    }
    return Object.assign(o, a);
}

const _ECCLIB_CACHE = {};
function initEccLib(eccLib) {
    if (!eccLib) {
        _ECCLIB_CACHE.eccLib = eccLib;
    }
    else if (eccLib !== _ECCLIB_CACHE.eccLib) {
        verifyEcc(eccLib);
        _ECCLIB_CACHE.eccLib = eccLib;
    }
}
function getEccLib() {
    if (!_ECCLIB_CACHE.eccLib)
        throw new Error('No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance');
    return _ECCLIB_CACHE.eccLib;
}
const h = (hex) => Buffer$1.from(hex, 'hex');
function verifyEcc(ecc) {
    assert(typeof ecc.isXOnlyPoint === 'function');
    assert(ecc.isXOnlyPoint(h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798')));
    assert(ecc.isXOnlyPoint(h('fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e')));
    assert(ecc.isXOnlyPoint(h('f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9')));
    assert(ecc.isXOnlyPoint(h('0000000000000000000000000000000000000000000000000000000000000001')));
    assert(!ecc.isXOnlyPoint(h('0000000000000000000000000000000000000000000000000000000000000000')));
    assert(!ecc.isXOnlyPoint(h('fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f')));
    assert(typeof ecc.xOnlyPointAddTweak === 'function');
    tweakAddVectors.forEach((t) => {
        const r = ecc.xOnlyPointAddTweak(h(t.pubkey), h(t.tweak));
        if (t.result === null) {
            assert(r === null);
        }
        else {
            assert(r !== null);
            assert(r.parity === t.parity);
            assert(Buffer$1.from(r.xOnlyPubkey).equals(h(t.result)));
        }
    });
}
function assert(bool) {
    if (!bool)
        throw new Error('ecc library invalid');
}
const tweakAddVectors = [
    {
        pubkey: '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
        tweak: 'fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140',
        parity: -1,
        result: null,
    },
    {
        pubkey: '1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b',
        tweak: 'a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac',
        parity: 1,
        result: 'e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf',
    },
    {
        pubkey: '2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991',
        tweak: '823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47',
        parity: 0,
        result: '9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c',
    },
];

const HEX_STRINGS$1 = "0123456789abcdefABCDEF";
HEX_STRINGS$1.split("").map((c) => c.codePointAt(0));
Array(256)
    .fill(true)
    .map((_, i) => {
    const s = String.fromCodePoint(i);
    const index = HEX_STRINGS$1.indexOf(s);
    // ABCDEF will use 10 - 15
    return index < 0 ? undefined : index < 16 ? index : index - 6;
});
new TextEncoder();
new TextDecoder();
function writeUInt16$1(buffer, offset, value, littleEndian) {
    if (offset + 2 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    littleEndian = littleEndian.toUpperCase();
    if (value > 0xffff) {
        throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffff}. Received ${value}`);
    }
    if (littleEndian === "LE") {
        buffer[offset] = value & 0xff;
        buffer[offset + 1] = (value >> 8) & 0xff;
    }
    else {
        buffer[offset] = (value >> 8) & 0xff;
        buffer[offset + 1] = value & 0xff;
    }
}
function writeUInt32$1(buffer, offset, value, littleEndian) {
    if (offset + 4 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    littleEndian = littleEndian.toUpperCase();
    if (value > 0xffffffff) {
        throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffffffff}. Received ${value}`);
    }
    if (littleEndian === "LE") {
        buffer[offset] = value & 0xff;
        buffer[offset + 1] = (value >> 8) & 0xff;
        buffer[offset + 2] = (value >> 16) & 0xff;
        buffer[offset + 3] = (value >> 24) & 0xff;
    }
    else {
        buffer[offset] = (value >> 24) & 0xff;
        buffer[offset + 1] = (value >> 16) & 0xff;
        buffer[offset + 2] = (value >> 8) & 0xff;
        buffer[offset + 3] = value & 0xff;
    }
}
function writeUInt64$1(buffer, offset, value, littleEndian) {
    if (offset + 8 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    littleEndian = littleEndian.toUpperCase();
    if (value > 0xffffffffffffffffn) {
        throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffffffffffffffffn}. Received ${value}`);
    }
    if (littleEndian === "LE") {
        buffer[offset] = Number(value & 0xffn);
        buffer[offset + 1] = Number((value >> 8n) & 0xffn);
        buffer[offset + 2] = Number((value >> 16n) & 0xffn);
        buffer[offset + 3] = Number((value >> 24n) & 0xffn);
        buffer[offset + 4] = Number((value >> 32n) & 0xffn);
        buffer[offset + 5] = Number((value >> 40n) & 0xffn);
        buffer[offset + 6] = Number((value >> 48n) & 0xffn);
        buffer[offset + 7] = Number((value >> 56n) & 0xffn);
    }
    else {
        buffer[offset] = Number((value >> 56n) & 0xffn);
        buffer[offset + 1] = Number((value >> 48n) & 0xffn);
        buffer[offset + 2] = Number((value >> 40n) & 0xffn);
        buffer[offset + 3] = Number((value >> 32n) & 0xffn);
        buffer[offset + 4] = Number((value >> 24n) & 0xffn);
        buffer[offset + 5] = Number((value >> 16n) & 0xffn);
        buffer[offset + 6] = Number((value >> 8n) & 0xffn);
        buffer[offset + 7] = Number(value & 0xffn);
    }
}
function readUInt16$1(buffer, offset, littleEndian) {
    if (offset + 2 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    littleEndian = littleEndian.toUpperCase();
    if (littleEndian === "LE") {
        let num = 0;
        num = (num << 8) + buffer[offset + 1];
        num = (num << 8) + buffer[offset];
        return num;
    }
    else {
        let num = 0;
        num = (num << 8) + buffer[offset];
        num = (num << 8) + buffer[offset + 1];
        return num;
    }
}
function readUInt32$1(buffer, offset, littleEndian) {
    if (offset + 4 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    littleEndian = littleEndian.toUpperCase();
    if (littleEndian === "LE") {
        let num = 0;
        num = ((num << 8) + buffer[offset + 3]) >>> 0;
        num = ((num << 8) + buffer[offset + 2]) >>> 0;
        num = ((num << 8) + buffer[offset + 1]) >>> 0;
        num = ((num << 8) + buffer[offset]) >>> 0;
        return num;
    }
    else {
        let num = 0;
        num = ((num << 8) + buffer[offset]) >>> 0;
        num = ((num << 8) + buffer[offset + 1]) >>> 0;
        num = ((num << 8) + buffer[offset + 2]) >>> 0;
        num = ((num << 8) + buffer[offset + 3]) >>> 0;
        return num;
    }
}
function readUInt64$1(buffer, offset, littleEndian) {
    if (offset + 8 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    littleEndian = littleEndian.toUpperCase();
    if (littleEndian === "LE") {
        let num = 0n;
        num = (num << 8n) + BigInt(buffer[offset + 7]);
        num = (num << 8n) + BigInt(buffer[offset + 6]);
        num = (num << 8n) + BigInt(buffer[offset + 5]);
        num = (num << 8n) + BigInt(buffer[offset + 4]);
        num = (num << 8n) + BigInt(buffer[offset + 3]);
        num = (num << 8n) + BigInt(buffer[offset + 2]);
        num = (num << 8n) + BigInt(buffer[offset + 1]);
        num = (num << 8n) + BigInt(buffer[offset]);
        return num;
    }
    else {
        let num = 0n;
        num = (num << 8n) + BigInt(buffer[offset]);
        num = (num << 8n) + BigInt(buffer[offset + 1]);
        num = (num << 8n) + BigInt(buffer[offset + 2]);
        num = (num << 8n) + BigInt(buffer[offset + 3]);
        num = (num << 8n) + BigInt(buffer[offset + 4]);
        num = (num << 8n) + BigInt(buffer[offset + 5]);
        num = (num << 8n) + BigInt(buffer[offset + 6]);
        num = (num << 8n) + BigInt(buffer[offset + 7]);
        return num;
    }
}

const checkUInt64 = (n) => {
    if (n < 0 || n > 0xffffffffffffffffn) {
        throw new RangeError('value out of range');
    }
};
function checkUInt53(n) {
    if (n < 0 || n > Number.MAX_SAFE_INTEGER || n % 1 !== 0)
        throw new RangeError('value out of range');
}
function checkUint53OrUint64(n) {
    if (typeof n === 'number')
        checkUInt53(n);
    else
        checkUInt64(n);
}
function encode(n, buffer, offset) {
    checkUint53OrUint64(n);
    if (offset === undefined)
        offset = 0;
    if (buffer === undefined) {
        buffer = new Uint8Array(encodingLength(n));
    }
    let bytes = 0;
    // 8 bit
    if (n < 0xfd) {
        buffer.set([Number(n)], offset);
        bytes = 1;
        // 16 bit
    }
    else if (n <= 0xffff) {
        buffer.set([0xfd], offset);
        writeUInt16$1(buffer, offset + 1, Number(n), 'LE');
        bytes = 3;
        // 32 bit
    }
    else if (n <= 0xffffffff) {
        buffer.set([0xfe], offset);
        writeUInt32$1(buffer, offset + 1, Number(n), 'LE');
        bytes = 5;
        // 64 bit
    }
    else {
        buffer.set([0xff], offset);
        writeUInt64$1(buffer, offset + 1, BigInt(n), 'LE');
        bytes = 9;
    }
    return { buffer, bytes };
}
function decode(buffer, offset) {
    if (offset === undefined)
        offset = 0;
    const first = buffer.at(offset);
    if (first === undefined)
        throw new Error('buffer too small');
    // 8 bit
    if (first < 0xfd) {
        return { numberValue: first, bigintValue: BigInt(first), bytes: 1 };
        // 16 bit
    }
    else if (first === 0xfd) {
        const val = readUInt16$1(buffer, offset + 1, 'LE');
        return {
            numberValue: val,
            bigintValue: BigInt(val),
            bytes: 3
        };
        // 32 bit
    }
    else if (first === 0xfe) {
        const val = readUInt32$1(buffer, offset + 1, 'LE');
        return {
            numberValue: val,
            bigintValue: BigInt(val),
            bytes: 5
        };
        // 64 bit
    }
    else {
        const number = readUInt64$1(buffer, offset + 1, 'LE');
        return { numberValue: number <= Number.MAX_SAFE_INTEGER ? Number(number) : null, bigintValue: number, bytes: 9 };
    }
}
function encodingLength(n) {
    checkUint53OrUint64(n);
    return n < 0xfd ? 1 : n <= 0xffff ? 3 : n <= 0xffffffff ? 5 : 9;
}

const { typeforce: typeforce$1 } = types$3;
function verifuint(value, max) {
    if (typeof value !== 'number')
        throw new Error('cannot write a non-number as a number');
    if (value < 0)
        throw new Error('specified a negative value for writing an unsigned value');
    if (value > max)
        throw new Error('RangeError: value out of range');
    if (Math.floor(value) !== value)
        throw new Error('value has a fractional component');
}
function readUInt64LE(buffer, offset) {
    const a = buffer.readUInt32LE(offset);
    let b = buffer.readUInt32LE(offset + 4);
    b *= 0x100000000;
    verifuint(b + a, 0x001fffffffffffff);
    return b + a;
}
function writeUInt64LE(buffer, value, offset) {
    verifuint(value, 0x001fffffffffffff);
    buffer.writeInt32LE(value & -1, offset);
    buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);
    return offset + 8;
}
function reverseBuffer(buffer) {
    if (buffer.length < 1)
        return buffer;
    let j = buffer.length - 1;
    let tmp = 0;
    for (let i = 0; i < buffer.length / 2; i++) {
        tmp = buffer[i];
        buffer[i] = buffer[j];
        buffer[j] = tmp;
        j--;
    }
    return buffer;
}
function cloneBuffer(buffer) {
    const clone = Buffer$1.allocUnsafe(buffer.length);
    buffer.copy(clone);
    return clone;
}
class BufferWriter {
    constructor(buffer, offset = 0) {
        this.buffer = buffer;
        this.offset = offset;
        typeforce$1(tuple(Buffer, UInt32), [buffer, offset]);
    }
    static withCapacity(size) {
        return new BufferWriter(Buffer$1.alloc(size));
    }
    writeUInt8(i) {
        this.offset = this.buffer.writeUInt8(i, this.offset);
    }
    writeInt32(i) {
        this.offset = this.buffer.writeInt32LE(i, this.offset);
    }
    writeUInt32(i) {
        this.offset = this.buffer.writeUInt32LE(i, this.offset);
    }
    writeUInt64(i) {
        this.offset = writeUInt64LE(this.buffer, i, this.offset);
    }
    writeVarInt(i) {
        const encode$1 = encode(i, this.buffer, this.offset);
        this.offset += encode$1.bytes;
    }
    writeSlice(slice) {
        if (this.buffer.length < this.offset + slice.length) {
            throw new Error('Cannot write slice out of bounds');
        }
        this.offset += slice.copy(this.buffer, this.offset);
    }
    writeVarSlice(slice) {
        this.writeVarInt(slice.length);
        this.writeSlice(slice);
    }
    writeVector(vector) {
        this.writeVarInt(vector.length);
        vector.forEach((buf) => this.writeVarSlice(buf));
    }
    end() {
        if (this.buffer.length === this.offset) {
            return this.buffer;
        }
        throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);
    }
}
class BufferReader {
    constructor(buffer, offset = 0) {
        this.buffer = buffer;
        this.offset = offset;
        typeforce$1(tuple(Buffer, UInt32), [buffer, offset]);
    }
    readUInt8() {
        const result = this.buffer.readUInt8(this.offset);
        this.offset++;
        return result;
    }
    readInt32() {
        const result = this.buffer.readInt32LE(this.offset);
        this.offset += 4;
        return result;
    }
    readUInt32() {
        const result = this.buffer.readUInt32LE(this.offset);
        this.offset += 4;
        return result;
    }
    readUInt64() {
        const result = readUInt64LE(this.buffer, this.offset);
        this.offset += 8;
        return result;
    }
    readVarInt() {
        const vi = decode(this.buffer, this.offset);
        this.offset += vi.bytes;
        return vi.numberValue || 0;
    }
    readSlice(n) {
        if (this.buffer.length < this.offset + n) {
            throw new Error('Cannot read slice out of bounds');
        }
        const result = Buffer$1.from(this.buffer.subarray(this.offset, this.offset + n));
        this.offset += n;
        return result;
    }
    readVarSlice() {
        return this.readSlice(this.readVarInt());
    }
    readVector() {
        const count = this.readVarInt();
        const vector = [];
        for (let i = 0; i < count; i++)
            vector.push(this.readVarSlice());
        return vector;
    }
}

const LEAF_VERSION_TAPSCRIPT = 0xc0;
const MAX_TAPTREE_DEPTH = 128;
const isHashBranch = (ht) => 'left' in ht && 'right' in ht;
function rootHashFromPath(controlBlock, leafHash) {
    if (controlBlock.length < 33)
        throw new TypeError(`The control-block length is too small. Got ${controlBlock.length}, expected min 33.`);
    const m = (controlBlock.length - 33) / 32;
    let kj = leafHash;
    for (let j = 0; j < m; j++) {
        const ej = controlBlock.subarray(33 + 32 * j, 65 + 32 * j);
        if (kj.compare(ej) < 0) {
            kj = tapBranchHash(kj, ej);
        }
        else {
            kj = tapBranchHash(ej, kj);
        }
    }
    return kj;
}
function toHashTree(scriptTree) {
    if (isTapleaf(scriptTree))
        return { hash: tapleafHash(scriptTree) };
    const hashes = [toHashTree(scriptTree[0]), toHashTree(scriptTree[1])];
    hashes.sort((a, b) => a.hash.compare(b.hash));
    const [left, right] = hashes;
    return {
        hash: tapBranchHash(left.hash, right.hash),
        left,
        right,
    };
}
function findScriptPath(node, hash) {
    if (isHashBranch(node)) {
        const leftPath = findScriptPath(node.left, hash);
        if (leftPath !== undefined)
            return [...leftPath, node.right.hash];
        const rightPath = findScriptPath(node.right, hash);
        if (rightPath !== undefined)
            return [...rightPath, node.left.hash];
    }
    else if (node.hash.equals(hash)) {
        return [];
    }
    return undefined;
}
function tapleafHash(leaf) {
    const version = leaf.version || LEAF_VERSION_TAPSCRIPT;
    return taggedHash('TapLeaf', Buffer$1$1.concat([Buffer$1$1.from([version]), serializeScript(leaf.output)]));
}
function tapTweakHash$1(pubKey, h) {
    return taggedHash('TapTweak', Buffer$1$1.concat(h ? [pubKey, h] : [pubKey]));
}
function tweakKey(pubKey, h) {
    if (!Buffer$1$1.isBuffer(pubKey))
        return null;
    if (pubKey.length !== 32)
        return null;
    if (h && h.length !== 32)
        return null;
    const tweakHash = tapTweakHash$1(pubKey, h);
    const res = getEccLib().xOnlyPointAddTweak(pubKey, tweakHash);
    if (!res || res.xOnlyPubkey === null)
        return null;
    return {
        parity: res.parity,
        x: Buffer$1$1.from(res.xOnlyPubkey),
    };
}
function tapBranchHash(a, b) {
    return taggedHash('TapBranch', Buffer$1$1.concat([a, b]));
}
function serializeScript(s) {
    const varintLen = encodingLength(s.length);
    const buffer = Buffer$1$1.allocUnsafe(varintLen);
    encode(s.length, buffer);
    return Buffer$1$1.concat([buffer, s]);
}

const OPS$5 = opcodes;
const TAPROOT_WITNESS_VERSION = 0x01;
const ANNEX_PREFIX = 0x50;
function p2tr(a, opts) {
    if (!a.address &&
        !a.output &&
        !a.pubkey &&
        !a.internalPubkey &&
        !(a.witness && a.witness.length > 1))
        throw new TypeError('Not enough data');
    opts = Object.assign({ validate: true }, opts || {});
    typef({
        address: typef.maybe(typef.String),
        input: typef.maybe(typef.BufferN(0)),
        network: typef.maybe(typef.Object),
        output: typef.maybe(typef.BufferN(34)),
        internalPubkey: typef.maybe(typef.BufferN(32)),
        hash: typef.maybe(typef.BufferN(32)),
        pubkey: typef.maybe(typef.BufferN(32)),
        signature: typef.maybe(typef.anyOf(typef.BufferN(64), typef.BufferN(65))),
        witness: typef.maybe(typef.arrayOf(typef.Buffer)),
        scriptTree: typef.maybe(isTaptree),
        redeem: typef.maybe({
            output: typef.maybe(typef.Buffer),
            redeemVersion: typef.maybe(typef.Number),
            witness: typef.maybe(typef.arrayOf(typef.Buffer)),
        }),
        redeemVersion: typef.maybe(typef.Number),
    }, a);
    const _address = value(() => {
        return fromBech32(a.address);
    });
    const _witness = value(() => {
        if (!a.witness || !a.witness.length)
            return;
        if (a.witness.length >= 2 && a.witness[a.witness.length - 1][0] === ANNEX_PREFIX) {
            return a.witness.slice(0, -1);
        }
        return a.witness.slice();
    });
    const _hashTree = value(() => {
        if (a.scriptTree)
            return toHashTree(a.scriptTree);
        if (a.hash)
            return { hash: a.hash };
        return;
    });
    const network = a.network || bitcoin$1;
    const o = {
        name: PaymentType.P2TR,
        network,
    };
    prop(o, 'address', () => {
        if (!o.pubkey)
            return;
        const words = distExports$1.bech32m.toWords(o.pubkey);
        words.unshift(TAPROOT_WITNESS_VERSION);
        return distExports$1.bech32m.encode(network.bech32, words);
    });
    prop(o, 'hash', () => {
        const hashTree = _hashTree();
        if (hashTree)
            return hashTree.hash;
        const w = _witness();
        if (w && w.length > 1) {
            const controlBlock = w[w.length - 1];
            const leafVersion = controlBlock[0] & TAPLEAF_VERSION_MASK;
            const script = w[w.length - 2];
            const leafHash = tapleafHash({
                output: script,
                version: leafVersion,
            });
            return rootHashFromPath(controlBlock, leafHash);
        }
        return undefined;
    });
    prop(o, 'output', () => {
        if (!o.pubkey)
            return;
        return compile([OPS$5.OP_1, o.pubkey]);
    });
    prop(o, 'redeemVersion', () => {
        if (a.redeemVersion)
            return a.redeemVersion;
        if (a.redeem && a.redeem.redeemVersion !== undefined && a.redeem.redeemVersion !== null) {
            return a.redeem.redeemVersion;
        }
        return LEAF_VERSION_TAPSCRIPT;
    });
    prop(o, 'redeem', () => {
        const witness = _witness();
        if (!witness || witness.length < 2)
            return;
        return {
            output: witness[witness.length - 2],
            witness: witness.slice(0, -2),
            redeemVersion: witness[witness.length - 1][0] & TAPLEAF_VERSION_MASK,
        };
    });
    prop(o, 'pubkey', () => {
        if (a.pubkey)
            return a.pubkey;
        if (a.output)
            return a.output.subarray(2);
        if (a.address)
            return _address().data;
        if (o.internalPubkey) {
            const tweakedKey = tweakKey(o.internalPubkey, o.hash);
            if (tweakedKey)
                return tweakedKey.x;
        }
    });
    prop(o, 'internalPubkey', () => {
        if (a.internalPubkey)
            return a.internalPubkey;
        const witness = _witness();
        if (witness && witness.length > 1)
            return witness[witness.length - 1].subarray(1, 33);
    });
    prop(o, 'signature', () => {
        if (a.signature)
            return a.signature;
        const witness = _witness();
        if (!witness || witness.length !== 1)
            return;
        return witness[0];
    });
    prop(o, 'witness', () => {
        if (a.witness)
            return a.witness;
        const hashTree = _hashTree();
        if (hashTree && a.redeem && a.redeem.output && a.internalPubkey) {
            const leafHash = tapleafHash({
                output: a.redeem.output,
                version: o.redeemVersion,
            });
            const path = findScriptPath(hashTree, leafHash);
            if (!path)
                return;
            const outputKey = tweakKey(a.internalPubkey, hashTree.hash);
            if (!outputKey)
                return;
            const controlBock = Buffer$1$1.concat([Buffer$1$1.from([o.redeemVersion | outputKey.parity]), a.internalPubkey].concat(path));
            return [a.redeem.output, controlBock];
        }
        if (a.signature)
            return [a.signature];
    });
    if (opts.validate) {
        let pubkey = Buffer$1$1.from([]);
        if (a.address) {
            if (network && network.bech32 !== _address().prefix)
                throw new TypeError('Invalid prefix or Network mismatch');
            if (_address().version !== TAPROOT_WITNESS_VERSION)
                throw new TypeError('Invalid address version');
            if (_address().data.length !== 32)
                throw new TypeError('Invalid address data');
            pubkey = _address().data;
        }
        if (a.pubkey) {
            if (pubkey.length > 0 && !pubkey.equals(a.pubkey))
                throw new TypeError('Pubkey mismatch');
            else
                pubkey = a.pubkey;
        }
        if (a.output) {
            if (a.output.length !== 34 || a.output[0] !== OPS$5.OP_1 || a.output[1] !== 0x20)
                throw new TypeError('Output is invalid');
            if (pubkey.length > 0 && !pubkey.equals(a.output.subarray(2)))
                throw new TypeError('Pubkey mismatch');
            else
                pubkey = a.output.subarray(2);
        }
        if (a.internalPubkey) {
            const tweakedKey = tweakKey(a.internalPubkey, o.hash);
            if (pubkey.length > 0 && !pubkey.equals(tweakedKey.x))
                throw new TypeError('Pubkey mismatch');
            else
                pubkey = tweakedKey.x;
        }
        if (pubkey && pubkey.length) {
            if (!getEccLib().isXOnlyPoint(pubkey))
                throw new TypeError('Invalid pubkey for p2tr');
        }
        const hashTree = _hashTree();
        if (a.hash && hashTree) {
            if (!a.hash.equals(hashTree.hash))
                throw new TypeError('Hash mismatch');
        }
        if (a.redeem && a.redeem.output && hashTree) {
            const leafHash = tapleafHash({
                output: a.redeem.output,
                version: o.redeemVersion,
            });
            if (!findScriptPath(hashTree, leafHash))
                throw new TypeError('Redeem script not in tree');
        }
        const witness = _witness();
        if (a.redeem && o.redeem) {
            if (a.redeem.redeemVersion) {
                if (a.redeem.redeemVersion !== o.redeem.redeemVersion)
                    throw new TypeError('Redeem.redeemVersion and witness mismatch');
            }
            if (a.redeem.output) {
                if (decompile(a.redeem.output).length === 0)
                    throw new TypeError('Redeem.output is invalid');
                if (o.redeem.output && !a.redeem.output.equals(o.redeem.output))
                    throw new TypeError('Redeem.output and witness mismatch');
            }
            if (a.redeem.witness) {
                if (o.redeem.witness && !stacksEqual(a.redeem.witness, o.redeem.witness))
                    throw new TypeError('Redeem.witness and witness mismatch');
            }
        }
        if (witness && witness.length) {
            if (witness.length === 1) {
                if (a.signature && !a.signature.equals(witness[0]))
                    throw new TypeError('Signature mismatch');
            }
            else {
                const controlBlock = witness[witness.length - 1];
                if (controlBlock.length < 33)
                    throw new TypeError(`The control-block length is too small. Got ${controlBlock.length}, expected min 33.`);
                if ((controlBlock.length - 33) % 32 !== 0)
                    throw new TypeError(`The control-block length of ${controlBlock.length} is incorrect!`);
                const m = (controlBlock.length - 33) / 32;
                if (m > 128)
                    throw new TypeError(`The script path is too long. Got ${m}, expected max 128.`);
                const internalPubkey = controlBlock.subarray(1, 33);
                if (a.internalPubkey && !a.internalPubkey.equals(internalPubkey))
                    throw new TypeError('Internal pubkey mismatch');
                if (!getEccLib().isXOnlyPoint(internalPubkey))
                    throw new TypeError('Invalid internalPubkey for p2tr witness');
                const leafVersion = controlBlock[0] & TAPLEAF_VERSION_MASK;
                const script = witness[witness.length - 2];
                const leafHash = tapleafHash({
                    output: script,
                    version: leafVersion,
                });
                const hash = rootHashFromPath(controlBlock, leafHash);
                const outputKey = tweakKey(internalPubkey, hash);
                if (!outputKey)
                    throw new TypeError('Invalid outputKey for p2tr witness');
                if (pubkey.length && !pubkey.equals(outputKey.x))
                    throw new TypeError('Pubkey mismatch for p2tr witness');
                if (outputKey.parity !== (controlBlock[0] & 1))
                    throw new Error('Incorrect parity');
            }
        }
    }
    return Object.assign(o, a);
}

const OPS$4 = opcodes;
const EMPTY_BUFFER$2 = Buffer$1.alloc(0);
function p2wpkh(a, opts) {
    if (!a.address && !a.hash && !a.output && !a.pubkey && !a.witness)
        throw new TypeError('Not enough data');
    opts = Object.assign({ validate: true }, opts || {});
    typef({
        address: typef.maybe(typef.String),
        hash: typef.maybe(typef.BufferN(20)),
        input: typef.maybe(typef.BufferN(0)),
        network: typef.maybe(typef.Object),
        output: typef.maybe(typef.BufferN(22)),
        pubkey: typef.maybe(isPoint),
        signature: typef.maybe(isCanonicalScriptSignature),
        witness: typef.maybe(typef.arrayOf(typef.Buffer)),
    }, a);
    const _address = value(() => {
        const result = distExports$1.bech32.decode(a.address);
        const version = result.words.shift();
        const data = distExports$1.bech32.fromWords(result.words);
        return {
            version,
            prefix: result.prefix,
            data: Buffer$1.from(data),
        };
    });
    const network = a.network || bitcoin$1;
    const o = {
        name: PaymentType.P2WPKH,
        network,
    };
    prop(o, 'address', () => {
        if (!o.hash)
            return;
        const words = distExports$1.bech32.toWords(o.hash);
        words.unshift(0x00);
        return distExports$1.bech32.encode(network.bech32, words);
    });
    prop(o, 'hash', () => {
        if (a.output)
            return a.output.subarray(2, 22);
        if (a.address)
            return _address().data;
        if (a.pubkey || o.pubkey)
            return hash160(a.pubkey || o.pubkey);
    });
    prop(o, 'output', () => {
        if (!o.hash)
            return;
        return compile([OPS$4.OP_0, o.hash]);
    });
    prop(o, 'pubkey', () => {
        if (a.pubkey)
            return a.pubkey;
        if (!a.witness)
            return;
        return a.witness[1];
    });
    prop(o, 'signature', () => {
        if (!a.witness)
            return;
        return a.witness[0];
    });
    prop(o, 'input', () => {
        if (!o.witness)
            return;
        return EMPTY_BUFFER$2;
    });
    prop(o, 'witness', () => {
        if (!a.pubkey)
            return;
        if (!a.signature)
            return;
        return [a.signature, a.pubkey];
    });
    if (opts.validate) {
        let hash = Buffer$1.from([]);
        if (a.address) {
            if (network && network.bech32 !== _address().prefix)
                throw new TypeError('Invalid prefix or Network mismatch');
            if (_address().version !== 0x00)
                throw new TypeError('Invalid address version');
            if (_address().data.length !== 20)
                throw new TypeError('Invalid address data');
            hash = _address().data;
        }
        if (a.hash) {
            if (hash.length > 0 && !hash.equals(a.hash))
                throw new TypeError('Hash mismatch');
            else
                hash = a.hash;
        }
        if (a.output) {
            if (a.output.length !== 22 || a.output[0] !== OPS$4.OP_0 || a.output[1] !== 0x14)
                throw new TypeError('Output is invalid');
            if (hash.length > 0 && !hash.equals(a.output.subarray(2)))
                throw new TypeError('Hash mismatch');
            else
                hash = a.output.subarray(2);
        }
        if (a.pubkey) {
            const pkh = hash160(a.pubkey);
            if (hash.length > 0 && !hash.equals(pkh))
                throw new TypeError('Hash mismatch');
            else
                hash = pkh;
            if (!isPoint(a.pubkey) || a.pubkey.length !== 33)
                throw new TypeError('Invalid pubkey for p2wpkh');
        }
        if (a.witness) {
            if (a.witness.length !== 2)
                throw new TypeError('Witness is invalid');
            if (!isCanonicalScriptSignature(a.witness[0]))
                throw new TypeError('Witness has invalid signature');
            if (!isPoint(a.witness[1]) || a.witness[1].length !== 33)
                throw new TypeError('Witness has invalid pubkey');
            if (a.signature && !a.signature.equals(a.witness[0]))
                throw new TypeError('Signature mismatch');
            if (a.pubkey && !a.pubkey.equals(a.witness[1]))
                throw new TypeError('Pubkey mismatch');
            const pkh = hash160(a.witness[1]);
            if (hash.length > 0 && !hash.equals(pkh))
                throw new TypeError('Hash mismatch');
        }
    }
    return Object.assign(o, a);
}

const OPS$3 = opcodes;
const EMPTY_BUFFER$1 = Buffer$1.alloc(0);
function chunkHasUncompressedPubkey(chunk) {
    if (Buffer$1.isBuffer(chunk) && chunk.length === 65 && chunk[0] === 0x04 && isPoint(chunk)) {
        return true;
    }
    else {
        return false;
    }
}
function p2wsh(a, opts) {
    if (!a.address && !a.hash && !a.output && !a.redeem && !a.witness)
        throw new TypeError('Not enough data');
    opts = Object.assign({ validate: true }, opts || {});
    typef({
        network: typef.maybe(typef.Object),
        address: typef.maybe(typef.String),
        hash: typef.maybe(typef.BufferN(32)),
        output: typef.maybe(typef.BufferN(34)),
        redeem: typef.maybe({
            input: typef.maybe(typef.Buffer),
            network: typef.maybe(typef.Object),
            output: typef.maybe(typef.Buffer),
            witness: typef.maybe(typef.arrayOf(typef.Buffer)),
        }),
        input: typef.maybe(typef.BufferN(0)),
        witness: typef.maybe(typef.arrayOf(typef.Buffer)),
    }, a);
    const _address = value(() => {
        const result = distExports$1.bech32.decode(a.address);
        const version = result.words.shift();
        const data = distExports$1.bech32.fromWords(result.words);
        return {
            version,
            prefix: result.prefix,
            data: Buffer$1.from(data),
        };
    });
    const _rchunks = value(() => {
        return decompile(a.redeem.input);
    });
    let network = a.network;
    if (!network) {
        network = (a.redeem && a.redeem.network) || bitcoin$1;
    }
    const o = {
        network,
        name: PaymentType.P2WSH,
    };
    prop(o, 'address', () => {
        if (!o.hash)
            return;
        const words = distExports$1.bech32.toWords(o.hash);
        words.unshift(0x00);
        return distExports$1.bech32.encode(network.bech32, words);
    });
    prop(o, 'hash', () => {
        if (a.output)
            return a.output.subarray(2);
        if (a.address)
            return _address().data;
        if (o.redeem && o.redeem.output)
            return sha256$1(o.redeem.output);
    });
    prop(o, 'output', () => {
        if (!o.hash)
            return;
        return compile([OPS$3.OP_0, o.hash]);
    });
    prop(o, 'redeem', () => {
        if (!a.witness)
            return;
        return {
            output: a.witness[a.witness.length - 1],
            input: EMPTY_BUFFER$1,
            witness: a.witness.slice(0, -1),
        };
    });
    prop(o, 'input', () => {
        if (!o.witness)
            return;
        return EMPTY_BUFFER$1;
    });
    prop(o, 'witness', () => {
        if (a.redeem &&
            a.redeem.input &&
            a.redeem.input.length > 0 &&
            a.redeem.output &&
            a.redeem.output.length > 0) {
            const stack = toStack(_rchunks());
            o.redeem = Object.assign({ witness: stack }, a.redeem);
            o.redeem.input = EMPTY_BUFFER$1;
            return [].concat(stack, a.redeem.output);
        }
        if (!a.redeem)
            return;
        if (!a.redeem.output)
            return;
        if (!a.redeem.witness)
            return;
        return [].concat(a.redeem.witness, a.redeem.output);
    });
    prop(o, 'name', () => {
        const nameParts = ['p2wsh'];
        if (o.redeem !== undefined && o.redeem.name !== undefined)
            nameParts.push(o.redeem.name);
        return nameParts.join('-');
    });
    if (opts.validate) {
        let hash = Buffer$1.from([]);
        if (a.address) {
            if (_address().prefix !== network.bech32)
                throw new TypeError('Invalid prefix or Network mismatch');
            if (_address().version !== 0x00)
                throw new TypeError('Invalid address version');
            if (_address().data.length !== 32)
                throw new TypeError('Invalid address data');
            hash = _address().data;
        }
        if (a.hash) {
            if (hash.length > 0 && !hash.equals(a.hash))
                throw new TypeError('Hash mismatch');
            else
                hash = a.hash;
        }
        if (a.output) {
            if (a.output.length !== 34 || a.output[0] !== OPS$3.OP_0 || a.output[1] !== 0x20)
                throw new TypeError('Output is invalid');
            const hash2 = a.output.subarray(2);
            if (hash.length > 0 && !hash.equals(hash2))
                throw new TypeError('Hash mismatch');
            else
                hash = hash2;
        }
        if (a.redeem) {
            if (a.redeem.network && a.redeem.network !== network)
                throw new TypeError('Network mismatch');
            if (a.redeem.input &&
                a.redeem.input.length > 0 &&
                a.redeem.witness &&
                a.redeem.witness.length > 0)
                throw new TypeError('Ambiguous witness source');
            if (a.redeem.output) {
                const decompile$1 = decompile(a.redeem.output);
                if (!decompile$1 || decompile$1.length < 1)
                    throw new TypeError('Redeem.output is invalid');
                if (a.redeem.output.byteLength > 3600)
                    throw new TypeError('Redeem.output unspendable if larger than 3600 bytes');
                if (countNonPushOnlyOPs(decompile$1) > 201)
                    throw new TypeError('Redeem.output unspendable with more than 201 non-push ops');
                const hash2 = sha256$1(a.redeem.output);
                if (hash.length > 0 && !hash.equals(hash2))
                    throw new TypeError('Hash mismatch');
                else
                    hash = hash2;
            }
            if (a.redeem.input && !isPushOnly(_rchunks()))
                throw new TypeError('Non push-only scriptSig');
            if (a.witness && a.redeem.witness && !stacksEqual(a.witness, a.redeem.witness))
                throw new TypeError('Witness and redeem.witness mismatch');
            if ((a.redeem.input && _rchunks().some(chunkHasUncompressedPubkey)) ||
                (a.redeem.output &&
                    (decompile(a.redeem.output) || []).some(chunkHasUncompressedPubkey))) {
                throw new TypeError('redeem.input or redeem.output contains uncompressed pubkey');
            }
        }
        if (a.witness && a.witness.length > 0) {
            const wScript = a.witness[a.witness.length - 1];
            if (a.redeem && a.redeem.output && !a.redeem.output.equals(wScript))
                throw new TypeError('Witness and redeem.output mismatch');
            if (a.witness.some(chunkHasUncompressedPubkey) ||
                (decompile(wScript) || []).some(chunkHasUncompressedPubkey))
                throw new TypeError('Witness contains uncompressed pubkey');
        }
    }
    return Object.assign(o, a);
}

const FUTURE_SEGWIT_MAX_SIZE = 40;
const FUTURE_SEGWIT_MIN_SIZE = 2;
const FUTURE_SEGWIT_MAX_VERSION = 15;
const FUTURE_MAX_VERSION = 16;
const FUTURE_OPNET_VERSION = 16;
const FUTURE_SEGWIT_MIN_VERSION = 2;
const FUTURE_SEGWIT_VERSION_DIFF = 0x50;
const FUTURE_SEGWIT_VERSION_WARNING = 'WARNING: Sending to a future segwit version address can lead to loss of funds. ' +
    'End users MUST be warned carefully in the GUI and asked if they wish to proceed ' +
    'with caution. Wallets should verify the segwit version from the output of fromBech32, ' +
    'then decide when it is safe to use which version of segwit.';
const isUnknownSegwitVersion = (output) => {
    try {
        const data = Buffer$1.from(output.subarray(2));
        if (data.length < FUTURE_SEGWIT_MIN_SIZE || data.length > FUTURE_SEGWIT_MAX_SIZE) {
            throw new TypeError('Invalid program length for segwit address');
        }
        const version = output[0] - FUTURE_SEGWIT_VERSION_DIFF;
        if (version < FUTURE_SEGWIT_MIN_VERSION || version > FUTURE_SEGWIT_MAX_VERSION + 1) {
            throw new TypeError('Invalid version for segwit address');
        }
        if (version === 1)
            throw new TypeError('taproot');
        return true;
    }
    catch (e) { }
    return false;
};
function toFutureOPNetAddress(output, network) {
    if (!Buffer$1.isBuffer(output))
        throw new TypeError('output must be a Buffer');
    if (!network.bech32Opnet)
        throw new Error('Network does not support opnet');
    const opcode = output[0];
    let pushPos = 1, progLen;
    if (output[1] < 0x4c) {
        progLen = output[1];
        pushPos = 2;
    }
    else if (output[1] === 0x4c) {
        progLen = output[2];
        pushPos = 3;
    }
    else {
        throw new TypeError('Unsupported push opcode in script');
    }
    const program = Buffer$1.from(output.subarray(pushPos, pushPos + progLen));
    if (program.length < FUTURE_SEGWIT_MIN_SIZE || program.length > FUTURE_SEGWIT_MAX_SIZE)
        throw new TypeError('Invalid program length for segwit address');
    const version = opcode === opcodes.OP_0
        ? 0
        : opcode >= opcodes.OP_1 && opcode <= opcodes.OP_16
            ? opcode - (opcodes.OP_1 - 1)
            : -1;
    if (version < FUTURE_SEGWIT_MAX_VERSION || version > FUTURE_MAX_VERSION)
        throw new TypeError(`Invalid segwit version ${version}`);
    const words = [version, ...distExports$1.bech32m.toWords(program)];
    return distExports$1.bech32m.encode(network.bech32Opnet, words);
}
function _toFutureSegwitAddress(output, network) {
    const data = Buffer$1.from(output.subarray(2));
    if (data.length < FUTURE_SEGWIT_MIN_SIZE || data.length > FUTURE_SEGWIT_MAX_SIZE) {
        throw new TypeError('Invalid program length for segwit address');
    }
    const version = output[0] - FUTURE_SEGWIT_VERSION_DIFF;
    if (version < FUTURE_SEGWIT_MIN_VERSION || version > FUTURE_SEGWIT_MAX_VERSION) {
        throw new TypeError('Invalid version for segwit address');
    }
    if (output[1] !== data.length) {
        throw new TypeError(`Invalid script for segwit address ${output[1]} !== ${data.length}`);
    }
    return toBech32(data, version, network.bech32, network.bech32Opnet);
}
function fromBase58Check(address) {
    const payload = Buffer$1.from(index$1.decode(address));
    if (payload.length < 21)
        throw new TypeError(address + ' is too short');
    if (payload.length > 21)
        throw new TypeError(address + ' is too long');
    const version = payload.readUInt8(0);
    const hash = Buffer$1.from(payload.subarray(1));
    return { version, hash };
}
function toBech32(data, version, prefix, prefixOpnet) {
    const words = distExports$1.bech32.toWords(data);
    words.unshift(version);
    if (version === FUTURE_OPNET_VERSION && prefixOpnet) {
        return distExports$1.bech32m.encode(prefixOpnet, words);
    }
    return version === 0 ? distExports$1.bech32.encode(prefix, words) : distExports$1.bech32m.encode(prefix, words);
}
function fromOutputScript(output, network) {
    network = network || bitcoin$1;
    try {
        return p2pkh({ output, network }).address;
    }
    catch (e) { }
    try {
        return p2sh({ output, network }).address;
    }
    catch (e) { }
    try {
        return p2wpkh({ output, network }).address;
    }
    catch (e) { }
    try {
        return p2wsh({ output, network }).address;
    }
    catch (e) { }
    try {
        return p2tr({ output, network }).address;
    }
    catch (e) { }
    try {
        return toFutureOPNetAddress(output, network);
    }
    catch (e) { }
    try {
        return _toFutureSegwitAddress(output, network);
    }
    catch (e) { }
    throw new Error(toASM(output) + ' has no matching Address');
}
function toOutputScript(address, network) {
    network = network || bitcoin$1;
    let decodeBase58;
    let decodeBech32;
    try {
        decodeBase58 = fromBase58Check(address);
    }
    catch (e) { }
    if (decodeBase58) {
        if (decodeBase58.version === network.pubKeyHash)
            return p2pkh({ hash: decodeBase58.hash }).output;
        if (decodeBase58.version === network.scriptHash)
            return p2sh({ hash: decodeBase58.hash }).output;
    }
    else {
        try {
            decodeBech32 = fromBech32(address);
        }
        catch (e) { }
        if (decodeBech32) {
            if (decodeBech32.prefix !== network.bech32 &&
                network.bech32Opnet &&
                decodeBech32.prefix !== network.bech32Opnet)
                throw new Error(address + ' has an invalid prefix');
            if (decodeBech32.version === 0) {
                if (decodeBech32.data.length === 20)
                    return p2wpkh({ hash: decodeBech32.data }).output;
                if (decodeBech32.data.length === 32)
                    return p2wsh({ hash: decodeBech32.data }).output;
            }
            else if (decodeBech32.version === 1) {
                if (decodeBech32.data.length === 32)
                    return p2tr({ pubkey: decodeBech32.data }).output;
            }
            else if (decodeBech32.version === FUTURE_OPNET_VERSION) {
                if (!network.bech32Opnet)
                    throw new Error(address + ' has an invalid prefix');
                return p2op({
                    program: decodeBech32.data,
                    network,
                }).output;
            }
            else if (decodeBech32.version >= FUTURE_SEGWIT_MIN_VERSION &&
                decodeBech32.version <= FUTURE_SEGWIT_MAX_VERSION &&
                decodeBech32.data.length >= FUTURE_SEGWIT_MIN_SIZE &&
                decodeBech32.data.length <= FUTURE_SEGWIT_MAX_SIZE) {
                if (decodeBech32.version !== FUTURE_OPNET_VERSION) {
                    console.warn(FUTURE_SEGWIT_VERSION_WARNING);
                }
                return compile([
                    decodeBech32.version + FUTURE_SEGWIT_VERSION_DIFF,
                    decodeBech32.data,
                ]);
            }
        }
    }
    throw new TypeError(address + ' has no matching Script');
}

const OPS$2 = opcodes;
function p2data(a, opts) {
    if (!a.data && !a.output)
        throw new TypeError('Not enough data');
    opts = Object.assign({ validate: true }, opts || {});
    typef({
        network: typef.maybe(typef.Object),
        output: typef.maybe(typef.Buffer),
        data: typef.maybe(typef.arrayOf(typef.Buffer)),
    }, a);
    const network = a.network || bitcoin$1;
    const o = { name: PaymentType.Embed, network, data: [] };
    prop(o, 'output', () => {
        if (!a.data)
            return;
        return compile([OPS$2.OP_RETURN].concat(a.data));
    });
    prop(o, 'data', () => {
        if (!a.output)
            return;
        const script$1 = decompile(a.output);
        if (script$1 === null || script$1 === undefined) {
            return;
        }
        return script$1.slice(1);
    });
    if (opts.validate) {
        if (a.output) {
            const chunks = decompile(a.output);
            if (chunks[0] !== OPS$2.OP_RETURN)
                throw new TypeError('Output is invalid');
            if (!chunks.slice(1).every(typef.Buffer))
                throw new TypeError('Output is invalid');
            if (a.data && !stacksEqual(a.data, o.data))
                throw new TypeError('Data mismatch');
        }
    }
    return Object.assign(o, a);
}

const OPS$1 = opcodes;
const OP_INT_BASE = OPS$1.OP_RESERVED;
function p2ms(a, opts) {
    if (!a.input && !a.output && !(a.pubkeys && a.m !== undefined) && !a.signatures)
        throw new TypeError('Not enough data');
    opts = Object.assign({ validate: true }, opts || {});
    function isAcceptableSignature(x) {
        return (isCanonicalScriptSignature(x) ||
            (opts.allowIncomplete && x === OPS$1.OP_0) !== undefined);
    }
    typef({
        network: typef.maybe(typef.Object),
        m: typef.maybe(typef.Number),
        n: typef.maybe(typef.Number),
        output: typef.maybe(typef.Buffer),
        pubkeys: typef.maybe(typef.arrayOf(isPoint)),
        signatures: typef.maybe(typef.arrayOf(isAcceptableSignature)),
        input: typef.maybe(typef.Buffer),
    }, a);
    const network = a.network || bitcoin$1;
    const o = {
        network,
        name: PaymentType.P2MS,
    };
    let chunks = [];
    let decoded = false;
    function decode(output) {
        if (decoded)
            return;
        decoded = true;
        chunks = decompile(output);
        o.m = chunks[0] - OP_INT_BASE;
        o.n = chunks[chunks.length - 2] - OP_INT_BASE;
        o.pubkeys = chunks.slice(1, -2);
    }
    prop(o, 'output', () => {
        if (!a.m)
            return;
        if (!o.n)
            return;
        if (!a.pubkeys)
            return;
        return compile([].concat(OP_INT_BASE + a.m, a.pubkeys, OP_INT_BASE + o.n, OPS$1.OP_CHECKMULTISIG));
    });
    prop(o, 'm', () => {
        if (!o.output)
            return;
        decode(o.output);
        return o.m;
    });
    prop(o, 'n', () => {
        if (!o.pubkeys)
            return;
        return o.pubkeys.length;
    });
    prop(o, 'pubkeys', () => {
        if (!a.output)
            return;
        decode(a.output);
        return o.pubkeys;
    });
    prop(o, 'signatures', () => {
        if (!a.input)
            return;
        const decompiled = decompile(a.input);
        if (decompiled === null || decompiled === undefined)
            return;
        return decompiled.slice(1);
    });
    prop(o, 'input', () => {
        if (!a.signatures)
            return;
        return compile([OPS$1.OP_0].concat(a.signatures));
    });
    prop(o, 'witness', () => {
        if (!o.input)
            return;
        return [];
    });
    prop(o, 'name', () => {
        if (!o.m || !o.n)
            return;
        return `p2ms(${o.m} of ${o.n})`;
    });
    if (opts.validate) {
        if (a.output) {
            decode(a.output);
            if (!typef.Number(chunks[0]))
                throw new TypeError('Output is invalid');
            if (!typef.Number(chunks[chunks.length - 2]))
                throw new TypeError('Output is invalid');
            if (chunks[chunks.length - 1] !== OPS$1.OP_CHECKMULTISIG)
                throw new TypeError('Output is invalid');
            if (o.m <= 0 || o.n > 16 || o.m > o.n || o.n !== chunks.length - 3)
                throw new TypeError('Output is invalid');
            if (!o.pubkeys.every((x) => isPoint(x)))
                throw new TypeError('Output is invalid');
            if (a.m !== undefined && a.m !== o.m)
                throw new TypeError('m mismatch');
            if (a.n !== undefined && a.n !== o.n)
                throw new TypeError('n mismatch');
            if (a.pubkeys && !stacksEqual(a.pubkeys, o.pubkeys))
                throw new TypeError('Pubkeys mismatch');
        }
        if (a.pubkeys) {
            if (a.n !== undefined && a.n !== a.pubkeys.length)
                throw new TypeError('Pubkey count mismatch');
            o.n = a.pubkeys.length;
            if (o.n < o.m)
                throw new TypeError('Pubkey count cannot be less than m');
        }
        if (a.signatures) {
            if (a.signatures.length < o.m)
                throw new TypeError('Not enough signatures provided');
            if (a.signatures.length > o.m)
                throw new TypeError('Too many signatures provided');
        }
        if (a.input) {
            if (a.input[0] !== OPS$1.OP_0)
                throw new TypeError('Input is invalid');
            if (o.signatures.length === 0 || !o.signatures.every(isAcceptableSignature))
                throw new TypeError('Input has invalid signature(s)');
            if (a.signatures && !stacksEqual(a.signatures, o.signatures))
                throw new TypeError('Signature mismatch');
            if (a.m !== undefined && a.m !== a.signatures.length)
                throw new TypeError('Signature count mismatch');
        }
    }
    return Object.assign(o, a);
}

const OPS = opcodes;
function p2pk(a, opts) {
    if (!a.input && !a.output && !a.pubkey && !a.input && !a.signature)
        throw new TypeError('Not enough data');
    opts = Object.assign({ validate: true }, opts || {});
    typef({
        network: typef.maybe(typef.Object),
        output: typef.maybe(typef.Buffer),
        pubkey: typef.maybe(isPoint),
        signature: typef.maybe(isCanonicalScriptSignature),
        input: typef.maybe(typef.Buffer),
    }, a);
    const _chunks = value(() => {
        return decompile(a.input);
    });
    const network = a.network || bitcoin$1;
    const o = {
        name: PaymentType.P2PK,
        network,
        pubkey: undefined,
    };
    prop(o, 'output', () => {
        if (!a.pubkey)
            return;
        return compile([a.pubkey, OPS.OP_CHECKSIG]);
    });
    prop(o, 'pubkey', () => {
        if (!a.output)
            return;
        return a.output.subarray(1, -1);
    });
    prop(o, 'signature', () => {
        if (!a.input)
            return;
        return _chunks()[0];
    });
    prop(o, 'input', () => {
        if (!a.signature)
            return;
        return compile([a.signature]);
    });
    prop(o, 'witness', () => {
        if (!o.input)
            return;
        return [];
    });
    if (opts.validate) {
        if (a.output) {
            if (a.output[a.output.length - 1] !== OPS.OP_CHECKSIG)
                throw new TypeError('Output is invalid');
            if (!isPoint(o.pubkey))
                throw new TypeError('Output pubkey is invalid');
            if (a.pubkey && !a.pubkey.equals(o.pubkey))
                throw new TypeError('Pubkey mismatch');
        }
        if (a.signature) {
            if (a.input && !a.input.equals(o.input))
                throw new TypeError('Signature mismatch');
        }
        if (a.input) {
            if (_chunks().length !== 1)
                throw new TypeError('Input is invalid');
            if (!isCanonicalScriptSignature(o.signature))
                throw new TypeError('Input has invalid signature');
        }
    }
    return Object.assign(o, a);
}

const payments = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	LEAF_VERSION_TAPSCRIPT,
	MAX_TAPTREE_DEPTH,
	get PaymentType () { return PaymentType; },
	findScriptPath,
	p2data,
	p2ms,
	p2op,
	p2pk,
	p2pkh,
	p2sh,
	p2tr,
	p2wpkh,
	p2wsh,
	prop,
	rootHashFromPath,
	tapleafHash,
	toHashTree,
	tweakKey,
	value
}, Symbol.toStringTag, { value: 'Module' }));

const { typeforce } = types$3;
function varSliceSize(someScript) {
    const length = someScript.length;
    return encodingLength(length) + length;
}
function vectorSize(someVector) {
    const length = someVector.length;
    return (encodingLength(length) +
        someVector.reduce((sum, witness) => {
            return sum + varSliceSize(witness);
        }, 0));
}
const EMPTY_BUFFER = Buffer$1.allocUnsafe(0);
const EMPTY_WITNESS = [];
const ZERO$1 = Buffer$1.from('0000000000000000000000000000000000000000000000000000000000000000', 'hex');
const ONE$1 = Buffer$1.from('0000000000000000000000000000000000000000000000000000000000000001', 'hex');
const VALUE_UINT64_MAX = Buffer$1.from('ffffffffffffffff', 'hex');
const BLANK_OUTPUT = {
    script: EMPTY_BUFFER,
    valueBuffer: VALUE_UINT64_MAX,
};
function isOutput(out) {
    return 'value' in out;
}
class Transaction {
    constructor() {
        this.version = 1;
        this.locktime = 0;
        this.ins = [];
        this.outs = [];
    }
    static fromBuffer(buffer, _NO_STRICT) {
        const bufferReader = new BufferReader(buffer);
        const tx = new Transaction();
        tx.version = bufferReader.readInt32();
        const marker = bufferReader.readUInt8();
        const flag = bufferReader.readUInt8();
        let hasWitnesses = false;
        if (marker === Transaction.ADVANCED_TRANSACTION_MARKER &&
            flag === Transaction.ADVANCED_TRANSACTION_FLAG) {
            hasWitnesses = true;
        }
        else {
            bufferReader.offset -= 2;
        }
        const vinLen = bufferReader.readVarInt();
        for (let i = 0; i < vinLen; ++i) {
            const hash = bufferReader.readSlice(32);
            const index = bufferReader.readUInt32();
            const script = bufferReader.readVarSlice();
            const sequence = bufferReader.readUInt32();
            tx.ins.push({
                hash: hash,
                index: index,
                script: script,
                sequence: sequence,
                witness: EMPTY_WITNESS,
            });
        }
        const voutLen = bufferReader.readVarInt();
        for (let i = 0; i < voutLen; ++i) {
            tx.outs.push({
                value: bufferReader.readUInt64(),
                script: bufferReader.readVarSlice(),
            });
        }
        if (hasWitnesses) {
            for (let i = 0; i < vinLen; ++i) {
                tx.ins[i].witness = bufferReader.readVector();
            }
            if (!tx.hasWitnesses())
                throw new Error('Transaction has superfluous witness data');
        }
        tx.locktime = bufferReader.readUInt32();
        if (_NO_STRICT)
            return tx;
        if (bufferReader.offset !== buffer.length)
            throw new Error('Transaction has unexpected data');
        return tx;
    }
    static fromHex(hex) {
        return Transaction.fromBuffer(Buffer$1.from(hex, 'hex'), false);
    }
    static isCoinbaseHash(buffer) {
        typeforce(Hash256bit, buffer);
        for (let i = 0; i < 32; ++i) {
            if (buffer[i] !== 0)
                return false;
        }
        return true;
    }
    isCoinbase() {
        return this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash);
    }
    addInput(hash, index, sequence, scriptSig) {
        typeforce(tuple(Hash256bit, UInt32, maybe(UInt32), maybe(Buffer)), [hash, index, sequence, scriptSig]);
        if (Null(sequence)) {
            sequence = Transaction.DEFAULT_SEQUENCE;
        }
        return (this.ins.push({
            hash,
            index,
            script: scriptSig || EMPTY_BUFFER,
            sequence: sequence,
            witness: EMPTY_WITNESS,
        }) - 1);
    }
    addOutput(scriptPubKey, value) {
        typeforce(tuple(Buffer, Satoshi), [scriptPubKey, value]);
        return (this.outs.push({
            script: scriptPubKey,
            value,
        }) - 1);
    }
    hasWitnesses() {
        return this.ins.some((x) => {
            return x.witness.length !== 0;
        });
    }
    weight() {
        const base = this.byteLength(false);
        const total = this.byteLength(true);
        return base * 3 + total;
    }
    virtualSize() {
        return Math.ceil(this.weight() / 4);
    }
    byteLength(_ALLOW_WITNESS = true) {
        const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();
        return ((hasWitnesses ? 10 : 8) +
            encodingLength(this.ins.length) +
            encodingLength(this.outs.length) +
            this.ins.reduce((sum, input) => {
                return sum + 40 + varSliceSize(input.script);
            }, 0) +
            this.outs.reduce((sum, output) => {
                return sum + 8 + varSliceSize(output.script);
            }, 0) +
            (hasWitnesses
                ? this.ins.reduce((sum, input) => {
                    return sum + vectorSize(input.witness);
                }, 0)
                : 0));
    }
    clone() {
        const newTx = new Transaction();
        newTx.version = this.version;
        newTx.locktime = this.locktime;
        newTx.ins = this.ins.map((txIn) => {
            return {
                hash: txIn.hash,
                index: txIn.index,
                script: txIn.script,
                sequence: txIn.sequence,
                witness: txIn.witness,
            };
        });
        newTx.outs = this.outs.map((txOut) => {
            return {
                script: txOut.script,
                value: txOut.value,
            };
        });
        return newTx;
    }
    hashForSignature(inIndex, prevOutScript, hashType) {
        typeforce(tuple(UInt32, Buffer, Number$1), [
            inIndex,
            prevOutScript,
            hashType,
        ]);
        if (inIndex >= this.ins.length)
            return ONE$1;
        const decompiled = decompile(prevOutScript);
        if (!decompiled)
            throw new Error('Could not decompile prevOutScript');
        const ourScript = compile(decompiled.filter((x) => {
            return x !== opcodes.OP_CODESEPARATOR;
        }));
        const txTmp = this.clone();
        if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {
            txTmp.outs = [];
            txTmp.ins.forEach((input, i) => {
                if (i === inIndex)
                    return;
                input.sequence = 0;
            });
        }
        else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {
            if (inIndex >= this.outs.length)
                return ONE$1;
            txTmp.outs.length = inIndex + 1;
            for (let i = 0; i < inIndex; i++) {
                txTmp.outs[i] = BLANK_OUTPUT;
            }
            txTmp.ins.forEach((input, y) => {
                if (y === inIndex)
                    return;
                input.sequence = 0;
            });
        }
        if (hashType & Transaction.SIGHASH_ANYONECANPAY) {
            txTmp.ins = [txTmp.ins[inIndex]];
            txTmp.ins[0].script = ourScript;
        }
        else {
            txTmp.ins.forEach((input) => {
                input.script = EMPTY_BUFFER;
            });
            txTmp.ins[inIndex].script = ourScript;
        }
        const buffer = Buffer$1.allocUnsafe(txTmp.byteLength(false) + 4);
        buffer.writeInt32LE(hashType, buffer.length - 4);
        txTmp.__toBuffer(buffer, 0, false);
        return hash256(buffer);
    }
    hashForWitnessV1(inIndex, prevOutScripts, values, hashType, leafHash, annex) {
        typeforce(tuple(UInt32, typeforce.arrayOf(Buffer), typeforce.arrayOf(Satoshi), UInt32), [inIndex, prevOutScripts, values, hashType]);
        if (values.length !== this.ins.length || prevOutScripts.length !== this.ins.length) {
            throw new Error('Must supply prevout script and value for all inputs');
        }
        const outputType = hashType === Transaction.SIGHASH_DEFAULT
            ? Transaction.SIGHASH_ALL
            : hashType & Transaction.SIGHASH_OUTPUT_MASK;
        const inputType = hashType & Transaction.SIGHASH_INPUT_MASK;
        const isAnyoneCanPay = inputType === Transaction.SIGHASH_ANYONECANPAY;
        const isNone = outputType === Transaction.SIGHASH_NONE;
        const isSingle = outputType === Transaction.SIGHASH_SINGLE;
        let hashPrevouts = EMPTY_BUFFER;
        let hashAmounts = EMPTY_BUFFER;
        let hashScriptPubKeys = EMPTY_BUFFER;
        let hashSequences = EMPTY_BUFFER;
        let hashOutputs = EMPTY_BUFFER;
        if (!isAnyoneCanPay) {
            let bufferWriter = BufferWriter.withCapacity(36 * this.ins.length);
            this.ins.forEach((txIn) => {
                bufferWriter.writeSlice(txIn.hash);
                bufferWriter.writeUInt32(txIn.index);
            });
            hashPrevouts = sha256$1(bufferWriter.end());
            bufferWriter = BufferWriter.withCapacity(8 * this.ins.length);
            values.forEach((value) => bufferWriter.writeUInt64(value));
            hashAmounts = sha256$1(bufferWriter.end());
            bufferWriter = BufferWriter.withCapacity(prevOutScripts.map(varSliceSize).reduce((a, b) => a + b));
            prevOutScripts.forEach((prevOutScript) => bufferWriter.writeVarSlice(prevOutScript));
            hashScriptPubKeys = sha256$1(bufferWriter.end());
            bufferWriter = BufferWriter.withCapacity(4 * this.ins.length);
            this.ins.forEach((txIn) => bufferWriter.writeUInt32(txIn.sequence));
            hashSequences = sha256$1(bufferWriter.end());
        }
        if (!(isNone || isSingle)) {
            if (!this.outs.length)
                throw new Error('Add outputs to the transaction before signing.');
            const txOutsSize = this.outs
                .map((output) => 8 + varSliceSize(output.script))
                .reduce((a, b) => a + b);
            const bufferWriter = BufferWriter.withCapacity(txOutsSize);
            this.outs.forEach((out) => {
                bufferWriter.writeUInt64(out.value);
                bufferWriter.writeVarSlice(out.script);
            });
            hashOutputs = sha256$1(bufferWriter.end());
        }
        else if (isSingle && inIndex < this.outs.length) {
            const output = this.outs[inIndex];
            const bufferWriter = BufferWriter.withCapacity(8 + varSliceSize(output.script));
            bufferWriter.writeUInt64(output.value);
            bufferWriter.writeVarSlice(output.script);
            hashOutputs = sha256$1(bufferWriter.end());
        }
        const spendType = (leafHash ? 2 : 0) + (annex ? 1 : 0);
        const sigMsgSize = 174 -
            (isAnyoneCanPay ? 49 : 0) -
            (isNone ? 32 : 0) +
            (annex ? 32 : 0) +
            (leafHash ? 37 : 0);
        const sigMsgWriter = BufferWriter.withCapacity(sigMsgSize);
        sigMsgWriter.writeUInt8(hashType);
        sigMsgWriter.writeInt32(this.version);
        sigMsgWriter.writeUInt32(this.locktime);
        sigMsgWriter.writeSlice(hashPrevouts);
        sigMsgWriter.writeSlice(hashAmounts);
        sigMsgWriter.writeSlice(hashScriptPubKeys);
        sigMsgWriter.writeSlice(hashSequences);
        if (!(isNone || isSingle)) {
            sigMsgWriter.writeSlice(hashOutputs);
        }
        sigMsgWriter.writeUInt8(spendType);
        if (isAnyoneCanPay) {
            const input = this.ins[inIndex];
            sigMsgWriter.writeSlice(input.hash);
            sigMsgWriter.writeUInt32(input.index);
            sigMsgWriter.writeUInt64(values[inIndex]);
            sigMsgWriter.writeVarSlice(prevOutScripts[inIndex]);
            sigMsgWriter.writeUInt32(input.sequence);
        }
        else {
            sigMsgWriter.writeUInt32(inIndex);
        }
        if (annex) {
            const bufferWriter = BufferWriter.withCapacity(varSliceSize(annex));
            bufferWriter.writeVarSlice(annex);
            sigMsgWriter.writeSlice(sha256$1(bufferWriter.end()));
        }
        if (isSingle) {
            sigMsgWriter.writeSlice(hashOutputs);
        }
        if (leafHash) {
            sigMsgWriter.writeSlice(leafHash);
            sigMsgWriter.writeUInt8(0);
            sigMsgWriter.writeUInt32(0xffffffff);
        }
        return taggedHash('TapSighash', Buffer$1.concat([Buffer$1.from([0x00]), sigMsgWriter.end()]));
    }
    hashForWitnessV0(inIndex, prevOutScript, value, hashType) {
        typeforce(tuple(UInt32, Buffer, Satoshi, UInt32), [
            inIndex,
            prevOutScript,
            value,
            hashType,
        ]);
        let tbuffer = Buffer$1.from([]);
        let bufferWriter;
        let hashOutputs = ZERO$1;
        let hashPrevouts = ZERO$1;
        let hashSequence = ZERO$1;
        if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {
            tbuffer = Buffer$1.allocUnsafe(36 * this.ins.length);
            bufferWriter = new BufferWriter(tbuffer, 0);
            this.ins.forEach((txIn) => {
                bufferWriter.writeSlice(txIn.hash);
                bufferWriter.writeUInt32(txIn.index);
            });
            hashPrevouts = hash256(tbuffer);
        }
        if (!(hashType & Transaction.SIGHASH_ANYONECANPAY) &&
            (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&
            (hashType & 0x1f) !== Transaction.SIGHASH_NONE) {
            tbuffer = Buffer$1.allocUnsafe(4 * this.ins.length);
            bufferWriter = new BufferWriter(tbuffer, 0);
            this.ins.forEach((txIn) => {
                bufferWriter.writeUInt32(txIn.sequence);
            });
            hashSequence = hash256(tbuffer);
        }
        if ((hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&
            (hashType & 0x1f) !== Transaction.SIGHASH_NONE) {
            const txOutsSize = this.outs.reduce((sum, output) => {
                return sum + 8 + varSliceSize(output.script);
            }, 0);
            tbuffer = Buffer$1.allocUnsafe(txOutsSize);
            bufferWriter = new BufferWriter(tbuffer, 0);
            this.outs.forEach((out) => {
                bufferWriter.writeUInt64(out.value);
                bufferWriter.writeVarSlice(out.script);
            });
            hashOutputs = hash256(tbuffer);
        }
        else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE && inIndex < this.outs.length) {
            const output = this.outs[inIndex];
            tbuffer = Buffer$1.allocUnsafe(8 + varSliceSize(output.script));
            bufferWriter = new BufferWriter(tbuffer, 0);
            bufferWriter.writeUInt64(output.value);
            bufferWriter.writeVarSlice(output.script);
            hashOutputs = hash256(tbuffer);
        }
        tbuffer = Buffer$1.allocUnsafe(156 + varSliceSize(prevOutScript));
        bufferWriter = new BufferWriter(tbuffer, 0);
        const input = this.ins[inIndex];
        bufferWriter.writeInt32(this.version);
        bufferWriter.writeSlice(hashPrevouts);
        bufferWriter.writeSlice(hashSequence);
        bufferWriter.writeSlice(input.hash);
        bufferWriter.writeUInt32(input.index);
        bufferWriter.writeVarSlice(prevOutScript);
        bufferWriter.writeUInt64(value);
        bufferWriter.writeUInt32(input.sequence);
        bufferWriter.writeSlice(hashOutputs);
        bufferWriter.writeUInt32(this.locktime);
        bufferWriter.writeUInt32(hashType);
        return hash256(tbuffer);
    }
    getHash(forWitness) {
        if (forWitness && this.isCoinbase())
            return Buffer$1.alloc(32, 0);
        return hash256(this.__toBuffer(undefined, undefined, forWitness));
    }
    getId() {
        return reverseBuffer(this.getHash(false)).toString('hex');
    }
    toBuffer(buffer, initialOffset) {
        return this.__toBuffer(buffer, initialOffset, true);
    }
    toHex() {
        return this.toBuffer(undefined, undefined).toString('hex');
    }
    setInputScript(index, scriptSig) {
        typeforce(tuple(Number$1, Buffer), [index, scriptSig]);
        this.ins[index].script = scriptSig;
    }
    setWitness(index, witness) {
        typeforce(tuple(Number$1, [Buffer]), [index, witness]);
        this.ins[index].witness = witness;
    }
    __toBuffer(buffer, initialOffset, _ALLOW_WITNESS = false) {
        if (!buffer)
            buffer = Buffer$1.allocUnsafe(this.byteLength(_ALLOW_WITNESS));
        const bufferWriter = new BufferWriter(buffer, initialOffset || 0);
        bufferWriter.writeInt32(this.version);
        const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();
        if (hasWitnesses) {
            bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER);
            bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG);
        }
        bufferWriter.writeVarInt(this.ins.length);
        this.ins.forEach((txIn) => {
            bufferWriter.writeSlice(txIn.hash);
            bufferWriter.writeUInt32(txIn.index);
            bufferWriter.writeVarSlice(txIn.script);
            bufferWriter.writeUInt32(txIn.sequence);
        });
        bufferWriter.writeVarInt(this.outs.length);
        this.outs.forEach((txOut) => {
            if (isOutput(txOut)) {
                bufferWriter.writeUInt64(txOut.value);
            }
            else {
                bufferWriter.writeSlice(txOut.valueBuffer);
            }
            bufferWriter.writeVarSlice(txOut.script);
        });
        if (hasWitnesses) {
            this.ins.forEach((input) => {
                bufferWriter.writeVector(input.witness);
            });
        }
        bufferWriter.writeUInt32(this.locktime);
        if (initialOffset !== undefined)
            return buffer.subarray(initialOffset, bufferWriter.offset);
        return buffer;
    }
}
Transaction.DEFAULT_SEQUENCE = 0xffffffff;
Transaction.SIGHASH_DEFAULT = 0x00;
Transaction.SIGHASH_ALL = 0x01;
Transaction.SIGHASH_NONE = 0x02;
Transaction.SIGHASH_SINGLE = 0x03;
Transaction.SIGHASH_ANYONECANPAY = 0x80;
Transaction.SIGHASH_OUTPUT_MASK = 0x03;
Transaction.SIGHASH_INPUT_MASK = 0x80;
Transaction.ADVANCED_TRANSACTION_MARKER = 0x00;
Transaction.ADVANCED_TRANSACTION_FLAG = 0x01;
Transaction.TRUC_VERSION = 3;
Transaction.TRUC_MAX_VSIZE = 10000;
Transaction.TRUC_CHILD_MAX_VSIZE = 1000;

var psbt = {};

var combiner = {};

var parser = {};

var fromBuffer = {};

var converter = {};

var typeFields = {};

var hasRequiredTypeFields;

function requireTypeFields () {
	if (hasRequiredTypeFields) return typeFields;
	hasRequiredTypeFields = 1;
	(function (exports$1) {
		Object.defineProperty(exports$1, "__esModule", { value: true });
		(function(GlobalTypes2) {
		  GlobalTypes2[GlobalTypes2["UNSIGNED_TX"] = 0] = "UNSIGNED_TX";
		  GlobalTypes2[GlobalTypes2["GLOBAL_XPUB"] = 1] = "GLOBAL_XPUB";
		})(exports$1.GlobalTypes || (exports$1.GlobalTypes = {}));
		exports$1.GLOBAL_TYPE_NAMES = ["unsignedTx", "globalXpub"];
		(function(InputTypes2) {
		  InputTypes2[InputTypes2["NON_WITNESS_UTXO"] = 0] = "NON_WITNESS_UTXO";
		  InputTypes2[InputTypes2["WITNESS_UTXO"] = 1] = "WITNESS_UTXO";
		  InputTypes2[InputTypes2["PARTIAL_SIG"] = 2] = "PARTIAL_SIG";
		  InputTypes2[InputTypes2["SIGHASH_TYPE"] = 3] = "SIGHASH_TYPE";
		  InputTypes2[InputTypes2["REDEEM_SCRIPT"] = 4] = "REDEEM_SCRIPT";
		  InputTypes2[InputTypes2["WITNESS_SCRIPT"] = 5] = "WITNESS_SCRIPT";
		  InputTypes2[InputTypes2["BIP32_DERIVATION"] = 6] = "BIP32_DERIVATION";
		  InputTypes2[InputTypes2["FINAL_SCRIPTSIG"] = 7] = "FINAL_SCRIPTSIG";
		  InputTypes2[InputTypes2["FINAL_SCRIPTWITNESS"] = 8] = "FINAL_SCRIPTWITNESS";
		  InputTypes2[InputTypes2["POR_COMMITMENT"] = 9] = "POR_COMMITMENT";
		  InputTypes2[InputTypes2["TAP_KEY_SIG"] = 19] = "TAP_KEY_SIG";
		  InputTypes2[InputTypes2["TAP_SCRIPT_SIG"] = 20] = "TAP_SCRIPT_SIG";
		  InputTypes2[InputTypes2["TAP_LEAF_SCRIPT"] = 21] = "TAP_LEAF_SCRIPT";
		  InputTypes2[InputTypes2["TAP_BIP32_DERIVATION"] = 22] = "TAP_BIP32_DERIVATION";
		  InputTypes2[InputTypes2["TAP_INTERNAL_KEY"] = 23] = "TAP_INTERNAL_KEY";
		  InputTypes2[InputTypes2["TAP_MERKLE_ROOT"] = 24] = "TAP_MERKLE_ROOT";
		})(exports$1.InputTypes || (exports$1.InputTypes = {}));
		exports$1.INPUT_TYPE_NAMES = [
		  "nonWitnessUtxo",
		  "witnessUtxo",
		  "partialSig",
		  "sighashType",
		  "redeemScript",
		  "witnessScript",
		  "bip32Derivation",
		  "finalScriptSig",
		  "finalScriptWitness",
		  "porCommitment",
		  "tapKeySig",
		  "tapScriptSig",
		  "tapLeafScript",
		  "tapBip32Derivation",
		  "tapInternalKey",
		  "tapMerkleRoot"
		];
		(function(OutputTypes2) {
		  OutputTypes2[OutputTypes2["REDEEM_SCRIPT"] = 0] = "REDEEM_SCRIPT";
		  OutputTypes2[OutputTypes2["WITNESS_SCRIPT"] = 1] = "WITNESS_SCRIPT";
		  OutputTypes2[OutputTypes2["BIP32_DERIVATION"] = 2] = "BIP32_DERIVATION";
		  OutputTypes2[OutputTypes2["TAP_INTERNAL_KEY"] = 5] = "TAP_INTERNAL_KEY";
		  OutputTypes2[OutputTypes2["TAP_TREE"] = 6] = "TAP_TREE";
		  OutputTypes2[OutputTypes2["TAP_BIP32_DERIVATION"] = 7] = "TAP_BIP32_DERIVATION";
		})(exports$1.OutputTypes || (exports$1.OutputTypes = {}));
		exports$1.OUTPUT_TYPE_NAMES = [
		  "redeemScript",
		  "witnessScript",
		  "bip32Derivation",
		  "tapInternalKey",
		  "tapTree",
		  "tapBip32Derivation"
		]; 
	} (typeFields));
	return typeFields;
}

var globalXpub = {};

var hasRequiredGlobalXpub;

function requireGlobalXpub () {
	if (hasRequiredGlobalXpub) return globalXpub;
	hasRequiredGlobalXpub = 1;
	Object.defineProperty(globalXpub, "__esModule", { value: true });
	const typeFields_1 = requireTypeFields();
	const range = (n) => [...Array(n).keys()];
	function decode(keyVal) {
	  if (keyVal.key[0] !== typeFields_1.GlobalTypes.GLOBAL_XPUB) {
	    throw new Error(
	      "Decode Error: could not decode globalXpub with key 0x" + keyVal.key.toString("hex")
	    );
	  }
	  if (keyVal.key.length !== 79 || ![2, 3].includes(keyVal.key[46])) {
	    throw new Error(
	      "Decode Error: globalXpub has invalid extended pubkey in key 0x" + keyVal.key.toString("hex")
	    );
	  }
	  if (keyVal.value.length / 4 % 1 !== 0) {
	    throw new Error(
	      "Decode Error: Global GLOBAL_XPUB value length should be multiple of 4"
	    );
	  }
	  const extendedPubkey = keyVal.key.slice(1);
	  const data = {
	    masterFingerprint: keyVal.value.slice(0, 4),
	    extendedPubkey,
	    path: "m"
	  };
	  for (const i of range(keyVal.value.length / 4 - 1)) {
	    const val = keyVal.value.readUInt32LE(i * 4 + 4);
	    const isHard = !!(val & 2147483648);
	    const idx = val & 2147483647;
	    data.path += "/" + idx.toString(10) + (isHard ? "'" : "");
	  }
	  return data;
	}
	globalXpub.decode = decode;
	function encode(data) {
	  const head = Buffer$1.from([typeFields_1.GlobalTypes.GLOBAL_XPUB]);
	  const key = Buffer$1.concat([head, data.extendedPubkey]);
	  const splitPath = data.path.split("/");
	  const value = Buffer$1.allocUnsafe(splitPath.length * 4);
	  data.masterFingerprint.copy(value, 0);
	  let offset = 4;
	  splitPath.slice(1).forEach((level) => {
	    const isHard = level.slice(-1) === "'";
	    let num = 2147483647 & parseInt(isHard ? level.slice(0, -1) : level, 10);
	    if (isHard) num += 2147483648;
	    value.writeUInt32LE(num, offset);
	    offset += 4;
	  });
	  return {
	    key,
	    value
	  };
	}
	globalXpub.encode = encode;
	globalXpub.expected = "{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }";
	function check(data) {
	  const epk = data.extendedPubkey;
	  const mfp = data.masterFingerprint;
	  const p = data.path;
	  return Buffer$1.isBuffer(epk) && epk.length === 78 && [2, 3].indexOf(epk[45]) > -1 && Buffer$1.isBuffer(mfp) && mfp.length === 4 && typeof p === "string" && !!p.match(/^m(\/\d+'?)*$/);
	}
	globalXpub.check = check;
	function canAddToArray(array, item, dupeSet) {
	  const dupeString = item.extendedPubkey.toString("hex");
	  if (dupeSet.has(dupeString)) return false;
	  dupeSet.add(dupeString);
	  return array.filter((v) => v.extendedPubkey.equals(item.extendedPubkey)).length === 0;
	}
	globalXpub.canAddToArray = canAddToArray;
	return globalXpub;
}

var unsignedTx = {};

var hasRequiredUnsignedTx;

function requireUnsignedTx () {
	if (hasRequiredUnsignedTx) return unsignedTx;
	hasRequiredUnsignedTx = 1;
	Object.defineProperty(unsignedTx, '__esModule', { value: true });
	const typeFields_1 = requireTypeFields();
	function encode(data) {
	  return {
	    key: Buffer$1.from([typeFields_1.GlobalTypes.UNSIGNED_TX]),
	    value: data.toBuffer(),
	  };
	}
	unsignedTx.encode = encode;
	return unsignedTx;
}

var finalScriptSig = {};

var hasRequiredFinalScriptSig;

function requireFinalScriptSig () {
	if (hasRequiredFinalScriptSig) return finalScriptSig;
	hasRequiredFinalScriptSig = 1;
	Object.defineProperty(finalScriptSig, '__esModule', { value: true });
	const typeFields_1 = requireTypeFields();
	function decode(keyVal) {
	  if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTSIG) {
	    throw new Error(
	      'Decode Error: could not decode finalScriptSig with key 0x' +
	        keyVal.key.toString('hex'),
	    );
	  }
	  return keyVal.value;
	}
	finalScriptSig.decode = decode;
	function encode(data) {
	  const key = Buffer$1.from([typeFields_1.InputTypes.FINAL_SCRIPTSIG]);
	  return {
	    key,
	    value: data,
	  };
	}
	finalScriptSig.encode = encode;
	finalScriptSig.expected = 'Buffer';
	function check(data) {
	  return Buffer$1.isBuffer(data);
	}
	finalScriptSig.check = check;
	function canAdd(currentData, newData) {
	  return !!currentData && !!newData && currentData.finalScriptSig === undefined;
	}
	finalScriptSig.canAdd = canAdd;
	return finalScriptSig;
}

var finalScriptWitness = {};

var hasRequiredFinalScriptWitness;

function requireFinalScriptWitness () {
	if (hasRequiredFinalScriptWitness) return finalScriptWitness;
	hasRequiredFinalScriptWitness = 1;
	Object.defineProperty(finalScriptWitness, '__esModule', { value: true });
	const typeFields_1 = requireTypeFields();
	function decode(keyVal) {
	  if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTWITNESS) {
	    throw new Error(
	      'Decode Error: could not decode finalScriptWitness with key 0x' +
	        keyVal.key.toString('hex'),
	    );
	  }
	  return keyVal.value;
	}
	finalScriptWitness.decode = decode;
	function encode(data) {
	  const key = Buffer$1.from([typeFields_1.InputTypes.FINAL_SCRIPTWITNESS]);
	  return {
	    key,
	    value: data,
	  };
	}
	finalScriptWitness.encode = encode;
	finalScriptWitness.expected = 'Buffer';
	function check(data) {
	  return Buffer$1.isBuffer(data);
	}
	finalScriptWitness.check = check;
	function canAdd(currentData, newData) {
	  return (
	    !!currentData && !!newData && currentData.finalScriptWitness === undefined
	  );
	}
	finalScriptWitness.canAdd = canAdd;
	return finalScriptWitness;
}

var nonWitnessUtxo = {};

var hasRequiredNonWitnessUtxo;

function requireNonWitnessUtxo () {
	if (hasRequiredNonWitnessUtxo) return nonWitnessUtxo;
	hasRequiredNonWitnessUtxo = 1;
	Object.defineProperty(nonWitnessUtxo, '__esModule', { value: true });
	const typeFields_1 = requireTypeFields();
	function decode(keyVal) {
	  if (keyVal.key[0] !== typeFields_1.InputTypes.NON_WITNESS_UTXO) {
	    throw new Error(
	      'Decode Error: could not decode nonWitnessUtxo with key 0x' +
	        keyVal.key.toString('hex'),
	    );
	  }
	  return keyVal.value;
	}
	nonWitnessUtxo.decode = decode;
	function encode(data) {
	  return {
	    key: Buffer$1.from([typeFields_1.InputTypes.NON_WITNESS_UTXO]),
	    value: data,
	  };
	}
	nonWitnessUtxo.encode = encode;
	nonWitnessUtxo.expected = 'Buffer';
	function check(data) {
	  return Buffer$1.isBuffer(data);
	}
	nonWitnessUtxo.check = check;
	function canAdd(currentData, newData) {
	  return !!currentData && !!newData && currentData.nonWitnessUtxo === undefined;
	}
	nonWitnessUtxo.canAdd = canAdd;
	return nonWitnessUtxo;
}

var partialSig = {};

var hasRequiredPartialSig;

function requirePartialSig () {
	if (hasRequiredPartialSig) return partialSig;
	hasRequiredPartialSig = 1;
	Object.defineProperty(partialSig, '__esModule', { value: true });
	const typeFields_1 = requireTypeFields();
	function decode(keyVal) {
	  if (keyVal.key[0] !== typeFields_1.InputTypes.PARTIAL_SIG) {
	    throw new Error(
	      'Decode Error: could not decode partialSig with key 0x' +
	        keyVal.key.toString('hex'),
	    );
	  }
	  if (
	    !(keyVal.key.length === 34 || keyVal.key.length === 66) ||
	    ![2, 3, 4].includes(keyVal.key[1])
	  ) {
	    throw new Error(
	      'Decode Error: partialSig has invalid pubkey in key 0x' +
	        keyVal.key.toString('hex'),
	    );
	  }
	  const pubkey = keyVal.key.slice(1);
	  return {
	    pubkey,
	    signature: keyVal.value,
	  };
	}
	partialSig.decode = decode;
	function encode(pSig) {
	  const head = Buffer$1.from([typeFields_1.InputTypes.PARTIAL_SIG]);
	  return {
	    key: Buffer$1.concat([head, pSig.pubkey]),
	    value: pSig.signature,
	  };
	}
	partialSig.encode = encode;
	partialSig.expected = '{ pubkey: Buffer; signature: Buffer; }';
	function check(data) {
	  return (
	    Buffer$1.isBuffer(data.pubkey) &&
	    Buffer$1.isBuffer(data.signature) &&
	    [33, 65].includes(data.pubkey.length) &&
	    [2, 3, 4].includes(data.pubkey[0]) &&
	    isDerSigWithSighash(data.signature)
	  );
	}
	partialSig.check = check;
	function isDerSigWithSighash(buf) {
	  if (!Buffer$1.isBuffer(buf) || buf.length < 9) return false;
	  if (buf[0] !== 0x30) return false;
	  if (buf.length !== buf[1] + 3) return false;
	  if (buf[2] !== 0x02) return false;
	  const rLen = buf[3];
	  if (rLen > 33 || rLen < 1) return false;
	  if (buf[3 + rLen + 1] !== 0x02) return false;
	  const sLen = buf[3 + rLen + 2];
	  if (sLen > 33 || sLen < 1) return false;
	  if (buf.length !== 3 + rLen + 2 + sLen + 2) return false;
	  return true;
	}
	function canAddToArray(array, item, dupeSet) {
	  const dupeString = item.pubkey.toString('hex');
	  if (dupeSet.has(dupeString)) return false;
	  dupeSet.add(dupeString);
	  return array.filter(v => v.pubkey.equals(item.pubkey)).length === 0;
	}
	partialSig.canAddToArray = canAddToArray;
	return partialSig;
}

var porCommitment = {};

var hasRequiredPorCommitment;

function requirePorCommitment () {
	if (hasRequiredPorCommitment) return porCommitment;
	hasRequiredPorCommitment = 1;
	Object.defineProperty(porCommitment, '__esModule', { value: true });
	const typeFields_1 = requireTypeFields();
	function decode(keyVal) {
	  if (keyVal.key[0] !== typeFields_1.InputTypes.POR_COMMITMENT) {
	    throw new Error(
	      'Decode Error: could not decode porCommitment with key 0x' +
	        keyVal.key.toString('hex'),
	    );
	  }
	  return keyVal.value.toString('utf8');
	}
	porCommitment.decode = decode;
	function encode(data) {
	  const key = Buffer$1.from([typeFields_1.InputTypes.POR_COMMITMENT]);
	  return {
	    key,
	    value: Buffer$1.from(data, 'utf8'),
	  };
	}
	porCommitment.encode = encode;
	porCommitment.expected = 'string';
	function check(data) {
	  return typeof data === 'string';
	}
	porCommitment.check = check;
	function canAdd(currentData, newData) {
	  return !!currentData && !!newData && currentData.porCommitment === undefined;
	}
	porCommitment.canAdd = canAdd;
	return porCommitment;
}

var sighashType = {};

var hasRequiredSighashType;

function requireSighashType () {
	if (hasRequiredSighashType) return sighashType;
	hasRequiredSighashType = 1;
	Object.defineProperty(sighashType, '__esModule', { value: true });
	const typeFields_1 = requireTypeFields();
	function decode(keyVal) {
	  if (keyVal.key[0] !== typeFields_1.InputTypes.SIGHASH_TYPE) {
	    throw new Error(
	      'Decode Error: could not decode sighashType with key 0x' +
	        keyVal.key.toString('hex'),
	    );
	  }
	  return keyVal.value.readUInt32LE(0);
	}
	sighashType.decode = decode;
	function encode(data) {
	  const key = Buffer$1.from([typeFields_1.InputTypes.SIGHASH_TYPE]);
	  const value = Buffer$1.allocUnsafe(4);
	  value.writeUInt32LE(data, 0);
	  return {
	    key,
	    value,
	  };
	}
	sighashType.encode = encode;
	sighashType.expected = 'number';
	function check(data) {
	  return typeof data === 'number';
	}
	sighashType.check = check;
	function canAdd(currentData, newData) {
	  return !!currentData && !!newData && currentData.sighashType === undefined;
	}
	sighashType.canAdd = canAdd;
	return sighashType;
}

var tapKeySig = {};

var hasRequiredTapKeySig;

function requireTapKeySig () {
	if (hasRequiredTapKeySig) return tapKeySig;
	hasRequiredTapKeySig = 1;
	Object.defineProperty(tapKeySig, '__esModule', { value: true });
	const typeFields_1 = requireTypeFields();
	function decode(keyVal) {
	  if (
	    keyVal.key[0] !== typeFields_1.InputTypes.TAP_KEY_SIG ||
	    keyVal.key.length !== 1
	  ) {
	    throw new Error(
	      'Decode Error: could not decode tapKeySig with key 0x' +
	        keyVal.key.toString('hex'),
	    );
	  }
	  if (!check(keyVal.value)) {
	    throw new Error(
	      'Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature',
	    );
	  }
	  return keyVal.value;
	}
	tapKeySig.decode = decode;
	function encode(value) {
	  const key = Buffer$1.from([typeFields_1.InputTypes.TAP_KEY_SIG]);
	  return { key, value };
	}
	tapKeySig.encode = encode;
	tapKeySig.expected = 'Buffer';
	function check(data) {
	  return Buffer$1.isBuffer(data) && (data.length === 64 || data.length === 65);
	}
	tapKeySig.check = check;
	function canAdd(currentData, newData) {
	  return !!currentData && !!newData && currentData.tapKeySig === undefined;
	}
	tapKeySig.canAdd = canAdd;
	return tapKeySig;
}

var tapLeafScript = {};

var hasRequiredTapLeafScript;

function requireTapLeafScript () {
	if (hasRequiredTapLeafScript) return tapLeafScript;
	hasRequiredTapLeafScript = 1;
	Object.defineProperty(tapLeafScript, '__esModule', { value: true });
	const typeFields_1 = requireTypeFields();
	function decode(keyVal) {
	  if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_LEAF_SCRIPT) {
	    throw new Error(
	      'Decode Error: could not decode tapLeafScript with key 0x' +
	        keyVal.key.toString('hex'),
	    );
	  }
	  if ((keyVal.key.length - 2) % 32 !== 0) {
	    throw new Error(
	      'Decode Error: tapLeafScript has invalid control block in key 0x' +
	        keyVal.key.toString('hex'),
	    );
	  }
	  const leafVersion = keyVal.value[keyVal.value.length - 1];
	  if ((keyVal.key[1] & 0xfe) !== leafVersion) {
	    throw new Error(
	      'Decode Error: tapLeafScript bad leaf version in key 0x' +
	        keyVal.key.toString('hex'),
	    );
	  }
	  const script = keyVal.value.slice(0, -1);
	  const controlBlock = keyVal.key.slice(1);
	  return { controlBlock, script, leafVersion };
	}
	tapLeafScript.decode = decode;
	function encode(tScript) {
	  const head = Buffer$1.from([typeFields_1.InputTypes.TAP_LEAF_SCRIPT]);
	  const verBuf = Buffer$1.from([tScript.leafVersion]);
	  return {
	    key: Buffer$1.concat([head, tScript.controlBlock]),
	    value: Buffer$1.concat([tScript.script, verBuf]),
	  };
	}
	tapLeafScript.encode = encode;
	tapLeafScript.expected =
	  '{ controlBlock: Buffer; leafVersion: number, script: Buffer; }';
	function check(data) {
	  return (
	    Buffer$1.isBuffer(data.controlBlock) &&
	    (data.controlBlock.length - 1) % 32 === 0 &&
	    (data.controlBlock[0] & 0xfe) === data.leafVersion &&
	    Buffer$1.isBuffer(data.script)
	  );
	}
	tapLeafScript.check = check;
	function canAddToArray(array, item, dupeSet) {
	  const dupeString = item.controlBlock.toString('hex');
	  if (dupeSet.has(dupeString)) return false;
	  dupeSet.add(dupeString);
	  return (
	    array.filter(v => v.controlBlock.equals(item.controlBlock)).length === 0
	  );
	}
	tapLeafScript.canAddToArray = canAddToArray;
	return tapLeafScript;
}

var tapMerkleRoot = {};

var hasRequiredTapMerkleRoot;

function requireTapMerkleRoot () {
	if (hasRequiredTapMerkleRoot) return tapMerkleRoot;
	hasRequiredTapMerkleRoot = 1;
	Object.defineProperty(tapMerkleRoot, '__esModule', { value: true });
	const typeFields_1 = requireTypeFields();
	function decode(keyVal) {
	  if (
	    keyVal.key[0] !== typeFields_1.InputTypes.TAP_MERKLE_ROOT ||
	    keyVal.key.length !== 1
	  ) {
	    throw new Error(
	      'Decode Error: could not decode tapMerkleRoot with key 0x' +
	        keyVal.key.toString('hex'),
	    );
	  }
	  if (!check(keyVal.value)) {
	    throw new Error('Decode Error: tapMerkleRoot not a 32-byte hash');
	  }
	  return keyVal.value;
	}
	tapMerkleRoot.decode = decode;
	function encode(value) {
	  const key = Buffer$1.from([typeFields_1.InputTypes.TAP_MERKLE_ROOT]);
	  return { key, value };
	}
	tapMerkleRoot.encode = encode;
	tapMerkleRoot.expected = 'Buffer';
	function check(data) {
	  return Buffer$1.isBuffer(data) && data.length === 32;
	}
	tapMerkleRoot.check = check;
	function canAdd(currentData, newData) {
	  return !!currentData && !!newData && currentData.tapMerkleRoot === undefined;
	}
	tapMerkleRoot.canAdd = canAdd;
	return tapMerkleRoot;
}

var tapScriptSig = {};

var hasRequiredTapScriptSig;

function requireTapScriptSig () {
	if (hasRequiredTapScriptSig) return tapScriptSig;
	hasRequiredTapScriptSig = 1;
	Object.defineProperty(tapScriptSig, '__esModule', { value: true });
	const typeFields_1 = requireTypeFields();
	function decode(keyVal) {
	  if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_SCRIPT_SIG) {
	    throw new Error(
	      'Decode Error: could not decode tapScriptSig with key 0x' +
	        keyVal.key.toString('hex'),
	    );
	  }
	  if (keyVal.key.length !== 65) {
	    throw new Error(
	      'Decode Error: tapScriptSig has invalid key 0x' +
	        keyVal.key.toString('hex'),
	    );
	  }
	  if (keyVal.value.length !== 64 && keyVal.value.length !== 65) {
	    throw new Error(
	      'Decode Error: tapScriptSig has invalid signature in key 0x' +
	        keyVal.key.toString('hex'),
	    );
	  }
	  const pubkey = keyVal.key.slice(1, 33);
	  const leafHash = keyVal.key.slice(33);
	  return {
	    pubkey,
	    leafHash,
	    signature: keyVal.value,
	  };
	}
	tapScriptSig.decode = decode;
	function encode(tSig) {
	  const head = Buffer$1.from([typeFields_1.InputTypes.TAP_SCRIPT_SIG]);
	  return {
	    key: Buffer$1.concat([head, tSig.pubkey, tSig.leafHash]),
	    value: tSig.signature,
	  };
	}
	tapScriptSig.encode = encode;
	tapScriptSig.expected = '{ pubkey: Buffer; leafHash: Buffer; signature: Buffer; }';
	function check(data) {
	  return (
	    Buffer$1.isBuffer(data.pubkey) &&
	    Buffer$1.isBuffer(data.leafHash) &&
	    Buffer$1.isBuffer(data.signature) &&
	    data.pubkey.length === 32 &&
	    data.leafHash.length === 32 &&
	    (data.signature.length === 64 || data.signature.length === 65)
	  );
	}
	tapScriptSig.check = check;
	function canAddToArray(array, item, dupeSet) {
	  const dupeString =
	    item.pubkey.toString('hex') + item.leafHash.toString('hex');
	  if (dupeSet.has(dupeString)) return false;
	  dupeSet.add(dupeString);
	  return (
	    array.filter(
	      v => v.pubkey.equals(item.pubkey) && v.leafHash.equals(item.leafHash),
	    ).length === 0
	  );
	}
	tapScriptSig.canAddToArray = canAddToArray;
	return tapScriptSig;
}

var witnessUtxo = {};

var tools = {};

var varint = {};

var hasRequiredVarint;

function requireVarint () {
	if (hasRequiredVarint) return varint;
	hasRequiredVarint = 1;
	Object.defineProperty(varint, '__esModule', { value: true });
	// Number.MAX_SAFE_INTEGER
	const MAX_SAFE_INTEGER = 9007199254740991;
	function checkUInt53(n) {
	  if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0)
	    throw new RangeError('value out of range');
	}
	function encode(_number, buffer, offset) {
	  checkUInt53(_number);
	  if (!buffer) buffer = Buffer$1.allocUnsafe(encodingLength(_number));
	  if (!Buffer$1.isBuffer(buffer))
	    throw new TypeError('buffer must be a Buffer instance');
	  if (!offset) offset = 0;
	  // 8 bit
	  if (_number < 0xfd) {
	    buffer.writeUInt8(_number, offset);
	    Object.assign(encode, { bytes: 1 });
	    // 16 bit
	  } else if (_number <= 0xffff) {
	    buffer.writeUInt8(0xfd, offset);
	    buffer.writeUInt16LE(_number, offset + 1);
	    Object.assign(encode, { bytes: 3 });
	    // 32 bit
	  } else if (_number <= 0xffffffff) {
	    buffer.writeUInt8(0xfe, offset);
	    buffer.writeUInt32LE(_number, offset + 1);
	    Object.assign(encode, { bytes: 5 });
	    // 64 bit
	  } else {
	    buffer.writeUInt8(0xff, offset);
	    buffer.writeUInt32LE(_number >>> 0, offset + 1);
	    buffer.writeUInt32LE((_number / 0x100000000) | 0, offset + 5);
	    Object.assign(encode, { bytes: 9 });
	  }
	  return buffer;
	}
	varint.encode = encode;
	function decode(buffer, offset) {
	  if (!Buffer$1.isBuffer(buffer))
	    throw new TypeError('buffer must be a Buffer instance');
	  if (!offset) offset = 0;
	  const first = buffer.readUInt8(offset);
	  // 8 bit
	  if (first < 0xfd) {
	    Object.assign(decode, { bytes: 1 });
	    return first;
	    // 16 bit
	  } else if (first === 0xfd) {
	    Object.assign(decode, { bytes: 3 });
	    return buffer.readUInt16LE(offset + 1);
	    // 32 bit
	  } else if (first === 0xfe) {
	    Object.assign(decode, { bytes: 5 });
	    return buffer.readUInt32LE(offset + 1);
	    // 64 bit
	  } else {
	    Object.assign(decode, { bytes: 9 });
	    const lo = buffer.readUInt32LE(offset + 1);
	    const hi = buffer.readUInt32LE(offset + 5);
	    const _number = hi * 0x0100000000 + lo;
	    checkUInt53(_number);
	    return _number;
	  }
	}
	varint.decode = decode;
	function encodingLength(_number) {
	  checkUInt53(_number);
	  return _number < 0xfd
	    ? 1
	    : _number <= 0xffff
	    ? 3
	    : _number <= 0xffffffff
	    ? 5
	    : 9;
	}
	varint.encodingLength = encodingLength;
	return varint;
}

var hasRequiredTools;

function requireTools () {
	if (hasRequiredTools) return tools;
	hasRequiredTools = 1;
	Object.defineProperty(tools, '__esModule', { value: true });
	const varuint = requireVarint();
	tools.range = n => [...Array(n).keys()];
	function reverseBuffer(buffer) {
	  if (buffer.length < 1) return buffer;
	  let j = buffer.length - 1;
	  let tmp = 0;
	  for (let i = 0; i < buffer.length / 2; i++) {
	    tmp = buffer[i];
	    buffer[i] = buffer[j];
	    buffer[j] = tmp;
	    j--;
	  }
	  return buffer;
	}
	tools.reverseBuffer = reverseBuffer;
	function keyValsToBuffer(keyVals) {
	  const buffers = keyVals.map(keyValToBuffer);
	  buffers.push(Buffer$1.from([0]));
	  return Buffer$1.concat(buffers);
	}
	tools.keyValsToBuffer = keyValsToBuffer;
	function keyValToBuffer(keyVal) {
	  const keyLen = keyVal.key.length;
	  const valLen = keyVal.value.length;
	  const keyVarIntLen = varuint.encodingLength(keyLen);
	  const valVarIntLen = varuint.encodingLength(valLen);
	  const buffer = Buffer$1.allocUnsafe(
	    keyVarIntLen + keyLen + valVarIntLen + valLen,
	  );
	  varuint.encode(keyLen, buffer, 0);
	  keyVal.key.copy(buffer, keyVarIntLen);
	  varuint.encode(valLen, buffer, keyVarIntLen + keyLen);
	  keyVal.value.copy(buffer, keyVarIntLen + keyLen + valVarIntLen);
	  return buffer;
	}
	tools.keyValToBuffer = keyValToBuffer;
	// https://github.com/feross/buffer/blob/master/index.js#L1127
	function verifuint(value, max) {
	  if (typeof value !== 'number')
	    throw new Error('cannot write a non-number as a number');
	  if (value < 0)
	    throw new Error('specified a negative value for writing an unsigned value');
	  if (value > max) throw new Error('RangeError: value out of range');
	  if (Math.floor(value) !== value)
	    throw new Error('value has a fractional component');
	}
	function readUInt64LE(buffer, offset) {
	  const a = buffer.readUInt32LE(offset);
	  let b = buffer.readUInt32LE(offset + 4);
	  b *= 0x100000000;
	  verifuint(b + a, 0x001fffffffffffff);
	  return b + a;
	}
	tools.readUInt64LE = readUInt64LE;
	function writeUInt64LE(buffer, value, offset) {
	  verifuint(value, 0x001fffffffffffff);
	  buffer.writeInt32LE(value & -1, offset);
	  buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);
	  return offset + 8;
	}
	tools.writeUInt64LE = writeUInt64LE;
	return tools;
}

var hasRequiredWitnessUtxo;

function requireWitnessUtxo () {
	if (hasRequiredWitnessUtxo) return witnessUtxo;
	hasRequiredWitnessUtxo = 1;
	Object.defineProperty(witnessUtxo, '__esModule', { value: true });
	const typeFields_1 = requireTypeFields();
	const tools_1 = requireTools();
	const varuint = requireVarint();
	function decode(keyVal) {
	  if (keyVal.key[0] !== typeFields_1.InputTypes.WITNESS_UTXO) {
	    throw new Error(
	      'Decode Error: could not decode witnessUtxo with key 0x' +
	        keyVal.key.toString('hex'),
	    );
	  }
	  const value = tools_1.readUInt64LE(keyVal.value, 0);
	  let _offset = 8;
	  const scriptLen = varuint.decode(keyVal.value, _offset);
	  _offset += varuint.encodingLength(scriptLen);
	  const script = keyVal.value.slice(_offset);
	  if (script.length !== scriptLen) {
	    throw new Error('Decode Error: WITNESS_UTXO script is not proper length');
	  }
	  return {
	    script,
	    value,
	  };
	}
	witnessUtxo.decode = decode;
	function encode(data) {
	  const { script, value } = data;
	  const varintLen = varuint.encodingLength(script.length);
	  const result = Buffer$1.allocUnsafe(8 + varintLen + script.length);
	  tools_1.writeUInt64LE(result, value, 0);
	  varuint.encode(script.length, result, 8);
	  script.copy(result, 8 + varintLen);
	  return {
	    key: Buffer$1.from([typeFields_1.InputTypes.WITNESS_UTXO]),
	    value: result,
	  };
	}
	witnessUtxo.encode = encode;
	witnessUtxo.expected = '{ script: Buffer; value: number; }';
	function check(data) {
	  return Buffer$1.isBuffer(data.script) && typeof data.value === 'number';
	}
	witnessUtxo.check = check;
	function canAdd(currentData, newData) {
	  return !!currentData && !!newData && currentData.witnessUtxo === undefined;
	}
	witnessUtxo.canAdd = canAdd;
	return witnessUtxo;
}

var tapTree = {};

var hasRequiredTapTree;

function requireTapTree () {
	if (hasRequiredTapTree) return tapTree;
	hasRequiredTapTree = 1;
	Object.defineProperty(tapTree, '__esModule', { value: true });
	const typeFields_1 = requireTypeFields();
	const varuint = requireVarint();
	function decode(keyVal) {
	  if (
	    keyVal.key[0] !== typeFields_1.OutputTypes.TAP_TREE ||
	    keyVal.key.length !== 1
	  ) {
	    throw new Error(
	      'Decode Error: could not decode tapTree with key 0x' +
	        keyVal.key.toString('hex'),
	    );
	  }
	  let _offset = 0;
	  const data = [];
	  while (_offset < keyVal.value.length) {
	    const depth = keyVal.value[_offset++];
	    const leafVersion = keyVal.value[_offset++];
	    const scriptLen = varuint.decode(keyVal.value, _offset);
	    _offset += varuint.encodingLength(scriptLen);
	    data.push({
	      depth,
	      leafVersion,
	      script: keyVal.value.slice(_offset, _offset + scriptLen),
	    });
	    _offset += scriptLen;
	  }
	  return { leaves: data };
	}
	tapTree.decode = decode;
	function encode(tree) {
	  const key = Buffer$1.from([typeFields_1.OutputTypes.TAP_TREE]);
	  const bufs = [].concat(
	    ...tree.leaves.map(tapLeaf => [
	      Buffer$1.of(tapLeaf.depth, tapLeaf.leafVersion),
	      varuint.encode(tapLeaf.script.length),
	      tapLeaf.script,
	    ]),
	  );
	  return {
	    key,
	    value: Buffer$1.concat(bufs),
	  };
	}
	tapTree.encode = encode;
	tapTree.expected =
	  '{ leaves: [{ depth: number; leafVersion: number, script: Buffer; }] }';
	function check(data) {
	  return (
	    Array.isArray(data.leaves) &&
	    data.leaves.every(
	      tapLeaf =>
	        tapLeaf.depth >= 0 &&
	        tapLeaf.depth <= 128 &&
	        (tapLeaf.leafVersion & 0xfe) === tapLeaf.leafVersion &&
	        Buffer$1.isBuffer(tapLeaf.script),
	    )
	  );
	}
	tapTree.check = check;
	function canAdd(currentData, newData) {
	  return !!currentData && !!newData && currentData.tapTree === undefined;
	}
	tapTree.canAdd = canAdd;
	return tapTree;
}

var bip32Derivation = {};

var hasRequiredBip32Derivation;

function requireBip32Derivation () {
	if (hasRequiredBip32Derivation) return bip32Derivation;
	hasRequiredBip32Derivation = 1;
	Object.defineProperty(bip32Derivation, '__esModule', { value: true });
	const range = n => [...Array(n).keys()];
	const isValidDERKey = pubkey =>
	  (pubkey.length === 33 && [2, 3].includes(pubkey[0])) ||
	  (pubkey.length === 65 && 4 === pubkey[0]);
	function makeConverter(TYPE_BYTE, isValidPubkey = isValidDERKey) {
	  function decode(keyVal) {
	    if (keyVal.key[0] !== TYPE_BYTE) {
	      throw new Error(
	        'Decode Error: could not decode bip32Derivation with key 0x' +
	          keyVal.key.toString('hex'),
	      );
	    }
	    const pubkey = keyVal.key.slice(1);
	    if (!isValidPubkey(pubkey)) {
	      throw new Error(
	        'Decode Error: bip32Derivation has invalid pubkey in key 0x' +
	          keyVal.key.toString('hex'),
	      );
	    }
	    if ((keyVal.value.length / 4) % 1 !== 0) {
	      throw new Error(
	        'Decode Error: Input BIP32_DERIVATION value length should be multiple of 4',
	      );
	    }
	    const data = {
	      masterFingerprint: keyVal.value.slice(0, 4),
	      pubkey,
	      path: 'm',
	    };
	    for (const i of range(keyVal.value.length / 4 - 1)) {
	      const val = keyVal.value.readUInt32LE(i * 4 + 4);
	      const isHard = !!(val & 0x80000000);
	      const idx = val & 0x7fffffff;
	      data.path += '/' + idx.toString(10) + (isHard ? "'" : '');
	    }
	    return data;
	  }
	  function encode(data) {
	    const head = Buffer$1.from([TYPE_BYTE]);
	    const key = Buffer$1.concat([head, data.pubkey]);
	    const splitPath = data.path.split('/');
	    const value = Buffer$1.allocUnsafe(splitPath.length * 4);
	    data.masterFingerprint.copy(value, 0);
	    let offset = 4;
	    splitPath.slice(1).forEach(level => {
	      const isHard = level.slice(-1) === "'";
	      let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);
	      if (isHard) num += 0x80000000;
	      value.writeUInt32LE(num, offset);
	      offset += 4;
	    });
	    return {
	      key,
	      value,
	    };
	  }
	  const expected =
	    '{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }';
	  function check(data) {
	    return (
	      Buffer$1.isBuffer(data.pubkey) &&
	      Buffer$1.isBuffer(data.masterFingerprint) &&
	      typeof data.path === 'string' &&
	      isValidPubkey(data.pubkey) &&
	      data.masterFingerprint.length === 4
	    );
	  }
	  function canAddToArray(array, item, dupeSet) {
	    const dupeString = item.pubkey.toString('hex');
	    if (dupeSet.has(dupeString)) return false;
	    dupeSet.add(dupeString);
	    return array.filter(v => v.pubkey.equals(item.pubkey)).length === 0;
	  }
	  return {
	    decode,
	    encode,
	    check,
	    expected,
	    canAddToArray,
	  };
	}
	bip32Derivation.makeConverter = makeConverter;
	return bip32Derivation;
}

var checkPubkey = {};

var hasRequiredCheckPubkey;

function requireCheckPubkey () {
	if (hasRequiredCheckPubkey) return checkPubkey;
	hasRequiredCheckPubkey = 1;
	Object.defineProperty(checkPubkey, '__esModule', { value: true });
	function makeChecker(pubkeyTypes) {
	  return checkPubkey;
	  function checkPubkey(keyVal) {
	    let pubkey;
	    if (pubkeyTypes.includes(keyVal.key[0])) {
	      pubkey = keyVal.key.slice(1);
	      if (
	        !(pubkey.length === 33 || pubkey.length === 65) ||
	        ![2, 3, 4].includes(pubkey[0])
	      ) {
	        throw new Error(
	          'Format Error: invalid pubkey in key 0x' + keyVal.key.toString('hex'),
	        );
	      }
	    }
	    return pubkey;
	  }
	}
	checkPubkey.makeChecker = makeChecker;
	return checkPubkey;
}

var redeemScript = {};

var hasRequiredRedeemScript;

function requireRedeemScript () {
	if (hasRequiredRedeemScript) return redeemScript;
	hasRequiredRedeemScript = 1;
	Object.defineProperty(redeemScript, '__esModule', { value: true });
	function makeConverter(TYPE_BYTE) {
	  function decode(keyVal) {
	    if (keyVal.key[0] !== TYPE_BYTE) {
	      throw new Error(
	        'Decode Error: could not decode redeemScript with key 0x' +
	          keyVal.key.toString('hex'),
	      );
	    }
	    return keyVal.value;
	  }
	  function encode(data) {
	    const key = Buffer$1.from([TYPE_BYTE]);
	    return {
	      key,
	      value: data,
	    };
	  }
	  const expected = 'Buffer';
	  function check(data) {
	    return Buffer$1.isBuffer(data);
	  }
	  function canAdd(currentData, newData) {
	    return !!currentData && !!newData && currentData.redeemScript === undefined;
	  }
	  return {
	    decode,
	    encode,
	    check,
	    expected,
	    canAdd,
	  };
	}
	redeemScript.makeConverter = makeConverter;
	return redeemScript;
}

var tapBip32Derivation = {};

var hasRequiredTapBip32Derivation;

function requireTapBip32Derivation () {
	if (hasRequiredTapBip32Derivation) return tapBip32Derivation;
	hasRequiredTapBip32Derivation = 1;
	Object.defineProperty(tapBip32Derivation, '__esModule', { value: true });
	const varuint = requireVarint();
	const bip32Derivation = requireBip32Derivation();
	const isValidBIP340Key = pubkey => pubkey.length === 32;
	function makeConverter(TYPE_BYTE) {
	  const parent = bip32Derivation.makeConverter(TYPE_BYTE, isValidBIP340Key);
	  function decode(keyVal) {
	    const nHashes = varuint.decode(keyVal.value);
	    const nHashesLen = varuint.encodingLength(nHashes);
	    const base = parent.decode({
	      key: keyVal.key,
	      value: keyVal.value.slice(nHashesLen + nHashes * 32),
	    });
	    const leafHashes = new Array(nHashes);
	    for (let i = 0, _offset = nHashesLen; i < nHashes; i++, _offset += 32) {
	      leafHashes[i] = keyVal.value.slice(_offset, _offset + 32);
	    }
	    return Object.assign({}, base, { leafHashes });
	  }
	  function encode(data) {
	    const base = parent.encode(data);
	    const nHashesLen = varuint.encodingLength(data.leafHashes.length);
	    const nHashesBuf = Buffer$1.allocUnsafe(nHashesLen);
	    varuint.encode(data.leafHashes.length, nHashesBuf);
	    const value = Buffer$1.concat([nHashesBuf, ...data.leafHashes, base.value]);
	    return Object.assign({}, base, { value });
	  }
	  const expected =
	    '{ ' +
	    'masterFingerprint: Buffer; ' +
	    'pubkey: Buffer; ' +
	    'path: string; ' +
	    'leafHashes: Buffer[]; ' +
	    '}';
	  function check(data) {
	    return (
	      Array.isArray(data.leafHashes) &&
	      data.leafHashes.every(
	        leafHash => Buffer$1.isBuffer(leafHash) && leafHash.length === 32,
	      ) &&
	      parent.check(data)
	    );
	  }
	  return {
	    decode,
	    encode,
	    check,
	    expected,
	    canAddToArray: parent.canAddToArray,
	  };
	}
	tapBip32Derivation.makeConverter = makeConverter;
	return tapBip32Derivation;
}

var tapInternalKey = {};

var hasRequiredTapInternalKey;

function requireTapInternalKey () {
	if (hasRequiredTapInternalKey) return tapInternalKey;
	hasRequiredTapInternalKey = 1;
	Object.defineProperty(tapInternalKey, '__esModule', { value: true });
	function makeConverter(TYPE_BYTE) {
	  function decode(keyVal) {
	    if (keyVal.key[0] !== TYPE_BYTE || keyVal.key.length !== 1) {
	      throw new Error(
	        'Decode Error: could not decode tapInternalKey with key 0x' +
	          keyVal.key.toString('hex'),
	      );
	    }
	    if (keyVal.value.length !== 32) {
	      throw new Error(
	        'Decode Error: tapInternalKey not a 32-byte x-only pubkey',
	      );
	    }
	    return keyVal.value;
	  }
	  function encode(value) {
	    const key = Buffer$1.from([TYPE_BYTE]);
	    return { key, value };
	  }
	  const expected = 'Buffer';
	  function check(data) {
	    return Buffer$1.isBuffer(data) && data.length === 32;
	  }
	  function canAdd(currentData, newData) {
	    return (
	      !!currentData && !!newData && currentData.tapInternalKey === undefined
	    );
	  }
	  return {
	    decode,
	    encode,
	    check,
	    expected,
	    canAdd,
	  };
	}
	tapInternalKey.makeConverter = makeConverter;
	return tapInternalKey;
}

var witnessScript = {};

var hasRequiredWitnessScript;

function requireWitnessScript () {
	if (hasRequiredWitnessScript) return witnessScript;
	hasRequiredWitnessScript = 1;
	Object.defineProperty(witnessScript, '__esModule', { value: true });
	function makeConverter(TYPE_BYTE) {
	  function decode(keyVal) {
	    if (keyVal.key[0] !== TYPE_BYTE) {
	      throw new Error(
	        'Decode Error: could not decode witnessScript with key 0x' +
	          keyVal.key.toString('hex'),
	      );
	    }
	    return keyVal.value;
	  }
	  function encode(data) {
	    const key = Buffer$1.from([TYPE_BYTE]);
	    return {
	      key,
	      value: data,
	    };
	  }
	  const expected = 'Buffer';
	  function check(data) {
	    return Buffer$1.isBuffer(data);
	  }
	  function canAdd(currentData, newData) {
	    return (
	      !!currentData && !!newData && currentData.witnessScript === undefined
	    );
	  }
	  return {
	    decode,
	    encode,
	    check,
	    expected,
	    canAdd,
	  };
	}
	witnessScript.makeConverter = makeConverter;
	return witnessScript;
}

var hasRequiredConverter;

function requireConverter () {
	if (hasRequiredConverter) return converter;
	hasRequiredConverter = 1;
	Object.defineProperty(converter, "__esModule", { value: true });
	const typeFields_1 = requireTypeFields();
	const globalXpub = requireGlobalXpub();
	const unsignedTx = requireUnsignedTx();
	const finalScriptSig = requireFinalScriptSig();
	const finalScriptWitness = requireFinalScriptWitness();
	const nonWitnessUtxo = requireNonWitnessUtxo();
	const partialSig = requirePartialSig();
	const porCommitment = requirePorCommitment();
	const sighashType = requireSighashType();
	const tapKeySig = requireTapKeySig();
	const tapLeafScript = requireTapLeafScript();
	const tapMerkleRoot = requireTapMerkleRoot();
	const tapScriptSig = requireTapScriptSig();
	const witnessUtxo = requireWitnessUtxo();
	const tapTree = requireTapTree();
	const bip32Derivation = requireBip32Derivation();
	const checkPubkey = requireCheckPubkey();
	const redeemScript = requireRedeemScript();
	const tapBip32Derivation = requireTapBip32Derivation();
	const tapInternalKey = requireTapInternalKey();
	const witnessScript = requireWitnessScript();
	const globals = {
	  unsignedTx,
	  globalXpub,
	  // pass an Array of key bytes that require pubkey beside the key
	  checkPubkey: checkPubkey.makeChecker([])
	};
	converter.globals = globals;
	const inputs = {
	  nonWitnessUtxo,
	  partialSig,
	  sighashType,
	  finalScriptSig,
	  finalScriptWitness,
	  porCommitment,
	  witnessUtxo,
	  bip32Derivation: bip32Derivation.makeConverter(
	    typeFields_1.InputTypes.BIP32_DERIVATION
	  ),
	  redeemScript: redeemScript.makeConverter(
	    typeFields_1.InputTypes.REDEEM_SCRIPT
	  ),
	  witnessScript: witnessScript.makeConverter(
	    typeFields_1.InputTypes.WITNESS_SCRIPT
	  ),
	  checkPubkey: checkPubkey.makeChecker([
	    typeFields_1.InputTypes.PARTIAL_SIG,
	    typeFields_1.InputTypes.BIP32_DERIVATION
	  ]),
	  tapKeySig,
	  tapScriptSig,
	  tapLeafScript,
	  tapBip32Derivation: tapBip32Derivation.makeConverter(
	    typeFields_1.InputTypes.TAP_BIP32_DERIVATION
	  ),
	  tapInternalKey: tapInternalKey.makeConverter(
	    typeFields_1.InputTypes.TAP_INTERNAL_KEY
	  ),
	  tapMerkleRoot
	};
	converter.inputs = inputs;
	const outputs = {
	  bip32Derivation: bip32Derivation.makeConverter(
	    typeFields_1.OutputTypes.BIP32_DERIVATION
	  ),
	  redeemScript: redeemScript.makeConverter(
	    typeFields_1.OutputTypes.REDEEM_SCRIPT
	  ),
	  witnessScript: witnessScript.makeConverter(
	    typeFields_1.OutputTypes.WITNESS_SCRIPT
	  ),
	  checkPubkey: checkPubkey.makeChecker([
	    typeFields_1.OutputTypes.BIP32_DERIVATION
	  ]),
	  tapBip32Derivation: tapBip32Derivation.makeConverter(
	    typeFields_1.OutputTypes.TAP_BIP32_DERIVATION
	  ),
	  tapTree,
	  tapInternalKey: tapInternalKey.makeConverter(
	    typeFields_1.OutputTypes.TAP_INTERNAL_KEY
	  )
	};
	converter.outputs = outputs;
	return converter;
}

var hasRequiredFromBuffer;

function requireFromBuffer () {
	if (hasRequiredFromBuffer) return fromBuffer;
	hasRequiredFromBuffer = 1;
	Object.defineProperty(fromBuffer, "__esModule", { value: true });
	const convert = requireConverter();
	const tools_1 = requireTools();
	const varuint = requireVarint();
	const typeFields_1 = requireTypeFields();
	function psbtFromBuffer(buffer, txGetter) {
	  let offset = 0;
	  function varSlice() {
	    const keyLen = varuint.decode(buffer, offset);
	    offset += varuint.encodingLength(keyLen);
	    const key = buffer.slice(offset, offset + keyLen);
	    offset += keyLen;
	    return key;
	  }
	  function readUInt32BE() {
	    const num = buffer.readUInt32BE(offset);
	    offset += 4;
	    return num;
	  }
	  function readUInt8() {
	    const num = buffer.readUInt8(offset);
	    offset += 1;
	    return num;
	  }
	  function getKeyValue() {
	    const key = varSlice();
	    const value = varSlice();
	    return {
	      key,
	      value
	    };
	  }
	  function checkEndOfKeyValPairs() {
	    if (offset >= buffer.length) {
	      throw new Error("Format Error: Unexpected End of PSBT");
	    }
	    const isEnd = buffer.readUInt8(offset) === 0;
	    if (isEnd) {
	      offset++;
	    }
	    return isEnd;
	  }
	  if (readUInt32BE() !== 1886610036) {
	    throw new Error("Format Error: Invalid Magic Number");
	  }
	  if (readUInt8() !== 255) {
	    throw new Error(
	      "Format Error: Magic Number must be followed by 0xff separator"
	    );
	  }
	  const globalMapKeyVals = [];
	  const globalKeyIndex = {};
	  while (!checkEndOfKeyValPairs()) {
	    const keyVal = getKeyValue();
	    const hexKey = keyVal.key.toString("hex");
	    if (globalKeyIndex[hexKey]) {
	      throw new Error(
	        "Format Error: Keys must be unique for global keymap: key " + hexKey
	      );
	    }
	    globalKeyIndex[hexKey] = 1;
	    globalMapKeyVals.push(keyVal);
	  }
	  const unsignedTxMaps = globalMapKeyVals.filter(
	    (keyVal) => keyVal.key[0] === typeFields_1.GlobalTypes.UNSIGNED_TX
	  );
	  if (unsignedTxMaps.length !== 1) {
	    throw new Error("Format Error: Only one UNSIGNED_TX allowed");
	  }
	  const unsignedTx = txGetter(unsignedTxMaps[0].value);
	  const { inputCount, outputCount } = unsignedTx.getInputOutputCounts();
	  const inputKeyVals = [];
	  const outputKeyVals = [];
	  for (const index of tools_1.range(inputCount)) {
	    const inputKeyIndex = {};
	    const input = [];
	    while (!checkEndOfKeyValPairs()) {
	      const keyVal = getKeyValue();
	      const hexKey = keyVal.key.toString("hex");
	      if (inputKeyIndex[hexKey]) {
	        throw new Error(
	          "Format Error: Keys must be unique for each input: input index " + index + " key " + hexKey
	        );
	      }
	      inputKeyIndex[hexKey] = 1;
	      input.push(keyVal);
	    }
	    inputKeyVals.push(input);
	  }
	  for (const index of tools_1.range(outputCount)) {
	    const outputKeyIndex = {};
	    const output = [];
	    while (!checkEndOfKeyValPairs()) {
	      const keyVal = getKeyValue();
	      const hexKey = keyVal.key.toString("hex");
	      if (outputKeyIndex[hexKey]) {
	        throw new Error(
	          "Format Error: Keys must be unique for each output: output index " + index + " key " + hexKey
	        );
	      }
	      outputKeyIndex[hexKey] = 1;
	      output.push(keyVal);
	    }
	    outputKeyVals.push(output);
	  }
	  return psbtFromKeyVals(unsignedTx, {
	    globalMapKeyVals,
	    inputKeyVals,
	    outputKeyVals
	  });
	}
	fromBuffer.psbtFromBuffer = psbtFromBuffer;
	function checkKeyBuffer(type, keyBuf, keyNum) {
	  if (!keyBuf.equals(Buffer$1.from([keyNum]))) {
	    throw new Error(
	      `Format Error: Invalid ${type} key: ${keyBuf.toString("hex")}`
	    );
	  }
	}
	fromBuffer.checkKeyBuffer = checkKeyBuffer;
	function psbtFromKeyVals(unsignedTx, { globalMapKeyVals, inputKeyVals, outputKeyVals }) {
	  const globalMap = {
	    unsignedTx
	  };
	  let txCount = 0;
	  for (const keyVal of globalMapKeyVals) {
	    switch (keyVal.key[0]) {
	      case typeFields_1.GlobalTypes.UNSIGNED_TX:
	        checkKeyBuffer(
	          "global",
	          keyVal.key,
	          typeFields_1.GlobalTypes.UNSIGNED_TX
	        );
	        if (txCount > 0) {
	          throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");
	        }
	        txCount++;
	        break;
	      case typeFields_1.GlobalTypes.GLOBAL_XPUB:
	        if (globalMap.globalXpub === void 0) {
	          globalMap.globalXpub = [];
	        }
	        globalMap.globalXpub.push(convert.globals.globalXpub.decode(keyVal));
	        break;
	      default:
	        if (!globalMap.unknownKeyVals) globalMap.unknownKeyVals = [];
	        globalMap.unknownKeyVals.push(keyVal);
	    }
	  }
	  const inputCount = inputKeyVals.length;
	  const outputCount = outputKeyVals.length;
	  const inputs = [];
	  const outputs = [];
	  for (const index of tools_1.range(inputCount)) {
	    const input = {};
	    for (const keyVal of inputKeyVals[index]) {
	      convert.inputs.checkPubkey(keyVal);
	      switch (keyVal.key[0]) {
	        case typeFields_1.InputTypes.NON_WITNESS_UTXO:
	          checkKeyBuffer(
	            "input",
	            keyVal.key,
	            typeFields_1.InputTypes.NON_WITNESS_UTXO
	          );
	          if (input.nonWitnessUtxo !== void 0) {
	            throw new Error(
	              "Format Error: Input has multiple NON_WITNESS_UTXO"
	            );
	          }
	          input.nonWitnessUtxo = convert.inputs.nonWitnessUtxo.decode(keyVal);
	          break;
	        case typeFields_1.InputTypes.WITNESS_UTXO:
	          checkKeyBuffer(
	            "input",
	            keyVal.key,
	            typeFields_1.InputTypes.WITNESS_UTXO
	          );
	          if (input.witnessUtxo !== void 0) {
	            throw new Error("Format Error: Input has multiple WITNESS_UTXO");
	          }
	          input.witnessUtxo = convert.inputs.witnessUtxo.decode(keyVal);
	          break;
	        case typeFields_1.InputTypes.PARTIAL_SIG:
	          if (input.partialSig === void 0) {
	            input.partialSig = [];
	          }
	          input.partialSig.push(convert.inputs.partialSig.decode(keyVal));
	          break;
	        case typeFields_1.InputTypes.SIGHASH_TYPE:
	          checkKeyBuffer(
	            "input",
	            keyVal.key,
	            typeFields_1.InputTypes.SIGHASH_TYPE
	          );
	          if (input.sighashType !== void 0) {
	            throw new Error("Format Error: Input has multiple SIGHASH_TYPE");
	          }
	          input.sighashType = convert.inputs.sighashType.decode(keyVal);
	          break;
	        case typeFields_1.InputTypes.REDEEM_SCRIPT:
	          checkKeyBuffer(
	            "input",
	            keyVal.key,
	            typeFields_1.InputTypes.REDEEM_SCRIPT
	          );
	          if (input.redeemScript !== void 0) {
	            throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");
	          }
	          input.redeemScript = convert.inputs.redeemScript.decode(keyVal);
	          break;
	        case typeFields_1.InputTypes.WITNESS_SCRIPT:
	          checkKeyBuffer(
	            "input",
	            keyVal.key,
	            typeFields_1.InputTypes.WITNESS_SCRIPT
	          );
	          if (input.witnessScript !== void 0) {
	            throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");
	          }
	          input.witnessScript = convert.inputs.witnessScript.decode(keyVal);
	          break;
	        case typeFields_1.InputTypes.BIP32_DERIVATION:
	          if (input.bip32Derivation === void 0) {
	            input.bip32Derivation = [];
	          }
	          input.bip32Derivation.push(
	            convert.inputs.bip32Derivation.decode(keyVal)
	          );
	          break;
	        case typeFields_1.InputTypes.FINAL_SCRIPTSIG:
	          checkKeyBuffer(
	            "input",
	            keyVal.key,
	            typeFields_1.InputTypes.FINAL_SCRIPTSIG
	          );
	          input.finalScriptSig = convert.inputs.finalScriptSig.decode(keyVal);
	          break;
	        case typeFields_1.InputTypes.FINAL_SCRIPTWITNESS:
	          checkKeyBuffer(
	            "input",
	            keyVal.key,
	            typeFields_1.InputTypes.FINAL_SCRIPTWITNESS
	          );
	          input.finalScriptWitness = convert.inputs.finalScriptWitness.decode(
	            keyVal
	          );
	          break;
	        case typeFields_1.InputTypes.POR_COMMITMENT:
	          checkKeyBuffer(
	            "input",
	            keyVal.key,
	            typeFields_1.InputTypes.POR_COMMITMENT
	          );
	          input.porCommitment = convert.inputs.porCommitment.decode(keyVal);
	          break;
	        case typeFields_1.InputTypes.TAP_KEY_SIG:
	          checkKeyBuffer(
	            "input",
	            keyVal.key,
	            typeFields_1.InputTypes.TAP_KEY_SIG
	          );
	          input.tapKeySig = convert.inputs.tapKeySig.decode(keyVal);
	          break;
	        case typeFields_1.InputTypes.TAP_SCRIPT_SIG:
	          if (input.tapScriptSig === void 0) {
	            input.tapScriptSig = [];
	          }
	          input.tapScriptSig.push(convert.inputs.tapScriptSig.decode(keyVal));
	          break;
	        case typeFields_1.InputTypes.TAP_LEAF_SCRIPT:
	          if (input.tapLeafScript === void 0) {
	            input.tapLeafScript = [];
	          }
	          input.tapLeafScript.push(convert.inputs.tapLeafScript.decode(keyVal));
	          break;
	        case typeFields_1.InputTypes.TAP_BIP32_DERIVATION:
	          if (input.tapBip32Derivation === void 0) {
	            input.tapBip32Derivation = [];
	          }
	          input.tapBip32Derivation.push(
	            convert.inputs.tapBip32Derivation.decode(keyVal)
	          );
	          break;
	        case typeFields_1.InputTypes.TAP_INTERNAL_KEY:
	          checkKeyBuffer(
	            "input",
	            keyVal.key,
	            typeFields_1.InputTypes.TAP_INTERNAL_KEY
	          );
	          input.tapInternalKey = convert.inputs.tapInternalKey.decode(keyVal);
	          break;
	        case typeFields_1.InputTypes.TAP_MERKLE_ROOT:
	          checkKeyBuffer(
	            "input",
	            keyVal.key,
	            typeFields_1.InputTypes.TAP_MERKLE_ROOT
	          );
	          input.tapMerkleRoot = convert.inputs.tapMerkleRoot.decode(keyVal);
	          break;
	        default:
	          if (!input.unknownKeyVals) input.unknownKeyVals = [];
	          input.unknownKeyVals.push(keyVal);
	      }
	    }
	    inputs.push(input);
	  }
	  for (const index of tools_1.range(outputCount)) {
	    const output = {};
	    for (const keyVal of outputKeyVals[index]) {
	      convert.outputs.checkPubkey(keyVal);
	      switch (keyVal.key[0]) {
	        case typeFields_1.OutputTypes.REDEEM_SCRIPT:
	          checkKeyBuffer(
	            "output",
	            keyVal.key,
	            typeFields_1.OutputTypes.REDEEM_SCRIPT
	          );
	          if (output.redeemScript !== void 0) {
	            throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");
	          }
	          output.redeemScript = convert.outputs.redeemScript.decode(keyVal);
	          break;
	        case typeFields_1.OutputTypes.WITNESS_SCRIPT:
	          checkKeyBuffer(
	            "output",
	            keyVal.key,
	            typeFields_1.OutputTypes.WITNESS_SCRIPT
	          );
	          if (output.witnessScript !== void 0) {
	            throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");
	          }
	          output.witnessScript = convert.outputs.witnessScript.decode(keyVal);
	          break;
	        case typeFields_1.OutputTypes.BIP32_DERIVATION:
	          if (output.bip32Derivation === void 0) {
	            output.bip32Derivation = [];
	          }
	          output.bip32Derivation.push(
	            convert.outputs.bip32Derivation.decode(keyVal)
	          );
	          break;
	        case typeFields_1.OutputTypes.TAP_INTERNAL_KEY:
	          checkKeyBuffer(
	            "output",
	            keyVal.key,
	            typeFields_1.OutputTypes.TAP_INTERNAL_KEY
	          );
	          output.tapInternalKey = convert.outputs.tapInternalKey.decode(keyVal);
	          break;
	        case typeFields_1.OutputTypes.TAP_TREE:
	          checkKeyBuffer(
	            "output",
	            keyVal.key,
	            typeFields_1.OutputTypes.TAP_TREE
	          );
	          output.tapTree = convert.outputs.tapTree.decode(keyVal);
	          break;
	        case typeFields_1.OutputTypes.TAP_BIP32_DERIVATION:
	          if (output.tapBip32Derivation === void 0) {
	            output.tapBip32Derivation = [];
	          }
	          output.tapBip32Derivation.push(
	            convert.outputs.tapBip32Derivation.decode(keyVal)
	          );
	          break;
	        default:
	          if (!output.unknownKeyVals) output.unknownKeyVals = [];
	          output.unknownKeyVals.push(keyVal);
	      }
	    }
	    outputs.push(output);
	  }
	  return { globalMap, inputs, outputs };
	}
	fromBuffer.psbtFromKeyVals = psbtFromKeyVals;
	return fromBuffer;
}

var toBuffer$1 = {};

var hasRequiredToBuffer$1;

function requireToBuffer$1 () {
	if (hasRequiredToBuffer$1) return toBuffer$1;
	hasRequiredToBuffer$1 = 1;
	Object.defineProperty(toBuffer$1, "__esModule", { value: true });
	const convert = requireConverter();
	const tools_1 = requireTools();
	function psbtToBuffer({ globalMap, inputs, outputs }) {
	  const { globalKeyVals, inputKeyVals, outputKeyVals } = psbtToKeyVals({
	    globalMap,
	    inputs,
	    outputs
	  });
	  const globalBuffer = tools_1.keyValsToBuffer(globalKeyVals);
	  const keyValsOrEmptyToBuffer = (keyVals) => keyVals.length === 0 ? [Buffer$1.from([0])] : keyVals.map(tools_1.keyValsToBuffer);
	  const inputBuffers = keyValsOrEmptyToBuffer(inputKeyVals);
	  const outputBuffers = keyValsOrEmptyToBuffer(outputKeyVals);
	  const header = Buffer$1.allocUnsafe(5);
	  header.writeUIntBE(482972169471, 0, 5);
	  return Buffer$1.concat(
	    [header, globalBuffer].concat(inputBuffers, outputBuffers)
	  );
	}
	toBuffer$1.psbtToBuffer = psbtToBuffer;
	const sortKeyVals = (a, b) => {
	  return a.key.compare(b.key);
	};
	function keyValsFromMap(keyValMap, converterFactory) {
	  const keyHexSet = /* @__PURE__ */ new Set();
	  const keyVals = Object.entries(keyValMap).reduce((result, [key, value]) => {
	    if (key === "unknownKeyVals") return result;
	    const converter = converterFactory[key];
	    if (converter === void 0) return result;
	    const encodedKeyVals = (Array.isArray(value) ? value : [value]).map(
	      converter.encode
	    );
	    const keyHexes = encodedKeyVals.map((kv) => kv.key.toString("hex"));
	    keyHexes.forEach((hex) => {
	      if (keyHexSet.has(hex))
	        throw new Error("Serialize Error: Duplicate key: " + hex);
	      keyHexSet.add(hex);
	    });
	    return result.concat(encodedKeyVals);
	  }, []);
	  const otherKeyVals = keyValMap.unknownKeyVals ? keyValMap.unknownKeyVals.filter((keyVal) => {
	    return !keyHexSet.has(keyVal.key.toString("hex"));
	  }) : [];
	  return keyVals.concat(otherKeyVals).sort(sortKeyVals);
	}
	function psbtToKeyVals({ globalMap, inputs, outputs }) {
	  return {
	    globalKeyVals: keyValsFromMap(globalMap, convert.globals),
	    inputKeyVals: inputs.map((i) => keyValsFromMap(i, convert.inputs)),
	    outputKeyVals: outputs.map((o) => keyValsFromMap(o, convert.outputs))
	  };
	}
	toBuffer$1.psbtToKeyVals = psbtToKeyVals;
	return toBuffer$1;
}

var hasRequiredParser;

function requireParser () {
	if (hasRequiredParser) return parser;
	hasRequiredParser = 1;
	(function (exports$1) {
		function __export(m) {
		  for (var p in m) if (!exports$1.hasOwnProperty(p)) exports$1[p] = m[p];
		}
		Object.defineProperty(exports$1, '__esModule', { value: true });
		__export(requireFromBuffer());
		__export(requireToBuffer$1()); 
	} (parser));
	return parser;
}

var hasRequiredCombiner;

function requireCombiner () {
	if (hasRequiredCombiner) return combiner;
	hasRequiredCombiner = 1;
	Object.defineProperty(combiner, "__esModule", { value: true });
	const parser_1 = requireParser();
	function combine(psbts) {
	  const self = psbts[0];
	  const selfKeyVals = parser_1.psbtToKeyVals(self);
	  const others = psbts.slice(1);
	  if (others.length === 0) throw new Error("Combine: Nothing to combine");
	  const selfTx = getTx(self);
	  if (selfTx === void 0) {
	    throw new Error("Combine: Self missing transaction");
	  }
	  const selfGlobalSet = getKeySet(selfKeyVals.globalKeyVals);
	  const selfInputSets = selfKeyVals.inputKeyVals.map(getKeySet);
	  const selfOutputSets = selfKeyVals.outputKeyVals.map(getKeySet);
	  for (const other of others) {
	    const otherTx = getTx(other);
	    if (otherTx === void 0 || !otherTx.toBuffer().equals(selfTx.toBuffer())) {
	      throw new Error(
	        "Combine: One of the Psbts does not have the same transaction."
	      );
	    }
	    const otherKeyVals = parser_1.psbtToKeyVals(other);
	    const otherGlobalSet = getKeySet(otherKeyVals.globalKeyVals);
	    otherGlobalSet.forEach(
	      keyPusher(
	        selfGlobalSet,
	        selfKeyVals.globalKeyVals,
	        otherKeyVals.globalKeyVals
	      )
	    );
	    const otherInputSets = otherKeyVals.inputKeyVals.map(getKeySet);
	    otherInputSets.forEach(
	      (inputSet, idx) => inputSet.forEach(
	        keyPusher(
	          selfInputSets[idx],
	          selfKeyVals.inputKeyVals[idx],
	          otherKeyVals.inputKeyVals[idx]
	        )
	      )
	    );
	    const otherOutputSets = otherKeyVals.outputKeyVals.map(getKeySet);
	    otherOutputSets.forEach(
	      (outputSet, idx) => outputSet.forEach(
	        keyPusher(
	          selfOutputSets[idx],
	          selfKeyVals.outputKeyVals[idx],
	          otherKeyVals.outputKeyVals[idx]
	        )
	      )
	    );
	  }
	  return parser_1.psbtFromKeyVals(selfTx, {
	    globalMapKeyVals: selfKeyVals.globalKeyVals,
	    inputKeyVals: selfKeyVals.inputKeyVals,
	    outputKeyVals: selfKeyVals.outputKeyVals
	  });
	}
	combiner.combine = combine;
	function keyPusher(selfSet, selfKeyVals, otherKeyVals) {
	  return (key) => {
	    if (selfSet.has(key)) return;
	    const newKv = otherKeyVals.filter((kv) => kv.key.toString("hex") === key)[0];
	    selfKeyVals.push(newKv);
	    selfSet.add(key);
	  };
	}
	function getTx(psbt) {
	  return psbt.globalMap.unsignedTx;
	}
	function getKeySet(keyVals) {
	  const set = /* @__PURE__ */ new Set();
	  keyVals.forEach((keyVal) => {
	    const hex = keyVal.key.toString("hex");
	    if (set.has(hex))
	      throw new Error("Combine: KeyValue Map keys should be unique");
	    set.add(hex);
	  });
	  return set;
	}
	return combiner;
}

var utils$2 = {};

var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils$2;
	hasRequiredUtils = 1;
	(function (exports$1) {
		Object.defineProperty(exports$1, "__esModule", { value: true });
		const converter = requireConverter();
		function checkForInput(inputs, inputIndex) {
		  const input = inputs[inputIndex];
		  if (input === void 0) throw new Error(`No input #${inputIndex}`);
		  return input;
		}
		exports$1.checkForInput = checkForInput;
		function checkForOutput(outputs, outputIndex) {
		  const output = outputs[outputIndex];
		  if (output === void 0) throw new Error(`No output #${outputIndex}`);
		  return output;
		}
		exports$1.checkForOutput = checkForOutput;
		function checkHasKey(checkKeyVal, keyVals, enumLength) {
		  if (checkKeyVal.key[0] < enumLength) {
		    throw new Error(
		      `Use the method for your specific key instead of addUnknownKeyVal*`
		    );
		  }
		  if (keyVals && keyVals.filter((kv) => kv.key.equals(checkKeyVal.key)).length !== 0) {
		    throw new Error(`Duplicate Key: ${checkKeyVal.key.toString("hex")}`);
		  }
		}
		exports$1.checkHasKey = checkHasKey;
		function getEnumLength(myenum) {
		  let count = 0;
		  Object.keys(myenum).forEach((val) => {
		    if (Number(isNaN(Number(val)))) {
		      count++;
		    }
		  });
		  return count;
		}
		exports$1.getEnumLength = getEnumLength;
		function inputCheckUncleanFinalized(inputIndex, input) {
		  let result = false;
		  if (input.nonWitnessUtxo || input.witnessUtxo) {
		    const needScriptSig = !!input.redeemScript;
		    const needWitnessScript = !!input.witnessScript;
		    const scriptSigOK = !needScriptSig || !!input.finalScriptSig;
		    const witnessScriptOK = !needWitnessScript || !!input.finalScriptWitness;
		    const hasOneFinal = !!input.finalScriptSig || !!input.finalScriptWitness;
		    result = scriptSigOK && witnessScriptOK && hasOneFinal;
		  }
		  if (result === false) {
		    throw new Error(
		      `Input #${inputIndex} has too much or too little data to clean`
		    );
		  }
		}
		exports$1.inputCheckUncleanFinalized = inputCheckUncleanFinalized;
		function throwForUpdateMaker(typeName, name, expected, data) {
		  throw new Error(
		    `Data for ${typeName} key ${name} is incorrect: Expected ${expected} and got ${JSON.stringify(data)}`
		  );
		}
		function updateMaker(typeName) {
		  return (updateData, mainData) => {
		    for (const name of Object.keys(updateData)) {
		      const data = updateData[name];
		      const { canAdd, canAddToArray, check, expected } = (
		        // @ts-ignore
		        converter[typeName + "s"][name] || {}
		      );
		      const isArray = !!canAddToArray;
		      if (check) {
		        if (isArray) {
		          if (!Array.isArray(data) || // @ts-ignore
		          mainData[name] && !Array.isArray(mainData[name])) {
		            throw new Error(`Key type ${name} must be an array`);
		          }
		          if (!data.every(check)) {
		            throwForUpdateMaker(typeName, name, expected, data);
		          }
		          const arr = mainData[name] || [];
		          const dupeCheckSet = /* @__PURE__ */ new Set();
		          if (!data.every((v) => canAddToArray(arr, v, dupeCheckSet))) {
		            throw new Error("Can not add duplicate data to array");
		          }
		          mainData[name] = arr.concat(data);
		        } else {
		          if (!check(data)) {
		            throwForUpdateMaker(typeName, name, expected, data);
		          }
		          if (!canAdd(mainData, data)) {
		            throw new Error(`Can not add duplicate data to ${typeName}`);
		          }
		          mainData[name] = data;
		        }
		      }
		    }
		  };
		}
		exports$1.updateGlobal = updateMaker("global");
		exports$1.updateInput = updateMaker("input");
		exports$1.updateOutput = updateMaker("output");
		function addInputAttributes(inputs, data) {
		  const index = inputs.length - 1;
		  const input = checkForInput(inputs, index);
		  exports$1.updateInput(data, input);
		}
		exports$1.addInputAttributes = addInputAttributes;
		function addOutputAttributes(outputs, data) {
		  const index = outputs.length - 1;
		  const output = checkForOutput(outputs, index);
		  exports$1.updateOutput(data, output);
		}
		exports$1.addOutputAttributes = addOutputAttributes;
		function defaultVersionSetter(version, txBuf) {
		  if (!Buffer$1.isBuffer(txBuf) || txBuf.length < 4) {
		    throw new Error("Set Version: Invalid Transaction");
		  }
		  txBuf.writeUInt32LE(version, 0);
		  return txBuf;
		}
		exports$1.defaultVersionSetter = defaultVersionSetter;
		function defaultLocktimeSetter(locktime, txBuf) {
		  if (!Buffer$1.isBuffer(txBuf) || txBuf.length < 4) {
		    throw new Error("Set Locktime: Invalid Transaction");
		  }
		  txBuf.writeUInt32LE(locktime, txBuf.length - 4);
		  return txBuf;
		}
		exports$1.defaultLocktimeSetter = defaultLocktimeSetter; 
	} (utils$2));
	return utils$2;
}

var hasRequiredPsbt;

function requirePsbt () {
	if (hasRequiredPsbt) return psbt;
	hasRequiredPsbt = 1;
	Object.defineProperty(psbt, "__esModule", { value: true });
	const combiner_1 = requireCombiner();
	const parser_1 = requireParser();
	const typeFields_1 = requireTypeFields();
	const utils_1 = requireUtils();
	class Psbt {
	  constructor(tx) {
	    this.inputs = [];
	    this.outputs = [];
	    this.globalMap = {
	      unsignedTx: tx
	    };
	  }
	  static fromBase64(data, txFromBuffer) {
	    const buffer = Buffer$1.from(data, "base64");
	    return this.fromBuffer(buffer, txFromBuffer);
	  }
	  static fromHex(data, txFromBuffer) {
	    const buffer = Buffer$1.from(data, "hex");
	    return this.fromBuffer(buffer, txFromBuffer);
	  }
	  static fromBuffer(buffer, txFromBuffer) {
	    const results = parser_1.psbtFromBuffer(buffer, txFromBuffer);
	    const psbt = new this(results.globalMap.unsignedTx);
	    Object.assign(psbt, results);
	    return psbt;
	  }
	  toBase64() {
	    const buffer = this.toBuffer();
	    return buffer.toString("base64");
	  }
	  toHex() {
	    const buffer = this.toBuffer();
	    return buffer.toString("hex");
	  }
	  toBuffer() {
	    return parser_1.psbtToBuffer(this);
	  }
	  updateGlobal(updateData) {
	    utils_1.updateGlobal(updateData, this.globalMap);
	    return this;
	  }
	  updateInput(inputIndex, updateData) {
	    const input = utils_1.checkForInput(this.inputs, inputIndex);
	    utils_1.updateInput(updateData, input);
	    return this;
	  }
	  updateOutput(outputIndex, updateData) {
	    const output = utils_1.checkForOutput(this.outputs, outputIndex);
	    utils_1.updateOutput(updateData, output);
	    return this;
	  }
	  addUnknownKeyValToGlobal(keyVal) {
	    utils_1.checkHasKey(
	      keyVal,
	      this.globalMap.unknownKeyVals,
	      utils_1.getEnumLength(typeFields_1.GlobalTypes)
	    );
	    if (!this.globalMap.unknownKeyVals) this.globalMap.unknownKeyVals = [];
	    this.globalMap.unknownKeyVals.push(keyVal);
	    return this;
	  }
	  addUnknownKeyValToInput(inputIndex, keyVal) {
	    const input = utils_1.checkForInput(this.inputs, inputIndex);
	    utils_1.checkHasKey(
	      keyVal,
	      input.unknownKeyVals,
	      utils_1.getEnumLength(typeFields_1.InputTypes)
	    );
	    if (!input.unknownKeyVals) input.unknownKeyVals = [];
	    input.unknownKeyVals.push(keyVal);
	    return this;
	  }
	  addUnknownKeyValToOutput(outputIndex, keyVal) {
	    const output = utils_1.checkForOutput(this.outputs, outputIndex);
	    utils_1.checkHasKey(
	      keyVal,
	      output.unknownKeyVals,
	      utils_1.getEnumLength(typeFields_1.OutputTypes)
	    );
	    if (!output.unknownKeyVals) output.unknownKeyVals = [];
	    output.unknownKeyVals.push(keyVal);
	    return this;
	  }
	  addInput(inputData) {
	    this.globalMap.unsignedTx.addInput(inputData);
	    this.inputs.push({
	      unknownKeyVals: []
	    });
	    const addKeyVals = inputData.unknownKeyVals || [];
	    const inputIndex = this.inputs.length - 1;
	    if (!Array.isArray(addKeyVals)) {
	      throw new Error("unknownKeyVals must be an Array");
	    }
	    addKeyVals.forEach(
	      (keyVal) => this.addUnknownKeyValToInput(inputIndex, keyVal)
	    );
	    utils_1.addInputAttributes(this.inputs, inputData);
	    return this;
	  }
	  addOutput(outputData) {
	    this.globalMap.unsignedTx.addOutput(outputData);
	    this.outputs.push({
	      unknownKeyVals: []
	    });
	    const addKeyVals = outputData.unknownKeyVals || [];
	    const outputIndex = this.outputs.length - 1;
	    if (!Array.isArray(addKeyVals)) {
	      throw new Error("unknownKeyVals must be an Array");
	    }
	    addKeyVals.forEach(
	      (keyVal) => this.addUnknownKeyValToOutput(outputIndex, keyVal)
	    );
	    utils_1.addOutputAttributes(this.outputs, outputData);
	    return this;
	  }
	  clearFinalizedInput(inputIndex) {
	    const input = utils_1.checkForInput(this.inputs, inputIndex);
	    utils_1.inputCheckUncleanFinalized(inputIndex, input);
	    for (const key of Object.keys(input)) {
	      if (![
	        "witnessUtxo",
	        "nonWitnessUtxo",
	        "finalScriptSig",
	        "finalScriptWitness",
	        "unknownKeyVals"
	      ].includes(key)) {
	        delete input[key];
	      }
	    }
	    return this;
	  }
	  combine(...those) {
	    const result = combiner_1.combine([this].concat(those));
	    Object.assign(this, result);
	    return this;
	  }
	  getTransaction() {
	    return this.globalMap.unsignedTx.toBuffer();
	  }
	}
	psbt.Psbt = Psbt;
	return psbt;
}

var psbtExports = requirePsbt();

var varintExports = requireVarint();

var utilsExports = requireUtils();

function isPaymentFactory(payment) {
    return (script) => {
        try {
            payment({ output: script });
            return true;
        }
        catch {
            return false;
        }
    };
}
const isP2MS = isPaymentFactory(p2ms);
const isP2PK = isPaymentFactory(p2pk);
const isP2PKH = isPaymentFactory(p2pkh);
const isP2WPKH = isPaymentFactory(p2wpkh);
const isP2WSHScript = isPaymentFactory(p2wsh);
const isP2SHScript = isPaymentFactory(p2sh);
const isP2TR = isPaymentFactory(p2tr);
const isP2A = (script) => {
    return (script.length === 4 &&
        script[0] === 0x51 &&
        script[1] === 0x02 &&
        script[2] === 0x4e &&
        script[3] === 0x73);
};
function witnessStackToScriptWitness$1(witness) {
    let buffer = Buffer$1.allocUnsafe(0);
    function writeSlice(slice) {
        buffer = Buffer$1.concat([buffer, Buffer$1.from(slice)]);
    }
    function writeVarInt(i) {
        const currentLen = buffer.length;
        const varintLen = varintExports.encodingLength(i);
        buffer = Buffer$1.concat([buffer, Buffer$1.allocUnsafe(varintLen)]);
        varintExports.encode(i, buffer, currentLen);
    }
    function writeVarSlice(slice) {
        writeVarInt(slice.length);
        writeSlice(slice);
    }
    function writeVector(vector) {
        writeVarInt(vector.length);
        vector.forEach(writeVarSlice);
    }
    writeVector(witness);
    return buffer;
}
function pubkeyPositionInScript(pubkey, script$1) {
    const decompiled = decompile(script$1);
    if (decompiled === null)
        throw new Error('Unknown script error');
    const pubkeyHash = hash160(pubkey);
    const pubkeyXOnly = toXOnly(pubkey);
    const uncompressed = decompressPublicKey(pubkey);
    const pubkeyHybridHash = uncompressed?.hybrid ? hash160(uncompressed.hybrid) : undefined;
    const pubkeyUncompressedHash = uncompressed?.uncompressed
        ? hash160(uncompressed.uncompressed)
        : undefined;
    return decompiled.findIndex((element) => {
        if (typeof element === 'number')
            return false;
        if (pubkeysMatch(element, pubkey))
            return true;
        if (pubkeysMatch(element, pubkeyXOnly))
            return true;
        if (element.equals(pubkeyHash)) {
            return true;
        }
        if (uncompressed) {
            if (pubkeysMatch(element, uncompressed.uncompressed))
                return true;
            if (pubkeysMatch(element, uncompressed.hybrid))
                return true;
            if ((pubkeyHybridHash && element.equals(pubkeyHybridHash)) ||
                (pubkeyUncompressedHash && element.equals(pubkeyUncompressedHash))) {
                return true;
            }
        }
    });
}
function pubkeyInScript$1(pubkey, script) {
    return pubkeyPositionInScript(pubkey, script) !== -1;
}
function checkInputForSig(input, action) {
    const pSigs = extractPartialSigs(input);
    return pSigs.some((pSig) => signatureBlocksAction(pSig, signature.decode, action));
}
function signatureBlocksAction(signature, signatureDecodeFn, action) {
    const { hashType } = signatureDecodeFn(signature);
    const whitelist = [];
    const isAnyoneCanPay = hashType & Transaction.SIGHASH_ANYONECANPAY;
    if (isAnyoneCanPay)
        whitelist.push('addInput');
    const hashMod = hashType & 0x1f;
    switch (hashMod) {
        case Transaction.SIGHASH_ALL:
            break;
        case Transaction.SIGHASH_SINGLE:
        case Transaction.SIGHASH_NONE:
            whitelist.push('addOutput');
            whitelist.push('setInputSequence');
            break;
    }
    return whitelist.indexOf(action) === -1;
}
function extractPartialSigs(input) {
    const { partialSig } = input;
    let pSigs;
    if (!partialSig || partialSig.length === 0) {
        if (!input.finalScriptSig && !input.finalScriptWitness)
            return [];
        pSigs = getPsigsFromInputFinalScripts(input);
    }
    else {
        pSigs = partialSig;
    }
    return pSigs.map((p) => p.signature);
}
function getPsigsFromInputFinalScripts(input) {
    const scriptItems = !input.finalScriptSig ? [] : decompile(input.finalScriptSig) || [];
    const witnessItems = !input.finalScriptWitness
        ? []
        : decompile(input.finalScriptWitness) || [];
    return scriptItems
        .concat(witnessItems)
        .filter((item) => {
        return Buffer$1.isBuffer(item) && isCanonicalScriptSignature(item);
    })
        .map((sig) => ({ signature: sig }));
}

function tapScriptFinalizer(inputIndex, input, tapLeafHashToFinalize) {
    const tapLeaf = findTapLeafToFinalize(input, inputIndex, tapLeafHashToFinalize);
    try {
        const sigs = sortSignatures(input, tapLeaf);
        const witness = sigs.concat(tapLeaf.script).concat(tapLeaf.controlBlock);
        return { finalScriptWitness: witnessStackToScriptWitness$1(witness) };
    }
    catch (err) {
        throw new Error(`Can not finalize taproot input #${inputIndex}: ${err}`);
    }
}
function serializeTaprootSignature(sig, sighashType) {
    const sighashTypeByte = sighashType ? Buffer$1.from([sighashType]) : Buffer$1.from([]);
    return Buffer$1.concat([sig, sighashTypeByte]);
}
function isTaprootInput$1(input) {
    return (input &&
        !!(input.tapInternalKey ||
            input.tapMerkleRoot ||
            (input.tapLeafScript && input.tapLeafScript.length) ||
            (input.tapBip32Derivation && input.tapBip32Derivation.length) ||
            (input.witnessUtxo && isP2TR(input.witnessUtxo.script))));
}
function isTaprootOutput(output, script) {
    return (output &&
        !!(output.tapInternalKey ||
            output.tapTree ||
            (output.tapBip32Derivation && output.tapBip32Derivation.length) ||
            (script)));
}
function checkTaprootInputFields(inputData, newInputData, action) {
    checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action);
    checkIfTapLeafInTree(inputData, newInputData, action);
}
function checkTaprootOutputFields(outputData, newOutputData, action) {
    checkMixedTaprootAndNonTaprootOutputFields(outputData, newOutputData, action);
    checkTaprootScriptPubkey(outputData, newOutputData);
}
function checkTaprootScriptPubkey(outputData, newOutputData) {
    if (!newOutputData.tapTree && !newOutputData.tapInternalKey)
        return;
    const tapInternalKey = newOutputData.tapInternalKey || outputData.tapInternalKey;
    const tapTree = newOutputData.tapTree || outputData.tapTree;
    if (tapInternalKey) {
        const scriptPubkey = outputData.script;
        const script = getTaprootScripPubkey(tapInternalKey, tapTree);
        if (scriptPubkey && !scriptPubkey.equals(script))
            throw new Error('Error adding output. Script or address missmatch.');
    }
}
function getTaprootScripPubkey(tapInternalKey, tapTree) {
    const scriptTree = tapTree && tapTreeFromList(tapTree.leaves);
    const { output } = p2tr({
        internalPubkey: tapInternalKey,
        scriptTree,
    });
    if (!output)
        throw new Error('Failed to generate taproot script pubkey');
    return output;
}
function tapTreeFromList(leaves = []) {
    if (leaves.length === 1 && leaves[0].depth === 0)
        return {
            output: leaves[0].script,
            version: leaves[0].leafVersion,
        };
    return insertLeavesInTree(leaves);
}
function checkTaprootInputForSigs(input, action) {
    const sigs = extractTaprootSigs(input);
    return sigs.some((sig) => signatureBlocksAction(sig, decodeSchnorrSignature, action));
}
function decodeSchnorrSignature(signature) {
    return {
        signature: signature.subarray(0, 64),
        hashType: signature.subarray(64)[0] || Transaction.SIGHASH_DEFAULT,
    };
}
function extractTaprootSigs(input) {
    const sigs = [];
    if (input.tapKeySig)
        sigs.push(input.tapKeySig);
    if (input.tapScriptSig)
        sigs.push(...input.tapScriptSig.map((s) => s.signature));
    if (!sigs.length) {
        const finalTapKeySig = getTapKeySigFromWitness(input.finalScriptWitness);
        if (finalTapKeySig)
            sigs.push(finalTapKeySig);
    }
    return sigs;
}
function getTapKeySigFromWitness(finalScriptWitness) {
    if (!finalScriptWitness)
        return;
    const witness = finalScriptWitness.subarray(2);
    if (witness.length === 64 || witness.length === 65)
        return witness;
}
function insertLeavesInTree(leaves) {
    let tree;
    for (const leaf of leaves) {
        tree = insertLeafInTree(leaf, tree);
        if (!tree)
            throw new Error(`No room left to insert tapleaf in tree`);
    }
    return tree;
}
function insertLeafInTree(leaf, tree, depth = 0) {
    if (depth > MAX_TAPTREE_DEPTH)
        throw new Error('Max taptree depth exceeded.');
    if (leaf.depth === depth) {
        if (!tree)
            return {
                output: leaf.script,
                version: leaf.leafVersion,
            };
        return;
    }
    if (isTapleaf(tree))
        return;
    const leftSide = insertLeafInTree(leaf, tree && tree[0], depth + 1);
    if (leftSide)
        return [leftSide, tree && tree[1]];
    const rightSide = insertLeafInTree(leaf, tree && tree[1], depth + 1);
    if (rightSide)
        return [tree && tree[0], rightSide];
}
function checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action) {
    const isBadTaprootUpdate = isTaprootInput$1(inputData) && hasNonTaprootFields(newInputData);
    const isBadNonTaprootUpdate = hasNonTaprootFields(inputData) && isTaprootInput$1(newInputData);
    const hasMixedFields = inputData === newInputData &&
        isTaprootInput$1(newInputData) &&
        hasNonTaprootFields(newInputData);
    if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)
        throw new Error(`Invalid arguments for Psbt.${action}. ` +
            `Cannot use both taproot and non-taproot fields.`);
}
function checkMixedTaprootAndNonTaprootOutputFields(inputData, newInputData, action) {
    const isBadTaprootUpdate = isTaprootOutput(inputData) && hasNonTaprootFields(newInputData);
    const isBadNonTaprootUpdate = hasNonTaprootFields(inputData) && isTaprootOutput(newInputData);
    const hasMixedFields = inputData === newInputData &&
        isTaprootOutput(newInputData) &&
        hasNonTaprootFields(newInputData);
    if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)
        throw new Error(`Invalid arguments for Psbt.${action}. ` +
            `Cannot use both taproot and non-taproot fields.`);
}
function checkIfTapLeafInTree(inputData, newInputData, action) {
    if (newInputData.tapMerkleRoot) {
        const newLeafsInTree = (newInputData.tapLeafScript || []).every((l) => isTapLeafInTree(l, newInputData.tapMerkleRoot));
        const oldLeafsInTree = (inputData.tapLeafScript || []).every((l) => isTapLeafInTree(l, newInputData.tapMerkleRoot));
        if (!newLeafsInTree || !oldLeafsInTree)
            throw new Error(`Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`);
    }
    else if (inputData.tapMerkleRoot) {
        const newLeafsInTree = (newInputData.tapLeafScript || []).every((l) => isTapLeafInTree(l, inputData.tapMerkleRoot));
        if (!newLeafsInTree)
            throw new Error(`Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`);
    }
}
function isTapLeafInTree(tapLeaf, merkleRoot) {
    if (!merkleRoot)
        return true;
    const leafHash = tapleafHash({
        output: tapLeaf.script,
        version: tapLeaf.leafVersion,
    });
    const rootHash = rootHashFromPath(tapLeaf.controlBlock, leafHash);
    return rootHash.equals(merkleRoot);
}
function sortSignatures(input, tapLeaf) {
    const leafHash = tapleafHash({
        output: tapLeaf.script,
        version: tapLeaf.leafVersion,
    });
    return (input.tapScriptSig || [])
        .filter((tss) => tss.leafHash.equals(leafHash))
        .map((tss) => addPubkeyPositionInScript(tapLeaf.script, tss))
        .sort((t1, t2) => t2.positionInScript - t1.positionInScript)
        .map((t) => t.signature);
}
function addPubkeyPositionInScript(script, tss) {
    return Object.assign({
        positionInScript: pubkeyPositionInScript(tss.pubkey, script),
    }, tss);
}
function findTapLeafToFinalize(input, inputIndex, leafHashToFinalize) {
    const { tapScriptSig } = input;
    if (!tapScriptSig || !tapScriptSig.length)
        throw new Error(`Can not finalize taproot input #${inputIndex}. No tapleaf script signature provided.`);
    const tapLeaf = (input.tapLeafScript || [])
        .sort((a, b) => a.controlBlock.length - b.controlBlock.length)
        .find((leaf) => canFinalizeLeaf(leaf, tapScriptSig, leafHashToFinalize));
    if (!tapLeaf)
        throw new Error(`Can not finalize taproot input #${inputIndex}. Signature for tapleaf script not found.`);
    return tapLeaf;
}
function canFinalizeLeaf(leaf, tapScriptSig, hash) {
    const leafHash = tapleafHash({
        output: leaf.script,
        version: leaf.leafVersion,
    });
    const whiteListedHash = !hash || hash.equals(leafHash);
    return (whiteListedHash && tapScriptSig.find((tss) => tss.leafHash.equals(leafHash)) !== undefined);
}
function hasNonTaprootFields(io) {
    return (io &&
        !!(io.redeemScript || io.witnessScript || (io.bip32Derivation && io.bip32Derivation.length)));
}

const varuintDecode = varintExports.decode;
const DEFAULT_OPTS = {
  network: bitcoin$1,
  maximumFeeRate: 5e3
};
class Psbt {
  constructor(opts = {}, data = new psbtExports.Psbt(new PsbtTransaction())) {
    this.data = data;
    this.opts = Object.assign({}, DEFAULT_OPTS, opts);
    this.__CACHE = {
      __NON_WITNESS_UTXO_TX_CACHE: [],
      __NON_WITNESS_UTXO_BUF_CACHE: [],
      __TX_IN_CACHE: {},
      __TX: this.data.globalMap.unsignedTx.tx,
      __UNSAFE_SIGN_NONSEGWIT: false
    };
    if (opts.version === 3) {
      this.setVersionTRUC();
    } else if (this.data.inputs.length === 0)
      this.setVersion(2);
    const dpew = (obj, attr, enumerable, writable) => {
      Object.defineProperty(obj, attr, {
        enumerable,
        writable
      });
    };
    dpew(this, "__CACHE", false, true);
    dpew(this, "opts", false, true);
  }
  get inputCount() {
    return this.data.inputs.length;
  }
  get version() {
    return this.__CACHE.__TX.version;
  }
  set version(version) {
    this.setVersion(version);
  }
  get locktime() {
    return this.__CACHE.__TX.locktime;
  }
  set locktime(locktime) {
    this.setLocktime(locktime);
  }
  get txInputs() {
    return this.__CACHE.__TX.ins.map((input) => ({
      hash: cloneBuffer(input.hash),
      index: input.index,
      sequence: input.sequence
    }));
  }
  get txOutputs() {
    return this.__CACHE.__TX.outs.map((output) => {
      let address;
      try {
        address = fromOutputScript(output.script, this.opts.network);
      } catch (_) {
      }
      return {
        script: cloneBuffer(output.script),
        value: output.value,
        address
      };
    });
  }
  static fromBase64(data, opts = {}) {
    const buffer = Buffer$1.from(data, "base64");
    return this.fromBuffer(buffer, opts);
  }
  static fromHex(data, opts = {}) {
    const buffer = Buffer$1.from(data, "hex");
    return this.fromBuffer(buffer, opts);
  }
  static fromBuffer(buffer, opts = {}) {
    const psbtBase = psbtExports.Psbt.fromBuffer(buffer, transactionFromBuffer);
    const psbt = new Psbt(opts, psbtBase);
    checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);
    return psbt;
  }
  combine(...those) {
    this.data.combine(...those.map((o) => o.data));
    return this;
  }
  clone() {
    const clonedOpts = JSON.parse(JSON.stringify(this.opts));
    return Psbt.fromBuffer(this.data.toBuffer(), clonedOpts);
  }
  setMaximumFeeRate(satoshiPerByte) {
    check32Bit(satoshiPerByte);
    this.opts.maximumFeeRate = satoshiPerByte;
  }
  setVersion(version) {
    check32Bit(version);
    checkInputsForPartialSig(this.data.inputs, "setVersion");
    const c = this.__CACHE;
    c.__TX.version = version;
    c.__EXTRACTED_TX = void 0;
    return this;
  }
  setVersionTRUC() {
    return this.setVersion(Transaction.TRUC_VERSION);
  }
  setLocktime(locktime) {
    check32Bit(locktime);
    checkInputsForPartialSig(this.data.inputs, "setLocktime");
    const c = this.__CACHE;
    c.__TX.locktime = locktime;
    c.__EXTRACTED_TX = void 0;
    return this;
  }
  setInputSequence(inputIndex, sequence) {
    check32Bit(sequence);
    checkInputsForPartialSig(this.data.inputs, "setInputSequence");
    const c = this.__CACHE;
    if (c.__TX.ins.length <= inputIndex) {
      throw new Error("Input index too high");
    }
    c.__TX.ins[inputIndex].sequence = sequence;
    c.__EXTRACTED_TX = void 0;
    return this;
  }
  addInputs(inputDatas, checkPartialSigs = true) {
    inputDatas.forEach((inputData) => this.addInput(inputData, checkPartialSigs));
    return this;
  }
  addInput(inputData, checkPartialSigs = true) {
    if (!inputData || inputData.hash === void 0 || inputData.index === void 0) {
      throw new Error(`Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]`);
    }
    checkTaprootInputFields(inputData, inputData, "addInput");
    if (checkPartialSigs) {
      checkInputsForPartialSig(this.data.inputs, "addInput");
    }
    if (inputData.witnessScript)
      checkInvalidP2WSH(inputData.witnessScript);
    const c = this.__CACHE;
    this.data.addInput(inputData);
    const txIn = c.__TX.ins[c.__TX.ins.length - 1];
    checkTxInputCache(c, txIn);
    const inputIndex = this.data.inputs.length - 1;
    const input = this.data.inputs[inputIndex];
    if (input.nonWitnessUtxo) {
      addNonWitnessTxCache(this.__CACHE, input, inputIndex);
    }
    c.__FEE = void 0;
    c.__FEE_RATE = void 0;
    c.__EXTRACTED_TX = void 0;
    return this;
  }
  addOutputs(outputDatas) {
    outputDatas.forEach((outputData) => this.addOutput(outputData));
    return this;
  }
  addOutput(outputData) {
    const hasAddress = "address" in outputData;
    const hasScript = "script" in outputData;
    if (arguments.length > 1 || !outputData || outputData.value === void 0 || !hasAddress && !hasScript) {
      throw new Error(`Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]`);
    }
    checkInputsForPartialSig(this.data.inputs, "addOutput");
    if (hasAddress) {
      const { address } = outputData;
      const { network } = this.opts;
      const script = toOutputScript(address, network);
      outputData = Object.assign({}, outputData, { script });
    }
    checkTaprootOutputFields(outputData, outputData, "addOutput");
    const c = this.__CACHE;
    this.data.addOutput(outputData);
    c.__FEE = void 0;
    c.__FEE_RATE = void 0;
    c.__EXTRACTED_TX = void 0;
    return this;
  }
  extractTransaction(disableFeeCheck, disableOutputChecks) {
    if (disableOutputChecks) {
      this.data.inputs = this.data.inputs.filter((i) => !i.partialSig);
    }
    if (!this.data.inputs.every(isFinalized))
      throw new Error("Not finalized");
    const c = this.__CACHE;
    if (!disableFeeCheck) {
      checkFees(this, c, this.opts);
    }
    if (c.__EXTRACTED_TX)
      return c.__EXTRACTED_TX;
    const tx = c.__TX.clone();
    inputFinalizeGetAmts(this.data.inputs, tx, c, true, disableOutputChecks);
    return tx;
  }
  getFeeRate(disableOutputChecks = false) {
    return getTxCacheValue("__FEE_RATE", "fee rate", this.data.inputs, this.__CACHE, disableOutputChecks);
  }
  getFee(disableOutputChecks = false) {
    return getTxCacheValue("__FEE", "fee", this.data.inputs, this.__CACHE, disableOutputChecks);
  }
  finalizeAllInputs() {
    utilsExports.checkForInput(this.data.inputs, 0);
    range$1(this.data.inputs.length).forEach((idx) => this.finalizeInput(idx));
    return this;
  }
  finalizeInput(inputIndex, finalScriptsFunc, canRunChecks) {
    const input = utilsExports.checkForInput(this.data.inputs, inputIndex);
    if (isTaprootInput$1(input)) {
      return this._finalizeTaprootInput(inputIndex, input, void 0, finalScriptsFunc);
    }
    return this._finalizeInput(inputIndex, input, finalScriptsFunc, canRunChecks ?? true);
  }
  finalizeTaprootInput(inputIndex, tapLeafHashToFinalize, finalScriptsFunc = tapScriptFinalizer) {
    const input = utilsExports.checkForInput(this.data.inputs, inputIndex);
    if (isTaprootInput$1(input))
      return this._finalizeTaprootInput(inputIndex, input, tapLeafHashToFinalize, finalScriptsFunc);
    throw new Error(`Cannot finalize input #${inputIndex}. Not Taproot.`);
  }
  getInputType(inputIndex) {
    const input = utilsExports.checkForInput(this.data.inputs, inputIndex);
    const script = getScriptFromUtxo(inputIndex, input, this.__CACHE);
    const result = getMeaningfulScript(script, inputIndex, "input", input.redeemScript || redeemFromFinalScriptSig(input.finalScriptSig), input.witnessScript || redeemFromFinalWitnessScript(input.finalScriptWitness));
    const type = result.type === "raw" ? "" : result.type + "-";
    const mainType = classifyScript(result.meaningfulScript);
    return type + mainType;
  }
  inputHasPubkey(inputIndex, pubkey) {
    const input = utilsExports.checkForInput(this.data.inputs, inputIndex);
    return pubkeyInInput(pubkey, input, inputIndex, this.__CACHE);
  }
  inputHasHDKey(inputIndex, root) {
    const input = utilsExports.checkForInput(this.data.inputs, inputIndex);
    const derivationIsMine = bip32DerivationIsMine(root);
    return !!input.bip32Derivation && input.bip32Derivation.some(derivationIsMine);
  }
  outputHasPubkey(outputIndex, pubkey) {
    const output = utilsExports.checkForOutput(this.data.outputs, outputIndex);
    return pubkeyInOutput(pubkey, output, outputIndex, this.__CACHE);
  }
  outputHasHDKey(outputIndex, root) {
    const output = utilsExports.checkForOutput(this.data.outputs, outputIndex);
    const derivationIsMine = bip32DerivationIsMine(root);
    return !!output.bip32Derivation && output.bip32Derivation.some(derivationIsMine);
  }
  validateSignaturesOfAllInputs(validator) {
    utilsExports.checkForInput(this.data.inputs, 0);
    const results = range$1(this.data.inputs.length).map((idx) => this.validateSignaturesOfInput(idx, validator));
    return results.reduce((final, res) => res && final, true);
  }
  validateSignaturesOfInput(inputIndex, validator, pubkey) {
    const input = this.data.inputs[inputIndex];
    if (isTaprootInput$1(input))
      return this.validateSignaturesOfTaprootInput(inputIndex, validator, pubkey);
    return this._validateSignaturesOfInput(inputIndex, validator, pubkey);
  }
  signAllInputsHD(hdKeyPair, sighashTypes = [Transaction.SIGHASH_ALL]) {
    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
      throw new Error("Need HDSigner to sign input");
    }
    const results = [];
    for (const i of range$1(this.data.inputs.length)) {
      try {
        this.signInputHD(i, hdKeyPair, sighashTypes);
        results.push(true);
      } catch (err) {
        results.push(false);
      }
    }
    if (results.every((v) => !v)) {
      throw new Error("No inputs were signed");
    }
    return this;
  }
  signAllInputsHDAsync(hdKeyPair, sighashTypes = [Transaction.SIGHASH_ALL]) {
    return new Promise((resolve, reject) => {
      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
        return reject(new Error("Need HDSigner to sign input"));
      }
      const results = [];
      const promises = [];
      for (const i of range$1(this.data.inputs.length)) {
        promises.push(this.signInputHDAsync(i, hdKeyPair, sighashTypes).then(() => {
          results.push(true);
        }, () => {
          results.push(false);
        }));
      }
      return Promise.all(promises).then(() => {
        if (results.every((v) => !v)) {
          return reject(new Error("No inputs were signed"));
        }
        resolve();
      });
    });
  }
  signInputHD(inputIndex, hdKeyPair, sighashTypes = [Transaction.SIGHASH_ALL]) {
    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
      throw new Error("Need HDSigner to sign input");
    }
    const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
    signers.forEach((signer) => this.signInput(inputIndex, signer, sighashTypes));
    return this;
  }
  signInputHDAsync(inputIndex, hdKeyPair, sighashTypes = [Transaction.SIGHASH_ALL]) {
    return new Promise((resolve, reject) => {
      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
        return reject(new Error("Need HDSigner to sign input"));
      }
      const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
      const promises = signers.map((signer) => this.signInputAsync(inputIndex, signer, sighashTypes));
      return Promise.all(promises).then(() => {
        resolve();
      }).catch(reject);
    });
  }
  signAllInputs(keyPair, sighashTypes) {
    if (!keyPair || !keyPair.publicKey)
      throw new Error("Need Signer to sign input");
    const results = [];
    for (const i of range$1(this.data.inputs.length)) {
      try {
        this.signInput(i, keyPair, sighashTypes);
        results.push(true);
      } catch (err) {
        results.push(false);
      }
    }
    if (results.every((v) => !v)) {
      throw new Error("No inputs were signed");
    }
    return this;
  }
  signAllInputsAsync(keyPair, sighashTypes) {
    return new Promise((resolve, reject) => {
      if (!keyPair || !keyPair.publicKey)
        return reject(new Error("Need Signer to sign input"));
      const results = [];
      const promises = [];
      for (const [i] of this.data.inputs.entries()) {
        promises.push(this.signInputAsync(i, keyPair, sighashTypes).then(() => {
          results.push(true);
        }, () => {
          results.push(false);
        }));
      }
      return Promise.all(promises).then(() => {
        if (results.every((v) => !v)) {
          return reject(new Error("No inputs were signed"));
        }
        resolve();
      });
    });
  }
  signInput(inputIndex, keyPair, sighashTypes) {
    if (!keyPair || !keyPair.publicKey) {
      throw new Error("Need Signer to sign input");
    }
    const input = utilsExports.checkForInput(this.data.inputs, inputIndex);
    if (isTaprootInput$1(input)) {
      return this._signTaprootInput(inputIndex, input, keyPair, void 0, sighashTypes);
    }
    return this._signInput(inputIndex, keyPair, sighashTypes);
  }
  signTaprootInput(inputIndex, keyPair, tapLeafHashToSign, sighashTypes) {
    if (!keyPair || !keyPair.publicKey) {
      throw new Error("Need Signer to sign input");
    }
    const input = utilsExports.checkForInput(this.data.inputs, inputIndex);
    if (isTaprootInput$1(input)) {
      return this._signTaprootInput(inputIndex, input, keyPair, tapLeafHashToSign, sighashTypes);
    }
    throw new Error(`Input #${inputIndex} is not of type Taproot.`);
  }
  signInputAsync(inputIndex, keyPair, sighashTypes) {
    return Promise.resolve().then(() => {
      if (!keyPair || !keyPair.publicKey)
        throw new Error("Need Signer to sign input");
      const input = utilsExports.checkForInput(this.data.inputs, inputIndex);
      if (isTaprootInput$1(input))
        return this._signTaprootInputAsync(inputIndex, input, keyPair, void 0, sighashTypes);
      return this._signInputAsync(inputIndex, keyPair, sighashTypes);
    });
  }
  signTaprootInputAsync(inputIndex, keyPair, tapLeafHash, sighashTypes) {
    return Promise.resolve().then(() => {
      if (!keyPair || !keyPair.publicKey)
        throw new Error("Need Signer to sign input");
      const input = utilsExports.checkForInput(this.data.inputs, inputIndex);
      if (isTaprootInput$1(input))
        return this._signTaprootInputAsync(inputIndex, input, keyPair, tapLeafHash, sighashTypes);
      throw new Error(`Input #${inputIndex} is not of type Taproot.`);
    });
  }
  toBuffer() {
    checkCache(this.__CACHE);
    return this.data.toBuffer();
  }
  toHex() {
    checkCache(this.__CACHE);
    return this.data.toHex();
  }
  toBase64() {
    checkCache(this.__CACHE);
    return this.data.toBase64();
  }
  updateGlobal(updateData) {
    this.data.updateGlobal(updateData);
    return this;
  }
  updateInput(inputIndex, updateData) {
    if (updateData.witnessScript)
      checkInvalidP2WSH(updateData.witnessScript);
    checkTaprootInputFields(this.data.inputs[inputIndex], updateData, "updateInput");
    this.data.updateInput(inputIndex, updateData);
    if (updateData.nonWitnessUtxo) {
      addNonWitnessTxCache(this.__CACHE, this.data.inputs[inputIndex], inputIndex);
    }
    return this;
  }
  updateOutput(outputIndex, updateData) {
    const outputData = this.data.outputs[outputIndex];
    checkTaprootOutputFields(outputData, updateData, "updateOutput");
    this.data.updateOutput(outputIndex, updateData);
    return this;
  }
  addUnknownKeyValToGlobal(keyVal) {
    this.data.addUnknownKeyValToGlobal(keyVal);
    return this;
  }
  addUnknownKeyValToInput(inputIndex, keyVal) {
    this.data.addUnknownKeyValToInput(inputIndex, keyVal);
    return this;
  }
  addUnknownKeyValToOutput(outputIndex, keyVal) {
    this.data.addUnknownKeyValToOutput(outputIndex, keyVal);
    return this;
  }
  clearFinalizedInput(inputIndex) {
    this.data.clearFinalizedInput(inputIndex);
    return this;
  }
  checkTaprootHashesForSig(inputIndex, input, keyPair, tapLeafHashToSign, allowedSighashTypes) {
    if (typeof keyPair.signSchnorr !== "function")
      throw new Error(`Need Schnorr Signer to sign taproot input #${inputIndex}.`);
    const pubkey = Buffer$1.isBuffer(keyPair.publicKey) ? keyPair.publicKey : Buffer$1.from(keyPair.publicKey);
    const hashesForSig = getTaprootHashesForSig(inputIndex, input, this.data.inputs, pubkey, this.__CACHE, tapLeafHashToSign, allowedSighashTypes);
    if (!hashesForSig || !hashesForSig.length)
      throw new Error(`Can not sign for input #${inputIndex} with the key ${pubkey.toString("hex")}`);
    return hashesForSig;
  }
  _finalizeInput(inputIndex, input, finalScriptsFunc = getFinalScripts, canRunChecks = true) {
    const { script, isP2SH, isP2WSH, isSegwit } = getScriptFromInput(inputIndex, input, this.__CACHE);
    if (!script)
      throw new Error(`No script found for input #${inputIndex}`);
    checkPartialSigSighashes(input);
    const { finalScriptSig, finalScriptWitness } = finalScriptsFunc(inputIndex, input, script, isSegwit, isP2SH, isP2WSH, canRunChecks);
    if (finalScriptSig)
      this.data.updateInput(inputIndex, { finalScriptSig });
    if (finalScriptWitness)
      this.data.updateInput(inputIndex, { finalScriptWitness });
    if (!finalScriptSig && !finalScriptWitness)
      throw new Error(`Unknown error finalizing input #${inputIndex}`);
    this.data.clearFinalizedInput(inputIndex);
    return this;
  }
  _finalizeTaprootInput(inputIndex, input, tapLeafHashToFinalize, finalScriptsFunc = tapScriptFinalizer) {
    if (!input.witnessUtxo)
      throw new Error(`Cannot finalize input #${inputIndex}. Missing witness utxo.`);
    if (input.tapKeySig) {
      const payment = p2tr({
        output: input.witnessUtxo.script,
        signature: input.tapKeySig
      });
      if (!payment.witness)
        throw new Error("Cannot finalize taproot key spend");
      const finalScriptWitness = witnessStackToScriptWitness$1(payment.witness);
      this.data.updateInput(inputIndex, { finalScriptWitness });
    } else {
      const { finalScriptWitness } = finalScriptsFunc(inputIndex, input, tapLeafHashToFinalize);
      this.data.updateInput(inputIndex, { finalScriptWitness });
    }
    this.data.clearFinalizedInput(inputIndex);
    return this;
  }
  _validateSignaturesOfInput(inputIndex, validator, pubkey) {
    const input = this.data.inputs[inputIndex];
    const partialSig = (input || {}).partialSig;
    if (!input || !partialSig || partialSig.length < 1)
      throw new Error("No signatures to validate");
    if (typeof validator !== "function")
      throw new Error("Need validator function to validate signatures");
    const mySigs = pubkey ? partialSig.filter((sig) => sig.pubkey.equals(pubkey)) : partialSig;
    if (mySigs.length < 1)
      throw new Error("No signatures for this pubkey");
    const results = [];
    let hashCache;
    let scriptCache;
    let sighashCache;
    for (const pSig of mySigs) {
      const sig = signature.decode(pSig.signature);
      const { hash, script: script$1 } = sighashCache !== sig.hashType || !hashCache || !scriptCache ? getHashForSig(inputIndex, Object.assign({}, input, {
        sighashType: sig.hashType
      }), this.__CACHE, true) : { hash: hashCache, script: scriptCache };
      sighashCache = sig.hashType;
      hashCache = hash;
      scriptCache = script$1;
      checkScriptForPubkey(pSig.pubkey, script$1, "verify");
      results.push(validator(pSig.pubkey, hash, sig.signature));
    }
    return results.every((res) => res);
  }
  validateSignaturesOfTaprootInput(inputIndex, validator, pubkey) {
    const input = this.data.inputs[inputIndex];
    const tapKeySig = (input || {}).tapKeySig;
    const tapScriptSig = (input || {}).tapScriptSig;
    if (!input && !tapKeySig && !(tapScriptSig && !tapScriptSig.length))
      throw new Error("No signatures to validate");
    if (typeof validator !== "function")
      throw new Error("Need validator function to validate signatures");
    pubkey = pubkey && toXOnly(pubkey);
    const allHashses = pubkey ? getTaprootHashesForSig(inputIndex, input, this.data.inputs, pubkey, this.__CACHE) : getAllTaprootHashesForSig(inputIndex, input, this.data.inputs, this.__CACHE);
    if (!allHashses.length)
      throw new Error("No signatures for this pubkey");
    const tapKeyHash = allHashses.find((h) => !h.leafHash);
    let validationResultCount = 0;
    if (tapKeySig && tapKeyHash) {
      const isValidTapkeySig = validator(tapKeyHash.pubkey, tapKeyHash.hash, trimTaprootSig(tapKeySig));
      if (!isValidTapkeySig)
        return false;
      validationResultCount++;
    }
    if (tapScriptSig) {
      for (const tapSig of tapScriptSig) {
        const tapSigHash = allHashses.find((h) => tapSig.pubkey.equals(h.pubkey));
        if (tapSigHash) {
          const isValidTapScriptSig = validator(tapSig.pubkey, tapSigHash.hash, trimTaprootSig(tapSig.signature));
          if (!isValidTapScriptSig)
            return false;
          validationResultCount++;
        }
      }
    }
    return validationResultCount > 0;
  }
  _signInput(inputIndex, keyPair, sighashTypes = [Transaction.SIGHASH_ALL]) {
    const pubkey = Buffer$1.isBuffer(keyPair.publicKey) ? keyPair.publicKey : Buffer$1.from(keyPair.publicKey);
    const { hash, sighashType } = getHashAndSighashType(this.data.inputs, inputIndex, pubkey, this.__CACHE, sighashTypes);
    const sig = keyPair.sign(hash);
    const partialSig = [
      {
        pubkey,
        signature: signature.encode(Buffer$1.isBuffer(sig) ? sig : Buffer$1.from(sig), sighashType)
      }
    ];
    this.data.updateInput(inputIndex, { partialSig });
    return this;
  }
  _signTaprootInput(inputIndex, input, keyPair, tapLeafHashToSign, allowedSighashTypes = [Transaction.SIGHASH_DEFAULT]) {
    const pubkey = Buffer$1.isBuffer(keyPair.publicKey) ? keyPair.publicKey : Buffer$1.from(keyPair.publicKey);
    const hashesForSig = this.checkTaprootHashesForSig(inputIndex, input, keyPair, tapLeafHashToSign, allowedSighashTypes);
    const signSchnorr = keyPair.signSchnorr.bind(keyPair);
    const toBuffer = (data) => Buffer$1.isBuffer(data) ? data : Buffer$1.from(data);
    const tapKeySig = hashesForSig.filter((h) => !h.leafHash).map((h) => serializeTaprootSignature(toBuffer(signSchnorr(h.hash)), input.sighashType))[0];
    const tapScriptSig = hashesForSig.filter((h) => !!h.leafHash).map((h) => ({
      pubkey: toXOnly(pubkey),
      signature: serializeTaprootSignature(toBuffer(signSchnorr(h.hash)), input.sighashType),
      leafHash: h.leafHash
    }));
    if (tapKeySig) {
      this.data.updateInput(inputIndex, { tapKeySig });
    }
    if (tapScriptSig.length) {
      this.data.updateInput(inputIndex, { tapScriptSig });
    }
    return this;
  }
  _signInputAsync(inputIndex, keyPair, sighashTypes = [Transaction.SIGHASH_ALL]) {
    const pubkey = Buffer$1.isBuffer(keyPair.publicKey) ? keyPair.publicKey : Buffer$1.from(keyPair.publicKey);
    const { hash, sighashType } = getHashAndSighashType(this.data.inputs, inputIndex, pubkey, this.__CACHE, sighashTypes);
    return Promise.resolve(keyPair.sign(hash)).then((signature$1) => {
      const sig = Buffer$1.isBuffer(signature$1) ? signature$1 : Buffer$1.from(signature$1);
      const partialSig = [
        {
          pubkey,
          signature: signature.encode(sig, sighashType)
        }
      ];
      this.data.updateInput(inputIndex, { partialSig });
    });
  }
  async _signTaprootInputAsync(inputIndex, input, keyPair, tapLeafHash, sighashTypes = [Transaction.SIGHASH_DEFAULT]) {
    const pubkey = Buffer$1.isBuffer(keyPair.publicKey) ? keyPair.publicKey : Buffer$1.from(keyPair.publicKey);
    const hashesForSig = this.checkTaprootHashesForSig(inputIndex, input, keyPair, tapLeafHash, sighashTypes);
    const signSchnorr = keyPair.signSchnorr.bind(keyPair);
    const toBuffer = (data) => Buffer$1.isBuffer(data) ? data : Buffer$1.from(data);
    const signaturePromises = [];
    const tapKeyHash = hashesForSig.filter((h) => !h.leafHash)[0];
    if (tapKeyHash) {
      const tapKeySigPromise = Promise.resolve(signSchnorr(tapKeyHash.hash)).then((sig) => {
        return {
          tapKeySig: serializeTaprootSignature(toBuffer(sig), input.sighashType)
        };
      });
      signaturePromises.push(tapKeySigPromise);
    }
    const tapScriptHashes = hashesForSig.filter((h) => !!h.leafHash);
    if (tapScriptHashes.length) {
      const tapScriptSigPromises = tapScriptHashes.map(async (tsh) => {
        const signature = await signSchnorr(tsh.hash);
        const tapScriptSig = [
          {
            pubkey: toXOnly(pubkey),
            signature: serializeTaprootSignature(toBuffer(signature), input.sighashType),
            leafHash: tsh.leafHash
          }
        ];
        return { tapScriptSig };
      });
      signaturePromises.push(...tapScriptSigPromises);
    }
    const results = await Promise.all(signaturePromises);
    for (const v of results) {
      this.data.updateInput(inputIndex, v);
    }
  }
}
const transactionFromBuffer = (buffer) => new PsbtTransaction(buffer);
class PsbtTransaction {
  constructor(buffer = Buffer$1.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {
    this.tx = Transaction.fromBuffer(buffer);
    checkTxEmpty(this.tx);
    Object.defineProperty(this, "tx", {
      enumerable: false,
      writable: true
    });
  }
  getInputOutputCounts() {
    return {
      inputCount: this.tx.ins.length,
      outputCount: this.tx.outs.length
    };
  }
  addInput(input) {
    if (input.hash === void 0 || input.index === void 0 || !Buffer$1.isBuffer(input.hash) && typeof input.hash !== "string" || typeof input.index !== "number") {
      throw new Error("Error adding input.");
    }
    const hash = typeof input.hash === "string" ? reverseBuffer(Buffer$1.from(input.hash, "hex")) : input.hash;
    this.tx.addInput(hash, input.index, input.sequence);
  }
  addOutput(output) {
    if (output.script === void 0 || output.value === void 0 || !Buffer$1.isBuffer(output.script) || typeof output.value !== "number") {
      throw new Error("Error adding output.");
    }
    this.tx.addOutput(output.script, output.value);
  }
  toBuffer() {
    return this.tx.toBuffer();
  }
}
function canFinalize(input, script, scriptType) {
  switch (scriptType) {
    case "pubkey":
    case "pubkeyhash":
    case "witnesspubkeyhash":
      return hasSigs(1, input.partialSig);
    case "multisig": {
      const p2ms$1 = p2ms({
        output: script
      });
      return hasSigs(p2ms$1.m, input.partialSig, p2ms$1.pubkeys);
    }
    case "nonstandard":
      return true;
    default:
      return false;
  }
}
function checkCache(cache) {
  if (cache.__UNSAFE_SIGN_NONSEGWIT) {
    throw new Error("Not BIP174 compliant, can not export");
  }
}
function hasSigs(neededSigs, partialSig, pubkeys) {
  if (!partialSig)
    return false;
  let sigs;
  if (pubkeys) {
    sigs = pubkeys.map((pkey) => {
      const pubkey = compressPubkey(pkey);
      return partialSig.find((pSig) => pSig.pubkey.equals(pubkey));
    }).filter((v) => !!v);
  } else {
    sigs = partialSig;
  }
  if (sigs.length > neededSigs)
    throw new Error("Too many signatures");
  return sigs.length === neededSigs;
}
function isFinalized(input) {
  return !!input.finalScriptSig || !!input.finalScriptWitness;
}
function bip32DerivationIsMine(root) {
  return (d) => {
    const fingerprint = Buffer$1.isBuffer(root.fingerprint) ? root.fingerprint : Buffer$1.from(root.fingerprint);
    if (!d.masterFingerprint.equals(fingerprint))
      return false;
    const derivedPubkey = root.derivePath(d.path).publicKey;
    const pubkey = Buffer$1.isBuffer(derivedPubkey) ? derivedPubkey : Buffer$1.from(derivedPubkey);
    if (!pubkey.equals(d.pubkey))
      return false;
    return true;
  };
}
function check32Bit(num) {
  if (typeof num !== "number" || num !== Math.floor(num) || num > 4294967295 || num < 0) {
    throw new Error("Invalid 32 bit integer");
  }
}
function checkFees(psbt, cache, opts) {
  const feeRate = cache.__FEE_RATE || psbt.getFeeRate();
  const vsize = cache.__EXTRACTED_TX.virtualSize();
  const satoshis = feeRate * vsize;
  if (feeRate >= opts.maximumFeeRate) {
    throw new Error(`Warning: You are paying around ${(satoshis / 1e8).toFixed(8)} in fees, which is ${feeRate} satoshi per byte for a transaction with a VSize of ${vsize} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`);
  }
}
function checkInputsForPartialSig(inputs, action) {
  inputs.forEach((input) => {
    const throws = isTaprootInput$1(input) ? checkTaprootInputForSigs(input, action) : checkInputForSig(input, action);
    if (throws)
      throw new Error("Can not modify transaction, signatures exist.");
  });
}
function checkPartialSigSighashes(input) {
  if (!input.sighashType || !input.partialSig)
    return;
  const { partialSig, sighashType } = input;
  partialSig.forEach((pSig) => {
    const { hashType } = signature.decode(pSig.signature);
    if (sighashType !== hashType) {
      throw new Error("Signature sighash does not match input sighash type");
    }
  });
}
function checkScriptForPubkey(pubkey, script, action) {
  if (!pubkeyInScript$1(pubkey, script)) {
    throw new Error(`Can not ${action} for this input with the key ${pubkey.toString("hex")}`);
  }
}
function checkTxEmpty(tx) {
  const isEmpty = tx.ins.every((input) => input.script && input.script.length === 0 && input.witness && input.witness.length === 0);
  if (!isEmpty) {
    throw new Error("Format Error: Transaction ScriptSigs are not empty");
  }
}
function checkTxForDupeIns(tx, cache) {
  tx.ins.forEach((input) => {
    checkTxInputCache(cache, input);
  });
}
function checkTxInputCache(cache, input) {
  const key = `${reverseBuffer(Buffer$1.from(input.hash)).toString("hex")}:${input.index}`;
  if (cache.__TX_IN_CACHE[key])
    throw new Error("Duplicate input detected.");
  cache.__TX_IN_CACHE[key] = 1;
}
function scriptCheckerFactory(payment, paymentScriptName) {
  return (inputIndex, scriptPubKey, redeemScript, ioType) => {
    const redeemScriptOutput = payment({
      redeem: { output: redeemScript }
    }).output;
    if (!scriptPubKey.equals(redeemScriptOutput)) {
      throw new Error(`${paymentScriptName} for ${ioType} #${inputIndex} doesn't match the scriptPubKey in the prevout`);
    }
  };
}
const checkRedeemScript = scriptCheckerFactory(p2sh, "Redeem script");
const checkWitnessScript = scriptCheckerFactory(p2wsh, "Witness script");
function getTxCacheValue(key, name, inputs, c, disableOutputChecks = false) {
  if (!inputs.every(isFinalized))
    throw new Error(`PSBT must be finalized to calculate ${name}`);
  if (key === "__FEE_RATE" && c.__FEE_RATE)
    return c.__FEE_RATE;
  if (key === "__FEE" && c.__FEE)
    return c.__FEE;
  let tx;
  let mustFinalize = true;
  if (c.__EXTRACTED_TX) {
    tx = c.__EXTRACTED_TX;
    mustFinalize = false;
  } else {
    tx = c.__TX.clone();
  }
  inputFinalizeGetAmts(inputs, tx, c, mustFinalize, disableOutputChecks);
  const value = key === "__FEE_RATE" ? c.__FEE_RATE : c.__FEE;
  if (value === void 0)
    throw new Error(`Failed to calculate ${name}`);
  return value;
}
function getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH, canRunChecks = true, solution) {
  const scriptType = classifyScript(script);
  if (!canFinalize(input, script, scriptType) && canRunChecks) {
    throw new Error(`Can not finalize input #${inputIndex}`);
  }
  return prepareFinalScripts(script, scriptType, input.partialSig, isSegwit, isP2SH, isP2WSH, solution);
}
function prepareFinalScripts(script, scriptType, partialSig, isSegwit, isP2SH, isP2WSH, solution) {
  let finalScriptSig;
  let finalScriptWitness;
  const payment = getPayment(script, scriptType, partialSig);
  const p2wsh$1 = !isP2WSH ? null : p2wsh({ redeem: payment });
  const p2sh$1 = !isP2SH ? null : p2sh({ redeem: p2wsh$1 || payment });
  if (isSegwit) {
    if (p2wsh$1) {
      finalScriptWitness = witnessStackToScriptWitness$1(p2wsh$1.witness);
    } else if (payment) {
      finalScriptWitness = witnessStackToScriptWitness$1(payment.witness);
    } else {
      finalScriptWitness = witnessStackToScriptWitness$1(solution ?? [Buffer$1.from([0])]);
    }
    if (p2sh$1) {
      finalScriptSig = p2sh$1?.input;
    }
  } else {
    if (p2sh$1) {
      finalScriptSig = p2sh$1?.input;
    } else {
      if (!payment) {
        finalScriptSig = Array.isArray(solution) && solution[0] ? solution[0] : Buffer$1.from([1]);
      } else {
        finalScriptSig = payment.input;
      }
    }
  }
  return {
    finalScriptSig,
    finalScriptWitness
  };
}
function getHashAndSighashType(inputs, inputIndex, pubkey, cache, sighashTypes) {
  const input = utilsExports.checkForInput(inputs, inputIndex);
  const { hash, sighashType, script } = getHashForSig(inputIndex, input, cache, false, sighashTypes);
  checkScriptForPubkey(pubkey, script, "sign");
  return {
    hash,
    sighashType
  };
}
function getHashForSig(inputIndex, input, cache, forValidate, sighashTypes) {
  const unsignedTx = cache.__TX;
  const sighashType = input.sighashType || Transaction.SIGHASH_ALL;
  checkSighashTypeAllowed(sighashType, sighashTypes);
  let hash;
  let prevout;
  if (input.nonWitnessUtxo) {
    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(cache, input, inputIndex);
    const prevoutHash = unsignedTx.ins[inputIndex].hash;
    const utxoHash = nonWitnessUtxoTx.getHash();
    if (!prevoutHash.equals(utxoHash)) {
      throw new Error(`Non-witness UTXO hash for input #${inputIndex} doesn't match the hash specified in the prevout`);
    }
    const prevoutIndex = unsignedTx.ins[inputIndex].index;
    prevout = nonWitnessUtxoTx.outs[prevoutIndex];
  } else if (input.witnessUtxo) {
    prevout = input.witnessUtxo;
  } else {
    throw new Error("Need a Utxo input item for signing");
  }
  const { meaningfulScript, type } = getMeaningfulScript(prevout.script, inputIndex, "input", input.redeemScript, input.witnessScript);
  if (["p2sh-p2wsh", "p2wsh"].indexOf(type) >= 0) {
    hash = unsignedTx.hashForWitnessV0(inputIndex, meaningfulScript, prevout.value, sighashType);
  } else if (isP2WPKH(meaningfulScript)) {
    const signingScript = p2pkh({
      hash: meaningfulScript.subarray(2)
    }).output;
    hash = unsignedTx.hashForWitnessV0(inputIndex, signingScript, prevout.value, sighashType);
  } else {
    if (input.nonWitnessUtxo === void 0 && !cache.__UNSAFE_SIGN_NONSEGWIT)
      throw new Error(`Input #${inputIndex} has witnessUtxo but non-segwit script: ` + meaningfulScript.toString("hex"));
    if (!forValidate && cache.__UNSAFE_SIGN_NONSEGWIT)
      console.warn("Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as Psbt's predecessor (TransactionBuilder - now removed) when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.\n*********************\nPROCEED WITH CAUTION!\n*********************");
    hash = unsignedTx.hashForSignature(inputIndex, meaningfulScript, sighashType);
  }
  return {
    script: meaningfulScript,
    sighashType,
    hash
  };
}
function getAllTaprootHashesForSig(inputIndex, input, inputs, cache) {
  const allPublicKeys = [];
  if (input.tapInternalKey) {
    const key = getPrevoutTaprootKey(inputIndex, input, cache);
    if (key) {
      allPublicKeys.push(key);
    }
  }
  if (input.tapScriptSig) {
    const tapScriptPubkeys = input.tapScriptSig.map((tss) => tss.pubkey);
    allPublicKeys.push(...tapScriptPubkeys);
  }
  const allHashes = allPublicKeys.map((pubicKey) => getTaprootHashesForSig(inputIndex, input, inputs, pubicKey, cache));
  return allHashes.flat();
}
function getPrevoutTaprootKey(inputIndex, input, cache) {
  const { script } = getScriptAndAmountFromUtxo(inputIndex, input, cache);
  return isP2TR(script) ? Buffer$1.from(script.subarray(2, 34)) : null;
}
function trimTaprootSig(signature) {
  return signature.length === 64 ? signature : Buffer$1.from(signature.subarray(0, 64));
}
function getTaprootHashesForSig(inputIndex, input, inputs, pubkey, cache, tapLeafHashToSign, allowedSighashTypes) {
  const unsignedTx = cache.__TX;
  const sighashType = input.sighashType || Transaction.SIGHASH_DEFAULT;
  checkSighashTypeAllowed(sighashType, allowedSighashTypes);
  const prevOuts = inputs.map((i, index) => getScriptAndAmountFromUtxo(index, i, cache));
  const signingScripts = prevOuts.map((o) => o.script);
  const values = prevOuts.map((o) => o.value);
  const hashes = [];
  if (input.tapInternalKey && !tapLeafHashToSign) {
    const outputKey = getPrevoutTaprootKey(inputIndex, input, cache) || Buffer$1.from([]);
    if (toXOnly(pubkey).equals(outputKey)) {
      const tapKeyHash = unsignedTx.hashForWitnessV1(inputIndex, signingScripts, values, sighashType);
      hashes.push({ pubkey, hash: tapKeyHash });
    }
  }
  const tapLeafHashes = (input.tapLeafScript || []).filter((tapLeaf) => pubkeyInScript$1(pubkey, tapLeaf.script)).map((tapLeaf) => {
    const hash = tapleafHash({
      output: tapLeaf.script,
      version: tapLeaf.leafVersion
    });
    return Object.assign({ hash }, tapLeaf);
  }).filter((tapLeaf) => !tapLeafHashToSign || tapLeafHashToSign.equals(tapLeaf.hash)).map((tapLeaf) => {
    const tapScriptHash = unsignedTx.hashForWitnessV1(inputIndex, signingScripts, values, sighashType, tapLeaf.hash);
    return {
      pubkey,
      hash: tapScriptHash,
      leafHash: tapLeaf.hash
    };
  });
  return hashes.concat(tapLeafHashes);
}
function checkSighashTypeAllowed(sighashType, sighashTypes) {
  if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {
    const str = sighashTypeToString(sighashType);
    throw new Error(`Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${str}`);
  }
}
function getPayment(script, scriptType, partialSig) {
  let payment;
  switch (scriptType) {
    case "multisig": {
      const sigs = getSortedSigs(script, partialSig);
      payment = p2ms({
        output: script,
        signatures: sigs
      });
      break;
    }
    case "pubkey":
      payment = p2pk({
        output: script,
        signature: partialSig[0].signature
      });
      break;
    case "pubkeyhash":
      payment = p2pkh({
        output: script,
        pubkey: partialSig[0].pubkey,
        signature: partialSig[0].signature
      });
      break;
    case "witnesspubkeyhash":
      payment = p2wpkh({
        output: script,
        pubkey: partialSig[0].pubkey,
        signature: partialSig[0].signature
      });
      break;
  }
  return payment;
}
function getScriptFromInput(inputIndex, input, cache) {
  const unsignedTx = cache.__TX;
  const res = {
    script: null,
    isSegwit: false,
    isP2SH: false,
    isP2WSH: false
  };
  res.isP2SH = !!input.redeemScript;
  res.isP2WSH = !!input.witnessScript;
  if (input.witnessScript) {
    res.script = input.witnessScript;
  } else if (input.redeemScript) {
    res.script = input.redeemScript;
  } else {
    if (input.nonWitnessUtxo) {
      const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(cache, input, inputIndex);
      const prevoutIndex = unsignedTx.ins[inputIndex].index;
      res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;
    } else if (input.witnessUtxo) {
      res.script = input.witnessUtxo.script;
    }
  }
  if (input.witnessScript || isP2WPKH(res.script)) {
    res.isSegwit = true;
  } else {
    try {
      const output = res.script;
      if (!output)
        throw new TypeError("Invalid script for segwit address");
      res.isSegwit = isUnknownSegwitVersion(output);
    } catch (e) {
    }
  }
  return res;
}
function getSignersFromHD(inputIndex, inputs, hdKeyPair) {
  const input = utilsExports.checkForInput(inputs, inputIndex);
  if (!input.bip32Derivation || input.bip32Derivation.length === 0) {
    throw new Error("Need bip32Derivation to sign with HD");
  }
  const myDerivations = input.bip32Derivation.map((bipDv) => {
    if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {
      return bipDv;
    } else {
      return;
    }
  }).filter((v) => !!v);
  if (myDerivations.length === 0) {
    throw new Error("Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint");
  }
  return myDerivations.map((bipDv) => {
    const node = hdKeyPair.derivePath(bipDv.path);
    if (!bipDv.pubkey.equals(node.publicKey)) {
      throw new Error("pubkey did not match bip32Derivation");
    }
    return node;
  });
}
function getSortedSigs(script, partialSig) {
  const p2ms$1 = p2ms({ output: script });
  return p2ms$1.pubkeys.map((pk) => {
    return (partialSig.filter((ps) => {
      return ps.pubkey.equals(pk);
    })[0] || {}).signature;
  }).filter((v) => !!v);
}
function scriptWitnessToWitnessStack(buffer) {
  let offset = 0;
  function readSlice(n) {
    offset += n;
    return buffer.subarray(offset - n, offset);
  }
  function readVarInt() {
    const vi = varuintDecode(buffer, offset);
    offset += varuintDecode.bytes;
    return vi;
  }
  function readVarSlice() {
    return readSlice(readVarInt());
  }
  function readVector() {
    const count = readVarInt();
    const vector = [];
    for (let i = 0; i < count; i++)
      vector.push(readVarSlice());
    return vector;
  }
  return readVector();
}
function sighashTypeToString(sighashType) {
  let text = sighashType & Transaction.SIGHASH_ANYONECANPAY ? "SIGHASH_ANYONECANPAY | " : "";
  const sigMod = sighashType & 31;
  switch (sigMod) {
    case Transaction.SIGHASH_ALL:
      text += "SIGHASH_ALL";
      break;
    case Transaction.SIGHASH_SINGLE:
      text += "SIGHASH_SINGLE";
      break;
    case Transaction.SIGHASH_NONE:
      text += "SIGHASH_NONE";
      break;
  }
  return text;
}
function addNonWitnessTxCache(cache, input, inputIndex) {
  cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;
  cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = Transaction.fromBuffer(input.nonWitnessUtxo);
  const self = cache;
  const selfIndex = inputIndex;
  delete input.nonWitnessUtxo;
  Object.defineProperty(input, "nonWitnessUtxo", {
    enumerable: true,
    get() {
      const buf = self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];
      const txCache = self.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];
      if (buf !== void 0) {
        return buf;
      } else {
        const newBuf = txCache.toBuffer();
        self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;
        return newBuf;
      }
    },
    set(data) {
      self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;
    }
  });
}
function inputFinalizeGetAmts(inputs, tx, cache, mustFinalize, disableOutputChecks) {
  let inputAmount = 0;
  inputs.forEach((input, idx) => {
    if (mustFinalize && input.finalScriptSig)
      tx.ins[idx].script = input.finalScriptSig;
    if (mustFinalize && input.finalScriptWitness) {
      tx.ins[idx].witness = scriptWitnessToWitnessStack(input.finalScriptWitness);
    }
    if (input.witnessUtxo) {
      inputAmount += input.witnessUtxo.value;
    } else if (input.nonWitnessUtxo) {
      const nwTx = nonWitnessUtxoTxFromCache(cache, input, idx);
      const vout = tx.ins[idx].index;
      const out = nwTx.outs[vout];
      inputAmount += out.value;
    }
  });
  const outputAmount = tx.outs.reduce((total, o) => total + o.value, 0);
  const fee = inputAmount - outputAmount;
  if (!disableOutputChecks) {
    if (fee < 0) {
      throw new Error(`Outputs are spending more than Inputs ${inputAmount} < ${outputAmount}`);
    }
  }
  const bytes = tx.virtualSize();
  cache.__FEE = fee;
  cache.__EXTRACTED_TX = tx;
  cache.__FEE_RATE = Math.floor(fee / bytes);
}
function nonWitnessUtxoTxFromCache(cache, input, inputIndex) {
  const c = cache.__NON_WITNESS_UTXO_TX_CACHE;
  if (!c[inputIndex]) {
    addNonWitnessTxCache(cache, input, inputIndex);
  }
  return c[inputIndex];
}
function getScriptFromUtxo(inputIndex, input, cache) {
  const { script } = getScriptAndAmountFromUtxo(inputIndex, input, cache);
  return script;
}
function getScriptAndAmountFromUtxo(inputIndex, input, cache) {
  if (input.witnessUtxo !== void 0) {
    return {
      script: input.witnessUtxo.script,
      value: input.witnessUtxo.value
    };
  } else if (input.nonWitnessUtxo !== void 0) {
    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(cache, input, inputIndex);
    const o = nonWitnessUtxoTx.outs[cache.__TX.ins[inputIndex].index];
    return { script: o.script, value: o.value };
  } else {
    throw new Error("Can't find pubkey in input without Utxo data");
  }
}
function pubkeyInInput(pubkey, input, inputIndex, cache) {
  const script = getScriptFromUtxo(inputIndex, input, cache);
  const { meaningfulScript } = getMeaningfulScript(script, inputIndex, "input", input.redeemScript, input.witnessScript);
  return pubkeyInScript$1(pubkey, meaningfulScript);
}
function pubkeyInOutput(pubkey, output, outputIndex, cache) {
  const script = cache.__TX.outs[outputIndex].script;
  const { meaningfulScript } = getMeaningfulScript(script, outputIndex, "output", output.redeemScript, output.witnessScript);
  return pubkeyInScript$1(pubkey, meaningfulScript);
}
function redeemFromFinalScriptSig(finalScript) {
  if (!finalScript)
    return;
  const decomp = decompile(finalScript);
  if (!decomp)
    return;
  const lastItem = decomp[decomp.length - 1];
  if (!Buffer$1.isBuffer(lastItem) || isPubkeyLike(lastItem) || isSigLike(lastItem))
    return;
  const sDecomp = decompile(lastItem);
  if (!sDecomp)
    return;
  return lastItem;
}
function redeemFromFinalWitnessScript(finalScript) {
  if (!finalScript)
    return;
  const decomp = scriptWitnessToWitnessStack(finalScript);
  const lastItem = decomp[decomp.length - 1];
  if (isPubkeyLike(lastItem))
    return;
  const sDecomp = decompile(lastItem);
  if (!sDecomp)
    return;
  return lastItem;
}
function compressPubkey(pubkey) {
  if (pubkey.length === 65) {
    const parity = pubkey[64] & 1;
    const newKey = Buffer$1.from(pubkey.subarray(0, 33));
    newKey[0] = 2 | parity;
    return newKey;
  }
  return Buffer$1.from(pubkey);
}
function isPubkeyLike(buf) {
  return buf.length === 33 && isCanonicalPubKey(buf);
}
function isSigLike(buf) {
  return isCanonicalScriptSignature(buf);
}
function getMeaningfulScript(script, index, ioType, redeemScript, witnessScript) {
  const isP2SH = isP2SHScript(script);
  const isP2SHP2WSH = isP2SH && redeemScript && isP2WSHScript(redeemScript);
  const isP2WSH = isP2WSHScript(script);
  if (isP2SH && redeemScript === void 0)
    throw new Error("scriptPubkey is P2SH but redeemScript missing");
  if ((isP2WSH || isP2SHP2WSH) && witnessScript === void 0)
    throw new Error("scriptPubkey or redeemScript is P2WSH but witnessScript missing");
  let meaningfulScript;
  if (isP2SHP2WSH) {
    meaningfulScript = witnessScript;
    checkRedeemScript(index, script, redeemScript, ioType);
    checkWitnessScript(index, redeemScript, witnessScript, ioType);
    checkInvalidP2WSH(meaningfulScript);
  } else if (isP2WSH) {
    meaningfulScript = witnessScript;
    checkWitnessScript(index, script, witnessScript, ioType);
    checkInvalidP2WSH(meaningfulScript);
  } else if (isP2SH) {
    meaningfulScript = redeemScript;
    checkRedeemScript(index, script, redeemScript, ioType);
  } else {
    meaningfulScript = script;
  }
  return {
    meaningfulScript,
    type: isP2SHP2WSH ? "p2sh-p2wsh" : isP2SH ? "p2sh" : isP2WSH ? "p2wsh" : "raw"
  };
}
function checkInvalidP2WSH(script) {
  if (isP2WPKH(script) || isP2SHScript(script)) {
    throw new Error("P2WPKH or P2SH can not be contained within P2WSH");
  }
}
function classifyScript(script) {
  if (isP2WPKH(script))
    return "witnesspubkeyhash";
  if (isP2PKH(script))
    return "pubkeyhash";
  if (isP2MS(script))
    return "multisig";
  if (isP2PK(script))
    return "pubkey";
  return "nonstandard";
}
function range$1(n) {
  return [...Array(n).keys()];
}

const bitcoin = {
    payments,
    script,
    crypto: crypto$3};

var dist$1 = {};

var hasRequiredDist$1;

function requireDist$1 () {
	if (hasRequiredDist$1) return dist$1;
	hasRequiredDist$1 = 1;

	var secp256k1 = /*@__PURE__*/ requireSecp256k1();
	var mod = /*@__PURE__*/ requireModular();
	var utils = /*@__PURE__*/ requireUtils$1();

	function _interopNamespaceDefault(e) {
	  var n = Object.create(null);
	  if (e) {
	    Object.keys(e).forEach(function (k) {
	      if (k !== 'default') {
	        var d = Object.getOwnPropertyDescriptor(e, k);
	        Object.defineProperty(n, k, d.get ? d : {
	          enumerable: true,
	          get: function () { return e[k]; }
	        });
	      }
	    });
	  }
	  n.default = e;
	  return Object.freeze(n);
	}

	var mod__namespace = /*#__PURE__*/_interopNamespaceDefault(mod);
	var utils__namespace = /*#__PURE__*/_interopNamespaceDefault(utils);

	/*
	 * Copyright (c) 2023 Jose-Luis Landabaso
	 * Distributed under the MIT software license.
	 *
	 * This file includes code from the following sources:
	 *  * Paul Miller's @noble/secp256k1 (specifically, the privateAdd,
	 *    privateNegate, pointAddScalar, and pointMultiply functions).
	 *  * Some pieces from tiny-secp256k1
	 *    (https://github.com/bitcoinjs/tiny-secp256k1)
	 *  * It also uses code from BitGo's BitGoJS library
	 *    (https://github.com/BitGo/BitGoJS)
	 *
	 * This package's tests are based on modified versions of tests from
	 * tiny-secp256k1 (https://github.com/bitcoinjs/tiny-secp256k1/tests).
	 */

	const Point = secp256k1.secp256k1.ProjectivePoint;

	const THROW_BAD_PRIVATE = "Expected Private";
	const THROW_BAD_POINT = "Expected Point";
	const THROW_BAD_TWEAK = "Expected Tweak";
	const THROW_BAD_HASH = "Expected Hash";
	const THROW_BAD_SIGNATURE = "Expected Signature";
	const THROW_BAD_EXTRA_DATA = "Expected Extra Data (32 bytes)";
	const THROW_BAD_SCALAR = "Expected Scalar";
	const THROW_BAD_RECOVERY_ID = "Bad Recovery Id";

	const HASH_SIZE = 32;
	const TWEAK_SIZE = 32;
	const BN32_N = new Uint8Array([
	  255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
	  254, 186, 174, 220, 230, 175, 72, 160, 59, 191, 210, 94, 140, 208, 54, 65, 65,
	]);
	const EXTRA_DATA_SIZE = 32;
	const BN32_ZERO = new Uint8Array(32);
	const BN32_P_MINUS_N = new Uint8Array([
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 69, 81, 35, 25, 80, 183, 95,
	  196, 64, 45, 161, 114, 47, 201, 186, 238,
	]);
	const _1n = BigInt(1);

	function isUint8Array(value) {
	  return value instanceof Uint8Array;
	}

	function cmpBN32(data1, data2) {
	  for (let i = 0; i < 32; ++i) {
	    if (data1[i] !== data2[i]) {
	      return data1[i] < data2[i] ? -1 : 1;
	    }
	  }
	  return 0;
	}

	function isZero(x) {
	  return cmpBN32(x, BN32_ZERO) === 0;
	}

	function isTweak(tweak) {
	  if (
	    !(tweak instanceof Uint8Array) ||
	    tweak.length !== TWEAK_SIZE ||
	    cmpBN32(tweak, BN32_N) >= 0
	  ) {
	    return false;
	  }
	  return true;
	}

	function isSignature(signature) {
	  return (
	    signature instanceof Uint8Array &&
	    signature.length === 64 &&
	    cmpBN32(signature.subarray(0, 32), BN32_N) < 0 &&
	    cmpBN32(signature.subarray(32, 64), BN32_N) < 0
	  );
	}

	function isSigrLessThanPMinusN(signature) {
	  return (
	    isUint8Array(signature) &&
	    signature.length === 64 &&
	    cmpBN32(signature.subarray(0, 32), BN32_P_MINUS_N) < 0
	  );
	}

	function isSignatureNonzeroRS(signature) {
	  return !(
	    isZero(signature.subarray(0, 32)) || isZero(signature.subarray(32, 64))
	  );
	}

	function isHash(h) {
	  return h instanceof Uint8Array && h.length === HASH_SIZE;
	}

	function isExtraData(e) {
	  return (
	    e === undefined || (e instanceof Uint8Array && e.length === EXTRA_DATA_SIZE)
	  );
	}

	function normalizeScalar(scalar) {
	  let num;
	  if (typeof scalar === "bigint") {
	    num = scalar;
	  } else if (
	    typeof scalar === "number" &&
	    Number.isSafeInteger(scalar) &&
	    scalar >= 0
	  ) {
	    num = BigInt(scalar);
	  } else if (typeof scalar === "string") {
	    if (scalar.length !== 64)
	      throw new Error("Expected 32 bytes of private scalar");
	    num = utils__namespace.hexToNumber(scalar);
	  } else if (scalar instanceof Uint8Array) {
	    if (scalar.length !== 32)
	      throw new Error("Expected 32 bytes of private scalar");
	    num = utils__namespace.bytesToNumberBE(scalar);
	  } else {
	    throw new TypeError("Expected valid private scalar");
	  }
	  if (num < 0) throw new Error("Expected private scalar >= 0");
	  return num;
	}

	function normalizePrivateKey(privateKey) {
	  return secp256k1.secp256k1.utils.normPrivateKeyToScalar(privateKey);
	}

	function _privateAdd(privateKey, tweak) {
	  const p = normalizePrivateKey(privateKey);
	  const t = normalizeScalar(tweak);
	  const add = utils__namespace.numberToBytesBE(mod__namespace.mod(p + t, secp256k1.secp256k1.CURVE.n), 32);
	  return secp256k1.secp256k1.utils.isValidPrivateKey(add) ? add : null;
	}

	function _privateSub(privateKey, tweak) {
	  const p = normalizePrivateKey(privateKey);
	  const t = normalizeScalar(tweak);
	  const sub = utils__namespace.numberToBytesBE(mod__namespace.mod(p - t, secp256k1.secp256k1.CURVE.n), 32);
	  return secp256k1.secp256k1.utils.isValidPrivateKey(sub) ? sub : null;
	}

	function _privateNegate(privateKey) {
	  const p = normalizePrivateKey(privateKey);
	  const not = utils__namespace.numberToBytesBE(secp256k1.secp256k1.CURVE.n - p, 32);
	  return secp256k1.secp256k1.utils.isValidPrivateKey(not) ? not : null;
	}

	function _pointAddScalar(p, tweak, isCompressed) {
	  const P = fromHex(p);
	  const t = normalizeScalar(tweak);
	  // multiplyAndAddUnsafe(P, scalar, 1) = P + scalar*G
	  const Q = Point.BASE.multiplyAndAddUnsafe(P, t, _1n);
	  if (!Q) throw new Error("Tweaked point at infinity");
	  return Q.toRawBytes(isCompressed);
	}

	function _pointMultiply(p, tweak, isCompressed) {
	  const P = fromHex(p);
	  const h = typeof tweak === "string" ? tweak : utils__namespace.bytesToHex(tweak);
	  const t = utils__namespace.hexToNumber(h);
	  return P.multiply(t).toRawBytes(isCompressed);
	}

	function assumeCompression(compressed, p) {
	  if (compressed === undefined) {
	    return p !== undefined ? isPointCompressed(p) : true;
	  }
	  return !!compressed;
	}

	function throwToNull(fn) {
	  try {
	    return fn();
	  } catch (e) {
	    return null;
	  }
	}

	function fromXOnly(bytes) {
	  return secp256k1.schnorr.utils.lift_x(utils__namespace.bytesToNumberBE(bytes));
	}

	function fromHex(bytes) {
	  return bytes.length === 32 ? fromXOnly(bytes) : Point.fromHex(bytes);
	}

	function _isPoint(p, xOnly) {
	  if ((p.length === 32) !== xOnly) return false;
	  try {
	    if (xOnly) return !!fromXOnly(p);
	    else return !!Point.fromHex(p);
	  } catch (e) {
	    return false;
	  }
	}

	function isPoint(p) {
	  return _isPoint(p, false);
	}

	function isPointCompressed(p) {
	  const PUBLIC_KEY_COMPRESSED_SIZE = 33;
	  return _isPoint(p, false) && p.length === PUBLIC_KEY_COMPRESSED_SIZE;
	}

	function isPrivate(d) {
	  return secp256k1.secp256k1.utils.isValidPrivateKey(d);
	}

	function isXOnlyPoint(p) {
	  return _isPoint(p, true);
	}

	function xOnlyPointAddTweak(p, tweak) {
	  if (!isXOnlyPoint(p)) {
	    throw new Error(THROW_BAD_POINT);
	  }
	  if (!isTweak(tweak)) {
	    throw new Error(THROW_BAD_TWEAK);
	  }
	  return throwToNull(() => {
	    const P = _pointAddScalar(p, tweak, true);
	    const parity = P[0] % 2 === 1 ? 1 : 0;
	    return { parity, xOnlyPubkey: P.slice(1) };
	  });
	}

	function xOnlyPointFromPoint(p) {
	  if (!isPoint(p)) {
	    throw new Error(THROW_BAD_POINT);
	  }
	  return p.slice(1, 33);
	}

	function pointFromScalar(sk, compressed) {
	  if (!isPrivate(sk)) {
	    throw new Error(THROW_BAD_PRIVATE);
	  }
	  return throwToNull(() =>
	    secp256k1.secp256k1.getPublicKey(sk, assumeCompression(compressed)),
	  );
	}

	function xOnlyPointFromScalar(d) {
	  if (!isPrivate(d)) {
	    throw new Error(THROW_BAD_PRIVATE);
	  }
	  return xOnlyPointFromPoint(pointFromScalar(d));
	}

	function pointCompress(p, compressed) {
	  if (!isPoint(p)) {
	    throw new Error(THROW_BAD_POINT);
	  }
	  return fromHex(p).toRawBytes(assumeCompression(compressed, p));
	}

	function pointMultiply(a, tweak, compressed) {
	  if (!isPoint(a)) {
	    throw new Error(THROW_BAD_POINT);
	  }
	  if (!isTweak(tweak)) {
	    throw new Error(THROW_BAD_TWEAK);
	  }
	  return throwToNull(() =>
	    _pointMultiply(a, tweak, assumeCompression(compressed, a)),
	  );
	}

	function pointAdd(a, b, compressed) {
	  if (!isPoint(a) || !isPoint(b)) {
	    throw new Error(THROW_BAD_POINT);
	  }
	  return throwToNull(() => {
	    const A = fromHex(a);
	    const B = fromHex(b);
	    if (A.equals(B.negate())) {
	      return null;
	    } else {
	      return A.add(B).toRawBytes(assumeCompression(compressed, a));
	    }
	  });
	}

	function pointAddScalar(p, tweak, compressed) {
	  if (!isPoint(p)) {
	    throw new Error(THROW_BAD_POINT);
	  }
	  if (!isTweak(tweak)) {
	    throw new Error(THROW_BAD_TWEAK);
	  }
	  return throwToNull(() =>
	    _pointAddScalar(p, tweak, assumeCompression(compressed, p)),
	  );
	}

	function privateAdd(d, tweak) {
	  if (!isPrivate(d)) {
	    throw new Error(THROW_BAD_PRIVATE);
	  }
	  if (!isTweak(tweak)) {
	    throw new Error(THROW_BAD_TWEAK);
	  }
	  return throwToNull(() => _privateAdd(d, tweak));
	}

	function privateSub(d, tweak) {
	  if (!isPrivate(d)) {
	    throw new Error(THROW_BAD_PRIVATE);
	  }
	  if (!isTweak(tweak)) {
	    throw new Error(THROW_BAD_TWEAK);
	  }
	  return throwToNull(() => _privateSub(d, tweak));
	}

	function privateNegate(d) {
	  if (!isPrivate(d)) {
	    throw new Error(THROW_BAD_PRIVATE);
	  }
	  return _privateNegate(d);
	}

	function sign(h, d, e) {
	  if (!isPrivate(d)) {
	    throw new Error(THROW_BAD_PRIVATE);
	  }
	  if (!isHash(h)) {
	    throw new Error(THROW_BAD_SCALAR);
	  }
	  if (!isExtraData(e)) {
	    throw new Error(THROW_BAD_EXTRA_DATA);
	  }
	  return secp256k1.secp256k1.sign(h, d, { extraEntropy: e }).toCompactRawBytes();
	}

	function signRecoverable(h, d, e) {
	  if (!isPrivate(d)) {
	    throw new Error(THROW_BAD_PRIVATE);
	  }
	  if (!isHash(h)) {
	    throw new Error(THROW_BAD_SCALAR);
	  }
	  if (!isExtraData(e)) {
	    throw new Error(THROW_BAD_EXTRA_DATA);
	  }
	  const sig = secp256k1.secp256k1.sign(h, d, { extraEntropy: e });
	  return {
	    signature: sig.toCompactRawBytes(),
	    recoveryId: sig.recovery,
	  };
	}

	function signSchnorr(h, d, e) {
	  if (!isPrivate(d)) {
	    throw new Error(THROW_BAD_PRIVATE);
	  }
	  if (!isHash(h)) {
	    throw new Error(THROW_BAD_SCALAR);
	  }
	  if (!isExtraData(e)) {
	    throw new Error(THROW_BAD_EXTRA_DATA);
	  }
	  return secp256k1.schnorr.sign(h, d, e);
	}

	function recover(h, signature, recoveryId, compressed) {
	  if (!isHash(h)) {
	    throw new Error(THROW_BAD_HASH);
	  }

	  if (!isSignature(signature) || !isSignatureNonzeroRS(signature)) {
	    throw new Error(THROW_BAD_SIGNATURE);
	  }

	  if (recoveryId & 2) {
	    if (!isSigrLessThanPMinusN(signature))
	      throw new Error(THROW_BAD_RECOVERY_ID);
	  }
	  if (!isXOnlyPoint(signature.subarray(0, 32))) {
	    throw new Error(THROW_BAD_SIGNATURE);
	  }

	  const s =
	    secp256k1.secp256k1.Signature.fromCompact(signature).addRecoveryBit(recoveryId);
	  const Q = s.recoverPublicKey(h);
	  if (!Q) throw new Error(THROW_BAD_SIGNATURE);
	  return Q.toRawBytes(assumeCompression(compressed));
	}

	function verify(h, Q, signature, strict) {
	  if (!isPoint(Q)) {
	    throw new Error(THROW_BAD_POINT);
	  }
	  if (!isSignature(signature)) {
	    throw new Error(THROW_BAD_SIGNATURE);
	  }
	  if (!isHash(h)) {
	    throw new Error(THROW_BAD_SCALAR);
	  }
	  return secp256k1.secp256k1.verify(signature, h, Q, { lowS: strict });
	}

	function verifySchnorr(h, Q, signature) {
	  if (!isXOnlyPoint(Q)) {
	    throw new Error(THROW_BAD_POINT);
	  }
	  if (!isSignature(signature)) {
	    throw new Error(THROW_BAD_SIGNATURE);
	  }
	  if (!isHash(h)) {
	    throw new Error(THROW_BAD_SCALAR);
	  }
	  return secp256k1.schnorr.verify(signature, h, Q);
	}

	dist$1.isPoint = isPoint;
	dist$1.isPointCompressed = isPointCompressed;
	dist$1.isPrivate = isPrivate;
	dist$1.isXOnlyPoint = isXOnlyPoint;
	dist$1.pointAdd = pointAdd;
	dist$1.pointAddScalar = pointAddScalar;
	dist$1.pointCompress = pointCompress;
	dist$1.pointFromScalar = pointFromScalar;
	dist$1.pointMultiply = pointMultiply;
	dist$1.privateAdd = privateAdd;
	dist$1.privateNegate = privateNegate;
	dist$1.privateSub = privateSub;
	dist$1.recover = recover;
	dist$1.sign = sign;
	dist$1.signRecoverable = signRecoverable;
	dist$1.signSchnorr = signSchnorr;
	dist$1.verify = verify;
	dist$1.verifySchnorr = verifySchnorr;
	dist$1.xOnlyPointAddTweak = xOnlyPointAddTweak;
	dist$1.xOnlyPointFromPoint = xOnlyPointFromPoint;
	dist$1.xOnlyPointFromScalar = xOnlyPointFromScalar;
	return dist$1;
}

var distExports = requireDist$1();
const index = /*@__PURE__*/getDefaultExportFromCjs$1(distExports);

const ecc = /*#__PURE__*/_mergeNamespaces({
	__proto__: null,
	default: index
}, [distExports]);

var cjs$4 = {};

var bip32$1 = {};

var crypto$2 = {};

var hasRequiredCrypto;

function requireCrypto () {
	if (hasRequiredCrypto) return crypto$2;
	hasRequiredCrypto = 1;
	Object.defineProperty(crypto$2, "__esModule", { value: true });
	crypto$2.hash160 = hash160;
	crypto$2.hash256 = hash256;
	crypto$2.hmacSHA512 = hmacSHA512;
	const hmac_1 = /*@__PURE__*/ requireHmac();
	const ripemd160_1 = /*@__PURE__*/ requireRipemd160();
	const sha256_1 = /*@__PURE__*/ requireSha256$1();
	const sha512_1 = /*@__PURE__*/ requireSha512$1();
	function hash160(buffer) {
	    return (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(buffer));
	}
	function hash256(buffer) {
	    return (0, sha256_1.sha256)(buffer);
	}
	function hmacSHA512(key, data) {
	    return (0, hmac_1.hmac)(sha512_1.sha512, key, data);
	}
	return crypto$2;
}

var testecc$1 = {};

const HEX_STRINGS = "0123456789abcdefABCDEF";
const HEX_CODES = HEX_STRINGS.split("").map((c) => c.codePointAt(0));
const HEX_CODEPOINTS = Array(256)
    .fill(true)
    .map((_, i) => {
    const s = String.fromCodePoint(i);
    const index = HEX_STRINGS.indexOf(s);
    // ABCDEF will use 10 - 15
    return index < 0 ? undefined : index < 16 ? index : index - 6;
});
const ENCODER = new TextEncoder();
const DECODER = new TextDecoder();
function toUtf8(bytes) {
    return DECODER.decode(bytes);
}
function fromUtf8(s) {
    return ENCODER.encode(s);
}
function concat(arrays) {
    const totalLength = arrays.reduce((a, b) => a + b.length, 0);
    const result = new Uint8Array(totalLength);
    let offset = 0;
    for (const array of arrays) {
        result.set(array, offset);
        offset += array.length;
    }
    return result;
}
// There are two implementations.
// One optimizes for length of the bytes, and uses TextDecoder.
// One optimizes for iteration count, and appends strings.
// This removes the overhead of TextDecoder.
function toHex(bytes) {
    const b = bytes || new Uint8Array();
    return b.length > 512 ? _toHexLengthPerf(b) : _toHexIterPerf(b);
}
function _toHexIterPerf(bytes) {
    let s = "";
    for (let i = 0; i < bytes.length; ++i) {
        s += HEX_STRINGS[HEX_CODEPOINTS[HEX_CODES[bytes[i] >> 4]]];
        s += HEX_STRINGS[HEX_CODEPOINTS[HEX_CODES[bytes[i] & 15]]];
    }
    return s;
}
function _toHexLengthPerf(bytes) {
    const hexBytes = new Uint8Array(bytes.length * 2);
    for (let i = 0; i < bytes.length; ++i) {
        hexBytes[i * 2] = HEX_CODES[bytes[i] >> 4];
        hexBytes[i * 2 + 1] = HEX_CODES[bytes[i] & 15];
    }
    return DECODER.decode(hexBytes);
}
// Mimics Buffer.from(x, 'hex') logic
// Stops on first non-hex string and returns
// https://github.com/nodejs/node/blob/v14.18.1/src/string_bytes.cc#L246-L261
function fromHex(hexString) {
    const hexBytes = ENCODER.encode(hexString || "");
    const resultBytes = new Uint8Array(Math.floor(hexBytes.length / 2));
    let i;
    for (i = 0; i < resultBytes.length; i++) {
        const a = HEX_CODEPOINTS[hexBytes[i * 2]];
        const b = HEX_CODEPOINTS[hexBytes[i * 2 + 1]];
        if (a === undefined || b === undefined) {
            break;
        }
        resultBytes[i] = (a << 4) | b;
    }
    return i === resultBytes.length ? resultBytes : resultBytes.slice(0, i);
}
function toBase64(bytes) {
    return btoa(String.fromCharCode(...bytes));
}
function fromBase64(base64) {
    const binaryString = atob(base64);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes;
}
// Same behavior as Buffer.compare()
function compare$1(v1, v2) {
    const minLength = Math.min(v1.length, v2.length);
    for (let i = 0; i < minLength; ++i) {
        if (v1[i] !== v2[i]) {
            return v1[i] < v2[i] ? -1 : 1;
        }
    }
    return v1.length === v2.length ? 0 : v1.length > v2.length ? 1 : -1;
}
function writeUInt8(buffer, offset, value) {
    if (offset + 1 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    if (value > 0xff) {
        throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xff}. Received ${value}`);
    }
    buffer[offset] = value;
    return offset + 1;
}
function writeUInt16(buffer, offset, value, littleEndian) {
    if (offset + 2 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    littleEndian = littleEndian.toUpperCase();
    if (value > 0xffff) {
        throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffff}. Received ${value}`);
    }
    if (littleEndian === "LE") {
        buffer[offset] = value & 0xff;
        buffer[offset + 1] = (value >> 8) & 0xff;
    }
    else {
        buffer[offset] = (value >> 8) & 0xff;
        buffer[offset + 1] = value & 0xff;
    }
    return offset + 2;
}
function writeUInt32(buffer, offset, value, littleEndian) {
    if (offset + 4 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    littleEndian = littleEndian.toUpperCase();
    if (value > 0xffffffff) {
        throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffffffff}. Received ${value}`);
    }
    if (littleEndian === "LE") {
        buffer[offset] = value & 0xff;
        buffer[offset + 1] = (value >> 8) & 0xff;
        buffer[offset + 2] = (value >> 16) & 0xff;
        buffer[offset + 3] = (value >> 24) & 0xff;
    }
    else {
        buffer[offset] = (value >> 24) & 0xff;
        buffer[offset + 1] = (value >> 16) & 0xff;
        buffer[offset + 2] = (value >> 8) & 0xff;
        buffer[offset + 3] = value & 0xff;
    }
    return offset + 4;
}
function writeUInt64(buffer, offset, value, littleEndian) {
    if (offset + 8 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    littleEndian = littleEndian.toUpperCase();
    if (value > 0xffffffffffffffffn) {
        throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffffffffffffffffn}. Received ${value}`);
    }
    if (littleEndian === "LE") {
        buffer[offset] = Number(value & 0xffn);
        buffer[offset + 1] = Number((value >> 8n) & 0xffn);
        buffer[offset + 2] = Number((value >> 16n) & 0xffn);
        buffer[offset + 3] = Number((value >> 24n) & 0xffn);
        buffer[offset + 4] = Number((value >> 32n) & 0xffn);
        buffer[offset + 5] = Number((value >> 40n) & 0xffn);
        buffer[offset + 6] = Number((value >> 48n) & 0xffn);
        buffer[offset + 7] = Number((value >> 56n) & 0xffn);
    }
    else {
        buffer[offset] = Number((value >> 56n) & 0xffn);
        buffer[offset + 1] = Number((value >> 48n) & 0xffn);
        buffer[offset + 2] = Number((value >> 40n) & 0xffn);
        buffer[offset + 3] = Number((value >> 32n) & 0xffn);
        buffer[offset + 4] = Number((value >> 24n) & 0xffn);
        buffer[offset + 5] = Number((value >> 16n) & 0xffn);
        buffer[offset + 6] = Number((value >> 8n) & 0xffn);
        buffer[offset + 7] = Number(value & 0xffn);
    }
    return offset + 8;
}
function readUInt8(buffer, offset) {
    if (offset + 1 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    return buffer[offset];
}
function readUInt16(buffer, offset, littleEndian) {
    if (offset + 2 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    littleEndian = littleEndian.toUpperCase();
    if (littleEndian === "LE") {
        let num = 0;
        num = (num << 8) + buffer[offset + 1];
        num = (num << 8) + buffer[offset];
        return num;
    }
    else {
        let num = 0;
        num = (num << 8) + buffer[offset];
        num = (num << 8) + buffer[offset + 1];
        return num;
    }
}
function readUInt32(buffer, offset, littleEndian) {
    if (offset + 4 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    littleEndian = littleEndian.toUpperCase();
    if (littleEndian === "LE") {
        let num = 0;
        num = ((num << 8) + buffer[offset + 3]) >>> 0;
        num = ((num << 8) + buffer[offset + 2]) >>> 0;
        num = ((num << 8) + buffer[offset + 1]) >>> 0;
        num = ((num << 8) + buffer[offset]) >>> 0;
        return num;
    }
    else {
        let num = 0;
        num = ((num << 8) + buffer[offset]) >>> 0;
        num = ((num << 8) + buffer[offset + 1]) >>> 0;
        num = ((num << 8) + buffer[offset + 2]) >>> 0;
        num = ((num << 8) + buffer[offset + 3]) >>> 0;
        return num;
    }
}
function readUInt64(buffer, offset, littleEndian) {
    if (offset + 8 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    littleEndian = littleEndian.toUpperCase();
    if (littleEndian === "LE") {
        let num = 0n;
        num = (num << 8n) + BigInt(buffer[offset + 7]);
        num = (num << 8n) + BigInt(buffer[offset + 6]);
        num = (num << 8n) + BigInt(buffer[offset + 5]);
        num = (num << 8n) + BigInt(buffer[offset + 4]);
        num = (num << 8n) + BigInt(buffer[offset + 3]);
        num = (num << 8n) + BigInt(buffer[offset + 2]);
        num = (num << 8n) + BigInt(buffer[offset + 1]);
        num = (num << 8n) + BigInt(buffer[offset]);
        return num;
    }
    else {
        let num = 0n;
        num = (num << 8n) + BigInt(buffer[offset]);
        num = (num << 8n) + BigInt(buffer[offset + 1]);
        num = (num << 8n) + BigInt(buffer[offset + 2]);
        num = (num << 8n) + BigInt(buffer[offset + 3]);
        num = (num << 8n) + BigInt(buffer[offset + 4]);
        num = (num << 8n) + BigInt(buffer[offset + 5]);
        num = (num << 8n) + BigInt(buffer[offset + 6]);
        num = (num << 8n) + BigInt(buffer[offset + 7]);
        return num;
    }
}
function writeInt8(buffer, offset, value) {
    if (offset + 1 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    if (value > 0x7f || value < -128) {
        throw new Error(`The value of "value" is out of range. It must be >= ${ -128} and <= ${0x7f}. Received ${value}`);
    }
    buffer[offset] = value;
    return offset + 1;
}
function writeInt16(buffer, offset, value, littleEndian) {
    if (offset + 2 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    if (value > 0x7fff || value < -32768) {
        throw new Error(`The value of "value" is out of range. It must be >= ${ -32768} and <= ${0x7fff}. Received ${value}`);
    }
    littleEndian = littleEndian.toUpperCase();
    if (littleEndian === "LE") {
        buffer[offset] = value & 0xff;
        buffer[offset + 1] = (value >> 8) & 0xff;
    }
    else {
        buffer[offset] = (value >> 8) & 0xff;
        buffer[offset + 1] = value & 0xff;
    }
    return offset + 2;
}
function writeInt32(buffer, offset, value, littleEndian) {
    if (offset + 4 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    if (value > 0x7fffffff || value < -2147483648) {
        throw new Error(`The value of "value" is out of range. It must be >= ${ -2147483648} and <= ${0x7fffffff}. Received ${value}`);
    }
    littleEndian = littleEndian.toUpperCase();
    if (littleEndian === "LE") {
        buffer[offset] = value & 0xff;
        buffer[offset + 1] = (value >> 8) & 0xff;
        buffer[offset + 2] = (value >> 16) & 0xff;
        buffer[offset + 3] = (value >> 24) & 0xff;
    }
    else {
        buffer[offset] = (value >> 24) & 0xff;
        buffer[offset + 1] = (value >> 16) & 0xff;
        buffer[offset + 2] = (value >> 8) & 0xff;
        buffer[offset + 3] = value & 0xff;
    }
    return offset + 4;
}
function writeInt64(buffer, offset, value, littleEndian) {
    if (offset + 8 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    if (value > 0x7fffffffffffffffn || value < -0x8000000000000000n) {
        throw new Error(`The value of "value" is out of range. It must be >= ${-0x8000000000000000n} and <= ${0x7fffffffffffffffn}. Received ${value}`);
    }
    littleEndian = littleEndian.toUpperCase();
    if (littleEndian === "LE") {
        buffer[offset] = Number(value & 0xffn);
        buffer[offset + 1] = Number((value >> 8n) & 0xffn);
        buffer[offset + 2] = Number((value >> 16n) & 0xffn);
        buffer[offset + 3] = Number((value >> 24n) & 0xffn);
        buffer[offset + 4] = Number((value >> 32n) & 0xffn);
        buffer[offset + 5] = Number((value >> 40n) & 0xffn);
        buffer[offset + 6] = Number((value >> 48n) & 0xffn);
        buffer[offset + 7] = Number((value >> 56n) & 0xffn);
    }
    else {
        buffer[offset] = Number((value >> 56n) & 0xffn);
        buffer[offset + 1] = Number((value >> 48n) & 0xffn);
        buffer[offset + 2] = Number((value >> 40n) & 0xffn);
        buffer[offset + 3] = Number((value >> 32n) & 0xffn);
        buffer[offset + 4] = Number((value >> 24n) & 0xffn);
        buffer[offset + 5] = Number((value >> 16n) & 0xffn);
        buffer[offset + 6] = Number((value >> 8n) & 0xffn);
        buffer[offset + 7] = Number(value & 0xffn);
    }
    return offset + 8;
}
function readInt8(buffer, offset) {
    if (offset + 1 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    const val = buffer[offset];
    if (val <= 0x7f) {
        return val;
    }
    else {
        return val - 0x100;
    }
}
function readInt16(buffer, offset, littleEndian) {
    if (offset + 2 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    littleEndian = littleEndian.toUpperCase();
    if (littleEndian === "LE") {
        const val = buffer[offset] + (buffer[offset + 1] << 8);
        return buffer[offset + 1] <= 0x7f ? val : val - 0x10000;
    }
    else {
        const val = (buffer[offset] << 8) + buffer[offset + 1];
        return buffer[offset] <= 0x7f ? val : val - 0x10000;
    }
}
function readInt32(buffer, offset, littleEndian) {
    if (offset + 4 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    littleEndian = littleEndian.toUpperCase();
    if (littleEndian === "LE") {
        const val = buffer[offset] +
            (buffer[offset + 1] << 8) +
            (buffer[offset + 2] << 16) +
            ((buffer[offset + 3] << 24) >>> 0);
        return buffer[offset + 3] <= 0x7f ? val : val - 0x100000000;
    }
    else {
        const val = ((buffer[offset] << 24) >>> 0) +
            (buffer[offset + 1] << 16) +
            (buffer[offset + 2] << 8) +
            buffer[offset + 3];
        return buffer[offset] <= 0x7f ? val : val - 0x100000000;
    }
}
function readInt64(buffer, offset, littleEndian) {
    if (offset + 8 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    littleEndian = littleEndian.toUpperCase();
    let num = 0n;
    if (littleEndian === "LE") {
        num = (num << 8n) + BigInt(buffer[offset + 7]);
        num = (num << 8n) + BigInt(buffer[offset + 6]);
        num = (num << 8n) + BigInt(buffer[offset + 5]);
        num = (num << 8n) + BigInt(buffer[offset + 4]);
        num = (num << 8n) + BigInt(buffer[offset + 3]);
        num = (num << 8n) + BigInt(buffer[offset + 2]);
        num = (num << 8n) + BigInt(buffer[offset + 1]);
        num = (num << 8n) + BigInt(buffer[offset]);
        return buffer[offset + 7] <= 0x7f ? num : num - 0x10000000000000000n;
    }
    else {
        let num = 0n;
        num = (num << 8n) + BigInt(buffer[offset]);
        num = (num << 8n) + BigInt(buffer[offset + 1]);
        num = (num << 8n) + BigInt(buffer[offset + 2]);
        num = (num << 8n) + BigInt(buffer[offset + 3]);
        num = (num << 8n) + BigInt(buffer[offset + 4]);
        num = (num << 8n) + BigInt(buffer[offset + 5]);
        num = (num << 8n) + BigInt(buffer[offset + 6]);
        num = (num << 8n) + BigInt(buffer[offset + 7]);
        return buffer[offset] <= 0x7f ? num : num - 0x10000000000000000n;
    }
}

const browser$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	compare: compare$1,
	concat,
	fromBase64,
	fromHex,
	fromUtf8,
	readInt16,
	readInt32,
	readInt64,
	readInt8,
	readUInt16,
	readUInt32,
	readUInt64,
	readUInt8,
	toBase64,
	toHex,
	toUtf8,
	writeInt16,
	writeInt32,
	writeInt64,
	writeInt8,
	writeUInt16,
	writeUInt32,
	writeUInt64,
	writeUInt8
}, Symbol.toStringTag, { value: 'Module' }));

const require$$2$1 = /*@__PURE__*/getAugmentedNamespace(browser$1);

var hasRequiredTestecc$1;

function requireTestecc$1 () {
	if (hasRequiredTestecc$1) return testecc$1;
	hasRequiredTestecc$1 = 1;
	var __createBinding = (testecc$1 && testecc$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (testecc$1 && testecc$1.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (testecc$1 && testecc$1.__importStar) || (function () {
	    var ownKeys = function(o) {
	        ownKeys = Object.getOwnPropertyNames || function (o) {
	            var ar = [];
	            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
	            return ar;
	        };
	        return ownKeys(o);
	    };
	    return function (mod) {
	        if (mod && mod.__esModule) return mod;
	        var result = {};
	        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
	        __setModuleDefault(result, mod);
	        return result;
	    };
	})();
	Object.defineProperty(testecc$1, "__esModule", { value: true });
	testecc$1.testEcc = testEcc;
	const tools = __importStar(require$$2$1);
	const h = (hex) => tools.fromHex(hex);
	function testEcc(ecc) {
	    assert(ecc.isPoint(h('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798')));
	    assert(!ecc.isPoint(h('030000000000000000000000000000000000000000000000000000000000000005')));
	    assert(ecc.isPrivate(h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798')));
	    // order - 1
	    assert(ecc.isPrivate(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')));
	    // 0
	    assert(!ecc.isPrivate(h('0000000000000000000000000000000000000000000000000000000000000000')));
	    // order
	    assert(!ecc.isPrivate(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141')));
	    // order + 1
	    assert(!ecc.isPrivate(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142')));
	    assert(tools.compare(ecc.pointFromScalar(h('b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af')), h('02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99')) === 0);
	    if (ecc.xOnlyPointAddTweak) {
	        assert(ecc.xOnlyPointAddTweak(h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'), h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')) === null);
	        let xOnlyRes = ecc.xOnlyPointAddTweak(h('1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b'), h('a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac'));
	        assert(tools.compare(xOnlyRes.xOnlyPubkey, h('e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf')) === 0 && xOnlyRes.parity === 1);
	        xOnlyRes = ecc.xOnlyPointAddTweak(h('2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991'), h('823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47'));
	    }
	    assert(tools.compare(ecc.pointAddScalar(h('0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'), h('0000000000000000000000000000000000000000000000000000000000000003')), h('02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5')) === 0);
	    assert(tools.compare(ecc.privateAdd(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e'), h('0000000000000000000000000000000000000000000000000000000000000002')), h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')) === 0);
	    if (ecc.privateNegate) {
	        assert(tools.compare(ecc.privateNegate(h('0000000000000000000000000000000000000000000000000000000000000001')), h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')) === 0);
	        assert(tools.compare(ecc.privateNegate(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e')), h('0000000000000000000000000000000000000000000000000000000000000003')) === 0);
	        assert(tools.compare(ecc.privateNegate(h('b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af')), h('4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792')) === 0);
	    }
	    assert(tools.compare(ecc.sign(h('5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed'), h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')), h('54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5')) === 0);
	    assert(ecc.verify(h('5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed'), h('0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'), h('54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5')));
	    if (ecc.signSchnorr) {
	        assert(tools.compare(ecc.signSchnorr(h('7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c'), h('c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9'), h('c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906')), h('5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7')) === 0);
	    }
	    if (ecc.verifySchnorr) {
	        assert(ecc.verifySchnorr(h('7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c'), h('dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8'), h('5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7')));
	    }
	}
	function assert(bool) {
	    if (!bool)
	        throw new Error('ecc library invalid');
	}
	return testecc$1;
}

/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function isBytes(a) {
    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');
}
/** Asserts something is Uint8Array. */
function abytes(b) {
    if (!isBytes(b))
        throw new Error('Uint8Array expected');
}
function isArrayOf(isString, arr) {
    if (!Array.isArray(arr))
        return false;
    if (arr.length === 0)
        return true;
    if (isString) {
        return arr.every((item) => typeof item === 'string');
    }
    else {
        return arr.every((item) => Number.isSafeInteger(item));
    }
}
function afn(input) {
    if (typeof input !== 'function')
        throw new Error('function expected');
    return true;
}
function astr(label, input) {
    if (typeof input !== 'string')
        throw new Error(`${label}: string expected`);
    return true;
}
function anumber(n) {
    if (!Number.isSafeInteger(n))
        throw new Error(`invalid integer: ${n}`);
}
function aArr(input) {
    if (!Array.isArray(input))
        throw new Error('array expected');
}
function astrArr(label, input) {
    if (!isArrayOf(true, input))
        throw new Error(`${label}: array of strings expected`);
}
function anumArr(label, input) {
    if (!isArrayOf(false, input))
        throw new Error(`${label}: array of numbers expected`);
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function chain(...args) {
    const id = (a) => a;
    // Wrap call in closure so JIT can inline calls
    const wrap = (a, b) => (c) => a(b(c));
    // Construct chain of args[-1].encode(args[-2].encode([...]))
    const encode = args.map((x) => x.encode).reduceRight(wrap, id);
    // Construct chain of args[0].decode(args[1].decode(...))
    const decode = args.map((x) => x.decode).reduce(wrap, id);
    return { encode, decode };
}
/**
 * Encodes integer radix representation to array of strings using alphabet and back.
 * Could also be array of strings.
 * @__NO_SIDE_EFFECTS__
 */
function alphabet(letters) {
    // mapping 1 to "b"
    const lettersA = typeof letters === 'string' ? letters.split('') : letters;
    const len = lettersA.length;
    astrArr('alphabet', lettersA);
    // mapping "b" to 1
    const indexes = new Map(lettersA.map((l, i) => [l, i]));
    return {
        encode: (digits) => {
            aArr(digits);
            return digits.map((i) => {
                if (!Number.isSafeInteger(i) || i < 0 || i >= len)
                    throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${letters}`);
                return lettersA[i];
            });
        },
        decode: (input) => {
            aArr(input);
            return input.map((letter) => {
                astr('alphabet.decode', letter);
                const i = indexes.get(letter);
                if (i === undefined)
                    throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
                return i;
            });
        },
    };
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function join(separator = '') {
    astr('join', separator);
    return {
        encode: (from) => {
            astrArr('join.decode', from);
            return from.join(separator);
        },
        decode: (to) => {
            astr('join.decode', to);
            return to.split(separator);
        },
    };
}
/**
 * Pad strings array so it has integer number of bits
 * @__NO_SIDE_EFFECTS__
 */
function padding(bits, chr = '=') {
    anumber(bits);
    astr('padding', chr);
    return {
        encode(data) {
            astrArr('padding.encode', data);
            while ((data.length * bits) % 8)
                data.push(chr);
            return data;
        },
        decode(input) {
            astrArr('padding.decode', input);
            let end = input.length;
            if ((end * bits) % 8)
                throw new Error('padding: invalid, string should have whole number of bytes');
            for (; end > 0 && input[end - 1] === chr; end--) {
                const last = end - 1;
                const byte = last * bits;
                if (byte % 8 === 0)
                    throw new Error('padding: invalid, string has too much padding');
            }
            return input.slice(0, end);
        },
    };
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function normalize(fn) {
    afn(fn);
    return { encode: (from) => from, decode: (to) => fn(to) };
}
/**
 * Slow: O(n^2) time complexity
 */
function convertRadix(data, from, to) {
    // base 1 is impossible
    if (from < 2)
        throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);
    if (to < 2)
        throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);
    aArr(data);
    if (!data.length)
        return [];
    let pos = 0;
    const res = [];
    const digits = Array.from(data, (d) => {
        anumber(d);
        if (d < 0 || d >= from)
            throw new Error(`invalid integer: ${d}`);
        return d;
    });
    const dlen = digits.length;
    while (true) {
        let carry = 0;
        let done = true;
        for (let i = pos; i < dlen; i++) {
            const digit = digits[i];
            const fromCarry = from * carry;
            const digitBase = fromCarry + digit;
            if (!Number.isSafeInteger(digitBase) ||
                fromCarry / from !== carry ||
                digitBase - digit !== fromCarry) {
                throw new Error('convertRadix: carry overflow');
            }
            const div = digitBase / to;
            carry = digitBase % to;
            const rounded = Math.floor(div);
            digits[i] = rounded;
            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
                throw new Error('convertRadix: carry overflow');
            if (!done)
                continue;
            else if (!rounded)
                pos = i;
            else
                done = false;
        }
        res.push(carry);
        if (done)
            break;
    }
    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)
        res.push(0);
    return res.reverse();
}
const gcd = (a, b) => (b === 0 ? a : gcd(b, a % b));
const radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));
const powers = /* @__PURE__ */ (() => {
    let res = [];
    for (let i = 0; i < 40; i++)
        res.push(2 ** i);
    return res;
})();
/**
 * Implemented with numbers, because BigInt is 5x slower
 */
function convertRadix2(data, from, to, padding) {
    aArr(data);
    if (from <= 0 || from > 32)
        throw new Error(`convertRadix2: wrong from=${from}`);
    if (to <= 0 || to > 32)
        throw new Error(`convertRadix2: wrong to=${to}`);
    if (radix2carry(from, to) > 32) {
        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
    }
    let carry = 0;
    let pos = 0; // bitwise position in current element
    const max = powers[from];
    const mask = powers[to] - 1;
    const res = [];
    for (const n of data) {
        anumber(n);
        if (n >= max)
            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
        carry = (carry << from) | n;
        if (pos + from > 32)
            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
        pos += from;
        for (; pos >= to; pos -= to)
            res.push(((carry >> (pos - to)) & mask) >>> 0);
        const pow = powers[pos];
        if (pow === undefined)
            throw new Error('invalid carry');
        carry &= pow - 1; // clean carry, otherwise it will cause overflow
    }
    carry = (carry << (to - pos)) & mask;
    if (!padding && pos >= from)
        throw new Error('Excess padding');
    if (!padding && carry > 0)
        throw new Error(`Non-zero padding: ${carry}`);
    if (padding && pos > 0)
        res.push(carry >>> 0);
    return res;
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function radix(num) {
    anumber(num);
    const _256 = 2 ** 8;
    return {
        encode: (bytes) => {
            if (!isBytes(bytes))
                throw new Error('radix.encode input should be Uint8Array');
            return convertRadix(Array.from(bytes), _256, num);
        },
        decode: (digits) => {
            anumArr('radix.decode', digits);
            return Uint8Array.from(convertRadix(digits, num, _256));
        },
    };
}
/**
 * If both bases are power of same number (like `2**8 <-> 2**64`),
 * there is a linear algorithm. For now we have implementation for power-of-two bases only.
 * @__NO_SIDE_EFFECTS__
 */
function radix2(bits, revPadding = false) {
    anumber(bits);
    if (bits <= 0 || bits > 32)
        throw new Error('radix2: bits should be in (0..32]');
    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
        throw new Error('radix2: carry overflow');
    return {
        encode: (bytes) => {
            if (!isBytes(bytes))
                throw new Error('radix2.encode input should be Uint8Array');
            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
        },
        decode: (digits) => {
            anumArr('radix2.decode', digits);
            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
        },
    };
}
function unsafeWrapper(fn) {
    afn(fn);
    return function (...args) {
        try {
            return fn.apply(null, args);
        }
        catch (e) { }
    };
}
function checksum(len, fn) {
    anumber(len);
    afn(fn);
    return {
        encode(data) {
            if (!isBytes(data))
                throw new Error('checksum.encode: input should be Uint8Array');
            const sum = fn(data).slice(0, len);
            const res = new Uint8Array(data.length + len);
            res.set(data);
            res.set(sum, data.length);
            return res;
        },
        decode(data) {
            if (!isBytes(data))
                throw new Error('checksum.decode: input should be Uint8Array');
            const payload = data.slice(0, -len);
            const oldChecksum = data.slice(-len);
            const newChecksum = fn(payload).slice(0, len);
            for (let i = 0; i < len; i++)
                if (newChecksum[i] !== oldChecksum[i])
                    throw new Error('Invalid checksum');
            return payload;
        },
    };
}
// prettier-ignore
const utils$1 = {
    alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,
};
// RFC 4648 aka RFC 3548
// ---------------------
/**
 * base16 encoding from RFC 4648.
 * @example
 * ```js
 * base16.encode(Uint8Array.from([0x12, 0xab]));
 * // => '12AB'
 * ```
 */
const base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));
/**
 * base32 encoding from RFC 4648. Has padding.
 * Use `base32nopad` for unpadded version.
 * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.
 * @example
 * ```js
 * base32.encode(Uint8Array.from([0x12, 0xab]));
 * // => 'CKVQ===='
 * base32.decode('CKVQ====');
 * // => Uint8Array.from([0x12, 0xab])
 * ```
 */
const base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));
/**
 * base32 encoding from RFC 4648. No padding.
 * Use `base32` for padded version.
 * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.
 * @example
 * ```js
 * base32nopad.encode(Uint8Array.from([0x12, 0xab]));
 * // => 'CKVQ'
 * base32nopad.decode('CKVQ');
 * // => Uint8Array.from([0x12, 0xab])
 * ```
 */
const base32nopad = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), join(''));
/**
 * base32 encoding from RFC 4648. Padded. Compared to ordinary `base32`, slightly different alphabet.
 * Use `base32hexnopad` for unpadded version.
 * @example
 * ```js
 * base32hex.encode(Uint8Array.from([0x12, 0xab]));
 * // => '2ALG===='
 * base32hex.decode('2ALG====');
 * // => Uint8Array.from([0x12, 0xab])
 * ```
 */
const base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));
/**
 * base32 encoding from RFC 4648. No padding. Compared to ordinary `base32`, slightly different alphabet.
 * Use `base32hex` for padded version.
 * @example
 * ```js
 * base32hexnopad.encode(Uint8Array.from([0x12, 0xab]));
 * // => '2ALG'
 * base32hexnopad.decode('2ALG');
 * // => Uint8Array.from([0x12, 0xab])
 * ```
 */
const base32hexnopad = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), join(''));
/**
 * base32 encoding from RFC 4648. Doug Crockford's version.
 * https://www.crockford.com/base32.html
 * @example
 * ```js
 * base32crockford.encode(Uint8Array.from([0x12, 0xab]));
 * // => '2ANG'
 * base32crockford.decode('2ANG');
 * // => Uint8Array.from([0x12, 0xab])
 * ```
 */
const base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));
// Built-in base64 conversion https://caniuse.com/mdn-javascript_builtins_uint8array_frombase64
// prettier-ignore
const hasBase64Builtin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toBase64 === 'function' &&
    typeof Uint8Array.fromBase64 === 'function')();
const decodeBase64Builtin = (s, isUrl) => {
    astr('base64', s);
    const re = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;
    const alphabet = isUrl ? 'base64url' : 'base64';
    if (s.length > 0 && !re.test(s))
        throw new Error('invalid base64');
    return Uint8Array.fromBase64(s, { alphabet, lastChunkHandling: 'strict' });
};
/**
 * base64 from RFC 4648. Padded.
 * Use `base64nopad` for unpadded version.
 * Also check out `base64url`, `base64urlnopad`.
 * Falls back to built-in function, when available.
 * @example
 * ```js
 * base64.encode(Uint8Array.from([0x12, 0xab]));
 * // => 'Eqs='
 * base64.decode('Eqs=');
 * // => Uint8Array.from([0x12, 0xab])
 * ```
 */
// prettier-ignore
const base64 = hasBase64Builtin ? {
    encode(b) { abytes(b); return b.toBase64(); },
    decode(s) { return decodeBase64Builtin(s, false); },
} : chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));
/**
 * base64 from RFC 4648. No padding.
 * Use `base64` for padded version.
 * @example
 * ```js
 * base64nopad.encode(Uint8Array.from([0x12, 0xab]));
 * // => 'Eqs'
 * base64nopad.decode('Eqs');
 * // => Uint8Array.from([0x12, 0xab])
 * ```
 */
const base64nopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), join(''));
/**
 * base64 from RFC 4648, using URL-safe alphabet. Padded.
 * Use `base64urlnopad` for unpadded version.
 * Falls back to built-in function, when available.
 * @example
 * ```js
 * base64url.encode(Uint8Array.from([0x12, 0xab]));
 * // => 'Eqs='
 * base64url.decode('Eqs=');
 * // => Uint8Array.from([0x12, 0xab])
 * ```
 */
// prettier-ignore
const base64url = hasBase64Builtin ? {
    encode(b) { abytes(b); return b.toBase64({ alphabet: 'base64url' }); },
    decode(s) { return decodeBase64Builtin(s, true); },
} : chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));
/**
 * base64 from RFC 4648, using URL-safe alphabet. No padding.
 * Use `base64url` for padded version.
 * @example
 * ```js
 * base64urlnopad.encode(Uint8Array.from([0x12, 0xab]));
 * // => 'Eqs'
 * base64urlnopad.decode('Eqs');
 * // => Uint8Array.from([0x12, 0xab])
 * ```
 */
const base64urlnopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));
// base58 code
// -----------
const genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc) => chain(radix(58), alphabet(abc), join(''));
/**
 * base58: base64 without ambigous characters +, /, 0, O, I, l.
 * Quadratic (O(n^2)) - so, can't be used on large inputs.
 * @example
 * ```js
 * base58.decode('01abcdef');
 * // => '3UhJW'
 * ```
 */
const base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');
/**
 * base58: flickr version. Check out `base58`.
 */
const base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');
/**
 * base58: XRP version. Check out `base58`.
 */
const base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');
// Data len (index) -> encoded block len
const XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];
/**
 * base58: XMR version. Check out `base58`.
 * Done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.
 * Block encoding significantly reduces quadratic complexity of base58.
 */
const base58xmr = {
    encode(data) {
        let res = '';
        for (let i = 0; i < data.length; i += 8) {
            const block = data.subarray(i, i + 8);
            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');
        }
        return res;
    },
    decode(str) {
        let res = [];
        for (let i = 0; i < str.length; i += 11) {
            const slice = str.slice(i, i + 11);
            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);
            const block = base58.decode(slice);
            for (let j = 0; j < block.length - blockLen; j++) {
                if (block[j] !== 0)
                    throw new Error('base58xmr: wrong padding');
            }
            res = res.concat(Array.from(block.slice(block.length - blockLen)));
        }
        return Uint8Array.from(res);
    },
};
/**
 * Method, which creates base58check encoder.
 * Requires function, calculating sha256.
 */
const createBase58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), base58);
/**
 * Use `createBase58check` instead.
 * @deprecated
 */
const base58check = createBase58check;
const BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));
const POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];
function bech32Polymod(pre) {
    const b = pre >> 25;
    let chk = (pre & 0x1ffffff) << 5;
    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {
        if (((b >> i) & 1) === 1)
            chk ^= POLYMOD_GENERATORS[i];
    }
    return chk;
}
function bechChecksum(prefix, words, encodingConst = 1) {
    const len = prefix.length;
    let chk = 1;
    for (let i = 0; i < len; i++) {
        const c = prefix.charCodeAt(i);
        if (c < 33 || c > 126)
            throw new Error(`Invalid prefix (${prefix})`);
        chk = bech32Polymod(chk) ^ (c >> 5);
    }
    chk = bech32Polymod(chk);
    for (let i = 0; i < len; i++)
        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);
    for (let v of words)
        chk = bech32Polymod(chk) ^ v;
    for (let i = 0; i < 6; i++)
        chk = bech32Polymod(chk);
    chk ^= encodingConst;
    return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function genBech32(encoding) {
    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;
    const _words = radix2(5);
    const fromWords = _words.decode;
    const toWords = _words.encode;
    const fromWordsUnsafe = unsafeWrapper(fromWords);
    function encode(prefix, words, limit = 90) {
        astr('bech32.encode prefix', prefix);
        if (isBytes(words))
            words = Array.from(words);
        anumArr('bech32.encode', words);
        const plen = prefix.length;
        if (plen === 0)
            throw new TypeError(`Invalid prefix length ${plen}`);
        const actualLength = plen + 7 + words.length;
        if (limit !== false && actualLength > limit)
            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
        const lowered = prefix.toLowerCase();
        const sum = bechChecksum(lowered, words, ENCODING_CONST);
        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
    }
    function decode(str, limit = 90) {
        astr('bech32.decode input', str);
        const slen = str.length;
        if (slen < 8 || (limit !== false && slen > limit))
            throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);
        // don't allow mixed case
        const lowered = str.toLowerCase();
        if (str !== lowered && str !== str.toUpperCase())
            throw new Error(`String must be lowercase or uppercase`);
        const sepIndex = lowered.lastIndexOf('1');
        if (sepIndex === 0 || sepIndex === -1)
            throw new Error(`Letter "1" must be present between prefix and data only`);
        const prefix = lowered.slice(0, sepIndex);
        const data = lowered.slice(sepIndex + 1);
        if (data.length < 6)
            throw new Error('Data must be at least 6 characters long');
        const words = BECH_ALPHABET.decode(data).slice(0, -6);
        const sum = bechChecksum(prefix, words, ENCODING_CONST);
        if (!data.endsWith(sum))
            throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
        return { prefix, words };
    }
    const decodeUnsafe = unsafeWrapper(decode);
    function decodeToBytes(str) {
        const { prefix, words } = decode(str, false);
        return { prefix, words, bytes: fromWords(words) };
    }
    function encodeFromBytes(prefix, bytes) {
        return encode(prefix, toWords(bytes));
    }
    return {
        encode,
        decode,
        encodeFromBytes,
        decodeToBytes,
        decodeUnsafe,
        fromWords,
        fromWordsUnsafe,
        toWords,
    };
}
/**
 * bech32 from BIP 173. Operates on words.
 * For high-level, check out scure-btc-signer:
 * https://github.com/paulmillr/scure-btc-signer.
 */
const bech32 = genBech32('bech32');
/**
 * bech32m from BIP 350. Operates on words.
 * It was to mitigate `bech32` weaknesses.
 * For high-level, check out scure-btc-signer:
 * https://github.com/paulmillr/scure-btc-signer.
 */
const bech32m = genBech32('bech32m');
/**
 * UTF-8-to-byte decoder. Uses built-in TextDecoder / TextEncoder.
 * @example
 * ```js
 * const b = utf8.decode("hey"); // => new Uint8Array([ 104, 101, 121 ])
 * const str = utf8.encode(b); // "hey"
 * ```
 */
const utf8 = {
    encode: (data) => new TextDecoder().decode(data),
    decode: (str) => new TextEncoder().encode(str),
};
// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex
// prettier-ignore
const hasHexBuiltin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toHex === 'function' &&
    typeof Uint8Array.fromHex === 'function')();
// prettier-ignore
const hexBuiltin = {
    encode(data) { abytes(data); return data.toHex(); },
    decode(s) { astr('hex', s); return Uint8Array.fromHex(s); },
};
/**
 * hex string decoder. Uses built-in function, when available.
 * @example
 * ```js
 * const b = hex.decode("0102ff"); // => new Uint8Array([ 1, 2, 255 ])
 * const str = hex.encode(b); // "0102ff"
 * ```
 */
const hex = hasHexBuiltin
    ? hexBuiltin
    : chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {
        if (typeof s !== 'string' || s.length % 2 !== 0)
            throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
        return s.toLowerCase();
    }));
// prettier-ignore
const CODERS = {
    utf8, hex, base16, base32, base64, base64url, base58, base58xmr
};
const coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';
/** @deprecated */
const bytesToString = (type, bytes) => {
    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))
        throw new TypeError(coderTypeError);
    if (!isBytes(bytes))
        throw new TypeError('bytesToString() expects Uint8Array');
    return CODERS[type].encode(bytes);
};
/** @deprecated */
const str = bytesToString; // as in python, but for bytes only
/** @deprecated */
const stringToBytes = (type, str) => {
    if (!CODERS.hasOwnProperty(type))
        throw new TypeError(coderTypeError);
    if (typeof str !== 'string')
        throw new TypeError('stringToBytes() expects string');
    return CODERS[type].decode(str);
};
/** @deprecated */
const bytes = stringToBytes;

const base$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	base16,
	base32,
	base32crockford,
	base32hex,
	base32hexnopad,
	base32nopad,
	base58,
	base58check,
	base58flickr,
	base58xmr,
	base58xrp,
	base64,
	base64nopad,
	base64url,
	base64urlnopad,
	bech32,
	bech32m,
	bytes,
	bytesToString,
	createBase58check,
	hex,
	str,
	stringToBytes,
	utf8,
	utils: utils$1
}, Symbol.toStringTag, { value: 'Module' }));

const require$$5$1 = /*@__PURE__*/getAugmentedNamespace(base$2);

var types$2 = {};

var hasRequiredTypes$2;

function requireTypes$2 () {
	if (hasRequiredTypes$2) return types$2;
	hasRequiredTypes$2 = 1;
	(function (exports$1) {
		var __createBinding = (types$2 && types$2.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (types$2 && types$2.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (types$2 && types$2.__importStar) || (function () {
		    var ownKeys = function(o) {
		        ownKeys = Object.getOwnPropertyNames || function (o) {
		            var ar = [];
		            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
		            return ar;
		        };
		        return ownKeys(o);
		    };
		    return function (mod) {
		        if (mod && mod.__esModule) return mod;
		        var result = {};
		        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
		        __setModuleDefault(result, mod);
		        return result;
		    };
		})();
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.Bip32PathSchema = exports$1.NetworkSchema = exports$1.Buffer33Bytes = exports$1.Buffer256Bit = exports$1.Uint31Schema = exports$1.Uint32Schema = void 0;
		const v = __importStar(/*@__PURE__*/ requireDist$3());
		exports$1.Uint32Schema = v.pipe(v.number(), v.integer(), v.minValue(0), v.maxValue(0xffffffff));
		exports$1.Uint31Schema = v.pipe(v.number(), v.integer(), v.minValue(0), v.maxValue(0x7fffffff));
		const Uint8Schema = v.pipe(v.number(), v.integer(), v.minValue(0), v.maxValue(0xff));
		exports$1.Buffer256Bit = v.pipe(v.instance(Uint8Array), v.length(32));
		exports$1.Buffer33Bytes = v.pipe(v.instance(Uint8Array), v.length(33));
		const Bip32Schema = v.object({
		    public: exports$1.Uint32Schema,
		    private: exports$1.Uint32Schema,
		});
		exports$1.NetworkSchema = v.object({
		    wif: Uint8Schema,
		    bip32: Bip32Schema,
		    messagePrefix: v.string(),
		    bech32: v.string(),
		    bech32Opnet: v.optional(v.string()),
		    pubKeyHash: Uint8Schema,
		    scriptHash: Uint8Schema,
		});
		exports$1.Bip32PathSchema = v.pipe(v.string(), v.regex(/^(m\/)?(\d+'?\/)*\d+'?$/)); 
	} (types$2));
	return types$2;
}

var cjs$3 = {};

var cjs$2 = {};

var base$1 = {};

var cjs$1 = {};

var cjs = {};

var hasRequiredCjs$4;

function requireCjs$4 () {
	if (hasRequiredCjs$4) return cjs;
	hasRequiredCjs$4 = 1;
	// base-x encoding / decoding
	// Copyright (c) 2018 base-x contributors
	// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
	// Distributed under the MIT software license, see the accompanying
	// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
	Object.defineProperty(cjs, '__esModule', { value: true });
	function base (ALPHABET) {
	  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }
	  const BASE_MAP = new Uint8Array(256);
	  for (let j = 0; j < BASE_MAP.length; j++) {
	    BASE_MAP[j] = 255;
	  }
	  for (let i = 0; i < ALPHABET.length; i++) {
	    const x = ALPHABET.charAt(i);
	    const xc = x.charCodeAt(0);
	    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }
	    BASE_MAP[xc] = i;
	  }
	  const BASE = ALPHABET.length;
	  const LEADER = ALPHABET.charAt(0);
	  const FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up
	  const iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up
	  function encode (source) {
	    // eslint-disable-next-line no-empty
	    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {
	      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
	    } else if (Array.isArray(source)) {
	      source = Uint8Array.from(source);
	    }
	    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }
	    if (source.length === 0) { return '' }
	    // Skip & count leading zeroes.
	    let zeroes = 0;
	    let length = 0;
	    let pbegin = 0;
	    const pend = source.length;
	    while (pbegin !== pend && source[pbegin] === 0) {
	      pbegin++;
	      zeroes++;
	    }
	    // Allocate enough space in big-endian base58 representation.
	    const size = ((pend - pbegin) * iFACTOR + 1) >>> 0;
	    const b58 = new Uint8Array(size);
	    // Process the bytes.
	    while (pbegin !== pend) {
	      let carry = source[pbegin];
	      // Apply "b58 = b58 * 256 + ch".
	      let i = 0;
	      for (let it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
	        carry += (256 * b58[it1]) >>> 0;
	        b58[it1] = (carry % BASE) >>> 0;
	        carry = (carry / BASE) >>> 0;
	      }
	      if (carry !== 0) { throw new Error('Non-zero carry') }
	      length = i;
	      pbegin++;
	    }
	    // Skip leading zeroes in base58 result.
	    let it2 = size - length;
	    while (it2 !== size && b58[it2] === 0) {
	      it2++;
	    }
	    // Translate the result into a string.
	    let str = LEADER.repeat(zeroes);
	    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }
	    return str
	  }
	  function decodeUnsafe (source) {
	    if (typeof source !== 'string') { throw new TypeError('Expected String') }
	    if (source.length === 0) { return new Uint8Array() }
	    let psz = 0;
	    // Skip and count leading '1's.
	    let zeroes = 0;
	    let length = 0;
	    while (source[psz] === LEADER) {
	      zeroes++;
	      psz++;
	    }
	    // Allocate enough space in big-endian base256 representation.
	    const size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.
	    const b256 = new Uint8Array(size);
	    // Process the characters.
	    while (psz < source.length) {
	      // Find code of next character
	      const charCode = source.charCodeAt(psz);
	      // Base map can not be indexed using char code
	      if (charCode > 255) { return }
	      // Decode character
	      let carry = BASE_MAP[charCode];
	      // Invalid character
	      if (carry === 255) { return }
	      let i = 0;
	      for (let it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
	        carry += (BASE * b256[it3]) >>> 0;
	        b256[it3] = (carry % 256) >>> 0;
	        carry = (carry / 256) >>> 0;
	      }
	      if (carry !== 0) { throw new Error('Non-zero carry') }
	      length = i;
	      psz++;
	    }
	    // Skip leading zeroes in b256.
	    let it4 = size - length;
	    while (it4 !== size && b256[it4] === 0) {
	      it4++;
	    }
	    const vch = new Uint8Array(zeroes + (size - it4));
	    let j = zeroes;
	    while (it4 !== size) {
	      vch[j++] = b256[it4++];
	    }
	    return vch
	  }
	  function decode (string) {
	    const buffer = decodeUnsafe(string);
	    if (buffer) { return buffer }
	    throw new Error('Non-base' + BASE + ' character')
	  }
	  return {
	    encode,
	    decodeUnsafe,
	    decode
	  }
	}
	cjs.default = base;
	return cjs;
}

var hasRequiredCjs$3;

function requireCjs$3 () {
	if (hasRequiredCjs$3) return cjs$1;
	hasRequiredCjs$3 = 1;
	var __importDefault = (cjs$1 && cjs$1.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(cjs$1, "__esModule", { value: true });
	var base_x_1 = __importDefault(requireCjs$4());
	var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
	cjs$1.default = (0, base_x_1.default)(ALPHABET);
	return cjs$1;
}

var hasRequiredBase$1;

function requireBase$1 () {
	if (hasRequiredBase$1) return base$1;
	hasRequiredBase$1 = 1;
	var __importDefault = (base$1 && base$1.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(base$1, "__esModule", { value: true });
	base$1.default = default_1;
	var bs58_1 = __importDefault(requireCjs$3());
	function default_1(checksumFn) {
	    // Encode a buffer as a base58-check encoded string
	    function encode(payload) {
	        var payloadU8 = Uint8Array.from(payload);
	        var checksum = checksumFn(payloadU8);
	        var length = payloadU8.length + 4;
	        var both = new Uint8Array(length);
	        both.set(payloadU8, 0);
	        both.set(checksum.subarray(0, 4), payloadU8.length);
	        return bs58_1.default.encode(both);
	    }
	    function decodeRaw(buffer) {
	        var payload = buffer.slice(0, -4);
	        var checksum = buffer.slice(-4);
	        var newChecksum = checksumFn(payload);
	        // eslint-disable-next-line
	        if (checksum[0] ^ newChecksum[0] |
	            checksum[1] ^ newChecksum[1] |
	            checksum[2] ^ newChecksum[2] |
	            checksum[3] ^ newChecksum[3])
	            return;
	        return payload;
	    }
	    // Decode a base58-check encoded string to a buffer, no result if checksum is wrong
	    function decodeUnsafe(str) {
	        var buffer = bs58_1.default.decodeUnsafe(str);
	        if (buffer == null)
	            return;
	        return decodeRaw(buffer);
	    }
	    function decode(str) {
	        var buffer = bs58_1.default.decode(str);
	        var payload = decodeRaw(buffer);
	        if (payload == null)
	            throw new Error('Invalid checksum');
	        return payload;
	    }
	    return {
	        encode: encode,
	        decode: decode,
	        decodeUnsafe: decodeUnsafe
	    };
	}
	return base$1;
}

var hasRequiredCjs$2;

function requireCjs$2 () {
	if (hasRequiredCjs$2) return cjs$2;
	hasRequiredCjs$2 = 1;
	var __importDefault = (cjs$2 && cjs$2.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(cjs$2, "__esModule", { value: true });
	var sha256_1 = /*@__PURE__*/ requireSha256$1();
	var base_js_1 = __importDefault(requireBase$1());
	// SHA256(SHA256(buffer))
	function sha256x2(buffer) {
	    return (0, sha256_1.sha256)((0, sha256_1.sha256)(buffer));
	}
	cjs$2.default = (0, base_js_1.default)(sha256x2);
	return cjs$2;
}

var hasRequiredCjs$1;

function requireCjs$1 () {
	if (hasRequiredCjs$1) return cjs$3;
	hasRequiredCjs$1 = 1;
	var __importDefault = (cjs$3 && cjs$3.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(cjs$3, "__esModule", { value: true });
	cjs$3.encode = cjs$3.decode = cjs$3.encodeRaw = cjs$3.decodeRaw = void 0;
	var bs58check_1 = __importDefault(requireCjs$2());
	function decodeRaw(buffer, version) {
	    // check version only if defined
	    if (version !== undefined && buffer[0] !== version)
	        throw new Error('Invalid network version');
	    // uncompressed
	    if (buffer.length === 33) {
	        return {
	            version: buffer[0],
	            privateKey: buffer.slice(1, 33),
	            compressed: false
	        };
	    }
	    // invalid length
	    if (buffer.length !== 34)
	        throw new Error('Invalid WIF length');
	    // invalid compression flag
	    if (buffer[33] !== 0x01)
	        throw new Error('Invalid compression flag');
	    return {
	        version: buffer[0],
	        privateKey: buffer.slice(1, 33),
	        compressed: true
	    };
	}
	cjs$3.decodeRaw = decodeRaw;
	function encodeRaw(version, privateKey, compressed) {
	    if (privateKey.length !== 32)
	        throw new TypeError('Invalid privateKey length');
	    var result = new Uint8Array(compressed ? 34 : 33);
	    var view = new DataView(result.buffer);
	    view.setUint8(0, version);
	    result.set(privateKey, 1);
	    if (compressed) {
	        result[33] = 0x01;
	    }
	    return result;
	}
	cjs$3.encodeRaw = encodeRaw;
	function decode(str, version) {
	    return decodeRaw(bs58check_1.default.decode(str), version);
	}
	cjs$3.decode = decode;
	function encode(wif) {
	    return bs58check_1.default.encode(encodeRaw(wif.version, wif.privateKey, wif.compressed));
	}
	cjs$3.encode = encode;
	return cjs$3;
}

var networks$1 = {};

var hasRequiredNetworks$1;

function requireNetworks$1 () {
	if (hasRequiredNetworks$1) return networks$1;
	hasRequiredNetworks$1 = 1;
	Object.defineProperty(networks$1, "__esModule", { value: true });
	networks$1.REGTEST = networks$1.TESTNET = networks$1.BITCOIN = void 0;
	/**
	 * Bitcoin mainnet network configuration
	 */
	networks$1.BITCOIN = {
	    messagePrefix: '\x18Bitcoin Signed Message:\n',
	    bech32: 'bc',
	    bip32: {
	        public: 0x0488b21e,
	        private: 0x0488ade4,
	    },
	    pubKeyHash: 0x00,
	    scriptHash: 0x05,
	    wif: 0x80,
	};
	/**
	 * Bitcoin testnet network configuration
	 */
	networks$1.TESTNET = {
	    messagePrefix: '\x18Bitcoin Signed Message:\n',
	    bech32: 'tb',
	    bip32: {
	        public: 0x043587cf,
	        private: 0x04358394,
	    },
	    pubKeyHash: 0x6f,
	    scriptHash: 0xc4,
	    wif: 0xef,
	};
	/**
	 * Bitcoin regtest network configuration
	 */
	networks$1.REGTEST = {
	    messagePrefix: '\x18Bitcoin Signed Message:\n',
	    bech32: 'bcrt',
	    bip32: {
	        public: 0x043587cf,
	        private: 0x04358394,
	    },
	    pubKeyHash: 0x6f,
	    scriptHash: 0xc4,
	    wif: 0xef,
	};
	return networks$1;
}

var hasRequiredBip32;

function requireBip32 () {
	if (hasRequiredBip32) return bip32$1;
	hasRequiredBip32 = 1;
	var __createBinding = (bip32$1 && bip32$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (bip32$1 && bip32$1.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (bip32$1 && bip32$1.__importStar) || (function () {
	    var ownKeys = function(o) {
	        ownKeys = Object.getOwnPropertyNames || function (o) {
	            var ar = [];
	            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
	            return ar;
	        };
	        return ownKeys(o);
	    };
	    return function (mod) {
	        if (mod && mod.__esModule) return mod;
	        var result = {};
	        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
	        __setModuleDefault(result, mod);
	        return result;
	    };
	})();
	Object.defineProperty(bip32$1, "__esModule", { value: true });
	bip32$1.BIP32Factory = BIP32Factory;
	const crypto = __importStar(requireCrypto());
	const testecc_js_1 = requireTestecc$1();
	const base_1 = require$$5$1;
	const sha256_1 = /*@__PURE__*/ requireSha256$1();
	const v = __importStar(/*@__PURE__*/ requireDist$3());
	const types_js_1 = requireTypes$2();
	const wif = __importStar(requireCjs$1());
	const tools = __importStar(require$$2$1);
	const networks_js_1 = requireNetworks$1();
	const _bs58check = (0, base_1.base58check)(sha256_1.sha256);
	const bs58check = {
	    encode: (data) => _bs58check.encode(data),
	    decode: (str) => _bs58check.decode(str),
	};
	function BIP32Factory(ecc) {
	    (0, testecc_js_1.testEcc)(ecc);
	    const HIGHEST_BIT = 0x80000000;
	    function toXOnly(pubKey) {
	        return pubKey.length === 32 ? pubKey : pubKey.slice(1, 33);
	    }
	    class Bip32Signer {
	        __D;
	        __Q;
	        lowR = false;
	        constructor(__D, __Q) {
	            this.__D = __D;
	            this.__Q = __Q;
	        }
	        get publicKey() {
	            if (this.__Q === undefined)
	                this.__Q = ecc.pointFromScalar(this.__D, true);
	            return this.__Q;
	        }
	        get privateKey() {
	            return this.__D;
	        }
	        sign(hash, lowR) {
	            if (!this.privateKey)
	                throw new Error('Missing private key');
	            if (lowR === undefined)
	                lowR = this.lowR;
	            if (!lowR) {
	                return ecc.sign(hash, this.privateKey);
	            }
	            else {
	                let sig = ecc.sign(hash, this.privateKey);
	                const extraData = new Uint8Array(32);
	                let counter = 0;
	                // if first try is lowR, skip the loop
	                // for second try and on, add extra entropy counting up
	                while (sig[0] > 0x7f) {
	                    counter++;
	                    tools.writeUInt32(extraData, 0, counter, 'LE');
	                    sig = ecc.sign(hash, this.privateKey, extraData);
	                }
	                return sig;
	            }
	        }
	        signSchnorr(hash) {
	            if (!this.privateKey)
	                throw new Error('Missing private key');
	            if (!ecc.signSchnorr)
	                throw new Error('signSchnorr not supported by ecc library');
	            return ecc.signSchnorr(hash, this.privateKey);
	        }
	        verify(hash, signature) {
	            return ecc.verify(hash, this.publicKey, signature);
	        }
	        verifySchnorr(hash, signature) {
	            if (!ecc.verifySchnorr)
	                throw new Error('verifySchnorr not supported by ecc library');
	            return ecc.verifySchnorr(hash, this.publicKey.subarray(1, 33), signature);
	        }
	    }
	    class BIP32 extends Bip32Signer {
	        chainCode;
	        network;
	        __DEPTH;
	        __INDEX;
	        __PARENT_FINGERPRINT;
	        constructor(__D, __Q, chainCode, network, __DEPTH = 0, __INDEX = 0, __PARENT_FINGERPRINT = 0x00000000) {
	            super(__D, __Q);
	            this.chainCode = chainCode;
	            this.network = network;
	            this.__DEPTH = __DEPTH;
	            this.__INDEX = __INDEX;
	            this.__PARENT_FINGERPRINT = __PARENT_FINGERPRINT;
	            v.parse(types_js_1.NetworkSchema, network);
	        }
	        get depth() {
	            return this.__DEPTH;
	        }
	        get index() {
	            return this.__INDEX;
	        }
	        get parentFingerprint() {
	            return this.__PARENT_FINGERPRINT;
	        }
	        get identifier() {
	            return crypto.hash160(this.publicKey);
	        }
	        get fingerprint() {
	            return this.identifier.slice(0, 4);
	        }
	        get compressed() {
	            return true;
	        }
	        // Private === not neutered
	        // Public === neutered
	        isNeutered() {
	            return this.__D === undefined;
	        }
	        neutered() {
	            return fromPublicKeyLocal(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);
	        }
	        toBase58() {
	            const network = this.network;
	            const version = !this.isNeutered()
	                ? network.bip32.private
	                : network.bip32.public;
	            const buffer = new Uint8Array(78);
	            // 4 bytes: version bytes
	            tools.writeUInt32(buffer, 0, version, 'BE');
	            // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....
	            tools.writeUInt8(buffer, 4, this.depth);
	            // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)
	            tools.writeUInt32(buffer, 5, this.parentFingerprint, 'BE');
	            // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.
	            // This is encoded in big endian. (0x00000000 if master key)
	            tools.writeUInt32(buffer, 9, this.index, 'BE');
	            // 32 bytes: the chain code
	            buffer.set(this.chainCode, 13);
	            // 33 bytes: the public key or private key data
	            if (!this.isNeutered()) {
	                // 0x00 + k for private keys
	                tools.writeUInt8(buffer, 45, 0);
	                buffer.set(this.privateKey, 46);
	                // 33 bytes: the public key
	            }
	            else {
	                // X9.62 encoding for public keys
	                buffer.set(this.publicKey, 45);
	            }
	            return bs58check.encode(buffer);
	        }
	        toWIF() {
	            if (!this.privateKey)
	                throw new TypeError('Missing private key');
	            return wif.encode({
	                version: this.network.wif,
	                privateKey: this.privateKey,
	                compressed: true,
	            });
	        }
	        // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions
	        derive(index) {
	            v.parse(types_js_1.Uint32Schema, index);
	            const isHardened = index >= HIGHEST_BIT;
	            const data = new Uint8Array(37);
	            // Hardened child
	            if (isHardened) {
	                if (this.isNeutered())
	                    throw new TypeError('Missing private key for hardened child key');
	                // data = 0x00 || ser256(kpar) || ser32(index)
	                data[0] = 0x00;
	                data.set(this.privateKey, 1);
	                tools.writeUInt32(data, 33, index, 'BE');
	                // Normal child
	            }
	            else {
	                // data = serP(point(kpar)) || ser32(index)
	                //      = serP(Kpar) || ser32(index)
	                data.set(this.publicKey, 0);
	                tools.writeUInt32(data, 33, index, 'BE');
	            }
	            const I = crypto.hmacSHA512(this.chainCode, data);
	            const IL = I.slice(0, 32);
	            const IR = I.slice(32);
	            // if parse256(IL) >= n, proceed with the next value for i
	            if (!ecc.isPrivate(IL))
	                return this.derive(index + 1);
	            // Private parent key -> private child key
	            let hd;
	            if (!this.isNeutered()) {
	                // ki = parse256(IL) + kpar (mod n)
	                const ki = ecc.privateAdd(this.privateKey, IL);
	                // In case ki == 0, proceed with the next value for i
	                if (ki == null)
	                    return this.derive(index + 1);
	                hd = fromPrivateKeyLocal(ki, IR, this.network, this.depth + 1, index, tools.readUInt32(this.fingerprint, 0, 'BE'));
	                // Public parent key -> public child key
	            }
	            else {
	                // Ki = point(parse256(IL)) + Kpar
	                //    = G*IL + Kpar
	                const Ki = ecc.pointAddScalar(this.publicKey, IL, true);
	                // In case Ki is the point at infinity, proceed with the next value for i
	                if (Ki === null)
	                    return this.derive(index + 1);
	                hd = fromPublicKeyLocal(Ki, IR, this.network, this.depth + 1, index, tools.readUInt32(this.fingerprint, 0, 'BE'));
	            }
	            return hd;
	        }
	        deriveHardened(index) {
	            if (typeof v.parse(types_js_1.Uint31Schema, index) === 'number')
	                // Only derives hardened private keys by default
	                return this.derive(index + HIGHEST_BIT);
	            throw new TypeError('Expected UInt31, got ' + index);
	        }
	        derivePath(path) {
	            v.parse(types_js_1.Bip32PathSchema, path);
	            let splitPath = path.split('/');
	            if (splitPath[0] === 'm') {
	                if (this.parentFingerprint)
	                    throw new TypeError('Expected master, got child');
	                splitPath = splitPath.slice(1);
	            }
	            return splitPath.reduce((prevHd, indexStr) => {
	                let index;
	                if (indexStr.slice(-1) === `'`) {
	                    index = parseInt(indexStr.slice(0, -1), 10);
	                    return prevHd.deriveHardened(index);
	                }
	                else {
	                    index = parseInt(indexStr, 10);
	                    return prevHd.derive(index);
	                }
	            }, this);
	        }
	        tweak(t) {
	            if (this.privateKey)
	                return this.tweakFromPrivateKey(t);
	            return this.tweakFromPublicKey(t);
	        }
	        tweakFromPublicKey(t) {
	            const xOnlyPubKey = toXOnly(this.publicKey);
	            if (!ecc.xOnlyPointAddTweak)
	                throw new Error('xOnlyPointAddTweak not supported by ecc library');
	            const tweakedPublicKey = ecc.xOnlyPointAddTweak(xOnlyPubKey, t);
	            if (!tweakedPublicKey || tweakedPublicKey.xOnlyPubkey === null)
	                throw new Error('Cannot tweak public key!');
	            const parityByte = Uint8Array.from([
	                tweakedPublicKey.parity === 0 ? 0x02 : 0x03,
	            ]);
	            const tweakedPublicKeyCompresed = tools.concat([
	                parityByte,
	                tweakedPublicKey.xOnlyPubkey,
	            ]);
	            return new Bip32Signer(undefined, tweakedPublicKeyCompresed);
	        }
	        tweakFromPrivateKey(t) {
	            const hasOddY = this.publicKey[0] === 3 ||
	                (this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1);
	            const privateKey = (() => {
	                if (!hasOddY)
	                    return this.privateKey;
	                else if (!ecc.privateNegate)
	                    throw new Error('privateNegate not supported by ecc library');
	                else
	                    return ecc.privateNegate(this.privateKey);
	            })();
	            const tweakedPrivateKey = ecc.privateAdd(privateKey, t);
	            if (!tweakedPrivateKey)
	                throw new Error('Invalid tweaked private key!');
	            return new Bip32Signer(tweakedPrivateKey, undefined);
	        }
	    }
	    function fromBase58(inString, network) {
	        const buffer = bs58check.decode(inString);
	        if (buffer.length !== 78)
	            throw new TypeError('Invalid buffer length');
	        network = network || networks_js_1.BITCOIN;
	        // 4 bytes: version bytes
	        const version = tools.readUInt32(buffer, 0, 'BE');
	        if (version !== network.bip32.private && version !== network.bip32.public)
	            throw new TypeError('Invalid network version');
	        // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...
	        const depth = buffer[4];
	        // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)
	        const parentFingerprint = tools.readUInt32(buffer, 5, 'BE');
	        if (depth === 0) {
	            if (parentFingerprint !== 0x00000000)
	                throw new TypeError('Invalid parent fingerprint');
	        }
	        // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.
	        // This is encoded in MSB order. (0x00000000 if master key)
	        const index = tools.readUInt32(buffer, 9, 'BE');
	        if (depth === 0 && index !== 0)
	            throw new TypeError('Invalid index');
	        // 32 bytes: the chain code
	        const chainCode = buffer.slice(13, 45);
	        let hd;
	        // 33 bytes: private key data (0x00 + k)
	        if (version === network.bip32.private) {
	            if (buffer[45] !== 0x00)
	                throw new TypeError('Invalid private key');
	            const k = buffer.slice(46, 78);
	            hd = fromPrivateKeyLocal(k, chainCode, network, depth, index, parentFingerprint);
	            // 33 bytes: public key data (0x02 + X or 0x03 + X)
	        }
	        else {
	            const X = buffer.slice(45, 78);
	            hd = fromPublicKeyLocal(X, chainCode, network, depth, index, parentFingerprint);
	        }
	        return hd;
	    }
	    function fromPrivateKey(privateKey, chainCode, network) {
	        return fromPrivateKeyLocal(privateKey, chainCode, network);
	    }
	    function fromPrivateKeyLocal(privateKey, chainCode, network, depth, index, parentFingerprint) {
	        v.parse(types_js_1.Buffer256Bit, privateKey);
	        v.parse(types_js_1.Buffer256Bit, chainCode);
	        network = network || networks_js_1.BITCOIN;
	        if (!ecc.isPrivate(privateKey))
	            throw new TypeError('Private key not in range [1, n)');
	        return new BIP32(privateKey, undefined, chainCode, network, depth, index, parentFingerprint);
	    }
	    function fromPublicKey(publicKey, chainCode, network) {
	        return fromPublicKeyLocal(publicKey, chainCode, network);
	    }
	    function fromPublicKeyLocal(publicKey, chainCode, network, depth, index, parentFingerprint) {
	        v.parse(types_js_1.Buffer33Bytes, publicKey);
	        v.parse(types_js_1.Buffer256Bit, chainCode);
	        network = network || networks_js_1.BITCOIN;
	        // verify the X coordinate is a point on the curve
	        if (!ecc.isPoint(publicKey))
	            throw new TypeError('Point is not on the curve');
	        return new BIP32(undefined, publicKey, chainCode, network, depth, index, parentFingerprint);
	    }
	    function fromSeed(seed, network) {
	        v.parse(v.instance(Uint8Array), seed);
	        if (seed.length < 16)
	            throw new TypeError('Seed should be at least 128 bits');
	        if (seed.length > 64)
	            throw new TypeError('Seed should be at most 512 bits');
	        network = network || networks_js_1.BITCOIN;
	        const I = crypto.hmacSHA512(tools.fromUtf8('Bitcoin seed'), seed);
	        const IL = I.slice(0, 32);
	        const IR = I.slice(32);
	        return fromPrivateKey(IL, IR, network);
	    }
	    return {
	        fromSeed,
	        fromBase58,
	        fromPublicKey,
	        fromPrivateKey,
	    };
	}
	return bip32$1;
}

var quantum = {};

var mldsa = {};

/**
 * Utilities for hex, bytearray and number handling.
 * @module
 */
/*! noble-post-quantum - MIT License (c) 2024 Paul Miller (paulmillr.com) */
const randomBytes$1 = randomBytes$2;
// Compares 2 u8a-s in kinda constant time
function equalBytes(a, b) {
    if (a.length !== b.length)
        return false;
    let diff = 0;
    for (let i = 0; i < a.length; i++)
        diff |= a[i] ^ b[i];
    return diff === 0;
}
// copy bytes to new u8a (aligned). Because Buffer.slice is broken.
function copyBytes(bytes) {
    return Uint8Array.from(bytes);
}
function validateOpts(opts) {
    // We try to catch u8a, since it was previously valid argument at this position
    if (typeof opts !== 'object' || opts === null || isBytes$2(opts))
        throw new Error('expected opts to be an object');
}
function validateVerOpts(opts) {
    validateOpts(opts);
    if (opts.context !== undefined)
        abytes$2(opts.context, undefined, 'opts.context');
}
function validateSigOpts(opts) {
    validateVerOpts(opts);
    if (opts.extraEntropy !== false && opts.extraEntropy !== undefined)
        abytes$2(opts.extraEntropy, undefined, 'opts.extraEntropy');
}
function splitCoder(label, ...lengths) {
    const getLength = (c) => (typeof c === 'number' ? c : c.bytesLen);
    const bytesLen = lengths.reduce((sum, a) => sum + getLength(a), 0);
    return {
        bytesLen,
        encode: (bufs) => {
            const res = new Uint8Array(bytesLen);
            for (let i = 0, pos = 0; i < lengths.length; i++) {
                const c = lengths[i];
                const l = getLength(c);
                const b = typeof c === 'number' ? bufs[i] : c.encode(bufs[i]);
                abytes$2(b, l, label);
                res.set(b, pos);
                if (typeof c !== 'number')
                    b.fill(0); // clean
                pos += l;
            }
            return res;
        },
        decode: (buf) => {
            abytes$2(buf, bytesLen, label);
            const res = [];
            for (const c of lengths) {
                const l = getLength(c);
                const b = buf.subarray(0, l);
                res.push(typeof c === 'number' ? b : c.decode(b));
                buf = buf.subarray(l);
            }
            return res;
        },
    };
}
// nano-packed.array (fixed size)
function vecCoder(c, vecLen) {
    const bytesLen = vecLen * c.bytesLen;
    return {
        bytesLen,
        encode: (u) => {
            if (u.length !== vecLen)
                throw new Error(`vecCoder.encode: wrong length=${u.length}. Expected: ${vecLen}`);
            const res = new Uint8Array(bytesLen);
            for (let i = 0, pos = 0; i < u.length; i++) {
                const b = c.encode(u[i]);
                res.set(b, pos);
                b.fill(0); // clean
                pos += b.length;
            }
            return res;
        },
        decode: (a) => {
            abytes$2(a, bytesLen);
            const r = [];
            for (let i = 0; i < a.length; i += c.bytesLen)
                r.push(c.decode(a.subarray(i, i + c.bytesLen)));
            return r;
        },
    };
}
// cleanBytes(Uint8Array.of(), [Uint16Array.of(), Uint32Array.of()])
function cleanBytes(...list) {
    for (const t of list) {
        if (Array.isArray(t))
            for (const b of t)
                b.fill(0);
        else
            t.fill(0);
    }
}
function getMask(bits) {
    return (1 << bits) - 1; // 4 -> 0b1111
}
const EMPTY = Uint8Array.of();
function getMessage(msg, ctx = EMPTY) {
    abytes$2(msg);
    abytes$2(ctx);
    if (ctx.length > 255)
        throw new Error('context should be less than 255 bytes');
    return concatBytes$1(new Uint8Array([0, ctx.length]), ctx, msg);
}
// 06 09 60 86 48 01 65 03 04 02
const oidNistP = /* @__PURE__ */ Uint8Array.from([6, 9, 0x60, 0x86, 0x48, 1, 0x65, 3, 4, 2]);
function checkHash(hash, requiredStrength = 0) {
    if (!hash.oid || !equalBytes(hash.oid.subarray(0, 10), oidNistP))
        throw new Error('hash.oid is invalid: expected NIST hash');
    const collisionResistance = (hash.outputLen * 8) / 2;
    if (requiredStrength > collisionResistance) {
        throw new Error('Pre-hash security strength too low: ' +
            collisionResistance +
            ', required: ' +
            requiredStrength);
    }
}
function getMessagePrehash(hash, msg, ctx = EMPTY) {
    abytes$2(msg);
    abytes$2(ctx);
    if (ctx.length > 255)
        throw new Error('context should be less than 255 bytes');
    const hashed = hash(msg);
    return concatBytes$1(new Uint8Array([1, ctx.length]), ctx, hash.oid, hashed);
}

const utils = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	EMPTY,
	abytes: abytes$2,
	checkHash,
	cleanBytes,
	concatBytes: concatBytes$1,
	copyBytes,
	equalBytes,
	getMask,
	getMessage,
	getMessagePrehash,
	randomBytes: randomBytes$1,
	splitCoder,
	validateOpts,
	validateSigOpts,
	validateVerOpts,
	vecCoder
}, Symbol.toStringTag, { value: 'Module' }));

const require$$0$3 = /*@__PURE__*/getAugmentedNamespace(utils);

var config = {};

/**
 * Internal methods for lattice-based ML-KEM and ML-DSA.
 * @module
 */
/*! noble-post-quantum - MIT License (c) 2024 Paul Miller (paulmillr.com) */
const genCrystals = (opts) => {
    // isKyber: true means Kyber, false means Dilithium
    const { newPoly, N, Q, F, ROOT_OF_UNITY, brvBits} = opts;
    const mod = (a, modulo = Q) => {
        const result = a % modulo | 0;
        return (result >= 0 ? result | 0 : (modulo + result) | 0) | 0;
    };
    // -(Q-1)/2 < a <= (Q-1)/2
    const smod = (a, modulo = Q) => {
        const r = mod(a, modulo) | 0;
        return (r > modulo >> 1 ? (r - modulo) | 0 : r) | 0;
    };
    // Generate zettas (different from roots of unity, negacyclic uses phi, where acyclic uses omega)
    function getZettas() {
        const out = newPoly(N);
        for (let i = 0; i < N; i++) {
            const b = reverseBits(i, brvBits);
            const p = BigInt(ROOT_OF_UNITY) ** BigInt(b) % BigInt(Q);
            out[i] = Number(p) | 0;
        }
        return out;
    }
    const nttZetas = getZettas();
    // Number-Theoretic Transform
    // Explained: https://electricdusk.com/ntt.html
    // Kyber has slightly different params, since there is no 512th primitive root of unity mod q,
    // only 256th primitive root of unity mod. Which also complicates MultiplyNTT.
    const field = {
        add: (a, b) => mod((a | 0) + (b | 0)) | 0,
        sub: (a, b) => mod((a | 0) - (b | 0)) | 0,
        mul: (a, b) => mod((a | 0) * (b | 0)) | 0,
        inv: (_a) => {
            throw new Error('not implemented');
        },
    };
    const nttOpts = {
        N,
        roots: nttZetas,
        invertButterflies: true,
        skipStages: 0,
        brp: false,
    };
    const dif = FFTCore(field, { dit: false, ...nttOpts });
    const dit = FFTCore(field, { dit: true, ...nttOpts });
    const NTT = {
        encode: (r) => {
            return dif(r);
        },
        decode: (r) => {
            dit(r);
            // kyber uses 128 here, because brv && stuff
            for (let i = 0; i < r.length; i++)
                r[i] = mod(F * r[i]);
            return r;
        },
    };
    // Encode polynominal as bits
    const bitsCoder = (d, c) => {
        const mask = getMask(d);
        const bytesLen = d * (N / 8);
        return {
            bytesLen,
            encode: (poly) => {
                const r = new Uint8Array(bytesLen);
                for (let i = 0, buf = 0, bufLen = 0, pos = 0; i < poly.length; i++) {
                    buf |= (c.encode(poly[i]) & mask) << bufLen;
                    bufLen += d;
                    for (; bufLen >= 8; bufLen -= 8, buf >>= 8)
                        r[pos++] = buf & getMask(bufLen);
                }
                return r;
            },
            decode: (bytes) => {
                const r = newPoly(N);
                for (let i = 0, buf = 0, bufLen = 0, pos = 0; i < bytes.length; i++) {
                    buf |= bytes[i] << bufLen;
                    bufLen += 8;
                    for (; bufLen >= d; bufLen -= d, buf >>= d)
                        r[pos++] = c.decode(buf & mask);
                }
                return r;
            },
        };
    };
    return { mod, smod, nttZetas, NTT, bitsCoder };
};
const createXofShake = (shake) => (seed, blockLen) => {
    if (!blockLen)
        blockLen = shake.blockLen;
    // Optimizations that won't mater:
    // - cached seed update (two .update(), on start and on the end)
    // - another cache which cloned into working copy
    // Faster than multiple updates, since seed less than blockLen
    const _seed = new Uint8Array(seed.length + 2);
    _seed.set(seed);
    const seedLen = seed.length;
    const buf = new Uint8Array(blockLen); // == shake128.blockLen
    let h = shake.create({});
    let calls = 0;
    let xofs = 0;
    return {
        stats: () => ({ calls, xofs }),
        get: (x, y) => {
            _seed[seedLen + 0] = x;
            _seed[seedLen + 1] = y;
            h.destroy();
            h = shake.create({}).update(_seed);
            calls++;
            return () => {
                xofs++;
                return h.xofInto(buf);
            };
        },
        clean: () => {
            h.destroy();
            cleanBytes(buf, _seed);
        },
    };
};
const XOF128 = /* @__PURE__ */ createXofShake(shake128);
const XOF256 = /* @__PURE__ */ createXofShake(shake256);

/**
 * ML-DSA: Module Lattice-based Digital Signature Algorithm from
 * [FIPS-204](https://csrc.nist.gov/pubs/fips/204/ipd). A.k.a. CRYSTALS-Dilithium.
 *
 * Has similar internals to ML-KEM, but their keys and params are different.
 * Check out [official site](https://www.pq-crystals.org/dilithium/index.shtml),
 * [repo](https://github.com/pq-crystals/dilithium).
 * @module
 */
/*! noble-post-quantum - MIT License (c) 2024 Paul Miller (paulmillr.com) */
function validateInternalOpts(opts) {
    validateOpts(opts);
    if (opts.externalMu !== undefined)
        abool(opts.externalMu, 'opts.externalMu');
}
// Constants
const N = 256;
// 2**23  2**13 + 1, 23 bits: multiply will be 46. We have enough precision in JS to avoid bigints
const Q = 8380417;
const ROOT_OF_UNITY = 1753;
// f = 256**1 mod q, pow(256, -1, q) = 8347681 (python3)
const F = 8347681;
const D = 13;
// Dilithium is kinda parametrized over GAMMA2, but everything will break with any other value.
const GAMMA2_1 = Math.floor((Q - 1) / 88) | 0;
const GAMMA2_2 = Math.floor((Q - 1) / 32) | 0;
/** Internal params for different versions of ML-DSA  */
// prettier-ignore
const PARAMS = {
    2: { K: 4, L: 4, D, GAMMA1: 2 ** 17, GAMMA2: GAMMA2_1, TAU: 39, ETA: 2, OMEGA: 80 },
    3: { K: 6, L: 5, D, GAMMA1: 2 ** 19, GAMMA2: GAMMA2_2, TAU: 49, ETA: 4, OMEGA: 55 },
    5: { K: 8, L: 7, D, GAMMA1: 2 ** 19, GAMMA2: GAMMA2_2, TAU: 60, ETA: 2, OMEGA: 75 },
};
const newPoly = (n) => new Int32Array(n);
const { mod, smod, NTT, bitsCoder } = genCrystals({
    N,
    Q,
    F,
    ROOT_OF_UNITY,
    newPoly,
    brvBits: 8,
});
const id = (n) => n;
const polyCoder = (d, compress = id, verify = id) => bitsCoder(d, {
    encode: (i) => compress(verify(i)),
    decode: (i) => verify(compress(i)),
});
const polyAdd = (a, b) => {
    for (let i = 0; i < a.length; i++)
        a[i] = mod(a[i] + b[i]);
    return a;
};
const polySub = (a, b) => {
    for (let i = 0; i < a.length; i++)
        a[i] = mod(a[i] - b[i]);
    return a;
};
const polyShiftl = (p) => {
    for (let i = 0; i < N; i++)
        p[i] <<= D;
    return p;
};
const polyChknorm = (p, B) => {
    // Not very sure about this, but FIPS204 doesn't provide any function for that :(
    for (let i = 0; i < N; i++)
        if (Math.abs(smod(p[i])) >= B)
            return true;
    return false;
};
const MultiplyNTTs = (a, b) => {
    // NOTE: we don't use montgomery reduction in code, since it requires 64 bit ints,
    // which is not available in JS. mod(a[i] * b[i]) is ok, since Q is 23 bit,
    // which means a[i] * b[i] is 46 bit, which is safe to use in JS. (number is 53 bits).
    // Barrett reduction is slower than mod :(
    const c = newPoly(N);
    for (let i = 0; i < a.length; i++)
        c[i] = mod(a[i] * b[i]);
    return c;
};
// Return poly in NTT representation
function RejNTTPoly(xof) {
    // Samples a polynomial  Tq.
    const r = newPoly(N);
    // NOTE: we can represent 3xu24 as 4xu32, but it doesn't improve perf :(
    for (let j = 0; j < N;) {
        const b = xof();
        if (b.length % 3)
            throw new Error('RejNTTPoly: unaligned block');
        for (let i = 0; j < N && i <= b.length - 3; i += 3) {
            const t = (b[i + 0] | (b[i + 1] << 8) | (b[i + 2] << 16)) & 0x7fffff; // 3 bytes
            if (t < Q)
                r[j++] = t;
        }
    }
    return r;
}
function getDilithium(opts) {
    const { K, L, GAMMA1, GAMMA2, TAU, ETA, OMEGA } = opts;
    const { CRH_BYTES, TR_BYTES, C_TILDE_BYTES, XOF128, XOF256, securityLevel } = opts;
    if (![2, 4].includes(ETA))
        throw new Error('Wrong ETA');
    if (![1 << 17, 1 << 19].includes(GAMMA1))
        throw new Error('Wrong GAMMA1');
    if (![GAMMA2_1, GAMMA2_2].includes(GAMMA2))
        throw new Error('Wrong GAMMA2');
    const BETA = TAU * ETA;
    const decompose = (r) => {
        // Decomposes r into (r1, r0) such that r  r1(22) + r0 mod q.
        const rPlus = mod(r);
        const r0 = smod(rPlus, 2 * GAMMA2) | 0;
        if (rPlus - r0 === Q - 1)
            return { r1: 0 | 0, r0: (r0 - 1) | 0 };
        const r1 = Math.floor((rPlus - r0) / (2 * GAMMA2)) | 0;
        return { r1, r0 }; // r1 = HighBits, r0 = LowBits
    };
    const HighBits = (r) => decompose(r).r1;
    const LowBits = (r) => decompose(r).r0;
    const MakeHint = (z, r) => {
        // Compute hint bit indicating whether adding z to r alters the high bits of r.
        // From dilithium code
        const res0 = z <= GAMMA2 || z > Q - GAMMA2 || (z === Q - GAMMA2 && r === 0) ? 0 : 1;
        // from FIPS204:
        // // const r1 = HighBits(r);
        // // const v1 = HighBits(r + z);
        // // const res1 = +(r1 !== v1);
        // But they return different results! However, decompose is same.
        // So, either there is a bug in Dilithium ref implementation or in FIPS204.
        // For now, lets use dilithium one, so test vectors can be passed.
        // See
        // https://github.com/GiacomoPope/dilithium-py?tab=readme-ov-file#optimising-decomposition-and-making-hints
        return res0;
    };
    /*const MakeHint = (z: number, r: number) => {
      const r1 = HighBits(r);
      const v1 = HighBits(r + z);
      return +(r1 !== v1);
    };*/
    const UseHint = (h, r) => {
        // Returns the high bits of r adjusted according to hint h
        const m = Math.floor((Q - 1) / (2 * GAMMA2));
        const { r1, r0 } = decompose(r);
        // 3: if h = 1 and r0 > 0 return (r1 + 1) mod m
        // 4: if h = 1 and r0  0 return (r1  1) mod m
        if (h === 1)
            return r0 > 0 ? mod(r1 + 1, m) | 0 : mod(r1 - 1, m) | 0;
        return r1 | 0;
    };
    const Power2Round = (r) => {
        // Decomposes r into (r1, r0) such that r  r1*(2**d) + r0 mod q.
        const rPlus = mod(r);
        const r0 = smod(rPlus, 2 ** D) | 0;
        return { r1: Math.floor((rPlus - r0) / 2 ** D) | 0, r0 };
    };
    const hintCoder = {
        bytesLen: OMEGA + K,
        encode: (h) => {
            if (h === false)
                throw new Error('hint.encode: hint is false'); // should never happen
            const res = new Uint8Array(OMEGA + K);
            for (let i = 0, k = 0; i < K; i++) {
                for (let j = 0; j < N; j++)
                    if (h[i][j] !== 0)
                        res[k++] = j;
                res[OMEGA + i] = k;
            }
            return res;
        },
        decode: (buf) => {
            const h = [];
            let k = 0;
            for (let i = 0; i < K; i++) {
                const hi = newPoly(N);
                if (buf[OMEGA + i] < k || buf[OMEGA + i] > OMEGA)
                    return false;
                for (let j = k; j < buf[OMEGA + i]; j++) {
                    if (j > k && buf[j] <= buf[j - 1])
                        return false;
                    hi[buf[j]] = 1;
                }
                k = buf[OMEGA + i];
                h.push(hi);
            }
            for (let j = k; j < OMEGA; j++)
                if (buf[j] !== 0)
                    return false;
            return h;
        },
    };
    const ETACoder = polyCoder(ETA === 2 ? 3 : 4, (i) => ETA - i, (i) => {
        if (!(-ETA <= i && i <= ETA))
            throw new Error(`malformed key s1/s3 ${i} outside of ETA range [${-ETA}, ${ETA}]`);
        return i;
    });
    const T0Coder = polyCoder(13, (i) => (1 << (D - 1)) - i);
    const T1Coder = polyCoder(10);
    // Requires smod. Need to fix!
    const ZCoder = polyCoder(GAMMA1 === 1 << 17 ? 18 : 20, (i) => smod(GAMMA1 - i));
    const W1Coder = polyCoder(GAMMA2 === GAMMA2_1 ? 6 : 4);
    const W1Vec = vecCoder(W1Coder, K);
    // Main structures
    const publicCoder = splitCoder('publicKey', 32, vecCoder(T1Coder, K));
    const secretCoder = splitCoder('secretKey', 32, 32, TR_BYTES, vecCoder(ETACoder, L), vecCoder(ETACoder, K), vecCoder(T0Coder, K));
    const sigCoder = splitCoder('signature', C_TILDE_BYTES, vecCoder(ZCoder, L), hintCoder);
    const CoefFromHalfByte = ETA === 2
        ? (n) => (n < 15 ? 2 - (n % 5) : false)
        : (n) => (n < 9 ? 4 - n : false);
    // Return poly in NTT representation
    function RejBoundedPoly(xof) {
        // Samples an element a  Rq with coeffcients in [, ] computed via rejection sampling from .
        const r = newPoly(N);
        for (let j = 0; j < N;) {
            const b = xof();
            for (let i = 0; j < N && i < b.length; i += 1) {
                // half byte. Should be superfast with vector instructions. But very slow with js :(
                const d1 = CoefFromHalfByte(b[i] & 0x0f);
                const d2 = CoefFromHalfByte((b[i] >> 4) & 0x0f);
                if (d1 !== false)
                    r[j++] = d1;
                if (j < N && d2 !== false)
                    r[j++] = d2;
            }
        }
        return r;
    }
    const SampleInBall = (seed) => {
        // Samples a polynomial c  Rq with coeffcients from {1, 0, 1} and Hamming weight 
        const pre = newPoly(N);
        const s = shake256.create({}).update(seed);
        const buf = new Uint8Array(shake256.blockLen);
        s.xofInto(buf);
        const masks = buf.slice(0, 8);
        for (let i = N - TAU, pos = 8, maskPos = 0, maskBit = 0; i < N; i++) {
            let b = i + 1;
            for (; b > i;) {
                b = buf[pos++];
                if (pos < shake256.blockLen)
                    continue;
                s.xofInto(buf);
                pos = 0;
            }
            pre[i] = pre[b];
            pre[b] = 1 - (((masks[maskPos] >> maskBit++) & 1) << 1);
            if (maskBit >= 8) {
                maskPos++;
                maskBit = 0;
            }
        }
        return pre;
    };
    const polyPowerRound = (p) => {
        const res0 = newPoly(N);
        const res1 = newPoly(N);
        for (let i = 0; i < p.length; i++) {
            const { r0, r1 } = Power2Round(p[i]);
            res0[i] = r0;
            res1[i] = r1;
        }
        return { r0: res0, r1: res1 };
    };
    const polyUseHint = (u, h) => {
        for (let i = 0; i < N; i++)
            u[i] = UseHint(h[i], u[i]);
        return u;
    };
    const polyMakeHint = (a, b) => {
        const v = newPoly(N);
        let cnt = 0;
        for (let i = 0; i < N; i++) {
            const h = MakeHint(a[i], b[i]);
            v[i] = h;
            cnt += h;
        }
        return { v, cnt };
    };
    const signRandBytes = 32;
    const seedCoder = splitCoder('seed', 32, 64, 32);
    // API & argument positions are exactly as in FIPS204.
    const internal = {
        info: { type: 'internal-ml-dsa' },
        lengths: {
            secretKey: secretCoder.bytesLen,
            publicKey: publicCoder.bytesLen,
            seed: 32,
            signature: sigCoder.bytesLen,
            signRand: signRandBytes,
        },
        keygen: (seed) => {
            // H(||IntegerToBytes(, 1)||IntegerToBytes(, 1), 128) 2:  expand seed
            const seedDst = new Uint8Array(32 + 2);
            const randSeed = seed === undefined;
            if (randSeed)
                seed = randomBytes$1(32);
            abytes$2(seed, 32, 'seed');
            seedDst.set(seed);
            if (randSeed)
                cleanBytes(seed);
            seedDst[32] = K;
            seedDst[33] = L;
            const [rho, rhoPrime, K_] = seedCoder.decode(shake256(seedDst, { dkLen: seedCoder.bytesLen }));
            const xofPrime = XOF256(rhoPrime);
            const s1 = [];
            for (let i = 0; i < L; i++)
                s1.push(RejBoundedPoly(xofPrime.get(i & 0xff, (i >> 8) & 0xff)));
            const s2 = [];
            for (let i = L; i < L + K; i++)
                s2.push(RejBoundedPoly(xofPrime.get(i & 0xff, (i >> 8) & 0xff)));
            const s1Hat = s1.map((i) => NTT.encode(i.slice()));
            const t0 = [];
            const t1 = [];
            const xof = XOF128(rho);
            const t = newPoly(N);
            for (let i = 0; i < K; i++) {
                // t  NTT1(A*NTT(s1)) + s2
                cleanBytes(t); // don't-reallocate
                for (let j = 0; j < L; j++) {
                    const aij = RejNTTPoly(xof.get(j, i)); // super slow!
                    polyAdd(t, MultiplyNTTs(aij, s1Hat[j]));
                }
                NTT.decode(t);
                const { r0, r1 } = polyPowerRound(polyAdd(t, s2[i])); // (t1, t0)  Power2Round(t, d)
                t0.push(r0);
                t1.push(r1);
            }
            const publicKey = publicCoder.encode([rho, t1]); // pk  pkEncode(, t1)
            const tr = shake256(publicKey, { dkLen: TR_BYTES }); // tr  H(BytesToBits(pk), 512)
            const secretKey = secretCoder.encode([rho, K_, tr, s1, s2, t0]); // sk  skEncode(, K,tr, s1, s2, t0)
            xof.clean();
            xofPrime.clean();
            // STATS
            // Kyber512:  { calls: 4, xofs: 12 }, Kyber768: { calls: 9, xofs: 27 }, Kyber1024: { calls: 16, xofs: 48 }
            // DSA44:    { calls: 24, xofs: 24 }, DSA65:    { calls: 41, xofs: 41 }, DSA87:    { calls: 71, xofs: 71 }
            cleanBytes(rho, rhoPrime, K_, s1, s2, s1Hat, t, t0, t1, tr, seedDst);
            return { publicKey, secretKey };
        },
        getPublicKey: (secretKey) => {
            const [rho, _K, _tr, s1, s2, _t0] = secretCoder.decode(secretKey); // (, K,tr, s1, s2, t0)  skDecode(sk)
            const xof = XOF128(rho);
            const s1Hat = s1.map((p) => NTT.encode(p.slice()));
            const t1 = [];
            const tmp = newPoly(N);
            for (let i = 0; i < K; i++) {
                tmp.fill(0);
                for (let j = 0; j < L; j++) {
                    const aij = RejNTTPoly(xof.get(j, i)); // A_ij in NTT
                    polyAdd(tmp, MultiplyNTTs(aij, s1Hat[j])); // += A_ij * s1_j
                }
                NTT.decode(tmp); // NTT
                polyAdd(tmp, s2[i]); // t_i = As1 + s2
                const { r1 } = polyPowerRound(tmp); // r1 = t1, r0  t0
                t1.push(r1);
            }
            xof.clean();
            cleanBytes(tmp, s1Hat, _t0, s1, s2);
            return publicCoder.encode([rho, t1]);
        },
        // NOTE: random is optional.
        sign: (msg, secretKey, opts = {}) => {
            validateSigOpts(opts);
            validateInternalOpts(opts);
            let { extraEntropy: random, externalMu = false } = opts;
            // This part can be pre-cached per secretKey, but there is only minor performance improvement,
            // since we re-use a lot of variables to computation.
            const [rho, _K, tr, s1, s2, t0] = secretCoder.decode(secretKey); // (, K,tr, s1, s2, t0)  skDecode(sk)
            // Cache matrix to avoid re-compute later
            const A = []; // A  ExpandA()
            const xof = XOF128(rho);
            for (let i = 0; i < K; i++) {
                const pv = [];
                for (let j = 0; j < L; j++)
                    pv.push(RejNTTPoly(xof.get(j, i)));
                A.push(pv);
            }
            xof.clean();
            for (let i = 0; i < L; i++)
                NTT.encode(s1[i]); // s1  NTT(s1)
            for (let i = 0; i < K; i++) {
                NTT.encode(s2[i]); // s2  NTT(s2)
                NTT.encode(t0[i]); // t0  NTT(t0)
            }
            // This part is per msg
            const mu = externalMu
                ? msg
                : shake256.create({ dkLen: CRH_BYTES }).update(tr).update(msg).digest(); // 6:   H(tr||M, 512)  Compute message representative 
            // Compute private random seed
            const rnd = random === false
                ? new Uint8Array(32)
                : random === undefined
                    ? randomBytes$1(signRandBytes)
                    : random;
            abytes$2(rnd, 32, 'extraEntropy');
            const rhoprime = shake256
                .create({ dkLen: CRH_BYTES })
                .update(_K)
                .update(rnd)
                .update(mu)
                .digest(); //  H(K||rnd||, 512)
            abytes$2(rhoprime, CRH_BYTES);
            const x256 = XOF256(rhoprime, ZCoder.bytesLen);
            //  Rejection sampling loop
            main_loop: for (let kappa = 0;;) {
                const y = [];
                // y  ExpandMask( , )
                for (let i = 0; i < L; i++, kappa++)
                    y.push(ZCoder.decode(x256.get(kappa & 0xff, kappa >> 8)()));
                const z = y.map((i) => NTT.encode(i.slice()));
                const w = [];
                for (let i = 0; i < K; i++) {
                    // w  NTT1(A  NTT(y))
                    const wi = newPoly(N);
                    for (let j = 0; j < L; j++)
                        polyAdd(wi, MultiplyNTTs(A[i][j], z[j]));
                    NTT.decode(wi);
                    w.push(wi);
                }
                const w1 = w.map((j) => j.map(HighBits)); // w1  HighBits(w)
                // Commitment hash: c {0, 1 2 }  H(||w1Encode(w1), 2)
                const cTilde = shake256
                    .create({ dkLen: C_TILDE_BYTES })
                    .update(mu)
                    .update(W1Vec.encode(w1))
                    .digest();
                // Verifers challenge
                const cHat = NTT.encode(SampleInBall(cTilde)); // c  SampleInBall(c1); c  NTT(c)
                // cs1  NTT1(c s1)
                const cs1 = s1.map((i) => MultiplyNTTs(i, cHat));
                for (let i = 0; i < L; i++) {
                    polyAdd(NTT.decode(cs1[i]), y[i]); // z  y + cs1
                    if (polyChknorm(cs1[i], GAMMA1 - BETA))
                        continue main_loop; // ||z||  1  
                }
                // cs1 is now z ( Signers response)
                let cnt = 0;
                const h = [];
                for (let i = 0; i < K; i++) {
                    const cs2 = NTT.decode(MultiplyNTTs(s2[i], cHat)); // cs2  NTT1(c s2)
                    const r0 = polySub(w[i], cs2).map(LowBits); // r0  LowBits(w  cs2)
                    if (polyChknorm(r0, GAMMA2 - BETA))
                        continue main_loop; // ||r0||  2  
                    const ct0 = NTT.decode(MultiplyNTTs(t0[i], cHat)); // ct0  NTT1(c t0)
                    if (polyChknorm(ct0, GAMMA2))
                        continue main_loop;
                    polyAdd(r0, ct0);
                    //  Signers hint
                    const hint = polyMakeHint(r0, w1[i]); // h  MakeHint(ct0, w cs2 + ct0)
                    h.push(hint.v);
                    cnt += hint.cnt;
                }
                if (cnt > OMEGA)
                    continue; // the number of 1s in h is greater than 
                x256.clean();
                const res = sigCoder.encode([cTilde, cs1, h]); //   sigEncode(c, z modq, h)
                // rho, _K, tr is subarray of secretKey, cannot clean.
                cleanBytes(cTilde, cs1, h, cHat, w1, w, z, y, rhoprime, mu, s1, s2, t0, ...A);
                return res;
            }
            // @ts-ignore
            throw new Error('Unreachable code path reached, report this error');
        },
        verify: (sig, msg, publicKey, opts = {}) => {
            validateInternalOpts(opts);
            const { externalMu = false } = opts;
            // ML-DSA.Verify(pk, M, ): Verifes a signature  for a message M.
            const [rho, t1] = publicCoder.decode(publicKey); // (, t1)  pkDecode(pk)
            const tr = shake256(publicKey, { dkLen: TR_BYTES }); // 6: tr  H(BytesToBits(pk), 512)
            if (sig.length !== sigCoder.bytesLen)
                return false; // return false instead of exception
            const [cTilde, z, h] = sigCoder.decode(sig); // (c, z, h)  sigDecode(),  Signers commitment hash c , response z and hint
            if (h === false)
                return false; // if h =  then return false
            for (let i = 0; i < L; i++)
                if (polyChknorm(z[i], GAMMA1 - BETA))
                    return false;
            const mu = externalMu
                ? msg
                : shake256.create({ dkLen: CRH_BYTES }).update(tr).update(msg).digest(); // 7:   H(tr||M, 512)
            // Compute verifers challenge from c
            const c = NTT.encode(SampleInBall(cTilde)); // c  SampleInBall(c1)
            const zNtt = z.map((i) => i.slice()); // zNtt = NTT(z)
            for (let i = 0; i < L; i++)
                NTT.encode(zNtt[i]);
            const wTick1 = [];
            const xof = XOF128(rho);
            for (let i = 0; i < K; i++) {
                const ct12d = MultiplyNTTs(NTT.encode(polyShiftl(t1[i])), c); //c * t1 * (2**d)
                const Az = newPoly(N); // // A * z
                for (let j = 0; j < L; j++) {
                    const aij = RejNTTPoly(xof.get(j, i)); // A[i][j] inplace
                    polyAdd(Az, MultiplyNTTs(aij, zNtt[j]));
                }
                // wApprox = A*z - c*t1 * (2**d)
                const wApprox = NTT.decode(polySub(Az, ct12d));
                // Reconstruction of signers commitment
                wTick1.push(polyUseHint(wApprox, h[i])); // w   UseHint(h, w'approx )
            }
            xof.clean();
            // c H (||w1Encode(w1), 2),  Hash it; this should match c
            const c2 = shake256
                .create({ dkLen: C_TILDE_BYTES })
                .update(mu)
                .update(W1Vec.encode(wTick1))
                .digest();
            // Additional checks in FIPS-204:
            // [[ ||z|| < 1   ]] and [[c  = c]] and [[number of 1s in h is  ]]
            for (const t of h) {
                const sum = t.reduce((acc, i) => acc + i, 0);
                if (!(sum <= OMEGA))
                    return false;
            }
            for (const t of z)
                if (polyChknorm(t, GAMMA1 - BETA))
                    return false;
            return equalBytes(cTilde, c2);
        },
    };
    return {
        info: { type: 'ml-dsa' },
        internal,
        securityLevel: securityLevel,
        keygen: internal.keygen,
        lengths: internal.lengths,
        getPublicKey: internal.getPublicKey,
        sign: (msg, secretKey, opts = {}) => {
            validateSigOpts(opts);
            const M = getMessage(msg, opts.context);
            const res = internal.sign(M, secretKey, opts);
            cleanBytes(M);
            return res;
        },
        verify: (sig, msg, publicKey, opts = {}) => {
            validateVerOpts(opts);
            return internal.verify(sig, getMessage(msg, opts.context), publicKey);
        },
        prehash: (hash) => {
            checkHash(hash, securityLevel);
            return {
                info: { type: 'hashml-dsa' },
                securityLevel: securityLevel,
                lengths: internal.lengths,
                keygen: internal.keygen,
                getPublicKey: internal.getPublicKey,
                sign: (msg, secretKey, opts = {}) => {
                    validateSigOpts(opts);
                    const M = getMessagePrehash(hash, msg, opts.context);
                    const res = internal.sign(M, secretKey, opts);
                    cleanBytes(M);
                    return res;
                },
                verify: (sig, msg, publicKey, opts = {}) => {
                    validateVerOpts(opts);
                    return internal.verify(sig, getMessagePrehash(hash, msg, opts.context), publicKey);
                },
            };
        },
    };
}
/** ML-DSA-44 for 128-bit security level. Not recommended after 2030, as per ASD. */
const ml_dsa44 = /* @__PURE__ */ getDilithium({
    ...PARAMS[2],
    CRH_BYTES: 64,
    TR_BYTES: 64,
    C_TILDE_BYTES: 32,
    XOF128,
    XOF256,
    securityLevel: 128,
});
/** ML-DSA-65 for 192-bit security level. Not recommended after 2030, as per ASD. */
const ml_dsa65 = /* @__PURE__ */ getDilithium({
    ...PARAMS[3],
    CRH_BYTES: 64,
    TR_BYTES: 64,
    C_TILDE_BYTES: 48,
    XOF128,
    XOF256,
    securityLevel: 192,
});
/** ML-DSA-87 for 256-bit security level. OK after 2030, as per ASD. */
const ml_dsa87 = /* @__PURE__ */ getDilithium({
    ...PARAMS[5],
    CRH_BYTES: 64,
    TR_BYTES: 64,
    C_TILDE_BYTES: 64,
    XOF128,
    XOF256,
    securityLevel: 256,
});

const mlDsa = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	PARAMS,
	ml_dsa44,
	ml_dsa65,
	ml_dsa87
}, Symbol.toStringTag, { value: 'Module' }));

const require$$0$2 = /*@__PURE__*/getAugmentedNamespace(mlDsa);

var hasRequiredConfig;

function requireConfig () {
	if (hasRequiredConfig) return config;
	hasRequiredConfig = 1;
	Object.defineProperty(config, "__esModule", { value: true });
	config.DEFAULT_SECURITY_LEVEL = config.MLDSASecurityLevel = void 0;
	config.getMLDSAConfig = getMLDSAConfig;
	config.findNetworkByVersion = findNetworkByVersion;
	const ml_dsa_js_1 = require$$0$2;
	const networks_js_1 = requireNetworks$1();
	/**
	 * ML-DSA security levels
	 *
	 * These correspond to NIST security levels:
	 * - LEVEL2: 128-bit classical security (ML-DSA-44)
	 * - LEVEL3: 192-bit classical security (ML-DSA-65)
	 * - LEVEL5: 256-bit classical security (ML-DSA-87)
	 */
	var MLDSASecurityLevel;
	(function (MLDSASecurityLevel) {
	    /** Level 2 security - 128-bit classical security (smallest keys) */
	    MLDSASecurityLevel[MLDSASecurityLevel["LEVEL2"] = 44] = "LEVEL2";
	    /** Level 3 security - 192-bit classical security (balanced) */
	    MLDSASecurityLevel[MLDSASecurityLevel["LEVEL3"] = 65] = "LEVEL3";
	    /** Level 5 security - 256-bit classical security (highest security) */
	    MLDSASecurityLevel[MLDSASecurityLevel["LEVEL5"] = 87] = "LEVEL5";
	})(MLDSASecurityLevel || (config.MLDSASecurityLevel = MLDSASecurityLevel = {}));
	/**
	 * Base configurations for each security level (network-agnostic)
	 */
	const BASE_CONFIGS = {
	    [MLDSASecurityLevel.LEVEL2]: {
	        level: MLDSASecurityLevel.LEVEL2,
	        privateKeySize: 2560,
	        publicKeySize: 1312,
	        signatureSize: 2420,
	        algorithm: ml_dsa_js_1.ml_dsa44,
	    },
	    [MLDSASecurityLevel.LEVEL3]: {
	        level: MLDSASecurityLevel.LEVEL3,
	        privateKeySize: 4032,
	        publicKeySize: 1952,
	        signatureSize: 3309,
	        algorithm: ml_dsa_js_1.ml_dsa65,
	    },
	    [MLDSASecurityLevel.LEVEL5]: {
	        level: MLDSASecurityLevel.LEVEL5,
	        privateKeySize: 4896,
	        publicKeySize: 2592,
	        signatureSize: 4627,
	        algorithm: ml_dsa_js_1.ml_dsa87,
	    },
	};
	/**
	 * Default security level (Level 2 - 128-bit classical security)
	 */
	config.DEFAULT_SECURITY_LEVEL = MLDSASecurityLevel.LEVEL2;
	/**
	 * Get ML-DSA configuration for a specific security level and network
	 * @param level - Security level (44, 65, or 87)
	 * @param network - Network configuration
	 */
	function getMLDSAConfig(level, network) {
	    const baseConfig = BASE_CONFIGS[level];
	    if (!baseConfig) {
	        throw new TypeError(`Invalid ML-DSA security level: ${level}. Must be MLDSASecurityLevel.LEVEL2 (44), LEVEL3 (65), or LEVEL5 (87)`);
	    }
	    return {
	        ...baseConfig,
	        network,
	    };
	}
	/**
	 * Find matching network and determine if private/public by version bytes
	 * Used when importing from base58
	 */
	function findNetworkByVersion(version) {
	    // Try common networks first
	    const commonNetworks = [networks_js_1.BITCOIN, networks_js_1.TESTNET, networks_js_1.REGTEST];
	    for (const network of commonNetworks) {
	        if (version === network.bip32.private) {
	            return { network, isPrivate: true };
	        }
	        if (version === network.bip32.public) {
	            return { network, isPrivate: false };
	        }
	    }
	    // For unknown networks, we can't determine which network it is
	    // The caller will need to have the network object or fail
	    return null;
	}
	return config;
}

var hasRequiredMldsa;

function requireMldsa () {
	if (hasRequiredMldsa) return mldsa;
	hasRequiredMldsa = 1;
	var __createBinding = (mldsa && mldsa.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (mldsa && mldsa.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (mldsa && mldsa.__importStar) || (function () {
	    var ownKeys = function(o) {
	        ownKeys = Object.getOwnPropertyNames || function (o) {
	            var ar = [];
	            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
	            return ar;
	        };
	        return ownKeys(o);
	    };
	    return function (mod) {
	        if (mod && mod.__esModule) return mod;
	        var result = {};
	        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
	        __setModuleDefault(result, mod);
	        return result;
	    };
	})();
	Object.defineProperty(mldsa, "__esModule", { value: true });
	mldsa.QuantumBIP32Factory = void 0;
	const utils_js_1 = require$$0$3;
	const crypto = __importStar(requireCrypto());
	const tools = __importStar(require$$2$1);
	const v = __importStar(/*@__PURE__*/ requireDist$3());
	const types_js_1 = requireTypes$2();
	const base_1 = require$$5$1;
	const sha256_1 = /*@__PURE__*/ requireSha256$1();
	const config_js_1 = requireConfig();
	const networks_js_1 = requireNetworks$1();
	const _bs58check = (0, base_1.base58check)(sha256_1.sha256);
	const bs58check = {
	    encode: (data) => _bs58check.encode(data),
	    decode: (str) => _bs58check.decode(str),
	};
	const CHAIN_CODE_SIZE = 32;
	const HIGHEST_BIT = 0x80000000;
	/**
	 * Quantum signer implementation using ML-DSA
	 */
	class QuantumBip32Signer {
	    _privateKey;
	    _publicKey;
	    config;
	    constructor(_privateKey, _publicKey, config) {
	        this._privateKey = _privateKey;
	        this._publicKey = _publicKey;
	        this.config = config;
	    }
	    get publicKey() {
	        if (!this._publicKey) {
	            throw new Error('Public key not available');
	        }
	        return this._publicKey;
	    }
	    get privateKey() {
	        return this._privateKey;
	    }
	    sign(hash) {
	        if (!this._privateKey) {
	            throw new Error('Missing private key');
	        }
	        // ML-DSA signature with extra entropy for enhanced security
	        const signature = this.config.algorithm.sign(hash, this._privateKey, {
	            extraEntropy: (0, utils_js_1.randomBytes)(32),
	        });
	        return signature;
	    }
	    verify(hash, signature) {
	        return this.config.algorithm.verify(signature, hash, this._publicKey);
	    }
	}
	/**
	 * Quantum BIP32 implementation using ML-DSA
	 * Uses BIP32 for hierarchical seed derivation, then ML-DSA for key generation
	 */
	class QuantumBIP32 extends QuantumBip32Signer {
	    chainCode;
	    _depth;
	    _index;
	    _parentFingerprint;
	    constructor(_privateKey, _publicKey, chainCode, config, _depth = 0, _index = 0, _parentFingerprint = 0x00000000) {
	        super(_privateKey, _publicKey, config);
	        this.chainCode = chainCode;
	        this._depth = _depth;
	        this._index = _index;
	        this._parentFingerprint = _parentFingerprint;
	    }
	    get depth() {
	        return this._depth;
	    }
	    get index() {
	        return this._index;
	    }
	    get parentFingerprint() {
	        return this._parentFingerprint;
	    }
	    get identifier() {
	        return crypto.hash160(this.publicKey);
	    }
	    get fingerprint() {
	        return this.identifier.slice(0, 4);
	    }
	    get securityLevel() {
	        return this.config.level;
	    }
	    get network() {
	        return this.config.network;
	    }
	    isNeutered() {
	        return this._privateKey === undefined;
	    }
	    neutered() {
	        return new QuantumBIP32(undefined, this.publicKey, this.chainCode, this.config, this.depth, this.index, this.parentFingerprint);
	    }
	    toBase58() {
	        const version = !this.isNeutered()
	            ? this.config.network.bip32.private
	            : this.config.network.bip32.public;
	        const isPrivate = !this.isNeutered();
	        const keySize = isPrivate
	            ? this.config.privateKeySize
	            : this.config.publicKeySize;
	        // Buffer structure:
	        // 4 bytes: version
	        // 1 byte: depth
	        // 4 bytes: parent fingerprint
	        // 4 bytes: child index
	        // 32 bytes: chain code
	        // variable bytes: key data (depends on security level)
	        const bufferSize = 4 + 1 + 4 + 4 + 32 + keySize;
	        const buffer = new Uint8Array(bufferSize);
	        let offset = 0;
	        // Version
	        tools.writeUInt32(buffer, offset, version, 'BE');
	        offset += 4;
	        // Depth
	        tools.writeUInt8(buffer, offset, this.depth);
	        offset += 1;
	        // Parent fingerprint
	        tools.writeUInt32(buffer, offset, this.parentFingerprint, 'BE');
	        offset += 4;
	        // Child index
	        tools.writeUInt32(buffer, offset, this.index, 'BE');
	        offset += 4;
	        // Chain code
	        buffer.set(this.chainCode, offset);
	        offset += 32;
	        // Key data
	        if (isPrivate) {
	            buffer.set(this._privateKey, offset);
	        }
	        else {
	            buffer.set(this._publicKey, offset);
	        }
	        return bs58check.encode(buffer);
	    }
	    /**
	     * Derive a child key using BIP32 HMAC chain for seed derivation,
	     * then ML-DSA for key generation
	     */
	    derive(index) {
	        v.parse(types_js_1.Uint32Schema, index);
	        // ML-DSA cannot derive child keys without the private key
	        // Unlike EC crypto, you cannot do public key only derivation
	        if (this.isNeutered()) {
	            throw new TypeError('Cannot derive child keys without private key');
	        }
	        const isHardened = index >= HIGHEST_BIT;
	        let data;
	        // Hardened child
	        if (isHardened) {
	            // For ML-DSA, we use a hash of the private key for derivation data
	            // since the private key can be large
	            const privateKeyHash = crypto.hash256(this._privateKey);
	            data = new Uint8Array(1 + 32 + 4);
	            data[0] = 0x00;
	            data.set(privateKeyHash, 1);
	            tools.writeUInt32(data, 33, index, 'BE');
	        }
	        else {
	            // Normal child - still needs private key for ML-DSA
	            // Use hash of private key (not public key like EC)
	            const privateKeyHash = crypto.hash256(this._privateKey);
	            data = new Uint8Array(32 + 4);
	            data.set(privateKeyHash, 0);
	            tools.writeUInt32(data, 32, index, 'BE');
	        }
	        // Derive 512-bit seed using HMAC-SHA512
	        const I = crypto.hmacSHA512(this.chainCode, data);
	        const IL = I.slice(0, 32); // 256 bits for key generation seed
	        const IR = I.slice(32); // 256 bits for new chain code
	        // Use IL as entropy for ML-DSA key generation
	        // Generate ML-DSA key pair from seed
	        const { secretKey: privateKey, publicKey } = this.config.algorithm.keygen(IL);
	        return new QuantumBIP32(privateKey, publicKey, IR, this.config, this.depth + 1, index, tools.readUInt32(this.fingerprint, 0, 'BE'));
	    }
	    deriveHardened(index) {
	        try {
	            v.parse(types_js_1.Uint31Schema, index);
	        }
	        catch (e) {
	            throw new TypeError('Expected UInt31, got ' + index);
	        }
	        return this.derive(index + HIGHEST_BIT);
	    }
	    derivePath(path) {
	        v.parse(types_js_1.Bip32PathSchema, path);
	        let splitPath = path.split('/');
	        if (splitPath[0] === 'm') {
	            if (this.parentFingerprint) {
	                throw new TypeError('Expected master, got child');
	            }
	            splitPath = splitPath.slice(1);
	        }
	        return splitPath.reduce((prevHd, indexStr) => {
	            let index;
	            if (indexStr.slice(-1) === `'`) {
	                index = parseInt(indexStr.slice(0, -1), 10);
	                return prevHd.deriveHardened(index);
	            }
	            else {
	                index = parseInt(indexStr, 10);
	                return prevHd.derive(index);
	            }
	        }, this);
	    }
	}
	/**
	 * Create a quantum BIP32 master key from a seed
	 * Follows standard BIP32 pattern: fromSeed(seed, network?, securityLevel?)
	 */
	function fromSeed(seed, network, securityLevel) {
	    v.parse(v.instance(Uint8Array), seed);
	    if (seed.length < 16) {
	        throw new TypeError('Seed should be at least 128 bits');
	    }
	    if (seed.length > 64) {
	        throw new TypeError('Seed should be at most 512 bits');
	    }
	    const config = (0, config_js_1.getMLDSAConfig)(securityLevel || config_js_1.MLDSASecurityLevel.LEVEL2, network || networks_js_1.BITCOIN);
	    // Use BIP32 standard HMAC for initial seed derivation
	    const I = crypto.hmacSHA512(tools.fromUtf8('Bitcoin seed'), seed);
	    const IL = I.slice(0, 32);
	    const IR = I.slice(32);
	    // Generate ML-DSA master key pair
	    const { secretKey: privateKey, publicKey } = config.algorithm.keygen(IL);
	    return new QuantumBIP32(privateKey, publicKey, IR, // Chain code
	    config, 0, // depth
	    0, // index
	    0);
	}
	/**
	 * Import a quantum key from base58
	 * Network is detected from version bytes, security level from key size
	 */
	function fromBase58(inString) {
	    const buffer = bs58check.decode(inString);
	    // Read version to determine network
	    const version = tools.readUInt32(buffer, 0, 'BE');
	    // Find matching network by version
	    const match = (0, config_js_1.findNetworkByVersion)(version);
	    if (!match) {
	        throw new TypeError('Unknown network version');
	    }
	    const { network, isPrivate } = match;
	    // Determine security level from buffer size
	    // Buffer structure: 4 (version) + 1 (depth) + 4 (parent fp) + 4 (index) + 32 (chain code) + key data
	    const headerSize = 4 + 1 + 4 + 4 + 32;
	    const keyDataSize = buffer.length - headerSize;
	    // Map key sizes to security levels
	    let securityLevel;
	    if (isPrivate) {
	        // Private key sizes: 2560 (44), 4032 (65), 4896 (87)
	        if (keyDataSize === 2560) {
	            securityLevel = config_js_1.MLDSASecurityLevel.LEVEL2;
	        }
	        else if (keyDataSize === 4032) {
	            securityLevel = config_js_1.MLDSASecurityLevel.LEVEL3;
	        }
	        else if (keyDataSize === 4896) {
	            securityLevel = config_js_1.MLDSASecurityLevel.LEVEL5;
	        }
	        else {
	            throw new TypeError(`Invalid private key size: ${keyDataSize}`);
	        }
	    }
	    else {
	        // Public key sizes: 1312 (44), 1952 (65), 2592 (87)
	        if (keyDataSize === 1312) {
	            securityLevel = config_js_1.MLDSASecurityLevel.LEVEL2;
	        }
	        else if (keyDataSize === 1952) {
	            securityLevel = config_js_1.MLDSASecurityLevel.LEVEL3;
	        }
	        else if (keyDataSize === 2592) {
	            securityLevel = config_js_1.MLDSASecurityLevel.LEVEL5;
	        }
	        else {
	            throw new TypeError(`Invalid public key size: ${keyDataSize}`);
	        }
	    }
	    const config = (0, config_js_1.getMLDSAConfig)(securityLevel, network);
	    const expectedSize = isPrivate
	        ? 4 + 1 + 4 + 4 + 32 + config.privateKeySize
	        : 4 + 1 + 4 + 4 + 32 + config.publicKeySize;
	    if (buffer.length !== expectedSize) {
	        throw new TypeError(`Invalid buffer length: expected ${expectedSize}, got ${buffer.length}`);
	    }
	    let offset = 4;
	    // Depth
	    const depth = buffer[offset];
	    offset += 1;
	    // Parent fingerprint
	    const parentFingerprint = tools.readUInt32(buffer, offset, 'BE');
	    if (depth === 0 && parentFingerprint !== 0x00000000) {
	        throw new TypeError('Invalid parent fingerprint');
	    }
	    offset += 4;
	    // Child index
	    const index = tools.readUInt32(buffer, offset, 'BE');
	    if (depth === 0 && index !== 0) {
	        throw new TypeError('Invalid index');
	    }
	    offset += 4;
	    // Chain code
	    const chainCode = buffer.slice(offset, offset + 32);
	    offset += 32;
	    // Key data
	    if (isPrivate) {
	        const privateKey = buffer.slice(offset, offset + config.privateKeySize);
	        const publicKey = config.algorithm.getPublicKey(privateKey);
	        return new QuantumBIP32(privateKey, publicKey, chainCode, config, depth, index, parentFingerprint);
	    }
	    else {
	        const publicKey = buffer.slice(offset, offset + config.publicKeySize);
	        return new QuantumBIP32(undefined, publicKey, chainCode, config, depth, index, parentFingerprint);
	    }
	}
	/**
	 * Create quantum key from public key and chain code
	 * Follows standard BIP32 pattern: fromPublicKey(publicKey, chainCode, network?, securityLevel?)
	 */
	function fromPublicKey(publicKey, chainCode, network, securityLevel) {
	    const config = (0, config_js_1.getMLDSAConfig)(securityLevel || config_js_1.MLDSASecurityLevel.LEVEL2, network || networks_js_1.BITCOIN);
	    if (publicKey.length !== config.publicKeySize) {
	        throw new TypeError(`Invalid public key length for ML-DSA-${securityLevel}: expected ${config.publicKeySize}, got ${publicKey.length}`);
	    }
	    if (chainCode.length !== CHAIN_CODE_SIZE) {
	        throw new TypeError(`Invalid chain code length: expected ${CHAIN_CODE_SIZE}, got ${chainCode.length}`);
	    }
	    return new QuantumBIP32(undefined, publicKey, chainCode, config, 0, 0, 0);
	}
	/**
	 * Create quantum key from private key and chain code
	 * Follows standard BIP32 pattern: fromPrivateKey(privateKey, chainCode, network?, securityLevel?)
	 */
	function fromPrivateKey(privateKey, chainCode, network, securityLevel) {
	    const config = (0, config_js_1.getMLDSAConfig)(securityLevel || config_js_1.MLDSASecurityLevel.LEVEL2, network || networks_js_1.BITCOIN);
	    if (privateKey.length !== config.privateKeySize) {
	        throw new TypeError(`Invalid private key length for ML-DSA-${securityLevel}: expected ${config.privateKeySize}, got ${privateKey.length}`);
	    }
	    if (chainCode.length !== CHAIN_CODE_SIZE) {
	        throw new TypeError(`Invalid chain code length: expected ${CHAIN_CODE_SIZE}, got ${chainCode.length}`);
	    }
	    // Derive public key from private key
	    const publicKey = config.algorithm.getPublicKey(privateKey);
	    return new QuantumBIP32(privateKey, publicKey, chainCode, config, 0, 0, 0);
	}
	/**
	 * Quantum BIP32 Factory
	 * Provides API for creating and managing ML-DSA hierarchical deterministic keys
	 * Supports ML-DSA-44 (default), ML-DSA-65, and ML-DSA-87
	 */
	mldsa.QuantumBIP32Factory = {
	    fromSeed,
	    fromBase58,
	    fromPublicKey,
	    fromPrivateKey,
	};
	return mldsa;
}

var derivationPaths = {};

var hasRequiredDerivationPaths;

function requireDerivationPaths () {
	if (hasRequiredDerivationPaths) return derivationPaths;
	hasRequiredDerivationPaths = 1;
	/**
	 * Standard BIP derivation paths for Bitcoin wallets
	 *
	 * These paths follow Bitcoin Improvement Proposals (BIPs) that define
	 * standardized derivation paths for different address types and use cases.
	 */
	Object.defineProperty(derivationPaths, "__esModule", { value: true });
	derivationPaths.QuantumDerivationPath = derivationPaths.DerivationPath = void 0;
	derivationPaths.getQuantumPath = getQuantumPath;
	derivationPaths.getBitcoinPath = getBitcoinPath;
	/**
	 * Standard derivation paths for Bitcoin addresses
	 */
	var DerivationPath;
	(function (DerivationPath) {
	    /** BIP44 - Legacy P2PKH addresses (1...) */
	    DerivationPath["BIP44"] = "m/44'/0'/0'/0/0";
	    /** BIP49 - SegWit P2SH-P2WPKH addresses (3...) */
	    DerivationPath["BIP49"] = "m/49'/0'/0'/0/0";
	    /** BIP84 - Native SegWit P2WPKH addresses (bc1q...) */
	    DerivationPath["BIP84"] = "m/84'/0'/0'/0/0";
	    /** BIP86 - Taproot P2TR addresses (bc1p...) */
	    DerivationPath["BIP86"] = "m/86'/0'/0'/0/0";
	    /** BIP360 - Post-Quantum (experimental, quantum-resistant keys) */
	    DerivationPath["BIP360"] = "m/360'/0'/0'/0/0";
	})(DerivationPath || (derivationPaths.DerivationPath = DerivationPath = {}));
	/**
	 * Quantum-specific derivation paths (using coin type 360' for quantum)
	 */
	var QuantumDerivationPath;
	(function (QuantumDerivationPath) {
	    /** Standard quantum path - m/360'/0'/0'/0/0 */
	    QuantumDerivationPath["STANDARD"] = "m/360'/0'/0'/0/0";
	    /** Quantum change path - m/360'/0'/0'/1/0 */
	    QuantumDerivationPath["CHANGE"] = "m/360'/0'/0'/1/0";
	    /** Quantum account 0, address 0 */
	    QuantumDerivationPath["ACCOUNT_0_ADDRESS_0"] = "m/360'/0'/0'/0/0";
	    /** Quantum account 0, address 1 */
	    QuantumDerivationPath["ACCOUNT_0_ADDRESS_1"] = "m/360'/0'/0'/0/1";
	    /** Quantum account 1, address 0 */
	    QuantumDerivationPath["ACCOUNT_1_ADDRESS_0"] = "m/360'/1'/0'/0/0";
	})(QuantumDerivationPath || (derivationPaths.QuantumDerivationPath = QuantumDerivationPath = {}));
	/**
	 * Get derivation path by account and address index
	 * @param account - Account index (default: 0)
	 * @param addressIndex - Address index (default: 0)
	 * @param isChange - Whether this is a change address (default: false)
	 * @returns BIP32 derivation path string
	 */
	function getQuantumPath(account = 0, addressIndex = 0, isChange = false) {
	    const changeIndex = isChange ? 1 : 0;
	    return `m/360'/${account}'/${changeIndex}'/${addressIndex}`;
	}
	/**
	 * Get standard Bitcoin derivation path by account and address index
	 * @param bipType - BIP type (44, 49, 84, or 86)
	 * @param account - Account index (default: 0)
	 * @param addressIndex - Address index (default: 0)
	 * @param isChange - Whether this is a change address (default: false)
	 * @returns BIP32 derivation path string
	 */
	function getBitcoinPath(bipType, account = 0, addressIndex = 0, isChange = false) {
	    const changeIndex = isChange ? 1 : 0;
	    return `m/${bipType}'/0'/${account}'/${changeIndex}/${addressIndex}`;
	}
	return derivationPaths;
}

var hasRequiredQuantum;

function requireQuantum () {
	if (hasRequiredQuantum) return quantum;
	hasRequiredQuantum = 1;
	(function (exports$1) {
		/**
		 * Quantum-resistant BIP32 implementation using ML-DSA
		 *
		 * This module provides hierarchical deterministic key derivation using
		 * ML-DSA (FIPS 204) for post-quantum security.
		 *
		 * Key features:
		 * - Uses BIP32 path derivation (e.g., m/360'/0'/0'/0/0)
		 * - Supports ML-DSA-44 (default), ML-DSA-65, and ML-DSA-87
		 * - ML-DSA-44 provides Level 2 security (128-bit classical security)
		 * - ML-DSA-65 provides Level 3 security (192-bit classical security)
		 * - ML-DSA-87 provides Level 5 security (256-bit classical security)
		 * - Compatible with standard BIP32 mnemonic seeds
		 *
		 * Usage:
		 * ```typescript
		 * import {
		 *   QuantumBIP32Factory,
		 *   MLDSASecurityLevel,
		 *   QuantumDerivationPath
		 * } from '@btc-vision/bip32/quantum';
		 *
		 * const seed = ...; // Your BIP39 seed
		 *
		 * // Default: ML-DSA-44 (Level 2 security)
		 * const master = QuantumBIP32Factory.fromSeed(seed);
		 *
		 * // Or specify security level explicitly using enum
		 * const master87 = QuantumBIP32Factory.fromSeed(seed, MLDSASecurityLevel.LEVEL5);
		 * const master65 = QuantumBIP32Factory.fromSeed(seed, MLDSASecurityLevel.LEVEL3);
		 * const master44 = QuantumBIP32Factory.fromSeed(seed, MLDSASecurityLevel.LEVEL2);
		 *
		 * // Use standard derivation paths
		 * const child = master.derivePath(QuantumDerivationPath.STANDARD);
		 *
		 * const signature = child.sign(messageHash);
		 * const isValid = child.verify(messageHash, signature);
		 * ```
		 */
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.getBitcoinPath = exports$1.getQuantumPath = exports$1.QuantumDerivationPath = exports$1.DerivationPath = exports$1.getMLDSAConfig = exports$1.DEFAULT_SECURITY_LEVEL = exports$1.MLDSASecurityLevel = exports$1.QuantumBIP32Factory = void 0;
		// Export the generic ML-DSA implementation (supports 44, 65, 87)
		var mldsa_js_1 = requireMldsa();
		Object.defineProperty(exports$1, "QuantumBIP32Factory", { enumerable: true, get: function () { return mldsa_js_1.QuantumBIP32Factory; } });
		var config_js_1 = requireConfig();
		Object.defineProperty(exports$1, "MLDSASecurityLevel", { enumerable: true, get: function () { return config_js_1.MLDSASecurityLevel; } });
		Object.defineProperty(exports$1, "DEFAULT_SECURITY_LEVEL", { enumerable: true, get: function () { return config_js_1.DEFAULT_SECURITY_LEVEL; } });
		Object.defineProperty(exports$1, "getMLDSAConfig", { enumerable: true, get: function () { return config_js_1.getMLDSAConfig; } });
		// Re-export derivation path enums for convenience
		var derivation_paths_js_1 = requireDerivationPaths();
		Object.defineProperty(exports$1, "DerivationPath", { enumerable: true, get: function () { return derivation_paths_js_1.DerivationPath; } });
		Object.defineProperty(exports$1, "QuantumDerivationPath", { enumerable: true, get: function () { return derivation_paths_js_1.QuantumDerivationPath; } });
		Object.defineProperty(exports$1, "getQuantumPath", { enumerable: true, get: function () { return derivation_paths_js_1.getQuantumPath; } });
		Object.defineProperty(exports$1, "getBitcoinPath", { enumerable: true, get: function () { return derivation_paths_js_1.getBitcoinPath; } }); 
	} (quantum));
	return quantum;
}

var hasRequiredCjs;

function requireCjs () {
	if (hasRequiredCjs) return cjs$4;
	hasRequiredCjs = 1;
	(function (exports$1) {
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.getBitcoinPath = exports$1.getQuantumPath = exports$1.QuantumDerivationPath = exports$1.DerivationPath = exports$1.getMLDSAConfig = exports$1.DEFAULT_SECURITY_LEVEL = exports$1.MLDSASecurityLevel = exports$1.QuantumBIP32Factory = exports$1.REGTEST = exports$1.TESTNET = exports$1.BITCOIN = exports$1.BIP32Factory = exports$1.default = void 0;
		var bip32_js_1 = requireBip32();
		Object.defineProperty(exports$1, "default", { enumerable: true, get: function () { return bip32_js_1.BIP32Factory; } });
		Object.defineProperty(exports$1, "BIP32Factory", { enumerable: true, get: function () { return bip32_js_1.BIP32Factory; } });
		// Network configurations
		var networks_js_1 = requireNetworks$1();
		Object.defineProperty(exports$1, "BITCOIN", { enumerable: true, get: function () { return networks_js_1.BITCOIN; } });
		Object.defineProperty(exports$1, "TESTNET", { enumerable: true, get: function () { return networks_js_1.TESTNET; } });
		Object.defineProperty(exports$1, "REGTEST", { enumerable: true, get: function () { return networks_js_1.REGTEST; } });
		// Quantum-resistant BIP32 using ML-DSA
		var index_js_1 = requireQuantum();
		Object.defineProperty(exports$1, "QuantumBIP32Factory", { enumerable: true, get: function () { return index_js_1.QuantumBIP32Factory; } });
		Object.defineProperty(exports$1, "MLDSASecurityLevel", { enumerable: true, get: function () { return index_js_1.MLDSASecurityLevel; } });
		Object.defineProperty(exports$1, "DEFAULT_SECURITY_LEVEL", { enumerable: true, get: function () { return index_js_1.DEFAULT_SECURITY_LEVEL; } });
		Object.defineProperty(exports$1, "getMLDSAConfig", { enumerable: true, get: function () { return index_js_1.getMLDSAConfig; } });
		// Derivation path enums
		var derivation_paths_js_1 = requireDerivationPaths();
		Object.defineProperty(exports$1, "DerivationPath", { enumerable: true, get: function () { return derivation_paths_js_1.DerivationPath; } });
		Object.defineProperty(exports$1, "QuantumDerivationPath", { enumerable: true, get: function () { return derivation_paths_js_1.QuantumDerivationPath; } });
		Object.defineProperty(exports$1, "getQuantumPath", { enumerable: true, get: function () { return derivation_paths_js_1.getQuantumPath; } });
		Object.defineProperty(exports$1, "getBitcoinPath", { enumerable: true, get: function () { return derivation_paths_js_1.getBitcoinPath; } }); 
	} (cjs$4));
	return cjs$4;
}

var cjsExports = requireCjs();
const bip32 = /*@__PURE__*/getDefaultExportFromCjs$1(cjsExports);

var src$2 = {};

var ecpair = {};

var networks = {};

var hasRequiredNetworks;

function requireNetworks () {
	if (hasRequiredNetworks) return networks;
	hasRequiredNetworks = 1;
	Object.defineProperty(networks, '__esModule', { value: true });
	networks.testnet = networks.bitcoin = void 0;
	networks.bitcoin = {
	  messagePrefix: '\x18Bitcoin Signed Message:\n',
	  bech32: 'bc',
	  bip32: {
	    public: 0x0488b21e,
	    private: 0x0488ade4,
	  },
	  pubKeyHash: 0x00,
	  scriptHash: 0x05,
	  wif: 0x80,
	};
	networks.testnet = {
	  messagePrefix: '\x18Bitcoin Signed Message:\n',
	  bech32: 'tb',
	  bip32: {
	    public: 0x043587cf,
	    private: 0x04358394,
	  },
	  pubKeyHash: 0x6f,
	  scriptHash: 0xc4,
	  wif: 0xef,
	};
	return networks;
}

var types$1 = {};

var hasRequiredTypes$1;

function requireTypes$1 () {
	if (hasRequiredTypes$1) return types$1;
	hasRequiredTypes$1 = 1;
	(function (exports$1) {
		Object.defineProperty(exports$1, '__esModule', { value: true });
		exports$1.maybe =
		  exports$1.Boolean =
		  exports$1.Array =
		  exports$1.Buffer256bit =
		  exports$1.Network =
		  exports$1.typeforce =
		    void 0;
		exports$1.typeforce = requireTypeforce();
		// exposed, external API
		exports$1.Network = exports$1.typeforce.compile({
		  messagePrefix: exports$1.typeforce.oneOf(
		    exports$1.typeforce.Buffer,
		    exports$1.typeforce.String,
		  ),
		  bip32: {
		    public: exports$1.typeforce.UInt32,
		    private: exports$1.typeforce.UInt32,
		  },
		  pubKeyHash: exports$1.typeforce.UInt8,
		  scriptHash: exports$1.typeforce.UInt8,
		  wif: exports$1.typeforce.UInt8,
		});
		exports$1.Buffer256bit = exports$1.typeforce.BufferN(32);
		exports$1.Array = exports$1.typeforce.Array;
		exports$1.Boolean = exports$1.typeforce.Boolean; // tslint:disable-line variable-name
		exports$1.maybe = exports$1.typeforce.maybe; 
	} (types$1));
	return types$1;
}

function assertArgument(check, message, name, value) {
  if (!check) {
    throw new Error(`${message} (${name}: ${value})`);
  }
}
function getGlobal() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  throw new Error("unable to locate global object");
}
const anyGlobal = getGlobal();
const crypto$1 = anyGlobal.crypto || anyGlobal.msCrypto;
function createHash$1(algo) {
  switch (algo) {
    case "sha1":
      return sha1$3.create();
    case "sha256":
      return sha256$2.create();
    case "sha512":
      return sha512$1.create();
  }
  assertArgument(false, "invalid hashing algorithm name", "algorithm", algo);
}
function createHmac(_algo, key) {
  const algo = { sha1: sha1$3, sha256: sha256$2, sha512: sha512$1 }[_algo];
  assertArgument(algo != null, "invalid hmac algorithm", "algorithm", _algo);
  return hmac.create(algo, key);
}
function pbkdf2Sync(password, salt, iterations, keylen, _algo) {
  const algo = { sha1: sha1$3, sha256: sha256$2, sha512: sha512$1 }[_algo];
  assertArgument(algo != null, "invalid pbkdf2 algorithm", "algorithm", _algo);
  return pbkdf2(algo, password, salt, { c: iterations, dkLen: keylen });
}
function randomBytes(length) {
  assertArgument(
    crypto$1 != null,
    "platform does not support secure random numbers",
    "UNSUPPORTED_OPERATION",
    {
      operation: "randomBytes"
    }
  );
  assertArgument(
    Number.isInteger(length) && length > 0 && length <= 1024,
    "invalid length",
    "length",
    length
  );
  const result = new Uint8Array(length);
  crypto$1.getRandomValues(result);
  return result;
}
const cryptoBrowser = {
  createHash: createHash$1,
  createHmac,
  pbkdf2Sync,
  randomBytes
};

const cryptoBrowser$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	createHash: createHash$1,
	createHmac,
	default: cryptoBrowser,
	pbkdf2Sync,
	randomBytes
}, Symbol.toStringTag, { value: 'Module' }));

const require$$0$1 = /*@__PURE__*/getAugmentedNamespace(cryptoBrowser$1);

var randombytes;
var hasRequiredRandombytes;

function requireRandombytes () {
	if (hasRequiredRandombytes) return randombytes;
	hasRequiredRandombytes = 1;
	randombytes = require$$0$1.randomBytes;
	return randombytes;
}

var createHash;
var hasRequiredCreateHash;

function requireCreateHash () {
	if (hasRequiredCreateHash) return createHash;
	hasRequiredCreateHash = 1;
	createHash = require$$0$1.createHash;
	return createHash;
}

var safeBuffer = {exports: {}};

var dist = {};

var hasRequiredDist;

function requireDist () {
	if (hasRequiredDist) return dist;
	hasRequiredDist = 1;
	(function (exports$1) {
		Object.defineProperties(exports$1, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
		var buffer = {};
		var base64Js = {};
		base64Js.byteLength = byteLength;
		base64Js.toByteArray = toByteArray;
		base64Js.fromByteArray = fromByteArray;
		var lookup = [];
		var revLookup = [];
		var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
		var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		for (var i = 0, len = code.length; i < len; ++i) {
		  lookup[i] = code[i];
		  revLookup[code.charCodeAt(i)] = i;
		}
		revLookup["-".charCodeAt(0)] = 62;
		revLookup["_".charCodeAt(0)] = 63;
		function getLens(b64) {
		  var len2 = b64.length;
		  if (len2 % 4 > 0) {
		    throw new Error("Invalid string. Length must be a multiple of 4");
		  }
		  var validLen = b64.indexOf("=");
		  if (validLen === -1) validLen = len2;
		  var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
		  return [validLen, placeHoldersLen];
		}
		function byteLength(b64) {
		  var lens = getLens(b64);
		  var validLen = lens[0];
		  var placeHoldersLen = lens[1];
		  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
		}
		function _byteLength(b64, validLen, placeHoldersLen) {
		  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
		}
		function toByteArray(b64) {
		  var tmp;
		  var lens = getLens(b64);
		  var validLen = lens[0];
		  var placeHoldersLen = lens[1];
		  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
		  var curByte = 0;
		  var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
		  var i2;
		  for (i2 = 0; i2 < len2; i2 += 4) {
		    tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
		    arr[curByte++] = tmp >> 16 & 255;
		    arr[curByte++] = tmp >> 8 & 255;
		    arr[curByte++] = tmp & 255;
		  }
		  if (placeHoldersLen === 2) {
		    tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
		    arr[curByte++] = tmp & 255;
		  }
		  if (placeHoldersLen === 1) {
		    tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
		    arr[curByte++] = tmp >> 8 & 255;
		    arr[curByte++] = tmp & 255;
		  }
		  return arr;
		}
		function tripletToBase64(num) {
		  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
		}
		function encodeChunk(uint8, start, end) {
		  var tmp;
		  var output = [];
		  for (var i2 = start; i2 < end; i2 += 3) {
		    tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
		    output.push(tripletToBase64(tmp));
		  }
		  return output.join("");
		}
		function fromByteArray(uint8) {
		  var tmp;
		  var len2 = uint8.length;
		  var extraBytes = len2 % 3;
		  var parts = [];
		  var maxChunkLength = 16383;
		  for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
		    parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
		  }
		  if (extraBytes === 1) {
		    tmp = uint8[len2 - 1];
		    parts.push(
		      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
		    );
		  } else if (extraBytes === 2) {
		    tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
		    parts.push(
		      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
		    );
		  }
		  return parts.join("");
		}
		var ieee754 = {};
		/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
		ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
		  var e, m;
		  var eLen = nBytes * 8 - mLen - 1;
		  var eMax = (1 << eLen) - 1;
		  var eBias = eMax >> 1;
		  var nBits = -7;
		  var i2 = isLE ? nBytes - 1 : 0;
		  var d = isLE ? -1 : 1;
		  var s = buffer2[offset + i2];
		  i2 += d;
		  e = s & (1 << -nBits) - 1;
		  s >>= -nBits;
		  nBits += eLen;
		  for (; nBits > 0; e = e * 256 + buffer2[offset + i2], i2 += d, nBits -= 8) {
		  }
		  m = e & (1 << -nBits) - 1;
		  e >>= -nBits;
		  nBits += mLen;
		  for (; nBits > 0; m = m * 256 + buffer2[offset + i2], i2 += d, nBits -= 8) {
		  }
		  if (e === 0) {
		    e = 1 - eBias;
		  } else if (e === eMax) {
		    return m ? NaN : (s ? -1 : 1) * Infinity;
		  } else {
		    m = m + Math.pow(2, mLen);
		    e = e - eBias;
		  }
		  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
		};
		ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
		  var e, m, c;
		  var eLen = nBytes * 8 - mLen - 1;
		  var eMax = (1 << eLen) - 1;
		  var eBias = eMax >> 1;
		  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
		  var i2 = isLE ? 0 : nBytes - 1;
		  var d = isLE ? 1 : -1;
		  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
		  value = Math.abs(value);
		  if (isNaN(value) || value === Infinity) {
		    m = isNaN(value) ? 1 : 0;
		    e = eMax;
		  } else {
		    e = Math.floor(Math.log(value) / Math.LN2);
		    if (value * (c = Math.pow(2, -e)) < 1) {
		      e--;
		      c *= 2;
		    }
		    if (e + eBias >= 1) {
		      value += rt / c;
		    } else {
		      value += rt * Math.pow(2, 1 - eBias);
		    }
		    if (value * c >= 2) {
		      e++;
		      c /= 2;
		    }
		    if (e + eBias >= eMax) {
		      m = 0;
		      e = eMax;
		    } else if (e + eBias >= 1) {
		      m = (value * c - 1) * Math.pow(2, mLen);
		      e = e + eBias;
		    } else {
		      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
		      e = 0;
		    }
		  }
		  for (; mLen >= 8; buffer2[offset + i2] = m & 255, i2 += d, m /= 256, mLen -= 8) {
		  }
		  e = e << mLen | m;
		  eLen += mLen;
		  for (; eLen > 0; buffer2[offset + i2] = e & 255, i2 += d, e /= 256, eLen -= 8) {
		  }
		  buffer2[offset + i2 - d] |= s * 128;
		};
		/*!
		 * The buffer module from node.js, for the browser.
		 *
		 * @author   Feross Aboukhadijeh <https://feross.org>
		 * @license  MIT
		 */
		(function(exports2) {
		  const base64 = base64Js;
		  const ieee754$1 = ieee754;
		  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
		  exports2.Buffer = Buffer2;
		  exports2.SlowBuffer = SlowBuffer;
		  exports2.INSPECT_MAX_BYTES = 50;
		  const K_MAX_LENGTH = 2147483647;
		  exports2.kMaxLength = K_MAX_LENGTH;
		  const { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;
		  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
		  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
		    console.error(
		      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
		    );
		  }
		  function typedArraySupport() {
		    try {
		      const arr = new GlobalUint8Array(1);
		      const proto = { foo: function() {
		        return 42;
		      } };
		      Object.setPrototypeOf(proto, GlobalUint8Array.prototype);
		      Object.setPrototypeOf(arr, proto);
		      return arr.foo() === 42;
		    } catch (e) {
		      return false;
		    }
		  }
		  Object.defineProperty(Buffer2.prototype, "parent", {
		    enumerable: true,
		    get: function() {
		      if (!Buffer2.isBuffer(this)) return void 0;
		      return this.buffer;
		    }
		  });
		  Object.defineProperty(Buffer2.prototype, "offset", {
		    enumerable: true,
		    get: function() {
		      if (!Buffer2.isBuffer(this)) return void 0;
		      return this.byteOffset;
		    }
		  });
		  function createBuffer(length) {
		    if (length > K_MAX_LENGTH) {
		      throw new RangeError('The value "' + length + '" is invalid for option "size"');
		    }
		    const buf = new GlobalUint8Array(length);
		    Object.setPrototypeOf(buf, Buffer2.prototype);
		    return buf;
		  }
		  function Buffer2(arg, encodingOrOffset, length) {
		    if (typeof arg === "number") {
		      if (typeof encodingOrOffset === "string") {
		        throw new TypeError(
		          'The "string" argument must be of type string. Received type number'
		        );
		      }
		      return allocUnsafe(arg);
		    }
		    return from(arg, encodingOrOffset, length);
		  }
		  Buffer2.poolSize = 8192;
		  function from(value, encodingOrOffset, length) {
		    if (typeof value === "string") {
		      return fromString(value, encodingOrOffset);
		    }
		    if (GlobalArrayBuffer.isView(value)) {
		      return fromArrayView(value);
		    }
		    if (value == null) {
		      throw new TypeError(
		        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
		      );
		    }
		    if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {
		      return fromArrayBuffer(value, encodingOrOffset, length);
		    }
		    if (typeof GlobalSharedArrayBuffer !== "undefined" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {
		      return fromArrayBuffer(value, encodingOrOffset, length);
		    }
		    if (typeof value === "number") {
		      throw new TypeError(
		        'The "value" argument must not be of type number. Received type number'
		      );
		    }
		    const valueOf = value.valueOf && value.valueOf();
		    if (valueOf != null && valueOf !== value) {
		      return Buffer2.from(valueOf, encodingOrOffset, length);
		    }
		    const b = fromObject(value);
		    if (b) return b;
		    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
		      return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
		    }
		    throw new TypeError(
		      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
		    );
		  }
		  Buffer2.from = function(value, encodingOrOffset, length) {
		    return from(value, encodingOrOffset, length);
		  };
		  Object.setPrototypeOf(Buffer2.prototype, GlobalUint8Array.prototype);
		  Object.setPrototypeOf(Buffer2, GlobalUint8Array);
		  function assertSize(size) {
		    if (typeof size !== "number") {
		      throw new TypeError('"size" argument must be of type number');
		    } else if (size < 0) {
		      throw new RangeError('The value "' + size + '" is invalid for option "size"');
		    }
		  }
		  function alloc(size, fill, encoding) {
		    assertSize(size);
		    if (size <= 0) {
		      return createBuffer(size);
		    }
		    if (fill !== void 0) {
		      return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
		    }
		    return createBuffer(size);
		  }
		  Buffer2.alloc = function(size, fill, encoding) {
		    return alloc(size, fill, encoding);
		  };
		  function allocUnsafe(size) {
		    assertSize(size);
		    return createBuffer(size < 0 ? 0 : checked(size) | 0);
		  }
		  Buffer2.allocUnsafe = function(size) {
		    return allocUnsafe(size);
		  };
		  Buffer2.allocUnsafeSlow = function(size) {
		    return allocUnsafe(size);
		  };
		  function fromString(string, encoding) {
		    if (typeof encoding !== "string" || encoding === "") {
		      encoding = "utf8";
		    }
		    if (!Buffer2.isEncoding(encoding)) {
		      throw new TypeError("Unknown encoding: " + encoding);
		    }
		    const length = byteLength2(string, encoding) | 0;
		    let buf = createBuffer(length);
		    const actual = buf.write(string, encoding);
		    if (actual !== length) {
		      buf = buf.slice(0, actual);
		    }
		    return buf;
		  }
		  function fromArrayLike(array) {
		    const length = array.length < 0 ? 0 : checked(array.length) | 0;
		    const buf = createBuffer(length);
		    for (let i2 = 0; i2 < length; i2 += 1) {
		      buf[i2] = array[i2] & 255;
		    }
		    return buf;
		  }
		  function fromArrayView(arrayView) {
		    if (isInstance(arrayView, GlobalUint8Array)) {
		      const copy = new GlobalUint8Array(arrayView);
		      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
		    }
		    return fromArrayLike(arrayView);
		  }
		  function fromArrayBuffer(array, byteOffset, length) {
		    if (byteOffset < 0 || array.byteLength < byteOffset) {
		      throw new RangeError('"offset" is outside of buffer bounds');
		    }
		    if (array.byteLength < byteOffset + (length || 0)) {
		      throw new RangeError('"length" is outside of buffer bounds');
		    }
		    let buf;
		    if (byteOffset === void 0 && length === void 0) {
		      buf = new GlobalUint8Array(array);
		    } else if (length === void 0) {
		      buf = new GlobalUint8Array(array, byteOffset);
		    } else {
		      buf = new GlobalUint8Array(array, byteOffset, length);
		    }
		    Object.setPrototypeOf(buf, Buffer2.prototype);
		    return buf;
		  }
		  function fromObject(obj) {
		    if (Buffer2.isBuffer(obj)) {
		      const len2 = checked(obj.length) | 0;
		      const buf = createBuffer(len2);
		      if (buf.length === 0) {
		        return buf;
		      }
		      obj.copy(buf, 0, 0, len2);
		      return buf;
		    }
		    if (obj.length !== void 0) {
		      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
		        return createBuffer(0);
		      }
		      return fromArrayLike(obj);
		    }
		    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
		      return fromArrayLike(obj.data);
		    }
		  }
		  function checked(length) {
		    if (length >= K_MAX_LENGTH) {
		      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
		    }
		    return length | 0;
		  }
		  function SlowBuffer(length) {
		    if (+length != length) {
		      length = 0;
		    }
		    return Buffer2.alloc(+length);
		  }
		  Buffer2.isBuffer = function isBuffer(b) {
		    return b != null && b._isBuffer === true && b !== Buffer2.prototype;
		  };
		  Buffer2.compare = function compare(a, b) {
		    if (isInstance(a, GlobalUint8Array)) a = Buffer2.from(a, a.offset, a.byteLength);
		    if (isInstance(b, GlobalUint8Array)) b = Buffer2.from(b, b.offset, b.byteLength);
		    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
		      throw new TypeError(
		        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
		      );
		    }
		    if (a === b) return 0;
		    let x = a.length;
		    let y = b.length;
		    for (let i2 = 0, len2 = Math.min(x, y); i2 < len2; ++i2) {
		      if (a[i2] !== b[i2]) {
		        x = a[i2];
		        y = b[i2];
		        break;
		      }
		    }
		    if (x < y) return -1;
		    if (y < x) return 1;
		    return 0;
		  };
		  Buffer2.isEncoding = function isEncoding(encoding) {
		    switch (String(encoding).toLowerCase()) {
		      case "hex":
		      case "utf8":
		      case "utf-8":
		      case "ascii":
		      case "latin1":
		      case "binary":
		      case "base64":
		      case "ucs2":
		      case "ucs-2":
		      case "utf16le":
		      case "utf-16le":
		        return true;
		      default:
		        return false;
		    }
		  };
		  Buffer2.concat = function concat(list, length) {
		    if (!Array.isArray(list)) {
		      throw new TypeError('"list" argument must be an Array of Buffers');
		    }
		    if (list.length === 0) {
		      return Buffer2.alloc(0);
		    }
		    let i2;
		    if (length === void 0) {
		      length = 0;
		      for (i2 = 0; i2 < list.length; ++i2) {
		        length += list[i2].length;
		      }
		    }
		    const buffer2 = Buffer2.allocUnsafe(length);
		    let pos = 0;
		    for (i2 = 0; i2 < list.length; ++i2) {
		      let buf = list[i2];
		      if (isInstance(buf, GlobalUint8Array)) {
		        if (pos + buf.length > buffer2.length) {
		          if (!Buffer2.isBuffer(buf)) buf = Buffer2.from(buf);
		          buf.copy(buffer2, pos);
		        } else {
		          GlobalUint8Array.prototype.set.call(
		            buffer2,
		            buf,
		            pos
		          );
		        }
		      } else if (!Buffer2.isBuffer(buf)) {
		        throw new TypeError('"list" argument must be an Array of Buffers');
		      } else {
		        buf.copy(buffer2, pos);
		      }
		      pos += buf.length;
		    }
		    return buffer2;
		  };
		  function byteLength2(string, encoding) {
		    if (Buffer2.isBuffer(string)) {
		      return string.length;
		    }
		    if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {
		      return string.byteLength;
		    }
		    if (typeof string !== "string") {
		      throw new TypeError(
		        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
		      );
		    }
		    const len2 = string.length;
		    const mustMatch = arguments.length > 2 && arguments[2] === true;
		    if (!mustMatch && len2 === 0) return 0;
		    let loweredCase = false;
		    for (; ; ) {
		      switch (encoding) {
		        case "ascii":
		        case "latin1":
		        case "binary":
		          return len2;
		        case "utf8":
		        case "utf-8":
		          return utf8ToBytes(string).length;
		        case "ucs2":
		        case "ucs-2":
		        case "utf16le":
		        case "utf-16le":
		          return len2 * 2;
		        case "hex":
		          return len2 >>> 1;
		        case "base64":
		          return base64ToBytes(string).length;
		        default:
		          if (loweredCase) {
		            return mustMatch ? -1 : utf8ToBytes(string).length;
		          }
		          encoding = ("" + encoding).toLowerCase();
		          loweredCase = true;
		      }
		    }
		  }
		  Buffer2.byteLength = byteLength2;
		  function slowToString(encoding, start, end) {
		    let loweredCase = false;
		    if (start === void 0 || start < 0) {
		      start = 0;
		    }
		    if (start > this.length) {
		      return "";
		    }
		    if (end === void 0 || end > this.length) {
		      end = this.length;
		    }
		    if (end <= 0) {
		      return "";
		    }
		    end >>>= 0;
		    start >>>= 0;
		    if (end <= start) {
		      return "";
		    }
		    if (!encoding) encoding = "utf8";
		    while (true) {
		      switch (encoding) {
		        case "hex":
		          return hexSlice(this, start, end);
		        case "utf8":
		        case "utf-8":
		          return utf8Slice(this, start, end);
		        case "ascii":
		          return asciiSlice(this, start, end);
		        case "latin1":
		        case "binary":
		          return latin1Slice(this, start, end);
		        case "base64":
		          return base64Slice(this, start, end);
		        case "ucs2":
		        case "ucs-2":
		        case "utf16le":
		        case "utf-16le":
		          return utf16leSlice(this, start, end);
		        default:
		          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
		          encoding = (encoding + "").toLowerCase();
		          loweredCase = true;
		      }
		    }
		  }
		  Buffer2.prototype._isBuffer = true;
		  function swap(b, n, m) {
		    const i2 = b[n];
		    b[n] = b[m];
		    b[m] = i2;
		  }
		  Buffer2.prototype.swap16 = function swap16() {
		    const len2 = this.length;
		    if (len2 % 2 !== 0) {
		      throw new RangeError("Buffer size must be a multiple of 16-bits");
		    }
		    for (let i2 = 0; i2 < len2; i2 += 2) {
		      swap(this, i2, i2 + 1);
		    }
		    return this;
		  };
		  Buffer2.prototype.swap32 = function swap32() {
		    const len2 = this.length;
		    if (len2 % 4 !== 0) {
		      throw new RangeError("Buffer size must be a multiple of 32-bits");
		    }
		    for (let i2 = 0; i2 < len2; i2 += 4) {
		      swap(this, i2, i2 + 3);
		      swap(this, i2 + 1, i2 + 2);
		    }
		    return this;
		  };
		  Buffer2.prototype.swap64 = function swap64() {
		    const len2 = this.length;
		    if (len2 % 8 !== 0) {
		      throw new RangeError("Buffer size must be a multiple of 64-bits");
		    }
		    for (let i2 = 0; i2 < len2; i2 += 8) {
		      swap(this, i2, i2 + 7);
		      swap(this, i2 + 1, i2 + 6);
		      swap(this, i2 + 2, i2 + 5);
		      swap(this, i2 + 3, i2 + 4);
		    }
		    return this;
		  };
		  Buffer2.prototype.toString = function toString() {
		    const length = this.length;
		    if (length === 0) return "";
		    if (arguments.length === 0) return utf8Slice(this, 0, length);
		    return slowToString.apply(this, arguments);
		  };
		  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
		  Buffer2.prototype.equals = function equals(b) {
		    if (!Buffer2.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
		    if (this === b) return true;
		    return Buffer2.compare(this, b) === 0;
		  };
		  Buffer2.prototype.inspect = function inspect() {
		    let str = "";
		    const max = exports2.INSPECT_MAX_BYTES;
		    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
		    if (this.length > max) str += " ... ";
		    return "<Buffer " + str + ">";
		  };
		  if (customInspectSymbol) {
		    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
		  }
		  Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
		    if (isInstance(target, GlobalUint8Array)) {
		      target = Buffer2.from(target, target.offset, target.byteLength);
		    }
		    if (!Buffer2.isBuffer(target)) {
		      throw new TypeError(
		        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
		      );
		    }
		    if (start === void 0) {
		      start = 0;
		    }
		    if (end === void 0) {
		      end = target ? target.length : 0;
		    }
		    if (thisStart === void 0) {
		      thisStart = 0;
		    }
		    if (thisEnd === void 0) {
		      thisEnd = this.length;
		    }
		    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
		      throw new RangeError("out of range index");
		    }
		    if (thisStart >= thisEnd && start >= end) {
		      return 0;
		    }
		    if (thisStart >= thisEnd) {
		      return -1;
		    }
		    if (start >= end) {
		      return 1;
		    }
		    start >>>= 0;
		    end >>>= 0;
		    thisStart >>>= 0;
		    thisEnd >>>= 0;
		    if (this === target) return 0;
		    let x = thisEnd - thisStart;
		    let y = end - start;
		    const len2 = Math.min(x, y);
		    const thisCopy = this.slice(thisStart, thisEnd);
		    const targetCopy = target.slice(start, end);
		    for (let i2 = 0; i2 < len2; ++i2) {
		      if (thisCopy[i2] !== targetCopy[i2]) {
		        x = thisCopy[i2];
		        y = targetCopy[i2];
		        break;
		      }
		    }
		    if (x < y) return -1;
		    if (y < x) return 1;
		    return 0;
		  };
		  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
		    if (buffer2.length === 0) return -1;
		    if (typeof byteOffset === "string") {
		      encoding = byteOffset;
		      byteOffset = 0;
		    } else if (byteOffset > 2147483647) {
		      byteOffset = 2147483647;
		    } else if (byteOffset < -2147483648) {
		      byteOffset = -2147483648;
		    }
		    byteOffset = +byteOffset;
		    if (numberIsNaN(byteOffset)) {
		      byteOffset = dir ? 0 : buffer2.length - 1;
		    }
		    if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
		    if (byteOffset >= buffer2.length) {
		      if (dir) return -1;
		      else byteOffset = buffer2.length - 1;
		    } else if (byteOffset < 0) {
		      if (dir) byteOffset = 0;
		      else return -1;
		    }
		    if (typeof val === "string") {
		      val = Buffer2.from(val, encoding);
		    }
		    if (Buffer2.isBuffer(val)) {
		      if (val.length === 0) {
		        return -1;
		      }
		      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
		    } else if (typeof val === "number") {
		      val = val & 255;
		      if (typeof GlobalUint8Array.prototype.indexOf === "function") {
		        if (dir) {
		          return GlobalUint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
		        } else {
		          return GlobalUint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
		        }
		      }
		      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
		    }
		    throw new TypeError("val must be string, number or Buffer");
		  }
		  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
		    let indexSize = 1;
		    let arrLength = arr.length;
		    let valLength = val.length;
		    if (encoding !== void 0) {
		      encoding = String(encoding).toLowerCase();
		      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
		        if (arr.length < 2 || val.length < 2) {
		          return -1;
		        }
		        indexSize = 2;
		        arrLength /= 2;
		        valLength /= 2;
		        byteOffset /= 2;
		      }
		    }
		    function read(buf, i3) {
		      if (indexSize === 1) {
		        return buf[i3];
		      } else {
		        return buf.readUInt16BE(i3 * indexSize);
		      }
		    }
		    let i2;
		    if (dir) {
		      let foundIndex = -1;
		      for (i2 = byteOffset; i2 < arrLength; i2++) {
		        if (read(arr, i2) === read(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
		          if (foundIndex === -1) foundIndex = i2;
		          if (i2 - foundIndex + 1 === valLength) return foundIndex * indexSize;
		        } else {
		          if (foundIndex !== -1) i2 -= i2 - foundIndex;
		          foundIndex = -1;
		        }
		      }
		    } else {
		      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
		      for (i2 = byteOffset; i2 >= 0; i2--) {
		        let found = true;
		        for (let j = 0; j < valLength; j++) {
		          if (read(arr, i2 + j) !== read(val, j)) {
		            found = false;
		            break;
		          }
		        }
		        if (found) return i2;
		      }
		    }
		    return -1;
		  }
		  Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
		    return this.indexOf(val, byteOffset, encoding) !== -1;
		  };
		  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
		    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
		  };
		  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
		    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
		  };
		  function hexWrite(buf, string, offset, length) {
		    offset = Number(offset) || 0;
		    const remaining = buf.length - offset;
		    if (!length) {
		      length = remaining;
		    } else {
		      length = Number(length);
		      if (length > remaining) {
		        length = remaining;
		      }
		    }
		    const strLen = string.length;
		    if (length > strLen / 2) {
		      length = strLen / 2;
		    }
		    let i2;
		    for (i2 = 0; i2 < length; ++i2) {
		      const parsed = parseInt(string.substr(i2 * 2, 2), 16);
		      if (numberIsNaN(parsed)) return i2;
		      buf[offset + i2] = parsed;
		    }
		    return i2;
		  }
		  function utf8Write(buf, string, offset, length) {
		    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
		  }
		  function asciiWrite(buf, string, offset, length) {
		    return blitBuffer(asciiToBytes(string), buf, offset, length);
		  }
		  function base64Write(buf, string, offset, length) {
		    return blitBuffer(base64ToBytes(string), buf, offset, length);
		  }
		  function ucs2Write(buf, string, offset, length) {
		    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
		  }
		  Buffer2.prototype.write = function write(string, offset, length, encoding) {
		    if (offset === void 0) {
		      encoding = "utf8";
		      length = this.length;
		      offset = 0;
		    } else if (length === void 0 && typeof offset === "string") {
		      encoding = offset;
		      length = this.length;
		      offset = 0;
		    } else if (isFinite(offset)) {
		      offset = offset >>> 0;
		      if (isFinite(length)) {
		        length = length >>> 0;
		        if (encoding === void 0) encoding = "utf8";
		      } else {
		        encoding = length;
		        length = void 0;
		      }
		    } else {
		      throw new Error(
		        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
		      );
		    }
		    const remaining = this.length - offset;
		    if (length === void 0 || length > remaining) length = remaining;
		    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
		      throw new RangeError("Attempt to write outside buffer bounds");
		    }
		    if (!encoding) encoding = "utf8";
		    let loweredCase = false;
		    for (; ; ) {
		      switch (encoding) {
		        case "hex":
		          return hexWrite(this, string, offset, length);
		        case "utf8":
		        case "utf-8":
		          return utf8Write(this, string, offset, length);
		        case "ascii":
		        case "latin1":
		        case "binary":
		          return asciiWrite(this, string, offset, length);
		        case "base64":
		          return base64Write(this, string, offset, length);
		        case "ucs2":
		        case "ucs-2":
		        case "utf16le":
		        case "utf-16le":
		          return ucs2Write(this, string, offset, length);
		        default:
		          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
		          encoding = ("" + encoding).toLowerCase();
		          loweredCase = true;
		      }
		    }
		  };
		  Buffer2.prototype.toJSON = function toJSON() {
		    return {
		      type: "Buffer",
		      data: Array.prototype.slice.call(this._arr || this, 0)
		    };
		  };
		  function base64Slice(buf, start, end) {
		    if (start === 0 && end === buf.length) {
		      return base64.fromByteArray(buf);
		    } else {
		      return base64.fromByteArray(buf.slice(start, end));
		    }
		  }
		  function utf8Slice(buf, start, end) {
		    end = Math.min(buf.length, end);
		    const res = [];
		    let i2 = start;
		    while (i2 < end) {
		      const firstByte = buf[i2];
		      let codePoint = null;
		      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
		      if (i2 + bytesPerSequence <= end) {
		        let secondByte, thirdByte, fourthByte, tempCodePoint;
		        switch (bytesPerSequence) {
		          case 1:
		            if (firstByte < 128) {
		              codePoint = firstByte;
		            }
		            break;
		          case 2:
		            secondByte = buf[i2 + 1];
		            if ((secondByte & 192) === 128) {
		              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
		              if (tempCodePoint > 127) {
		                codePoint = tempCodePoint;
		              }
		            }
		            break;
		          case 3:
		            secondByte = buf[i2 + 1];
		            thirdByte = buf[i2 + 2];
		            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
		              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
		              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
		                codePoint = tempCodePoint;
		              }
		            }
		            break;
		          case 4:
		            secondByte = buf[i2 + 1];
		            thirdByte = buf[i2 + 2];
		            fourthByte = buf[i2 + 3];
		            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
		              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
		              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
		                codePoint = tempCodePoint;
		              }
		            }
		        }
		      }
		      if (codePoint === null) {
		        codePoint = 65533;
		        bytesPerSequence = 1;
		      } else if (codePoint > 65535) {
		        codePoint -= 65536;
		        res.push(codePoint >>> 10 & 1023 | 55296);
		        codePoint = 56320 | codePoint & 1023;
		      }
		      res.push(codePoint);
		      i2 += bytesPerSequence;
		    }
		    return decodeCodePointsArray(res);
		  }
		  const MAX_ARGUMENTS_LENGTH = 4096;
		  function decodeCodePointsArray(codePoints) {
		    const len2 = codePoints.length;
		    if (len2 <= MAX_ARGUMENTS_LENGTH) {
		      return String.fromCharCode.apply(String, codePoints);
		    }
		    let res = "";
		    let i2 = 0;
		    while (i2 < len2) {
		      res += String.fromCharCode.apply(
		        String,
		        codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
		      );
		    }
		    return res;
		  }
		  function asciiSlice(buf, start, end) {
		    let ret = "";
		    end = Math.min(buf.length, end);
		    for (let i2 = start; i2 < end; ++i2) {
		      ret += String.fromCharCode(buf[i2] & 127);
		    }
		    return ret;
		  }
		  function latin1Slice(buf, start, end) {
		    let ret = "";
		    end = Math.min(buf.length, end);
		    for (let i2 = start; i2 < end; ++i2) {
		      ret += String.fromCharCode(buf[i2]);
		    }
		    return ret;
		  }
		  function hexSlice(buf, start, end) {
		    const len2 = buf.length;
		    if (!start || start < 0) start = 0;
		    if (!end || end < 0 || end > len2) end = len2;
		    let out = "";
		    for (let i2 = start; i2 < end; ++i2) {
		      out += hexSliceLookupTable[buf[i2]];
		    }
		    return out;
		  }
		  function utf16leSlice(buf, start, end) {
		    const bytes = buf.slice(start, end);
		    let res = "";
		    for (let i2 = 0; i2 < bytes.length - 1; i2 += 2) {
		      res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
		    }
		    return res;
		  }
		  Buffer2.prototype.slice = function slice(start, end) {
		    const len2 = this.length;
		    start = ~~start;
		    end = end === void 0 ? len2 : ~~end;
		    if (start < 0) {
		      start += len2;
		      if (start < 0) start = 0;
		    } else if (start > len2) {
		      start = len2;
		    }
		    if (end < 0) {
		      end += len2;
		      if (end < 0) end = 0;
		    } else if (end > len2) {
		      end = len2;
		    }
		    if (end < start) end = start;
		    const newBuf = this.subarray(start, end);
		    Object.setPrototypeOf(newBuf, Buffer2.prototype);
		    return newBuf;
		  };
		  function checkOffset(offset, ext, length) {
		    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
		    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
		  }
		  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
		    offset = offset >>> 0;
		    byteLength3 = byteLength3 >>> 0;
		    if (!noAssert) checkOffset(offset, byteLength3, this.length);
		    let val = this[offset];
		    let mul = 1;
		    let i2 = 0;
		    while (++i2 < byteLength3 && (mul *= 256)) {
		      val += this[offset + i2] * mul;
		    }
		    return val;
		  };
		  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
		    offset = offset >>> 0;
		    byteLength3 = byteLength3 >>> 0;
		    if (!noAssert) {
		      checkOffset(offset, byteLength3, this.length);
		    }
		    let val = this[offset + --byteLength3];
		    let mul = 1;
		    while (byteLength3 > 0 && (mul *= 256)) {
		      val += this[offset + --byteLength3] * mul;
		    }
		    return val;
		  };
		  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
		    offset = offset >>> 0;
		    if (!noAssert) checkOffset(offset, 1, this.length);
		    return this[offset];
		  };
		  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
		    offset = offset >>> 0;
		    if (!noAssert) checkOffset(offset, 2, this.length);
		    return this[offset] | this[offset + 1] << 8;
		  };
		  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
		    offset = offset >>> 0;
		    if (!noAssert) checkOffset(offset, 2, this.length);
		    return this[offset] << 8 | this[offset + 1];
		  };
		  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
		    offset = offset >>> 0;
		    if (!noAssert) checkOffset(offset, 4, this.length);
		    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
		  };
		  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
		    offset = offset >>> 0;
		    if (!noAssert) checkOffset(offset, 4, this.length);
		    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
		  };
		  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
		    offset = offset >>> 0;
		    validateNumber(offset, "offset");
		    const first = this[offset];
		    const last = this[offset + 7];
		    if (first === void 0 || last === void 0) {
		      boundsError(offset, this.length - 8);
		    }
		    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
		    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
		    return BigInt(lo) + (BigInt(hi) << BigInt(32));
		  });
		  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
		    offset = offset >>> 0;
		    validateNumber(offset, "offset");
		    const first = this[offset];
		    const last = this[offset + 7];
		    if (first === void 0 || last === void 0) {
		      boundsError(offset, this.length - 8);
		    }
		    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
		    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
		    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
		  });
		  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
		    offset = offset >>> 0;
		    byteLength3 = byteLength3 >>> 0;
		    if (!noAssert) checkOffset(offset, byteLength3, this.length);
		    let val = this[offset];
		    let mul = 1;
		    let i2 = 0;
		    while (++i2 < byteLength3 && (mul *= 256)) {
		      val += this[offset + i2] * mul;
		    }
		    mul *= 128;
		    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
		    return val;
		  };
		  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
		    offset = offset >>> 0;
		    byteLength3 = byteLength3 >>> 0;
		    if (!noAssert) checkOffset(offset, byteLength3, this.length);
		    let i2 = byteLength3;
		    let mul = 1;
		    let val = this[offset + --i2];
		    while (i2 > 0 && (mul *= 256)) {
		      val += this[offset + --i2] * mul;
		    }
		    mul *= 128;
		    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
		    return val;
		  };
		  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
		    offset = offset >>> 0;
		    if (!noAssert) checkOffset(offset, 1, this.length);
		    if (!(this[offset] & 128)) return this[offset];
		    return (255 - this[offset] + 1) * -1;
		  };
		  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
		    offset = offset >>> 0;
		    if (!noAssert) checkOffset(offset, 2, this.length);
		    const val = this[offset] | this[offset + 1] << 8;
		    return val & 32768 ? val | 4294901760 : val;
		  };
		  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
		    offset = offset >>> 0;
		    if (!noAssert) checkOffset(offset, 2, this.length);
		    const val = this[offset + 1] | this[offset] << 8;
		    return val & 32768 ? val | 4294901760 : val;
		  };
		  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
		    offset = offset >>> 0;
		    if (!noAssert) checkOffset(offset, 4, this.length);
		    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
		  };
		  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
		    offset = offset >>> 0;
		    if (!noAssert) checkOffset(offset, 4, this.length);
		    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
		  };
		  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
		    offset = offset >>> 0;
		    validateNumber(offset, "offset");
		    const first = this[offset];
		    const last = this[offset + 7];
		    if (first === void 0 || last === void 0) {
		      boundsError(offset, this.length - 8);
		    }
		    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
		    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
		  });
		  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
		    offset = offset >>> 0;
		    validateNumber(offset, "offset");
		    const first = this[offset];
		    const last = this[offset + 7];
		    if (first === void 0 || last === void 0) {
		      boundsError(offset, this.length - 8);
		    }
		    const val = (first << 24) + // Overflow
		    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
		    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
		  });
		  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
		    offset = offset >>> 0;
		    if (!noAssert) checkOffset(offset, 4, this.length);
		    return ieee754$1.read(this, offset, true, 23, 4);
		  };
		  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
		    offset = offset >>> 0;
		    if (!noAssert) checkOffset(offset, 4, this.length);
		    return ieee754$1.read(this, offset, false, 23, 4);
		  };
		  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
		    offset = offset >>> 0;
		    if (!noAssert) checkOffset(offset, 8, this.length);
		    return ieee754$1.read(this, offset, true, 52, 8);
		  };
		  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
		    offset = offset >>> 0;
		    if (!noAssert) checkOffset(offset, 8, this.length);
		    return ieee754$1.read(this, offset, false, 52, 8);
		  };
		  function checkInt(buf, value, offset, ext, max, min) {
		    if (!Buffer2.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
		    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
		    if (offset + ext > buf.length) throw new RangeError("Index out of range");
		  }
		  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
		    value = +value;
		    offset = offset >>> 0;
		    byteLength3 = byteLength3 >>> 0;
		    if (!noAssert) {
		      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
		      checkInt(this, value, offset, byteLength3, maxBytes, 0);
		    }
		    let mul = 1;
		    let i2 = 0;
		    this[offset] = value & 255;
		    while (++i2 < byteLength3 && (mul *= 256)) {
		      this[offset + i2] = value / mul & 255;
		    }
		    return offset + byteLength3;
		  };
		  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
		    value = +value;
		    offset = offset >>> 0;
		    byteLength3 = byteLength3 >>> 0;
		    if (!noAssert) {
		      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
		      checkInt(this, value, offset, byteLength3, maxBytes, 0);
		    }
		    let i2 = byteLength3 - 1;
		    let mul = 1;
		    this[offset + i2] = value & 255;
		    while (--i2 >= 0 && (mul *= 256)) {
		      this[offset + i2] = value / mul & 255;
		    }
		    return offset + byteLength3;
		  };
		  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
		    value = +value;
		    offset = offset >>> 0;
		    if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
		    this[offset] = value & 255;
		    return offset + 1;
		  };
		  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
		    value = +value;
		    offset = offset >>> 0;
		    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
		    this[offset] = value & 255;
		    this[offset + 1] = value >>> 8;
		    return offset + 2;
		  };
		  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
		    value = +value;
		    offset = offset >>> 0;
		    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
		    this[offset] = value >>> 8;
		    this[offset + 1] = value & 255;
		    return offset + 2;
		  };
		  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
		    value = +value;
		    offset = offset >>> 0;
		    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
		    this[offset + 3] = value >>> 24;
		    this[offset + 2] = value >>> 16;
		    this[offset + 1] = value >>> 8;
		    this[offset] = value & 255;
		    return offset + 4;
		  };
		  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
		    value = +value;
		    offset = offset >>> 0;
		    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
		    this[offset] = value >>> 24;
		    this[offset + 1] = value >>> 16;
		    this[offset + 2] = value >>> 8;
		    this[offset + 3] = value & 255;
		    return offset + 4;
		  };
		  function wrtBigUInt64LE(buf, value, offset, min, max) {
		    checkIntBI(value, min, max, buf, offset, 7);
		    let lo = Number(value & BigInt(4294967295));
		    buf[offset++] = lo;
		    lo = lo >> 8;
		    buf[offset++] = lo;
		    lo = lo >> 8;
		    buf[offset++] = lo;
		    lo = lo >> 8;
		    buf[offset++] = lo;
		    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
		    buf[offset++] = hi;
		    hi = hi >> 8;
		    buf[offset++] = hi;
		    hi = hi >> 8;
		    buf[offset++] = hi;
		    hi = hi >> 8;
		    buf[offset++] = hi;
		    return offset;
		  }
		  function wrtBigUInt64BE(buf, value, offset, min, max) {
		    checkIntBI(value, min, max, buf, offset, 7);
		    let lo = Number(value & BigInt(4294967295));
		    buf[offset + 7] = lo;
		    lo = lo >> 8;
		    buf[offset + 6] = lo;
		    lo = lo >> 8;
		    buf[offset + 5] = lo;
		    lo = lo >> 8;
		    buf[offset + 4] = lo;
		    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
		    buf[offset + 3] = hi;
		    hi = hi >> 8;
		    buf[offset + 2] = hi;
		    hi = hi >> 8;
		    buf[offset + 1] = hi;
		    hi = hi >> 8;
		    buf[offset] = hi;
		    return offset + 8;
		  }
		  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
		    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
		  });
		  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
		    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
		  });
		  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
		    value = +value;
		    offset = offset >>> 0;
		    if (!noAssert) {
		      const limit = Math.pow(2, 8 * byteLength3 - 1);
		      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
		    }
		    let i2 = 0;
		    let mul = 1;
		    let sub = 0;
		    this[offset] = value & 255;
		    while (++i2 < byteLength3 && (mul *= 256)) {
		      if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
		        sub = 1;
		      }
		      this[offset + i2] = (value / mul >> 0) - sub & 255;
		    }
		    return offset + byteLength3;
		  };
		  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
		    value = +value;
		    offset = offset >>> 0;
		    if (!noAssert) {
		      const limit = Math.pow(2, 8 * byteLength3 - 1);
		      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
		    }
		    let i2 = byteLength3 - 1;
		    let mul = 1;
		    let sub = 0;
		    this[offset + i2] = value & 255;
		    while (--i2 >= 0 && (mul *= 256)) {
		      if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
		        sub = 1;
		      }
		      this[offset + i2] = (value / mul >> 0) - sub & 255;
		    }
		    return offset + byteLength3;
		  };
		  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
		    value = +value;
		    offset = offset >>> 0;
		    if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
		    if (value < 0) value = 255 + value + 1;
		    this[offset] = value & 255;
		    return offset + 1;
		  };
		  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
		    value = +value;
		    offset = offset >>> 0;
		    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
		    this[offset] = value & 255;
		    this[offset + 1] = value >>> 8;
		    return offset + 2;
		  };
		  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
		    value = +value;
		    offset = offset >>> 0;
		    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
		    this[offset] = value >>> 8;
		    this[offset + 1] = value & 255;
		    return offset + 2;
		  };
		  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
		    value = +value;
		    offset = offset >>> 0;
		    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
		    this[offset] = value & 255;
		    this[offset + 1] = value >>> 8;
		    this[offset + 2] = value >>> 16;
		    this[offset + 3] = value >>> 24;
		    return offset + 4;
		  };
		  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
		    value = +value;
		    offset = offset >>> 0;
		    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
		    if (value < 0) value = 4294967295 + value + 1;
		    this[offset] = value >>> 24;
		    this[offset + 1] = value >>> 16;
		    this[offset + 2] = value >>> 8;
		    this[offset + 3] = value & 255;
		    return offset + 4;
		  };
		  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
		    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
		  });
		  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
		    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
		  });
		  function checkIEEE754(buf, value, offset, ext, max, min) {
		    if (offset + ext > buf.length) throw new RangeError("Index out of range");
		    if (offset < 0) throw new RangeError("Index out of range");
		  }
		  function writeFloat(buf, value, offset, littleEndian, noAssert) {
		    value = +value;
		    offset = offset >>> 0;
		    if (!noAssert) {
		      checkIEEE754(buf, value, offset, 4);
		    }
		    ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
		    return offset + 4;
		  }
		  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
		    return writeFloat(this, value, offset, true, noAssert);
		  };
		  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
		    return writeFloat(this, value, offset, false, noAssert);
		  };
		  function writeDouble(buf, value, offset, littleEndian, noAssert) {
		    value = +value;
		    offset = offset >>> 0;
		    if (!noAssert) {
		      checkIEEE754(buf, value, offset, 8);
		    }
		    ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
		    return offset + 8;
		  }
		  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
		    return writeDouble(this, value, offset, true, noAssert);
		  };
		  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
		    return writeDouble(this, value, offset, false, noAssert);
		  };
		  Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
		    if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
		    if (!start) start = 0;
		    if (!end && end !== 0) end = this.length;
		    if (targetStart >= target.length) targetStart = target.length;
		    if (!targetStart) targetStart = 0;
		    if (end > 0 && end < start) end = start;
		    if (end === start) return 0;
		    if (target.length === 0 || this.length === 0) return 0;
		    if (targetStart < 0) {
		      throw new RangeError("targetStart out of bounds");
		    }
		    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
		    if (end < 0) throw new RangeError("sourceEnd out of bounds");
		    if (end > this.length) end = this.length;
		    if (target.length - targetStart < end - start) {
		      end = target.length - targetStart + start;
		    }
		    const len2 = end - start;
		    if (this === target && typeof GlobalUint8Array.prototype.copyWithin === "function") {
		      this.copyWithin(targetStart, start, end);
		    } else {
		      GlobalUint8Array.prototype.set.call(
		        target,
		        this.subarray(start, end),
		        targetStart
		      );
		    }
		    return len2;
		  };
		  Buffer2.prototype.fill = function fill(val, start, end, encoding) {
		    if (typeof val === "string") {
		      if (typeof start === "string") {
		        encoding = start;
		        start = 0;
		        end = this.length;
		      } else if (typeof end === "string") {
		        encoding = end;
		        end = this.length;
		      }
		      if (encoding !== void 0 && typeof encoding !== "string") {
		        throw new TypeError("encoding must be a string");
		      }
		      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
		        throw new TypeError("Unknown encoding: " + encoding);
		      }
		      if (val.length === 1) {
		        const code2 = val.charCodeAt(0);
		        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
		          val = code2;
		        }
		      }
		    } else if (typeof val === "number") {
		      val = val & 255;
		    } else if (typeof val === "boolean") {
		      val = Number(val);
		    }
		    if (start < 0 || this.length < start || this.length < end) {
		      throw new RangeError("Out of range index");
		    }
		    if (end <= start) {
		      return this;
		    }
		    start = start >>> 0;
		    end = end === void 0 ? this.length : end >>> 0;
		    if (!val) val = 0;
		    let i2;
		    if (typeof val === "number") {
		      for (i2 = start; i2 < end; ++i2) {
		        this[i2] = val;
		      }
		    } else {
		      const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
		      const len2 = bytes.length;
		      if (len2 === 0) {
		        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
		      }
		      for (i2 = 0; i2 < end - start; ++i2) {
		        this[i2 + start] = bytes[i2 % len2];
		      }
		    }
		    return this;
		  };
		  const errors = {};
		  function E(sym, getMessage, Base) {
		    errors[sym] = class NodeError extends Base {
		      constructor() {
		        super();
		        Object.defineProperty(this, "message", {
		          value: getMessage.apply(this, arguments),
		          writable: true,
		          configurable: true
		        });
		        this.name = `${this.name} [${sym}]`;
		        this.stack;
		        delete this.name;
		      }
		      get code() {
		        return sym;
		      }
		      set code(value) {
		        Object.defineProperty(this, "code", {
		          configurable: true,
		          enumerable: true,
		          value,
		          writable: true
		        });
		      }
		      toString() {
		        return `${this.name} [${sym}]: ${this.message}`;
		      }
		    };
		  }
		  E(
		    "ERR_BUFFER_OUT_OF_BOUNDS",
		    function(name) {
		      if (name) {
		        return `${name} is outside of buffer bounds`;
		      }
		      return "Attempt to access memory outside buffer bounds";
		    },
		    RangeError
		  );
		  E(
		    "ERR_INVALID_ARG_TYPE",
		    function(name, actual) {
		      return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
		    },
		    TypeError
		  );
		  E(
		    "ERR_OUT_OF_RANGE",
		    function(str, range, input) {
		      let msg = `The value of "${str}" is out of range.`;
		      let received = input;
		      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
		        received = addNumericalSeparator(String(input));
		      } else if (typeof input === "bigint") {
		        received = String(input);
		        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
		          received = addNumericalSeparator(received);
		        }
		        received += "n";
		      }
		      msg += ` It must be ${range}. Received ${received}`;
		      return msg;
		    },
		    RangeError
		  );
		  function addNumericalSeparator(val) {
		    let res = "";
		    let i2 = val.length;
		    const start = val[0] === "-" ? 1 : 0;
		    for (; i2 >= start + 4; i2 -= 3) {
		      res = `_${val.slice(i2 - 3, i2)}${res}`;
		    }
		    return `${val.slice(0, i2)}${res}`;
		  }
		  function checkBounds(buf, offset, byteLength3) {
		    validateNumber(offset, "offset");
		    if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
		      boundsError(offset, buf.length - (byteLength3 + 1));
		    }
		  }
		  function checkIntBI(value, min, max, buf, offset, byteLength3) {
		    if (value > max || value < min) {
		      const n = typeof min === "bigint" ? "n" : "";
		      let range;
		      {
		        if (min === 0 || min === BigInt(0)) {
		          range = `>= 0${n} and < 2${n} ** ${(byteLength3 + 1) * 8}${n}`;
		        } else {
		          range = `>= -(2${n} ** ${(byteLength3 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n}`;
		        }
		      }
		      throw new errors.ERR_OUT_OF_RANGE("value", range, value);
		    }
		    checkBounds(buf, offset, byteLength3);
		  }
		  function validateNumber(value, name) {
		    if (typeof value !== "number") {
		      throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
		    }
		  }
		  function boundsError(value, length, type) {
		    if (Math.floor(value) !== value) {
		      validateNumber(value, type);
		      throw new errors.ERR_OUT_OF_RANGE("offset", "an integer", value);
		    }
		    if (length < 0) {
		      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
		    }
		    throw new errors.ERR_OUT_OF_RANGE(
		      "offset",
		      `>= ${0} and <= ${length}`,
		      value
		    );
		  }
		  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
		  function base64clean(str) {
		    str = str.split("=")[0];
		    str = str.trim().replace(INVALID_BASE64_RE, "");
		    if (str.length < 2) return "";
		    while (str.length % 4 !== 0) {
		      str = str + "=";
		    }
		    return str;
		  }
		  function utf8ToBytes(string, units) {
		    units = units || Infinity;
		    let codePoint;
		    const length = string.length;
		    let leadSurrogate = null;
		    const bytes = [];
		    for (let i2 = 0; i2 < length; ++i2) {
		      codePoint = string.charCodeAt(i2);
		      if (codePoint > 55295 && codePoint < 57344) {
		        if (!leadSurrogate) {
		          if (codePoint > 56319) {
		            if ((units -= 3) > -1) bytes.push(239, 191, 189);
		            continue;
		          } else if (i2 + 1 === length) {
		            if ((units -= 3) > -1) bytes.push(239, 191, 189);
		            continue;
		          }
		          leadSurrogate = codePoint;
		          continue;
		        }
		        if (codePoint < 56320) {
		          if ((units -= 3) > -1) bytes.push(239, 191, 189);
		          leadSurrogate = codePoint;
		          continue;
		        }
		        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
		      } else if (leadSurrogate) {
		        if ((units -= 3) > -1) bytes.push(239, 191, 189);
		      }
		      leadSurrogate = null;
		      if (codePoint < 128) {
		        if ((units -= 1) < 0) break;
		        bytes.push(codePoint);
		      } else if (codePoint < 2048) {
		        if ((units -= 2) < 0) break;
		        bytes.push(
		          codePoint >> 6 | 192,
		          codePoint & 63 | 128
		        );
		      } else if (codePoint < 65536) {
		        if ((units -= 3) < 0) break;
		        bytes.push(
		          codePoint >> 12 | 224,
		          codePoint >> 6 & 63 | 128,
		          codePoint & 63 | 128
		        );
		      } else if (codePoint < 1114112) {
		        if ((units -= 4) < 0) break;
		        bytes.push(
		          codePoint >> 18 | 240,
		          codePoint >> 12 & 63 | 128,
		          codePoint >> 6 & 63 | 128,
		          codePoint & 63 | 128
		        );
		      } else {
		        throw new Error("Invalid code point");
		      }
		    }
		    return bytes;
		  }
		  function asciiToBytes(str) {
		    const byteArray = [];
		    for (let i2 = 0; i2 < str.length; ++i2) {
		      byteArray.push(str.charCodeAt(i2) & 255);
		    }
		    return byteArray;
		  }
		  function utf16leToBytes(str, units) {
		    let c, hi, lo;
		    const byteArray = [];
		    for (let i2 = 0; i2 < str.length; ++i2) {
		      if ((units -= 2) < 0) break;
		      c = str.charCodeAt(i2);
		      hi = c >> 8;
		      lo = c % 256;
		      byteArray.push(lo);
		      byteArray.push(hi);
		    }
		    return byteArray;
		  }
		  function base64ToBytes(str) {
		    return base64.toByteArray(base64clean(str));
		  }
		  function blitBuffer(src, dst, offset, length) {
		    let i2;
		    for (i2 = 0; i2 < length; ++i2) {
		      if (i2 + offset >= dst.length || i2 >= src.length) break;
		      dst[i2 + offset] = src[i2];
		    }
		    return i2;
		  }
		  function isInstance(obj, type) {
		    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
		  }
		  function numberIsNaN(obj) {
		    return obj !== obj;
		  }
		  const hexSliceLookupTable = (function() {
		    const alphabet = "0123456789abcdef";
		    const table = new Array(256);
		    for (let i2 = 0; i2 < 16; ++i2) {
		      const i16 = i2 * 16;
		      for (let j = 0; j < 16; ++j) {
		        table[i16 + j] = alphabet[i2] + alphabet[j];
		      }
		    }
		    return table;
		  })();
		  function defineBigIntMethod(fn) {
		    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
		  }
		  function BufferBigIntNotDefined() {
		    throw new Error("BigInt not supported");
		  }
		})(buffer);
		const Buffer = buffer.Buffer;
		exports$1.Blob = buffer.Blob;
		exports$1.BlobOptions = buffer.BlobOptions;
		exports$1.Buffer = buffer.Buffer;
		exports$1.File = buffer.File;
		exports$1.FileOptions = buffer.FileOptions;
		exports$1.INSPECT_MAX_BYTES = buffer.INSPECT_MAX_BYTES;
		exports$1.SlowBuffer = buffer.SlowBuffer;
		exports$1.TranscodeEncoding = buffer.TranscodeEncoding;
		exports$1.atob = buffer.atob;
		exports$1.btoa = buffer.btoa;
		exports$1.constants = buffer.constants;
		exports$1.default = Buffer;
		exports$1.isAscii = buffer.isAscii;
		exports$1.isUtf8 = buffer.isUtf8;
		exports$1.kMaxLength = buffer.kMaxLength;
		exports$1.kStringMaxLength = buffer.kStringMaxLength;
		exports$1.resolveObjectURL = buffer.resolveObjectURL;
		exports$1.transcode = buffer.transcode; 
	} (dist));
	return dist;
}

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

var hasRequiredSafeBuffer;

function requireSafeBuffer () {
	if (hasRequiredSafeBuffer) return safeBuffer.exports;
	hasRequiredSafeBuffer = 1;
	(function (module, exports$1) {
		/* eslint-disable node/no-deprecated-api */
		var buffer = requireDist();
		var Buffer = buffer.Buffer;

		// alternative to using Object.keys for old browsers
		function copyProps (src, dst) {
		  for (var key in src) {
		    dst[key] = src[key];
		  }
		}
		if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
		  module.exports = buffer;
		} else {
		  // Copy properties from require('buffer')
		  copyProps(buffer, exports$1);
		  exports$1.Buffer = SafeBuffer;
		}

		function SafeBuffer (arg, encodingOrOffset, length) {
		  return Buffer(arg, encodingOrOffset, length)
		}

		SafeBuffer.prototype = Object.create(Buffer.prototype);

		// Copy static methods from Buffer
		copyProps(Buffer, SafeBuffer);

		SafeBuffer.from = function (arg, encodingOrOffset, length) {
		  if (typeof arg === 'number') {
		    throw new TypeError('Argument must not be a number')
		  }
		  return Buffer(arg, encodingOrOffset, length)
		};

		SafeBuffer.alloc = function (size, fill, encoding) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  var buf = Buffer(size);
		  if (fill !== undefined) {
		    if (typeof encoding === 'string') {
		      buf.fill(fill, encoding);
		    } else {
		      buf.fill(fill);
		    }
		  } else {
		    buf.fill(0);
		  }
		  return buf
		};

		SafeBuffer.allocUnsafe = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return Buffer(size)
		};

		SafeBuffer.allocUnsafeSlow = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return buffer.SlowBuffer(size)
		}; 
	} (safeBuffer, safeBuffer.exports));
	return safeBuffer.exports;
}

var src$1;
var hasRequiredSrc$2;

function requireSrc$2 () {
	if (hasRequiredSrc$2) return src$1;
	hasRequiredSrc$2 = 1;
	// base-x encoding / decoding
	// Copyright (c) 2018 base-x contributors
	// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
	// Distributed under the MIT software license, see the accompanying
	// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
	// @ts-ignore
	var _Buffer = requireSafeBuffer().Buffer;
	function base (ALPHABET) {
	  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }
	  var BASE_MAP = new Uint8Array(256);
	  for (var j = 0; j < BASE_MAP.length; j++) {
	    BASE_MAP[j] = 255;
	  }
	  for (var i = 0; i < ALPHABET.length; i++) {
	    var x = ALPHABET.charAt(i);
	    var xc = x.charCodeAt(0);
	    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }
	    BASE_MAP[xc] = i;
	  }
	  var BASE = ALPHABET.length;
	  var LEADER = ALPHABET.charAt(0);
	  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up
	  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up
	  function encode (source) {
	    if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source); }
	    if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }
	    if (source.length === 0) { return '' }
	        // Skip & count leading zeroes.
	    var zeroes = 0;
	    var length = 0;
	    var pbegin = 0;
	    var pend = source.length;
	    while (pbegin !== pend && source[pbegin] === 0) {
	      pbegin++;
	      zeroes++;
	    }
	        // Allocate enough space in big-endian base58 representation.
	    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;
	    var b58 = new Uint8Array(size);
	        // Process the bytes.
	    while (pbegin !== pend) {
	      var carry = source[pbegin];
	            // Apply "b58 = b58 * 256 + ch".
	      var i = 0;
	      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
	        carry += (256 * b58[it1]) >>> 0;
	        b58[it1] = (carry % BASE) >>> 0;
	        carry = (carry / BASE) >>> 0;
	      }
	      if (carry !== 0) { throw new Error('Non-zero carry') }
	      length = i;
	      pbegin++;
	    }
	        // Skip leading zeroes in base58 result.
	    var it2 = size - length;
	    while (it2 !== size && b58[it2] === 0) {
	      it2++;
	    }
	        // Translate the result into a string.
	    var str = LEADER.repeat(zeroes);
	    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }
	    return str
	  }
	  function decodeUnsafe (source) {
	    if (typeof source !== 'string') { throw new TypeError('Expected String') }
	    if (source.length === 0) { return _Buffer.alloc(0) }
	    var psz = 0;
	        // Skip and count leading '1's.
	    var zeroes = 0;
	    var length = 0;
	    while (source[psz] === LEADER) {
	      zeroes++;
	      psz++;
	    }
	        // Allocate enough space in big-endian base256 representation.
	    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.
	    var b256 = new Uint8Array(size);
	        // Process the characters.
	    while (psz < source.length) {
	            // Find code of next character
	      var charCode = source.charCodeAt(psz);
	            // Base map can not be indexed using char code
	      if (charCode > 255) { return }
	            // Decode character
	      var carry = BASE_MAP[charCode];
	            // Invalid character
	      if (carry === 255) { return }
	      var i = 0;
	      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
	        carry += (BASE * b256[it3]) >>> 0;
	        b256[it3] = (carry % 256) >>> 0;
	        carry = (carry / 256) >>> 0;
	      }
	      if (carry !== 0) { throw new Error('Non-zero carry') }
	      length = i;
	      psz++;
	    }
	        // Skip leading zeroes in b256.
	    var it4 = size - length;
	    while (it4 !== size && b256[it4] === 0) {
	      it4++;
	    }
	    var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
	    vch.fill(0x00, 0, zeroes);
	    var j = zeroes;
	    while (it4 !== size) {
	      vch[j++] = b256[it4++];
	    }
	    return vch
	  }
	  function decode (string) {
	    var buffer = decodeUnsafe(string);
	    if (buffer) { return buffer }
	    throw new Error('Non-base' + BASE + ' character')
	  }
	  return {
	    encode: encode,
	    decodeUnsafe: decodeUnsafe,
	    decode: decode
	  }
	}
	src$1 = base;
	return src$1;
}

var bs58;
var hasRequiredBs58;

function requireBs58 () {
	if (hasRequiredBs58) return bs58;
	hasRequiredBs58 = 1;
	var basex = requireSrc$2();
	var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';

	bs58 = basex(ALPHABET);
	return bs58;
}

var base;
var hasRequiredBase;

function requireBase () {
	if (hasRequiredBase) return base;
	hasRequiredBase = 1;

	var base58 = requireBs58();
	var Buffer = requireSafeBuffer().Buffer;

	base = function (checksumFn) {
	  // Encode a buffer as a base58-check encoded string
	  function encode (payload) {
	    var checksum = checksumFn(payload);

	    return base58.encode(Buffer.concat([
	      payload,
	      checksum
	    ], payload.length + 4))
	  }

	  function decodeRaw (buffer) {
	    var payload = buffer.slice(0, -4);
	    var checksum = buffer.slice(-4);
	    var newChecksum = checksumFn(payload);

	    if (checksum[0] ^ newChecksum[0] |
	        checksum[1] ^ newChecksum[1] |
	        checksum[2] ^ newChecksum[2] |
	        checksum[3] ^ newChecksum[3]) return

	    return payload
	  }

	  // Decode a base58-check encoded string to a buffer, no result if checksum is wrong
	  function decodeUnsafe (string) {
	    var buffer = base58.decodeUnsafe(string);
	    if (!buffer) return

	    return decodeRaw(buffer)
	  }

	  function decode (string) {
	    var buffer = base58.decode(string);
	    var payload = decodeRaw(buffer);
	    if (!payload) throw new Error('Invalid checksum')
	    return payload
	  }

	  return {
	    encode: encode,
	    decode: decode,
	    decodeUnsafe: decodeUnsafe
	  }
	};
	return base;
}

var bs58check;
var hasRequiredBs58check;

function requireBs58check () {
	if (hasRequiredBs58check) return bs58check;
	hasRequiredBs58check = 1;

	var createHash = requireCreateHash();
	var bs58checkBase = requireBase();

	// SHA256(SHA256(buffer))
	function sha256x2 (buffer) {
	  var tmp = createHash('sha256').update(buffer).digest();
	  return createHash('sha256').update(tmp).digest()
	}

	bs58check = bs58checkBase(sha256x2);
	return bs58check;
}

var wif;
var hasRequiredWif;

function requireWif () {
	if (hasRequiredWif) return wif;
	hasRequiredWif = 1;
	var bs58check = requireBs58check();

	function decodeRaw (buffer, version) {
	  // check version only if defined
	  if (version !== undefined && buffer[0] !== version) throw new Error('Invalid network version')

	  // uncompressed
	  if (buffer.length === 33) {
	    return {
	      version: buffer[0],
	      privateKey: buffer.slice(1, 33),
	      compressed: false
	    }
	  }

	  // invalid length
	  if (buffer.length !== 34) throw new Error('Invalid WIF length')

	  // invalid compression flag
	  if (buffer[33] !== 0x01) throw new Error('Invalid compression flag')

	  return {
	    version: buffer[0],
	    privateKey: buffer.slice(1, 33),
	    compressed: true
	  }
	}

	function encodeRaw (version, privateKey, compressed) {
	  var result = new Buffer$1(compressed ? 34 : 33);

	  result.writeUInt8(version, 0);
	  privateKey.copy(result, 1);

	  if (compressed) {
	    result[33] = 0x01;
	  }

	  return result
	}

	function decode (string, version) {
	  return decodeRaw(bs58check.decode(string), version)
	}

	function encode (version, privateKey, compressed) {
	  if (typeof version === 'number') return bs58check.encode(encodeRaw(version, privateKey, compressed))

	  return bs58check.encode(
	    encodeRaw(
	      version.version,
	      version.privateKey,
	      version.compressed
	    )
	  )
	}

	wif = {
	  decode: decode,
	  decodeRaw: decodeRaw,
	  encode: encode,
	  encodeRaw: encodeRaw
	};
	return wif;
}

var testecc = {};

var hasRequiredTestecc;

function requireTestecc () {
	if (hasRequiredTestecc) return testecc;
	hasRequiredTestecc = 1;
	Object.defineProperty(testecc, '__esModule', { value: true });
	testecc.testEcc = void 0;
	const h = (hex) => Buffer$1.from(hex, 'hex');
	function testEcc(ecc) {
	  assert(
	    ecc.isPoint(
	      h('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
	    ),
	  );
	  assert(
	    !ecc.isPoint(
	      h('030000000000000000000000000000000000000000000000000000000000000005'),
	    ),
	  );
	  assert(
	    ecc.isPrivate(
	      h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
	    ),
	  );
	  // order - 1
	  assert(
	    ecc.isPrivate(
	      h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140'),
	    ),
	  );
	  // 0
	  assert(
	    !ecc.isPrivate(
	      h('0000000000000000000000000000000000000000000000000000000000000000'),
	    ),
	  );
	  // order
	  assert(
	    !ecc.isPrivate(
	      h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),
	    ),
	  );
	  // order + 1
	  assert(
	    !ecc.isPrivate(
	      h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142'),
	    ),
	  );
	  // 1 + 0 == 1
	  assert(
	    Buffer$1.from(
	      ecc.privateAdd(
	        h('0000000000000000000000000000000000000000000000000000000000000001'),
	        h('0000000000000000000000000000000000000000000000000000000000000000'),
	      ),
	    ).equals(
	      h('0000000000000000000000000000000000000000000000000000000000000001'),
	    ),
	  );
	  // -3 + 3 == 0
	  assert(
	    ecc.privateAdd(
	      h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e'),
	      h('0000000000000000000000000000000000000000000000000000000000000003'),
	    ) === null,
	  );
	  assert(
	    Buffer$1.from(
	      ecc.privateAdd(
	        h('e211078564db65c3ce7704f08262b1f38f1ef412ad15b5ac2d76657a63b2c500'),
	        h('b51fbb69051255d1becbd683de5848242a89c229348dd72896a87ada94ae8665'),
	      ),
	    ).equals(
	      h('9730c2ee69edbb958d42db7460bafa18fef9d955325aec99044c81c8282b0a24'),
	    ),
	  );
	  assert(
	    Buffer$1.from(
	      ecc.privateNegate(
	        h('0000000000000000000000000000000000000000000000000000000000000001'),
	      ),
	    ).equals(
	      h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140'),
	    ),
	  );
	  assert(
	    Buffer$1.from(
	      ecc.privateNegate(
	        h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e'),
	      ),
	    ).equals(
	      h('0000000000000000000000000000000000000000000000000000000000000003'),
	    ),
	  );
	  assert(
	    Buffer$1.from(
	      ecc.privateNegate(
	        h('b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af'),
	      ),
	    ).equals(
	      h('4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792'),
	    ),
	  );
	  assert(
	    Buffer$1.from(
	      ecc.pointCompress(
	        h(
	          '0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
	        ),
	        true,
	      ),
	    ).equals(
	      h('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
	    ),
	  );
	  assert(
	    Buffer$1.from(
	      ecc.pointCompress(
	        h(
	          '0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
	        ),
	        false,
	      ),
	    ).equals(
	      h(
	        '0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
	      ),
	    ),
	  );
	  assert(
	    Buffer$1.from(
	      ecc.pointCompress(
	        h('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
	        true,
	      ),
	    ).equals(
	      h('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
	    ),
	  );
	  assert(
	    Buffer$1.from(
	      ecc.pointCompress(
	        h('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
	        false,
	      ),
	    ).equals(
	      h(
	        '0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
	      ),
	    ),
	  );
	  assert(
	    Buffer$1.from(
	      ecc.pointFromScalar(
	        h('b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af'),
	      ),
	    ).equals(
	      h('02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99'),
	    ),
	  );
	  assert(
	    ecc.xOnlyPointAddTweak(
	      h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
	      h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140'),
	    ) === null,
	  );
	  let xOnlyRes = ecc.xOnlyPointAddTweak(
	    h('1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b'),
	    h('a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac'),
	  );
	  assert(
	    Buffer$1.from(xOnlyRes.xOnlyPubkey).equals(
	      h('e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf'),
	    ) && xOnlyRes.parity === 1,
	  );
	  xOnlyRes = ecc.xOnlyPointAddTweak(
	    h('2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991'),
	    h('823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47'),
	  );
	  assert(
	    Buffer$1.from(xOnlyRes.xOnlyPubkey).equals(
	      h('9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c'),
	    ) && xOnlyRes.parity === 0,
	  );
	  assert(
	    Buffer$1.from(
	      ecc.sign(
	        h('5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed'),
	        h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140'),
	      ),
	    ).equals(
	      h(
	        '54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5',
	      ),
	    ),
	  );
	  assert(
	    ecc.verify(
	      h('5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed'),
	      h('0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
	      h(
	        '54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5',
	      ),
	    ),
	  );
	  if (ecc.signSchnorr) {
	    assert(
	      Buffer$1.from(
	        ecc.signSchnorr(
	          h('7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c'),
	          h('c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9'),
	          h('c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906'),
	        ),
	      ).equals(
	        h(
	          '5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7',
	        ),
	      ),
	    );
	  }
	  if (ecc.verifySchnorr) {
	    assert(
	      ecc.verifySchnorr(
	        h('7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c'),
	        h('dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8'),
	        h(
	          '5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7',
	        ),
	      ),
	    );
	  }
	}
	testecc.testEcc = testEcc;
	function assert(bool) {
	  if (!bool) throw new Error('ecc library invalid');
	}
	return testecc;
}

var hasRequiredEcpair;

function requireEcpair () {
	if (hasRequiredEcpair) return ecpair;
	hasRequiredEcpair = 1;
	Object.defineProperty(ecpair, '__esModule', { value: true });
	ecpair.ECPairFactory = ecpair.networks = void 0;
	const networks = requireNetworks();
	ecpair.networks = networks;
	const types = requireTypes$1();
	const randomBytes = requireRandombytes();
	const wif = requireWif();
	const testecc_1 = requireTestecc();
	const isOptions = types.typeforce.maybe(
	  types.typeforce.compile({
	    compressed: types.maybe(types.Boolean),
	    network: types.maybe(types.Network),
	  }),
	);
	const toXOnly = (pubKey) =>
	  pubKey.length === 32 ? pubKey : pubKey.slice(1, 33);
	function ECPairFactory(ecc) {
	  (0, testecc_1.testEcc)(ecc);
	  function isPoint(maybePoint) {
	    return ecc.isPoint(maybePoint);
	  }
	  function fromPrivateKey(buffer, options) {
	    types.typeforce(types.Buffer256bit, buffer);
	    if (!ecc.isPrivate(buffer))
	      throw new TypeError('Private key not in range [1, n)');
	    types.typeforce(isOptions, options);
	    return new ECPair(buffer, undefined, options);
	  }
	  function fromPublicKey(buffer, options) {
	    types.typeforce(ecc.isPoint, buffer);
	    types.typeforce(isOptions, options);
	    return new ECPair(undefined, buffer, options);
	  }
	  function fromWIF(wifString, network) {
	    const decoded = wif.decode(wifString);
	    const version = decoded.version;
	    // list of networks?
	    if (types.Array(network)) {
	      network = network
	        .filter((x) => {
	          return version === x.wif;
	        })
	        .pop();
	      if (!network) throw new Error('Unknown network version');
	      // otherwise, assume a network object (or default to bitcoin)
	    } else {
	      network = network || networks.bitcoin;
	      if (version !== network.wif) throw new Error('Invalid network version');
	    }
	    return fromPrivateKey(decoded.privateKey, {
	      compressed: decoded.compressed,
	      network: network,
	    });
	  }
	  function makeRandom(options) {
	    types.typeforce(isOptions, options);
	    if (options === undefined) options = {};
	    const rng = options.rng || randomBytes;
	    let d;
	    do {
	      d = rng(32);
	      types.typeforce(types.Buffer256bit, d);
	    } while (!ecc.isPrivate(d));
	    return fromPrivateKey(d, options);
	  }
	  class ECPair {
	    __D;
	    __Q;
	    compressed;
	    network;
	    lowR;
	    constructor(__D, __Q, options) {
	      this.__D = __D;
	      this.__Q = __Q;
	      this.lowR = false;
	      if (options === undefined) options = {};
	      this.compressed =
	        options.compressed === undefined ? true : options.compressed;
	      this.network = options.network || networks.bitcoin;
	      if (__Q !== undefined)
	        this.__Q = Buffer$1.from(ecc.pointCompress(__Q, this.compressed));
	    }
	    get privateKey() {
	      return this.__D;
	    }
	    get publicKey() {
	      if (!this.__Q) {
	        // It is not possible for both `__Q` and `__D` to be `undefined` at the same time.
	        // The factory methods guard for this.
	        const p = ecc.pointFromScalar(this.__D, this.compressed);
	        // It is not possible for `p` to be null.
	        // `fromPrivateKey()` checks that `__D` is a valid scalar.
	        this.__Q = Buffer$1.from(p);
	      }
	      return this.__Q;
	    }
	    toWIF() {
	      if (!this.__D) throw new Error('Missing private key');
	      return wif.encode(this.network.wif, this.__D, this.compressed);
	    }
	    tweak(t) {
	      if (this.privateKey) return this.tweakFromPrivateKey(t);
	      return this.tweakFromPublicKey(t);
	    }
	    sign(hash, lowR) {
	      if (!this.__D) throw new Error('Missing private key');
	      if (lowR === undefined) lowR = this.lowR;
	      if (lowR === false) {
	        return Buffer$1.from(ecc.sign(hash, this.__D));
	      } else {
	        let sig = ecc.sign(hash, this.__D);
	        const extraData = Buffer$1.alloc(32, 0);
	        let counter = 0;
	        // if first try is lowR, skip the loop
	        // for second try and on, add extra entropy counting up
	        while (sig[0] > 0x7f) {
	          counter++;
	          extraData.writeUIntLE(counter, 0, 6);
	          sig = ecc.sign(hash, this.__D, extraData);
	        }
	        return Buffer$1.from(sig);
	      }
	    }
	    signSchnorr(hash) {
	      if (!this.privateKey) throw new Error('Missing private key');
	      if (!ecc.signSchnorr)
	        throw new Error('signSchnorr not supported by ecc library');
	      return Buffer$1.from(ecc.signSchnorr(hash, this.privateKey));
	    }
	    verify(hash, signature) {
	      return ecc.verify(hash, this.publicKey, signature);
	    }
	    verifySchnorr(hash, signature) {
	      if (!ecc.verifySchnorr)
	        throw new Error('verifySchnorr not supported by ecc library');
	      return ecc.verifySchnorr(hash, this.publicKey.subarray(1, 33), signature);
	    }
	    tweakFromPublicKey(t) {
	      const xOnlyPubKey = toXOnly(this.publicKey);
	      const tweakedPublicKey = ecc.xOnlyPointAddTweak(xOnlyPubKey, t);
	      if (!tweakedPublicKey || tweakedPublicKey.xOnlyPubkey === null)
	        throw new Error('Cannot tweak public key!');
	      const parityByte = Buffer$1.from([
	        tweakedPublicKey.parity === 0 ? 0x02 : 0x03,
	      ]);
	      return fromPublicKey(
	        Buffer$1.concat([parityByte, tweakedPublicKey.xOnlyPubkey]),
	        { network: this.network, compressed: this.compressed },
	      );
	    }
	    tweakFromPrivateKey(t) {
	      const hasOddY =
	        this.publicKey[0] === 3 ||
	        (this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1);
	      const privateKey = hasOddY
	        ? ecc.privateNegate(this.privateKey)
	        : this.privateKey;
	      const tweakedPrivateKey = ecc.privateAdd(privateKey, t);
	      if (!tweakedPrivateKey) throw new Error('Invalid tweaked private key!');
	      return fromPrivateKey(Buffer$1.from(tweakedPrivateKey), {
	        network: this.network,
	        compressed: this.compressed,
	      });
	    }
	  }
	  return {
	    isPoint,
	    fromPrivateKey,
	    fromPublicKey,
	    fromWIF,
	    makeRandom,
	  };
	}
	ecpair.ECPairFactory = ECPairFactory;
	return ecpair;
}

var hasRequiredSrc$1;

function requireSrc$1 () {
	if (hasRequiredSrc$1) return src$2;
	hasRequiredSrc$1 = 1;
	(function (exports$1) {
		Object.defineProperty(exports$1, '__esModule', { value: true });
		exports$1.networks = exports$1.ECPairFactory = exports$1.default = void 0;
		var ecpair_1 = requireEcpair();
		Object.defineProperty(exports$1, 'default', {
		  enumerable: true,
		  get: function () {
		    return ecpair_1.ECPairFactory;
		  },
		});
		Object.defineProperty(exports$1, 'ECPairFactory', {
		  enumerable: true,
		  get: function () {
		    return ecpair_1.ECPairFactory;
		  },
		});
		Object.defineProperty(exports$1, 'networks', {
		  enumerable: true,
		  get: function () {
		    return ecpair_1.networks;
		  },
		}); 
	} (src$2));
	return src$2;
}

var srcExports = requireSrc$1();

initEccLib(ecc);
const BIP32factory = typeof bip32 === 'function' ? bip32 : cjsExports.BIP32Factory;
if (!BIP32factory) {
    throw new Error('Failed to load BIP32 library');
}
const Point = secp256k1.Point;
const CURVE_N = Point.Fn.ORDER;
const TAP_TAG = utf8ToBytes('TapTweak');
const TAP_TAG_HASH = sha256$4(TAP_TAG);
function tapTweakHash(x) {
    return sha256$4(concatBytes$2(TAP_TAG_HASH, TAP_TAG_HASH, x));
}
class EcKeyPair {
    static fromWIF(wif, network = bitcoin$1) {
        return this.ECPair.fromWIF(wif, network);
    }
    static fromPrivateKey(privateKey, network = bitcoin$1) {
        return this.ECPair.fromPrivateKey(!Buffer$1.isBuffer(privateKey) ? Buffer$1.from(privateKey) : privateKey, { network });
    }
    static fromPublicKey(publicKey, network = bitcoin$1) {
        const buf = !Buffer$1.isBuffer(publicKey) ? Buffer$1.from(publicKey) : publicKey;
        return this.ECPair.fromPublicKey(buf, { network });
    }
    static generateMultiSigAddress(pubKeys, minimumSignatureRequired, network = bitcoin$1) {
        const publicKeys = this.verifyPubKeys(pubKeys, network);
        if (publicKeys.length !== pubKeys.length)
            throw new Error(`Contains invalid public keys`);
        const p2ms$1 = p2ms({
            m: minimumSignatureRequired,
            pubkeys: publicKeys,
            network: network,
        });
        const p2wsh$1 = p2wsh({ redeem: p2ms$1, network: network });
        const address = p2wsh$1.address;
        if (!address) {
            throw new Error('Failed to generate address');
        }
        return address;
    }
    static verifyPubKeys(pubKeys, network = bitcoin$1) {
        return pubKeys.map((pubKey) => {
            const key = EcKeyPair.fromPublicKey(pubKey, network);
            if (!key) {
                throw new Error('Failed to regenerate key');
            }
            return Buffer$1.from(key.publicKey);
        });
    }
    static getP2WPKHAddress(keyPair, network = bitcoin$1) {
        const res = p2wpkh({ pubkey: Buffer$1.from(keyPair.publicKey), network: network });
        if (!res.address) {
            throw new Error('Failed to generate wallet');
        }
        return res.address;
    }
    static tweakedPubKeyToAddress(tweakedPubKeyHex, network) {
        if (tweakedPubKeyHex.startsWith('0x')) {
            tweakedPubKeyHex = tweakedPubKeyHex.slice(2);
        }
        let tweakedPubKeyBuffer = Buffer$1.from(tweakedPubKeyHex, 'hex');
        if (tweakedPubKeyBuffer.length !== 32) {
            tweakedPubKeyBuffer = toXOnly(tweakedPubKeyBuffer);
        }
        return EcKeyPair.tweakedPubKeyBufferToAddress(tweakedPubKeyBuffer, network);
    }
    static tweakedPubKeyBufferToAddress(tweakedPubKeyBuffer, network) {
        const { address } = p2tr({
            pubkey: Buffer$1.isBuffer(tweakedPubKeyBuffer)
                ? tweakedPubKeyBuffer
                : Buffer$1.from(tweakedPubKeyBuffer),
            network: network,
        });
        if (!address) {
            throw new Error('Failed to generate Taproot address');
        }
        return address;
    }
    static p2op(bytes, network = bitcoin$1, deploymentVersion = 0) {
        const witnessProgram = Buffer$1.concat([
            Buffer$1.from([deploymentVersion]),
            bitcoin.crypto.hash160(Buffer$1.from(bytes)),
        ]);
        if (witnessProgram.length < 2 || witnessProgram.length > 40) {
            throw new Error('Witness program must be 2-40 bytes.');
        }
        const scriptData = compile([opcodes.OP_16, witnessProgram]);
        return fromOutputScript(scriptData, network);
    }
    static xOnlyTweakedPubKeyToAddress(tweakedPubKeyHex, network) {
        if (tweakedPubKeyHex.startsWith('0x')) {
            tweakedPubKeyHex = tweakedPubKeyHex.slice(2);
        }
        const tweakedPubKeyBuffer = Buffer$1.from(tweakedPubKeyHex, 'hex');
        const { address } = p2tr({
            pubkey: tweakedPubKeyBuffer,
            network: network,
        });
        if (!address) {
            throw new Error('Failed to generate Taproot address');
        }
        return address;
    }
    static tweakPublicKey(pub) {
        if (typeof pub === 'string' && pub.startsWith('0x'))
            pub = pub.slice(2);
        const P = Point.fromHex(pub);
        const Peven = (P.y & 1n) === 0n ? P : P.negate();
        const xBytes = Buffer$1.from(Peven.toBytes(true).subarray(1));
        const tBytes = tapTweakHash(xBytes);
        const t = mod$1(bytesToNumberBE(tBytes), CURVE_N);
        const Q = Peven.add(Point.BASE.multiply(t));
        return Buffer$1.from(Q.toBytes(true));
    }
    static tweakBatchSharedT(pubkeys, tweakScalar) {
        const T = Point.BASE.multiply(tweakScalar);
        return pubkeys.map((bytes) => {
            const P = Point.fromHex(bytes);
            const P_even = P.y % 2n === 0n ? P : P.negate();
            const Q = P_even.add(T);
            return Q.toBytes(true);
        });
    }
    static generateWallet(network = bitcoin$1, securityLevel = cjsExports.MLDSASecurityLevel.LEVEL2) {
        const keyPair = this.ECPair.makeRandom({
            network: network,
        });
        const wallet = this.getP2WPKHAddress(keyPair, network);
        if (!wallet) {
            throw new Error('Failed to generate wallet');
        }
        const quantumKeyPair = this.generateQuantumKeyPair(securityLevel, network);
        return {
            address: wallet,
            privateKey: keyPair.toWIF(),
            publicKey: Buffer$1.from(keyPair.publicKey).toString('hex'),
            quantumPrivateKey: Buffer$1.from(quantumKeyPair.privateKey).toString('hex'),
            quantumPublicKey: Buffer$1.from(quantumKeyPair.publicKey).toString('hex'),
        };
    }
    static generateQuantumKeyPair(securityLevel = cjsExports.MLDSASecurityLevel.LEVEL2, network = bitcoin$1) {
        const randomSeed = randomBytes$3(64);
        const quantumRoot = cjsExports.QuantumBIP32Factory.fromSeed(Buffer$1.from(randomSeed), network, securityLevel);
        if (!quantumRoot.privateKey || !quantumRoot.publicKey) {
            throw new Error('Failed to generate quantum keypair');
        }
        return {
            privateKey: Buffer$1.from(quantumRoot.privateKey),
            publicKey: Buffer$1.from(quantumRoot.publicKey),
        };
    }
    static verifyContractAddress(contractAddress, network = bitcoin$1) {
        return !!toOutputScript(contractAddress, network);
    }
    static getLegacySegwitAddress(keyPair, network = bitcoin$1) {
        const wallet = p2sh({
            redeem: p2wpkh({ pubkey: Buffer$1.from(keyPair.publicKey), network: network }),
            network: network,
        });
        if (!wallet.address) {
            throw new Error('Failed to generate wallet');
        }
        return wallet.address;
    }
    static getLegacyAddress(keyPair, network = bitcoin$1) {
        const wallet = p2pkh({ pubkey: Buffer$1.from(keyPair.publicKey), network: network });
        if (!wallet.address) {
            throw new Error('Failed to generate wallet');
        }
        return wallet.address;
    }
    static getP2PKH(publicKey, network = bitcoin$1) {
        const wallet = p2pkh({ pubkey: Buffer$1.from(publicKey), network: network });
        if (!wallet.address) {
            throw new Error('Failed to generate wallet');
        }
        return wallet.address;
    }
    static getP2PKAddress(keyPair, network = bitcoin$1) {
        const wallet = p2pk({ pubkey: Buffer$1.from(keyPair.publicKey), network: network });
        if (!wallet.output) {
            throw new Error('Failed to generate wallet');
        }
        return '0x' + wallet.output.toString('hex');
    }
    static generateRandomKeyPair(network = bitcoin$1) {
        return this.ECPair.makeRandom({
            network: network,
        });
    }
    static fromSeed(seed, network = bitcoin$1) {
        return this.BIP32.fromSeed(seed, network);
    }
    static getTaprootAddress(keyPair, network = bitcoin$1) {
        const { address } = p2tr({
            internalPubkey: toXOnly(Buffer$1.from(keyPair.publicKey)),
            network: network,
        });
        if (!address) {
            throw new Error(`Failed to generate sender address for transaction`);
        }
        return address;
    }
    static getTaprootAddressFromAddress(inAddr, network = bitcoin$1) {
        const { address } = p2tr({
            address: inAddr,
            network: network,
        });
        if (!address) {
            throw new Error(`Failed to generate sender address for transaction`);
        }
        return address;
    }
    static fromSeedKeyPair(seed, network = bitcoin$1) {
        const fromSeed = this.BIP32.fromSeed(seed, network);
        const privKey = fromSeed.privateKey;
        if (!privKey)
            throw new Error('Failed to generate key pair');
        return this.ECPair.fromPrivateKey(Buffer$1.from(privKey), { network });
    }
}
EcKeyPair.BIP32 = BIP32factory(ecc);
EcKeyPair.ECPair = srcExports.ECPairFactory(ecc);
(() => {
    Point.BASE.precompute(8);
})();

const ADDRESS_BYTE_LENGTH = 32;
const U256_BYTE_LENGTH = 32;
const U128_BYTE_LENGTH = 16;
const U64_BYTE_LENGTH = 8;
const U32_BYTE_LENGTH = 4;
const U16_BYTE_LENGTH = 2;
const U8_BYTE_LENGTH = 1;
const I128_BYTE_LENGTH = 16;

class BufferHelper {
    static bufferToUint8Array(buffer) {
        if (Buffer$1.isBuffer(buffer)) {
            const length = buffer.byteLength;
            const arrayBuffer = new ArrayBuffer(length);
            const view = new Uint8Array(arrayBuffer);
            for (let i = 0; i < length; ++i) {
                view[i] = buffer[i];
            }
            return view;
        }
        return buffer;
    }
    static uint8ArrayToHex(input) {
        return Buffer$1.from(input.buffer, 0, input.byteLength).toString('hex');
    }
    static hexToUint8Array(input) {
        if (input.startsWith('0x')) {
            input = input.substring(2);
        }
        if (input.length % 2 !== 0) {
            input = '0' + input;
        }
        const lengthS = input.length / 2;
        const buffer = new Uint8Array(lengthS);
        for (let i = 0; i < lengthS; i++) {
            buffer[i] = parseInt(input.substring(i * 2, i * 2 + 2), 16);
        }
        return buffer;
    }
    static pointerToUint8Array(pointer) {
        const pointerHex = pointer.toString(16).padStart(64, '0');
        return BufferHelper.hexToUint8Array(pointerHex);
    }
    static uint8ArrayToPointer(input) {
        const hex = BufferHelper.uint8ArrayToHex(input);
        return BigInt('0x' + hex);
    }
    static valueToUint8Array(value, length = U256_BYTE_LENGTH) {
        const valueHex = value.toString(16).padStart(length * 2, '0');
        return BufferHelper.hexToUint8Array(valueHex);
    }
    static uint8ArrayToValue(input) {
        const hex = BufferHelper.uint8ArrayToHex(input);
        if (!hex)
            return BigInt(0);
        return BigInt('0x' + hex);
    }
}
BufferHelper.EXPECTED_BUFFER_LENGTH = 32;

const hexPattern = /^[0-9a-fA-F]+$/;
class BitcoinUtils {
  static btcToSatoshi(btc) {
    return BigInt(btc * 1e8);
  }
  static rndBytes() {
    const buf = BitcoinUtils.getSafeRandomValues(64);
    return Buffer$1.from(buf);
  }
  static getSafeRandomValues(length) {
    if (typeof globalThis.window !== "undefined" && globalThis.window.crypto && typeof globalThis.window.crypto.getRandomValues === "function") {
      const array = new Uint8Array(length);
      window.crypto.getRandomValues(array);
      return Buffer$1.from(array);
    } else if (globalThis.crypto && typeof globalThis.crypto.getRandomValues === "function") {
      const array = new Uint8Array(length);
      globalThis.crypto.getRandomValues(array);
      return Buffer$1.from(array);
    } else {
      console.log(`No secure random number generator available. Please upgrade your environment.`, globalThis.window.crypto, globalThis.crypto);
      throw new Error("No secure random number generator available. Please upgrade your environment.");
    }
  }
  static isValidHex(hex) {
    return hexPattern.test(hex);
  }
  static opnetHash(data) {
    const hashed = createHash$1("sha512");
    hashed.update(data);
    const hash = hashed.digest();
    return `0x${Buffer$1.from(hash).toString("hex")}`;
  }
}

class P2WDADetector {
    static isP2WDAUTXO(utxo) {
        if (!utxo.witnessScript) {
            return false;
        }
        const witnessScript = Buffer$1$1.isBuffer(utxo.witnessScript)
            ? utxo.witnessScript
            : Buffer$1$1.from(utxo.witnessScript, 'hex');
        return this.isP2WDAWitnessScript(witnessScript);
    }
    static isP2WDAWitnessScript(witnessScript) {
        try {
            const decompiled = decompile(witnessScript);
            if (!decompiled || decompiled.length !== 7) {
                return false;
            }
            for (let i = 0; i < 5; i++) {
                if (decompiled[i] !== opcodes.OP_2DROP) {
                    return false;
                }
            }
            return (Buffer$1$1.isBuffer(decompiled[5]) &&
                decompiled[5].length === 33 &&
                decompiled[6] === opcodes.OP_CHECKSIG);
        }
        catch {
            return false;
        }
    }
    static generateP2WDAAddress(publicKey, network) {
        if (publicKey.length !== 33) {
            throw new Error('Public key must be 33 bytes (compressed)');
        }
        const witnessScript = compile([
            opcodes.OP_2DROP,
            opcodes.OP_2DROP,
            opcodes.OP_2DROP,
            opcodes.OP_2DROP,
            opcodes.OP_2DROP,
            publicKey,
            opcodes.OP_CHECKSIG,
        ]);
        const p2wsh$1 = p2wsh({
            redeem: { output: witnessScript },
            network,
        });
        if (!p2wsh$1.address || !p2wsh$1.output) {
            throw new Error('Failed to generate P2WDA address');
        }
        return {
            address: p2wsh$1.address,
            witnessScript,
            scriptPubKey: p2wsh$1.output,
        };
    }
    static extractPublicKeyFromP2WDA(witnessScript) {
        try {
            const decompiled = decompile(witnessScript);
            if (!decompiled || decompiled.length !== 7) {
                return null;
            }
            for (let i = 0; i < 5; i++) {
                if (decompiled[i] !== opcodes.OP_2DROP) {
                    return null;
                }
            }
            if (Buffer$1$1.isBuffer(decompiled[5]) &&
                decompiled[5].length === 33 &&
                decompiled[6] === opcodes.OP_CHECKSIG) {
                return decompiled[5];
            }
            return null;
        }
        catch {
            return null;
        }
    }
    static createSimpleP2WDAWitness(transactionSignature, witnessScript) {
        const witnessStack = [transactionSignature];
        for (let i = 0; i < 10; i++) {
            witnessStack.push(Buffer$1$1.alloc(0));
        }
        witnessStack.push(witnessScript);
        return witnessStack;
    }
    static validateP2WDASignature(publicKey, dataSignature, operationData) {
        return dataSignature.length === 64;
    }
    static estimateP2WDAWitnessSize(dataSize = 0) {
        return 72 + dataSize + 39 + 12;
    }
    static couldBeP2WDA(scriptPubKey) {
        return scriptPubKey.length === 34 && scriptPubKey[0] === 0x00 && scriptPubKey[1] === 0x20;
    }
}

initEccLib(ecc);
var AddressTypes;
(function (AddressTypes) {
    AddressTypes["P2PKH"] = "P2PKH";
    AddressTypes["P2OP"] = "P2OP";
    AddressTypes["P2SH_OR_P2SH_P2WPKH"] = "P2SH_OR_P2SH-P2WPKH";
    AddressTypes["P2PK"] = "P2PK";
    AddressTypes["P2TR"] = "P2TR";
    AddressTypes["P2WPKH"] = "P2WPKH";
    AddressTypes["P2WSH"] = "P2WSH";
    AddressTypes["P2WDA"] = "P2WDA";
})(AddressTypes || (AddressTypes = {}));
class AddressVerificator {
    static isValidP2TRAddress(inAddress, network) {
        if (!inAddress || inAddress.length < 50)
            return false;
        let isValidTapRootAddress = false;
        try {
            toOutputScript(inAddress, network);
            const decodedAddress = fromBech32(inAddress);
            isValidTapRootAddress = decodedAddress.version === 1;
        }
        catch { }
        return isValidTapRootAddress;
    }
    static isP2WPKHAddress(inAddress, network) {
        if (!inAddress || inAddress.length < 20 || inAddress.length > 50)
            return false;
        let isValidSegWitAddress = false;
        try {
            const decodedAddress = fromBech32(inAddress);
            toOutputScript(inAddress, network);
            isValidSegWitAddress =
                decodedAddress.version === 0 && decodedAddress.data.length === 20;
        }
        catch { }
        return isValidSegWitAddress;
    }
    static isP2WDAWitnessScript(witnessScript) {
        return P2WDADetector.isP2WDAWitnessScript(witnessScript);
    }
    static isP2PKHOrP2SH(addy, network) {
        try {
            const decodedBase58 = fromBase58Check(addy);
            if (decodedBase58.version === network.pubKeyHash) {
                return true;
            }
            return decodedBase58.version === network.scriptHash;
        }
        catch (error) {
            return false;
        }
    }
    static isValidPublicKey(input, network) {
        try {
            if (input.startsWith('0x')) {
                input = input.slice(2);
            }
            if (!BitcoinUtils.isValidHex(input)) {
                return false;
            }
            if (input.length === 64) {
                return true;
            }
            const pubKeyBuffer = Buffer$1.from(input, 'hex');
            if ((input.length === 130 && pubKeyBuffer[0] === 0x06) || pubKeyBuffer[0] === 0x07) {
                return true;
            }
            if (input.length === 66 || input.length === 130) {
                EcKeyPair.fromPublicKey(pubKeyBuffer, network);
                return true;
            }
        }
        catch (e) {
            return false;
        }
        return false;
    }
    static isValidMLDSAPublicKey(input) {
        try {
            let byteLength;
            if (Buffer$1.isBuffer(input) || input instanceof Uint8Array) {
                byteLength = input.length;
            }
            else {
                if (input.startsWith('0x')) {
                    input = input.slice(2);
                }
                if (!BitcoinUtils.isValidHex(input)) {
                    return null;
                }
                byteLength = input.length / 2;
            }
            switch (byteLength) {
                case 1312:
                    return cjsExports.MLDSASecurityLevel.LEVEL2;
                case 1952:
                    return cjsExports.MLDSASecurityLevel.LEVEL3;
                case 2592:
                    return cjsExports.MLDSASecurityLevel.LEVEL5;
                default:
                    return null;
            }
        }
        catch (e) {
            return null;
        }
    }
    static isValidP2OPAddress(inAddress, network) {
        if (!inAddress || inAddress.length < 20)
            return false;
        try {
            const decodedAddress = fromBech32(inAddress);
            const validPrefix = decodedAddress.prefix === network.bech32 ||
                decodedAddress.prefix === network.bech32Opnet;
            if (!validPrefix) {
                return false;
            }
            return decodedAddress.version === 16 && decodedAddress.data.length === 21;
        }
        catch {
            return false;
        }
    }
    static requireRedeemScript(addy, network) {
        try {
            const decodedBase58 = fromBase58Check(addy);
            if (decodedBase58.version === network.pubKeyHash) {
                return false;
            }
            return decodedBase58.version === network.scriptHash;
        }
        catch {
            return false;
        }
    }
    static detectAddressType(addy, network) {
        if (AddressVerificator.isValidPublicKey(addy, network)) {
            return AddressTypes.P2PK;
        }
        try {
            const decodedBase58 = fromBase58Check(addy);
            if (decodedBase58.version === network.pubKeyHash) {
                return AddressTypes.P2PKH;
            }
            if (decodedBase58.version === network.scriptHash) {
                return AddressTypes.P2SH_OR_P2SH_P2WPKH;
            }
        }
        catch { }
        try {
            const decodedBech32 = fromBech32(addy);
            if ((decodedBech32.prefix === network.bech32Opnet ||
                decodedBech32.prefix === network.bech32) &&
                decodedBech32.version === 16 &&
                decodedBech32.data.length === 21) {
                return AddressTypes.P2OP;
            }
            if (decodedBech32.prefix === network.bech32) {
                if (decodedBech32.version === 0 && decodedBech32.data.length === 20) {
                    return AddressTypes.P2WPKH;
                }
                if (decodedBech32.version === 0 && decodedBech32.data.length === 32) {
                    return AddressTypes.P2WSH;
                }
                if (decodedBech32.version === 1 && decodedBech32.data.length === 32) {
                    return AddressTypes.P2TR;
                }
            }
        }
        catch { }
        return null;
    }
    static detectAddressTypeWithWitnessScript(addy, network, witnessScript) {
        const baseType = AddressVerificator.detectAddressType(addy, network);
        if (baseType === AddressTypes.P2WSH && witnessScript) {
            if (AddressVerificator.isP2WDAWitnessScript(witnessScript)) {
                return AddressTypes.P2WDA;
            }
        }
        return baseType;
    }
    static validateP2WDAAddress(address, network, witnessScript) {
        try {
            const addressType = AddressVerificator.detectAddressType(address, network);
            if (addressType !== AddressTypes.P2WSH) {
                return {
                    isValid: false,
                    isPotentiallyP2WDA: false,
                    isDefinitelyP2WDA: false,
                    error: 'Not a P2WSH address',
                };
            }
            if (!witnessScript) {
                return {
                    isValid: true,
                    isPotentiallyP2WDA: true,
                    isDefinitelyP2WDA: false,
                };
            }
            if (!AddressVerificator.isP2WDAWitnessScript(witnessScript)) {
                return {
                    isValid: true,
                    isPotentiallyP2WDA: true,
                    isDefinitelyP2WDA: false,
                    error: 'Witness script does not match P2WDA pattern',
                };
            }
            const p2wsh$1 = p2wsh({
                redeem: { output: witnessScript },
                network,
            });
            if (p2wsh$1.address !== address) {
                return {
                    isValid: false,
                    isPotentiallyP2WDA: false,
                    isDefinitelyP2WDA: false,
                    error: 'Witness script does not match address',
                };
            }
            const publicKey = P2WDADetector.extractPublicKeyFromP2WDA(witnessScript);
            if (!publicKey) {
                return {
                    isValid: false,
                    isPotentiallyP2WDA: false,
                    isDefinitelyP2WDA: false,
                    error: 'Failed to extract public key from witness script',
                };
            }
            return {
                isValid: true,
                isPotentiallyP2WDA: true,
                isDefinitelyP2WDA: true,
                publicKey,
            };
        }
        catch (error) {
            return {
                isValid: false,
                isPotentiallyP2WDA: false,
                isDefinitelyP2WDA: false,
                error: error.message,
            };
        }
    }
}

const P = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn;
class Secp256k1PointDeriver {
    constructor(maxTries = 10000) {
        this.maxTries = maxTries;
    }
    findOrDeriveValidPoint(xBytes, failOnInvalidX = true, maxTries = this.maxTries) {
        if (xBytes.length !== 32) {
            throw new Error('xBytes must be exactly 32 bytes.');
        }
        let xCandidate = this.bytesToBigInt(xBytes) % P;
        let sqrtVal = this.isValidX(xCandidate);
        if (failOnInvalidX && sqrtVal === null) {
            throw new Error(`The given x is not a valid curve point.`);
        }
        let tries = 0;
        while (sqrtVal === null) {
            xCandidate = (xCandidate + 1n) % P;
            sqrtVal = this.isValidX(xCandidate);
            tries++;
            if (tries > maxTries) {
                throw new Error(`Could not find a valid X point within ${maxTries} increments.`);
            }
        }
        const y1 = sqrtVal;
        const y2 = (P - y1) % P;
        return { x: xCandidate, y1, y2 };
    }
    getCanonicalY(y, y2) {
        return y < y2 ? y : y2;
    }
    getHybridPublicKey(x, y) {
        const prefix = y % 2n === 0n ? 0x06 : 0x07;
        const xBytes = this.bigIntTo32Bytes(x);
        const yBytes = this.bigIntTo32Bytes(y);
        const hybrid = new Uint8Array(65);
        hybrid[0] = prefix;
        hybrid.set(xBytes, 1);
        hybrid.set(yBytes, 33);
        return hybrid;
    }
    isValidX(x) {
        const alpha = (this.modPow(x, 3n, P) + 7n) % P;
        return this.sqrtModP(alpha, P);
    }
    modPow(base, exp, m) {
        let result = 1n;
        let cur = base % m;
        let e = exp;
        while (e > 0) {
            if ((e & 1n) === 1n) {
                result = (result * cur) % m;
            }
            cur = (cur * cur) % m;
            e >>= 1n;
        }
        return result;
    }
    sqrtModP(a, prime) {
        const root = this.modPow(a, (prime + 1n) >> 2n, prime);
        if ((root * root) % prime !== a % prime) {
            return null;
        }
        return root;
    }
    bytesToBigInt(bytes) {
        let b = 0n;
        for (const byte of bytes) {
            b = (b << 8n) | BigInt(byte);
        }
        return b;
    }
    bigIntTo32Bytes(value) {
        const bytes = new Uint8Array(32);
        for (let i = 31; i >= 0; i--) {
            bytes[i] = Number(value & 0xffn);
            value >>= 8n;
        }
        return bytes;
    }
}

class ContractAddressBase {
    constructor() {
        this.deriver = new Secp256k1PointDeriver();
    }
    generateHybridKeyFromHash(input) {
        const p = this.deriver.findOrDeriveValidPoint(this.cloneBuffer(input), false);
        const y = this.deriver.getCanonicalY(p.y1, p.y2);
        return Buffer$1.from(this.deriver.getHybridPublicKey(p.x, y));
    }
    cloneBuffer(buffer) {
        return Buffer$1.from(buffer);
    }
}
const ContractAddress = new ContractAddressBase();

class TimeLockGenerator {
    static generateTimeLockAddress(publicKey, network = bitcoin$1, csvBlocks = TimeLockGenerator.CSV_BLOCKS) {
        const witnessScript = this.generateTimeLockScript(publicKey, csvBlocks);
        const p2wsh = bitcoin.payments.p2wsh({
            redeem: { output: witnessScript },
            network,
        });
        if (!p2wsh.address) {
            throw new Error('Failed to generate P2WSH address');
        }
        return {
            address: p2wsh.address,
            witnessScript: witnessScript,
        };
    }
    static generateTimeLockAddressP2TR(publicKey, network = bitcoin$1, csvBlocks = TimeLockGenerator.CSV_BLOCKS) {
        if (publicKey.length !== 32) {
            throw new Error('Public key must be 32 bytes for Taproot');
        }
        const witnessScript = this.generateTimeLockScript(publicKey, csvBlocks);
        const taproot = bitcoin.payments.p2tr({
            redeem: { output: witnessScript },
            network,
            internalPubkey: TimeLockGenerator.UNSPENDABLE_INTERNAL_KEY,
        });
        if (!taproot.address) {
            throw new Error('Failed to generate P2TR address');
        }
        return taproot.address;
    }
    static generateTimeLockScript(publicKey, csvBlocks = TimeLockGenerator.CSV_BLOCKS) {
        return compile([
            number.encode(csvBlocks),
            opcodes.OP_CHECKSEQUENCEVERIFY,
            opcodes.OP_DROP,
            publicKey,
            opcodes.OP_CHECKSIG,
        ]);
    }
}
TimeLockGenerator.UNSPENDABLE_INTERNAL_KEY = Buffer$1.from('50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0', 'hex');
TimeLockGenerator.CSV_BLOCKS = 75;

var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet$1 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Address_p2tr, _Address_p2op, _Address_network, _Address_originalPublicKey, _Address_keyPair, _Address_uncompressed, _Address_tweakedUncompressed, _Address_p2wda, _Address_mldsaPublicKey, _Address_cachedBigInt, _Address_cachedUint64Array, _Address_originalMDLSAPublicKey, _Address_mldsaLevel, _Address_pendingLegacyKey, _Address_legacyProcessed, _Address_legacyPublicKey;
class Address extends Uint8Array {
    constructor(mldsaPublicKey, publicKeyOrTweak) {
        super(ADDRESS_BYTE_LENGTH);
        _Address_p2tr.set(this, void 0);
        _Address_p2op.set(this, void 0);
        _Address_network.set(this, void 0);
        _Address_originalPublicKey.set(this, void 0);
        _Address_keyPair.set(this, void 0);
        _Address_uncompressed.set(this, void 0);
        _Address_tweakedUncompressed.set(this, void 0);
        _Address_p2wda.set(this, void 0);
        _Address_mldsaPublicKey.set(this, void 0);
        _Address_cachedBigInt.set(this, void 0);
        _Address_cachedUint64Array.set(this, void 0);
        _Address_originalMDLSAPublicKey.set(this, void 0);
        _Address_mldsaLevel.set(this, void 0);
        _Address_pendingLegacyKey.set(this, void 0);
        _Address_legacyProcessed.set(this, false);
        _Address_legacyPublicKey.set(this, void 0);
        if (!mldsaPublicKey) {
            return;
        }
        if (publicKeyOrTweak) {
            const validLengths = [ADDRESS_BYTE_LENGTH, 33, 65];
            if (!validLengths.includes(publicKeyOrTweak.length)) {
                throw new Error(`Invalid public key length ${publicKeyOrTweak.length}`);
            }
            __classPrivateFieldSet(this, _Address_pendingLegacyKey, new Uint8Array(publicKeyOrTweak.length), "f");
            __classPrivateFieldGet$1(this, _Address_pendingLegacyKey, "f").set(publicKeyOrTweak);
        }
        this.setMldsaKey(mldsaPublicKey);
    }
    get mldsaLevel() {
        return __classPrivateFieldGet$1(this, _Address_mldsaLevel, "f");
    }
    set mldsaLevel(level) {
        __classPrivateFieldSet(this, _Address_mldsaLevel, level, "f");
    }
    get originalMDLSAPublicKey() {
        return __classPrivateFieldGet$1(this, _Address_originalMDLSAPublicKey, "f");
    }
    set originalMDLSAPublicKey(key) {
        __classPrivateFieldSet(this, _Address_originalMDLSAPublicKey, new Uint8Array(key), "f");
    }
    get originalPublicKey() {
        this.ensureLegacyProcessed();
        return __classPrivateFieldGet$1(this, _Address_originalPublicKey, "f");
    }
    get mldsaPublicKey() {
        return __classPrivateFieldGet$1(this, _Address_mldsaPublicKey, "f");
    }
    get legacyPublicKey() {
        this.ensureLegacyProcessed();
        return __classPrivateFieldGet$1(this, _Address_legacyPublicKey, "f");
    }
    get keyPair() {
        this.ensureLegacyProcessed();
        if (!__classPrivateFieldGet$1(this, _Address_keyPair, "f")) {
            throw new Error('Legacy public key not set for address');
        }
        return __classPrivateFieldGet$1(this, _Address_keyPair, "f");
    }
    static dead() {
        return Address.fromString('0x0000000000000000000000000000000000000000000000000000000000000000', '0x04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f');
    }
    static fromString(mldsaPublicKey, legacyPublicKey) {
        if (!mldsaPublicKey) {
            throw new Error('Invalid public key');
        }
        if (mldsaPublicKey.startsWith('0x')) {
            mldsaPublicKey = mldsaPublicKey.slice(2);
        }
        if (!BitcoinUtils.isValidHex(mldsaPublicKey)) {
            throw new Error('You must only pass public keys in hexadecimal format. If you have an address such as bc1q... you must convert it to a public key first. Please refer to await provider.getPublicKeyInfo("bc1q..."). If the public key associated with the address is not found, you must force the user to enter the destination public key. It looks like: 0x020373626d317ae8788ce3280b491068610d840c23ecb64c14075bbb9f670af52c.');
        }
        let classicBuffer;
        if (legacyPublicKey) {
            if (legacyPublicKey.startsWith('0x')) {
                legacyPublicKey = legacyPublicKey.slice(2);
            }
            if (!BitcoinUtils.isValidHex(legacyPublicKey)) {
                throw new Error('You must only pass classical public keys in hexadecimal format. If you have an address such as bc1q... you must convert it to a public key first. Please refer to await provider.getPublicKeyInfo("bc1q..."). If the public key associated with the address is not found, you must force the user to enter the destination public key. It looks like: 0x020373626d317ae8788ce3280b491068610d840c23ecb64c14075bbb9f670af52c.');
            }
            classicBuffer = Buffer$1.from(legacyPublicKey, 'hex');
        }
        return new Address(Buffer$1.from(mldsaPublicKey, 'hex'), classicBuffer);
    }
    static wrap(bytes) {
        return new Address(bytes);
    }
    static uncompressedToCompressed(publicKey) {
        const buffer = Uint8Array.from(publicKey);
        const x = buffer.slice(1, 33);
        const y = buffer.slice(33);
        const compressed = Buffer$1.alloc(33);
        compressed[0] = 0x02 + (y[y.length - 1] & 0x01);
        compressed.set(x, 1);
        return compressed;
    }
    static fromBigInt(value) {
        const buffer = new Uint8Array(32);
        const view = new DataView(buffer.buffer);
        view.setBigUint64(0, (value >> 192n) & 0xffffffffffffffffn, false);
        view.setBigUint64(8, (value >> 128n) & 0xffffffffffffffffn, false);
        view.setBigUint64(16, (value >> 64n) & 0xffffffffffffffffn, false);
        view.setBigUint64(24, value & 0xffffffffffffffffn, false);
        return new Address(buffer);
    }
    static fromUint64Array(w0, w1, w2, w3) {
        const buffer = new Uint8Array(32);
        const view = new DataView(buffer.buffer);
        view.setBigUint64(0, w0, false);
        view.setBigUint64(8, w1, false);
        view.setBigUint64(16, w2, false);
        view.setBigUint64(24, w3, false);
        return new Address(buffer);
    }
    toUint64Array() {
        if (__classPrivateFieldGet$1(this, _Address_cachedUint64Array, "f") !== undefined) {
            return __classPrivateFieldGet$1(this, _Address_cachedUint64Array, "f");
        }
        const view = new DataView(this.buffer, this.byteOffset, 32);
        __classPrivateFieldSet(this, _Address_cachedUint64Array, [
            view.getBigUint64(0, false),
            view.getBigUint64(8, false),
            view.getBigUint64(16, false),
            view.getBigUint64(24, false),
        ], "f");
        return __classPrivateFieldGet$1(this, _Address_cachedUint64Array, "f");
    }
    isDead() {
        for (let i = 0; i < ADDRESS_BYTE_LENGTH; i++) {
            if (this[i] !== 0) {
                return false;
            }
        }
        return true;
    }
    toHex() {
        return '0x' + Buffer$1.from(this).toString('hex');
    }
    tweakedToHex() {
        const key = this.legacyPublicKey;
        if (!key) {
            throw new Error('Legacy public key not set');
        }
        return '0x' + Buffer$1.from(key).toString('hex');
    }
    toBuffer() {
        return Buffer$1.from(this);
    }
    tweakedPublicKeyToBuffer() {
        const key = this.legacyPublicKey;
        if (!key) {
            throw new Error('Legacy public key not set');
        }
        return Buffer$1.from(key);
    }
    toUncompressedHex() {
        this.ensureLegacyProcessed();
        if (!__classPrivateFieldGet$1(this, _Address_uncompressed, "f")) {
            throw new Error('Legacy public key not set');
        }
        return '0x' + __classPrivateFieldGet$1(this, _Address_uncompressed, "f").uncompressed.toString('hex');
    }
    toUncompressedBuffer() {
        this.ensureLegacyProcessed();
        if (!__classPrivateFieldGet$1(this, _Address_uncompressed, "f")) {
            throw new Error('Legacy public key not set');
        }
        return __classPrivateFieldGet$1(this, _Address_uncompressed, "f").uncompressed;
    }
    toHybridPublicKeyHex() {
        this.ensureLegacyProcessed();
        if (!__classPrivateFieldGet$1(this, _Address_uncompressed, "f")) {
            throw new Error('Legacy public key not set');
        }
        return '0x' + __classPrivateFieldGet$1(this, _Address_uncompressed, "f").hybrid.toString('hex');
    }
    toHybridPublicKeyBuffer() {
        this.ensureLegacyProcessed();
        if (!__classPrivateFieldGet$1(this, _Address_uncompressed, "f")) {
            throw new Error('Legacy public key not set');
        }
        return __classPrivateFieldGet$1(this, _Address_uncompressed, "f").hybrid;
    }
    originalPublicKeyBuffer() {
        this.ensureLegacyProcessed();
        if (!__classPrivateFieldGet$1(this, _Address_originalPublicKey, "f")) {
            throw new Error('Legacy public key not set');
        }
        return Buffer$1.from(__classPrivateFieldGet$1(this, _Address_originalPublicKey, "f"));
    }
    toBigInt() {
        if (__classPrivateFieldGet$1(this, _Address_cachedBigInt, "f") !== undefined) {
            return __classPrivateFieldGet$1(this, _Address_cachedBigInt, "f");
        }
        const view = new DataView(this.buffer, this.byteOffset, 32);
        __classPrivateFieldSet(this, _Address_cachedBigInt, (view.getBigUint64(0, false) << 192n) |
            (view.getBigUint64(8, false) << 128n) |
            (view.getBigUint64(16, false) << 64n) |
            view.getBigUint64(24, false), "f");
        return __classPrivateFieldGet$1(this, _Address_cachedBigInt, "f");
    }
    equals(a) {
        const b = this;
        if (a.length !== b.length) {
            return false;
        }
        for (let i = 0; i < b.length; i++) {
            if (b[i] !== a[i]) {
                return false;
            }
        }
        return true;
    }
    lessThan(a) {
        const b = this;
        for (let i = 0; i < ADDRESS_BYTE_LENGTH; i++) {
            const thisByte = b[i];
            const aByte = a[i];
            if (thisByte < aByte) {
                return true;
            }
            else if (thisByte > aByte) {
                return false;
            }
        }
        return false;
    }
    greaterThan(a) {
        const b = this;
        for (let i = 0; i < ADDRESS_BYTE_LENGTH; i++) {
            const thisByte = b[i];
            const aByte = a[i];
            if (thisByte > aByte) {
                return true;
            }
            else if (thisByte < aByte) {
                return false;
            }
        }
        return false;
    }
    set(mldsaPublicKey) {
        this.setMldsaKey(mldsaPublicKey);
    }
    isValidLegacyPublicKey(network) {
        const key = this.legacyPublicKey;
        if (!key) {
            throw new Error(`Legacy key not set.`);
        }
        return AddressVerificator.isValidPublicKey(Buffer$1.from(key).toString('hex'), network);
    }
    p2pk() {
        return this.toHex();
    }
    p2wpkh(network) {
        return EcKeyPair.getP2WPKHAddress(this.keyPair, network);
    }
    p2pkh(network) {
        return EcKeyPair.getLegacyAddress(this.keyPair, network);
    }
    p2shp2wpkh(network) {
        return EcKeyPair.getLegacySegwitAddress(this.keyPair, network);
    }
    toString() {
        return this.toHex();
    }
    toJSON() {
        return this.toHex();
    }
    p2tr(network) {
        if (__classPrivateFieldGet$1(this, _Address_p2tr, "f") && __classPrivateFieldGet$1(this, _Address_network, "f") === network) {
            return __classPrivateFieldGet$1(this, _Address_p2tr, "f");
        }
        const key = this.legacyPublicKey;
        if (!key) {
            throw new Error('Legacy public key not set');
        }
        const p2trAddy = EcKeyPair.tweakedPubKeyBufferToAddress(key, network);
        if (p2trAddy) {
            __classPrivateFieldSet(this, _Address_network, network, "f");
            __classPrivateFieldSet(this, _Address_p2tr, p2trAddy, "f");
            return p2trAddy;
        }
        throw new Error('Legacy public key not set');
    }
    p2wda(network) {
        if (__classPrivateFieldGet$1(this, _Address_p2wda, "f") && __classPrivateFieldGet$1(this, _Address_network, "f") === network) {
            return __classPrivateFieldGet$1(this, _Address_p2wda, "f");
        }
        this.ensureLegacyProcessed();
        if (!__classPrivateFieldGet$1(this, _Address_originalPublicKey, "f")) {
            throw new Error('Cannot create P2WDA address: public key not set');
        }
        const publicKeyBuffer = Buffer$1.from(__classPrivateFieldGet$1(this, _Address_originalPublicKey, "f"));
        if (publicKeyBuffer.length !== 33) {
            throw new Error('P2WDA requires a compressed public key (33 bytes)');
        }
        try {
            const p2wdaInfo = P2WDADetector.generateP2WDAAddress(publicKeyBuffer, network);
            __classPrivateFieldSet(this, _Address_network, network, "f");
            __classPrivateFieldSet(this, _Address_p2wda, p2wdaInfo, "f");
            return {
                address: p2wdaInfo.address,
                witnessScript: p2wdaInfo.witnessScript,
            };
        }
        catch (error) {
            throw new Error(`Failed to generate P2WDA address: ${error.message}`);
        }
    }
    toCSV(duration, network) {
        const n = Number(duration);
        if (n < 1 || n > 65535) {
            throw new Error('CSV block number must be between 1 and 65535');
        }
        this.ensureLegacyProcessed();
        if (!__classPrivateFieldGet$1(this, _Address_originalPublicKey, "f")) {
            throw new Error('Cannot create CSV address: public key not set');
        }
        const publicKeyBuffer = Buffer$1.from(__classPrivateFieldGet$1(this, _Address_originalPublicKey, "f"));
        return TimeLockGenerator.generateTimeLockAddress(publicKeyBuffer, network, n);
    }
    toCSVTweaked(duration, network) {
        const n = Number(duration);
        if (n < 1 || n > 65535) {
            throw new Error('CSV block number must be between 1 and 65535');
        }
        this.ensureLegacyProcessed();
        if (!__classPrivateFieldGet$1(this, _Address_originalPublicKey, "f")) {
            throw new Error('Cannot create CSV address: public key not set');
        }
        return TimeLockGenerator.generateTimeLockAddressP2TR(this.tweakedPublicKeyToBuffer(), network, n);
    }
    p2op(network) {
        if (__classPrivateFieldGet$1(this, _Address_p2op, "f") && __classPrivateFieldGet$1(this, _Address_network, "f") === network) {
            return __classPrivateFieldGet$1(this, _Address_p2op, "f");
        }
        const p2opAddy = EcKeyPair.p2op(this, network);
        if (p2opAddy) {
            __classPrivateFieldSet(this, _Address_network, network, "f");
            __classPrivateFieldSet(this, _Address_p2op, p2opAddy, "f");
            return p2opAddy;
        }
        throw new Error('ML-DSA public key not set');
    }
    toTweakedHybridPublicKeyHex() {
        this.ensureLegacyProcessed();
        if (!__classPrivateFieldGet$1(this, _Address_tweakedUncompressed, "f")) {
            throw new Error('Legacy public key not set');
        }
        return '0x' + __classPrivateFieldGet$1(this, _Address_tweakedUncompressed, "f").toString('hex');
    }
    toTweakedHybridPublicKeyBuffer() {
        this.ensureLegacyProcessed();
        if (!__classPrivateFieldGet$1(this, _Address_tweakedUncompressed, "f")) {
            throw new Error('Legacy public key not set');
        }
        return __classPrivateFieldGet$1(this, _Address_tweakedUncompressed, "f");
    }
    setMldsaKey(mldsaPublicKey) {
        if (mldsaPublicKey.length === ADDRESS_BYTE_LENGTH) {
            const buf = new Uint8Array(ADDRESS_BYTE_LENGTH);
            buf.set(mldsaPublicKey);
            super.set(buf);
        }
        else {
            const validMLDSALengths = [1312, 1952, 2592];
            if (!validMLDSALengths.includes(mldsaPublicKey.length)) {
                throw new Error(`Invalid ML-DSA public key length: ${mldsaPublicKey.length}. ` +
                    `Expected 1312 (ML-DSA-44/LEVEL2), 1952 (ML-DSA-65/LEVEL3), or 2592 (ML-DSA-87/LEVEL5) bytes.`);
            }
            __classPrivateFieldSet(this, _Address_mldsaPublicKey, new Uint8Array(mldsaPublicKey.length), "f");
            __classPrivateFieldGet$1(this, _Address_mldsaPublicKey, "f").set(mldsaPublicKey);
            const hashedPublicKey = sha256$4(new Uint8Array(mldsaPublicKey));
            const buf = new Uint8Array(ADDRESS_BYTE_LENGTH);
            buf.set(hashedPublicKey);
            super.set(buf);
        }
    }
    ensureLegacyProcessed() {
        if (__classPrivateFieldGet$1(this, _Address_legacyProcessed, "f"))
            return;
        __classPrivateFieldSet(this, _Address_legacyProcessed, true, "f");
        const pending = __classPrivateFieldGet$1(this, _Address_pendingLegacyKey, "f");
        if (!pending)
            return;
        if (pending.length === ADDRESS_BYTE_LENGTH) {
            const buf = Buffer$1.alloc(ADDRESS_BYTE_LENGTH);
            buf.set(pending);
            __classPrivateFieldSet(this, _Address_tweakedUncompressed, ContractAddress.generateHybridKeyFromHash(buf), "f");
            __classPrivateFieldSet(this, _Address_legacyPublicKey, pending, "f");
        }
        else {
            this.autoFormat(pending);
        }
    }
    autoFormat(publicKey) {
        const firstByte = publicKey[0];
        if (firstByte === 0x03 || firstByte === 0x02) ;
        else if (firstByte === 0x04 || firstByte === 0x06 || firstByte === 0x07) {
            publicKey = Address.uncompressedToCompressed(publicKey);
        }
        __classPrivateFieldSet(this, _Address_originalPublicKey, Uint8Array.from(publicKey), "f");
        __classPrivateFieldSet(this, _Address_keyPair, EcKeyPair.fromPublicKey(__classPrivateFieldGet$1(this, _Address_originalPublicKey, "f")), "f");
        __classPrivateFieldSet(this, _Address_uncompressed, decompressPublicKey(__classPrivateFieldGet$1(this, _Address_originalPublicKey, "f")), "f");
        const tweakedBytes = toXOnly(EcKeyPair.tweakPublicKey(Buffer$1.from(__classPrivateFieldGet$1(this, _Address_originalPublicKey, "f"))));
        __classPrivateFieldSet(this, _Address_tweakedUncompressed, ContractAddress.generateHybridKeyFromHash(tweakedBytes), "f");
        __classPrivateFieldSet(this, _Address_legacyPublicKey, new Uint8Array(ADDRESS_BYTE_LENGTH), "f");
        __classPrivateFieldGet$1(this, _Address_legacyPublicKey, "f").set(tweakedBytes);
    }
}
_Address_p2tr = new WeakMap(), _Address_p2op = new WeakMap(), _Address_network = new WeakMap(), _Address_originalPublicKey = new WeakMap(), _Address_keyPair = new WeakMap(), _Address_uncompressed = new WeakMap(), _Address_tweakedUncompressed = new WeakMap(), _Address_p2wda = new WeakMap(), _Address_mldsaPublicKey = new WeakMap(), _Address_cachedBigInt = new WeakMap(), _Address_cachedUint64Array = new WeakMap(), _Address_originalMDLSAPublicKey = new WeakMap(), _Address_mldsaLevel = new WeakMap(), _Address_pendingLegacyKey = new WeakMap(), _Address_legacyProcessed = new WeakMap(), _Address_legacyPublicKey = new WeakMap();

class FastMap {
    constructor(iterable) {
        this._keys = [];
        this._values = {};
        if (iterable instanceof FastMap) {
            this.setAll(iterable);
        }
        else {
            if (iterable) {
                for (const [key, value] of iterable) {
                    this.set(key, value);
                }
            }
        }
    }
    get size() {
        return this._keys.length;
    }
    setAll(map) {
        this._keys = [...map._keys];
        this._values = { ...map._values };
    }
    addAll(map) {
        for (const [key, value] of map.entries()) {
            this.set(key, value);
        }
    }
    *keys() {
        yield* this._keys;
    }
    *values() {
        for (const key of this._keys) {
            yield this._values[key];
        }
    }
    *entries() {
        for (const key of this._keys) {
            yield [key, this._values[key]];
        }
    }
    set(key, value) {
        if (!this.has(key)) {
            this._keys.push(key);
        }
        this._values[key] = value;
        return this;
    }
    indexOf(key) {
        if (!this.has(key)) {
            return -1;
        }
        for (let i = 0; i < this._keys.length; i++) {
            if (this._keys[i] === key) {
                return i;
            }
        }
        throw new Error('Key not found, this should not happen.');
    }
    get(key) {
        return this._values[key];
    }
    has(key) {
        return Object.prototype.hasOwnProperty.call(this._values, key);
    }
    delete(key) {
        if (!this.has(key)) {
            return false;
        }
        const index = this.indexOf(key);
        this._keys.splice(index, 1);
        delete this._values[key];
        return true;
    }
    clear() {
        this._keys = [];
        this._values = {};
    }
    forEach(callback, thisArg) {
        for (const key of this._keys) {
            callback.call(thisArg, this._values[key], key, this);
        }
    }
    *[Symbol.iterator]() {
        for (const key of this._keys) {
            yield [key, this._values[key]];
        }
    }
}

class AddressMap {
    constructor(iterable) {
        this.items = new FastMap();
        if (iterable) {
            for (const [key, value] of iterable) {
                this.set(key, value);
            }
        }
    }
    get size() {
        return this.items.size;
    }
    set(key, value) {
        const keyBigInt = key.toBigInt();
        this.items.set(keyBigInt, value);
        return this;
    }
    get(key) {
        return this.items.get(key.toBigInt());
    }
    has(key) {
        return this.items.has(key.toBigInt());
    }
    delete(key) {
        const keyBigInt = key.toBigInt();
        return this.items.delete(keyBigInt);
    }
    clear() {
        this.items.clear();
    }
    indexOf(address) {
        return this.items.indexOf(address.toBigInt());
    }
    *entries() {
        for (const [keyBigInt, value] of this.items.entries()) {
            yield [Address.fromBigInt(keyBigInt), value];
        }
    }
    *keys() {
        for (const keyBigInt of this.items.keys()) {
            yield Address.fromBigInt(keyBigInt);
        }
    }
    *values() {
        for (const value of this.items.values()) {
            yield value;
        }
    }
    forEach(callback, thisArg) {
        for (const [keyBigInt, value] of this.items.entries()) {
            const key = Address.fromBigInt(keyBigInt);
            callback.call(thisArg, value, key, this);
        }
    }
    *[Symbol.iterator]() {
        yield* this.entries();
    }
}

class BinaryReader {
    constructor(bytes) {
        this.currentOffset = 0;
        this.buffer = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    }
    static stringCompare(a, b) {
        return a.localeCompare(b);
    }
    static bigintCompare(a, b) {
        if (a < b)
            return -1;
        if (a > b)
            return 1;
        return 0;
    }
    static numberCompare(a, b) {
        if (a < b)
            return -1;
        if (a > b)
            return 1;
        return 0;
    }
    setBuffer(bytes) {
        this.buffer = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
        this.currentOffset = 0;
    }
    length() {
        return this.buffer.byteLength;
    }
    bytesLeft() {
        return this.buffer.byteLength - this.currentOffset;
    }
    readU8() {
        this.verifyEnd(this.currentOffset + U8_BYTE_LENGTH);
        const value = this.buffer.getUint8(this.currentOffset);
        this.currentOffset += U8_BYTE_LENGTH;
        return value;
    }
    readU16(be = true) {
        this.verifyEnd(this.currentOffset + U16_BYTE_LENGTH);
        const value = this.buffer.getUint16(this.currentOffset, !be);
        this.currentOffset += U16_BYTE_LENGTH;
        return value;
    }
    readU32(be = true) {
        this.verifyEnd(this.currentOffset + U32_BYTE_LENGTH);
        const value = this.buffer.getUint32(this.currentOffset, !be);
        this.currentOffset += U32_BYTE_LENGTH;
        return value;
    }
    readU64(be = true) {
        this.verifyEnd(this.currentOffset + U64_BYTE_LENGTH);
        const value = this.buffer.getBigUint64(this.currentOffset, !be);
        this.currentOffset += U64_BYTE_LENGTH;
        return value;
    }
    readU128(be = true) {
        const raw = this.readBytes(U128_BYTE_LENGTH);
        let bytes = raw;
        if (!be) {
            bytes = this.reverseBytes(raw);
        }
        return BigInt('0x' + this.toHexString(bytes));
    }
    readU256(be = true) {
        const raw = this.readBytes(U256_BYTE_LENGTH);
        let bytes = raw;
        if (!be) {
            bytes = this.reverseBytes(raw);
        }
        return BigInt('0x' + this.toHexString(bytes));
    }
    readI128(be = true) {
        const raw = this.readBytes(I128_BYTE_LENGTH);
        let bytes = raw;
        if (!be) {
            bytes = this.reverseBytes(raw);
        }
        let value = BigInt('0x' + this.toHexString(bytes));
        const signBitMask = 0x80;
        if (bytes[0] & signBitMask) {
            const twoTo128 = BigInt(1) << BigInt(128);
            value = value - twoTo128;
        }
        return value;
    }
    readBoolean() {
        return this.readU8() !== 0;
    }
    readSelector() {
        return this.readU32(true);
    }
    readBytes(length, zeroStop = false) {
        this.verifyEnd(this.currentOffset + length);
        let bytes = new Uint8Array(length);
        for (let i = 0; i < length; i++) {
            const b = this.buffer.getUint8(this.currentOffset++);
            if (zeroStop && b === 0) {
                bytes = Buffer$1.from(bytes.subarray(0, i));
                break;
            }
            bytes[i] = b;
        }
        return bytes;
    }
    readString(length) {
        const textDecoder = new TextDecoder();
        const bytes = this.readBytes(length, false);
        return textDecoder.decode(bytes);
    }
    readStringWithLength(be = true) {
        const length = this.readU32(be);
        return this.readString(length);
    }
    readAddress() {
        const bytes = Array.from(this.readBytes(ADDRESS_BYTE_LENGTH));
        return new Address(bytes);
    }
    readBytesWithLength(maxLength = 0, be = true) {
        const length = this.readU32(be);
        if (maxLength > 0 && length > maxLength) {
            throw new Error('Data length exceeds maximum length.');
        }
        return this.readBytes(length);
    }
    readArrayOfBuffer(be = true) {
        const length = this.readU16(be);
        const result = new Array(length);
        for (let i = 0; i < length; i++) {
            result[i] = this.readBytesWithLength();
        }
        return result;
    }
    readAddressArray(be = true) {
        const length = this.readU16(be);
        const result = new Array(length);
        for (let i = 0; i < length; i++) {
            result[i] = this.readAddress();
        }
        return result;
    }
    readU256Array(be = true) {
        const length = this.readU16(be);
        const result = new Array(length);
        for (let i = 0; i < length; i++) {
            result[i] = this.readU256(be);
        }
        return result;
    }
    readU128Array(be = true) {
        const length = this.readU16(be);
        const result = new Array(length);
        for (let i = 0; i < length; i++) {
            result[i] = this.readU128(be);
        }
        return result;
    }
    readU64Array(be = true) {
        const length = this.readU16(be);
        const result = new Array(length);
        for (let i = 0; i < length; i++) {
            result[i] = this.readU64(be);
        }
        return result;
    }
    readU32Array(be = true) {
        const length = this.readU16(be);
        const result = new Array(length);
        for (let i = 0; i < length; i++) {
            result[i] = this.readU32(be);
        }
        return result;
    }
    readU16Array(be = true) {
        const length = this.readU16(be);
        const result = new Array(length);
        for (let i = 0; i < length; i++) {
            result[i] = this.readU16(be);
        }
        return result;
    }
    readU8Array() {
        const length = this.readU16(true);
        const result = new Array(length);
        for (let i = 0; i < length; i++) {
            result[i] = this.readU8();
        }
        return result;
    }
    readStringArray(be = true) {
        const length = this.readU16(be);
        const result = new Array(length);
        for (let i = 0; i < length; i++) {
            result[i] = this.readStringWithLength(be);
        }
        return result;
    }
    readBytesArray(be = true) {
        const length = this.readU16(be);
        const result = new Array(length);
        for (let i = 0; i < length; i++) {
            result[i] = this.readBytesWithLength(0, be);
        }
        return result;
    }
    readAddressValueTuple(be = true) {
        const length = this.readU16(be);
        const result = new AddressMap();
        for (let i = 0; i < length; i++) {
            const address = this.readAddress();
            const value = this.readU256(be);
            if (result.has(address)) {
                throw new Error('Duplicate address found in map');
            }
            result.set(address, value);
        }
        return result;
    }
    getOffset() {
        return this.currentOffset;
    }
    setOffset(offset) {
        this.currentOffset = offset;
    }
    verifyEnd(size) {
        if (size > this.buffer.byteLength) {
            throw new Error(`Attempt to read beyond buffer length: requested up to byte offset ${size}, but buffer is only ${this.buffer.byteLength} bytes.`);
        }
    }
    reverseBytes(bytes) {
        const out = new Uint8Array(bytes.length);
        for (let i = 0; i < bytes.length; i++) {
            out[i] = bytes[bytes.length - 1 - i];
        }
        return out;
    }
    toHexString(bytes) {
        return Array.from(bytes, (b) => b.toString(16).padStart(2, '0')).join('');
    }
}

class BinaryWriter {
    constructor(length = 0) {
        this.currentOffset = 0;
        this.buffer = this.getDefaultBuffer(length);
    }
    static estimateArrayOfBufferLength(values) {
        if (values.length > 65535)
            throw new Error('Array size is too large');
        let totalLength = U16_BYTE_LENGTH;
        for (let i = 0; i < values.length; i++) {
            totalLength += U32_BYTE_LENGTH + values[i].length;
        }
        return totalLength;
    }
    writeU8(value) {
        if (value > 255)
            throw new Error('u8 value is too large.');
        this.allocSafe(U8_BYTE_LENGTH);
        this.buffer.setUint8(this.currentOffset++, value);
    }
    writeU16(value, be = true) {
        if (value > 65535)
            throw new Error('u16 value is too large.');
        this.allocSafe(U16_BYTE_LENGTH);
        this.buffer.setUint16(this.currentOffset, value, !be);
        this.currentOffset += 2;
    }
    writeU32(value, be = true) {
        if (value > 4294967295)
            throw new Error('u32 value is too large.');
        this.allocSafe(U32_BYTE_LENGTH);
        this.buffer.setUint32(this.currentOffset, value, !be);
        this.currentOffset += 4;
    }
    writeU64(value, be = true) {
        if (value > 18446744073709551615n)
            throw new Error('u64 value is too large.');
        this.allocSafe(U64_BYTE_LENGTH);
        this.buffer.setBigUint64(this.currentOffset, value, !be);
        this.currentOffset += 8;
    }
    writeSelector(value) {
        this.writeU32(value, true);
    }
    writeBoolean(value) {
        this.writeU8(value ? 1 : 0);
    }
    writeI128(bigIntValue, be = true) {
        if (bigIntValue > 170141183460469231731687303715884105727n ||
            bigIntValue < -170141183460469231731687303715884105728n) {
            throw new Error('i128 value is too large.');
        }
        this.allocSafe(I128_BYTE_LENGTH);
        const bytesToHex = BufferHelper.valueToUint8Array(bigIntValue, I128_BYTE_LENGTH);
        if (bytesToHex.byteLength !== I128_BYTE_LENGTH) {
            throw new Error(`Invalid i128 value: ${bigIntValue}`);
        }
        if (be) {
            for (let i = 0; i < bytesToHex.byteLength; i++) {
                this.writeU8(bytesToHex[i]);
            }
        }
        else {
            for (let i = bytesToHex.byteLength - 1; i >= 0; i--) {
                this.writeU8(bytesToHex[i]);
            }
        }
    }
    writeU256(bigIntValue, be = true) {
        if (bigIntValue >
            115792089237316195423570985008687907853269984665640564039457584007913129639935n &&
            bigIntValue < 0n) {
            throw new Error('u256 value is too large or negative.');
        }
        this.allocSafe(U256_BYTE_LENGTH);
        const bytesToHex = BufferHelper.valueToUint8Array(bigIntValue);
        if (bytesToHex.byteLength !== U256_BYTE_LENGTH) {
            throw new Error(`Invalid u256 value: ${bigIntValue}`);
        }
        if (be) {
            for (let i = 0; i < bytesToHex.byteLength; i++) {
                this.writeU8(bytesToHex[i]);
            }
        }
        else {
            for (let i = bytesToHex.byteLength - 1; i >= 0; i--) {
                this.writeU8(bytesToHex[i]);
            }
        }
    }
    writeU128(bigIntValue, be = true) {
        if (bigIntValue > 340282366920938463463374607431768211455n && bigIntValue < 0n) {
            throw new Error('u128 value is too large or negative.');
        }
        this.allocSafe(U128_BYTE_LENGTH);
        const bytesToHex = BufferHelper.valueToUint8Array(bigIntValue, U128_BYTE_LENGTH);
        if (bytesToHex.byteLength !== U128_BYTE_LENGTH) {
            throw new Error(`Invalid u128 value: ${bigIntValue}`);
        }
        if (be) {
            for (let i = 0; i < bytesToHex.byteLength; i++) {
                this.writeU8(bytesToHex[i]);
            }
        }
        else {
            for (let i = bytesToHex.byteLength - 1; i >= 0; i--) {
                this.writeU8(bytesToHex[i]);
            }
        }
    }
    writeBytes(value) {
        this.allocSafe(value.byteLength);
        for (let i = 0; i < value.byteLength; i++) {
            this.writeU8(value[i]);
        }
    }
    writeString(value) {
        const encoder = new TextEncoder();
        const bytes = encoder.encode(value);
        this.allocSafe(bytes.length);
        this.writeBytes(bytes);
    }
    writeStringWithLength(value) {
        const encoder = new TextEncoder();
        const bytes = encoder.encode(value);
        this.allocSafe(U32_BYTE_LENGTH + bytes.length);
        this.writeU32(bytes.length);
        this.writeBytes(bytes);
    }
    writeAddress(value) {
        this.verifyAddress(value);
        this.writeBytes(value);
    }
    getBuffer(clear = true) {
        const buf = new Uint8Array(this.buffer.byteLength);
        for (let i = 0; i < this.buffer.byteLength; i++) {
            buf[i] = this.buffer.getUint8(i);
        }
        if (clear)
            this.clear();
        return buf;
    }
    reset() {
        this.currentOffset = 0;
        this.buffer = this.getDefaultBuffer(4);
    }
    toBytesReader() {
        return new BinaryReader(this.getBuffer());
    }
    getOffset() {
        return this.currentOffset;
    }
    setOffset(offset) {
        this.currentOffset = offset;
    }
    clear() {
        this.currentOffset = 0;
        this.buffer = this.getDefaultBuffer();
    }
    allocSafe(size) {
        if (this.currentOffset + size > this.buffer.byteLength) {
            this.resize(size);
        }
    }
    writeAddressValueTuple(map, be = true) {
        if (map.size > 65535)
            throw new Error('Map size is too large');
        this.writeU16(map.size, be);
        const keys = Array.from(map.keys());
        for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            const value = map.get(key);
            if (value === null || value === undefined)
                throw new Error('Value not found');
            this.writeAddress(key);
            this.writeU256(value, be);
        }
    }
    writeBytesWithLength(value) {
        this.writeU32(value.length);
        this.writeBytes(value);
    }
    writeArrayOfBuffer(values, be = true) {
        const totalLength = BinaryWriter.estimateArrayOfBufferLength(values);
        this.allocSafe(totalLength);
        this.writeU16(values.length, be);
        for (let i = 0; i < values.length; i++) {
            this.writeU32(values[i].length, be);
            this.writeBytes(values[i]);
        }
    }
    writeAddressArray(value) {
        if (value.length > 65535)
            throw new Error('Array size is too large');
        this.writeU16(value.length);
        for (let i = 0; i < value.length; i++) {
            this.writeAddress(value[i]);
        }
    }
    writeU32Array(value, be = true) {
        if (value.length > 65535)
            throw new Error('Array size is too large');
        this.writeU16(value.length, be);
        for (let i = 0; i < value.length; i++) {
            this.writeU32(value[i], be);
        }
    }
    writeU256Array(value, be = true) {
        if (value.length > 65535)
            throw new Error('Array size is too large');
        this.writeU16(value.length, be);
        for (let i = 0; i < value.length; i++) {
            this.writeU256(value[i], be);
        }
    }
    writeU128Array(value, be = true) {
        if (value.length > 65535)
            throw new Error('Array size is too large');
        this.writeU16(value.length, be);
        for (let i = 0; i < value.length; i++) {
            this.writeU128(value[i], be);
        }
    }
    writeStringArray(value) {
        if (value.length > 65535)
            throw new Error('Array size is too large');
        this.writeU16(value.length);
        for (let i = 0; i < value.length; i++) {
            this.writeStringWithLength(value[i]);
        }
    }
    writeU16Array(value, be = true) {
        if (value.length > 65535)
            throw new Error('Array size is too large');
        this.writeU16(value.length, be);
        for (let i = 0; i < value.length; i++) {
            this.writeU16(value[i], be);
        }
    }
    writeU8Array(value) {
        if (value.length > 65535)
            throw new Error('Array size is too large');
        this.writeU16(value.length);
        for (let i = 0; i < value.length; i++) {
            this.writeU8(value[i]);
        }
    }
    writeU64Array(value, be = true) {
        if (value.length > 65535)
            throw new Error('Array size is too large');
        this.writeU16(value.length, be);
        for (let i = 0; i < value.length; i++) {
            this.writeU64(value[i], be);
        }
    }
    writeBytesArray(value) {
        if (value.length > 65535)
            throw new Error('Array size is too large');
        this.writeU16(value.length);
        for (let i = 0; i < value.length; i++) {
            this.writeBytesWithLength(value[i]);
        }
    }
    verifyAddress(pubKey) {
        if (pubKey.byteLength > ADDRESS_BYTE_LENGTH) {
            throw new Error(`Address is too long ${pubKey.byteLength} > ${ADDRESS_BYTE_LENGTH} bytes`);
        }
    }
    resize(size) {
        const buf = new Uint8Array(this.buffer.byteLength + size);
        for (let i = 0; i < this.buffer.byteLength; i++) {
            buf[i] = this.buffer.getUint8(i);
        }
        this.buffer = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    }
    getDefaultBuffer(length = 0) {
        return new DataView(new ArrayBuffer(length));
    }
}

var Features;
(function (Features) {
    Features[Features["ACCESS_LIST"] = 1] = "ACCESS_LIST";
    Features[Features["EPOCH_SUBMISSION"] = 2] = "EPOCH_SUBMISSION";
    Features[Features["MLDSA_LINK_PUBKEY"] = 4] = "MLDSA_LINK_PUBKEY";
})(Features || (Features = {}));
var FeaturePriority;
(function (FeaturePriority) {
    FeaturePriority[FeaturePriority["ACCESS_LIST"] = 1] = "ACCESS_LIST";
    FeaturePriority[FeaturePriority["EPOCH_SUBMISSION"] = 2] = "EPOCH_SUBMISSION";
    FeaturePriority[FeaturePriority["MLDSA_LINK_PUBKEY"] = 3] = "MLDSA_LINK_PUBKEY";
})(FeaturePriority || (FeaturePriority = {}));

class Generator {
    constructor(senderPubKey, contractSaltPubKey, network = bitcoin$1) {
        this.network = bitcoin$1;
        this.senderPubKey = senderPubKey;
        this.contractSaltPubKey = contractSaltPubKey;
        this.network = network;
        this.xSenderPubKey = toXOnly(senderPubKey);
    }
    buildHeader(features) {
        let flags = 0;
        for (const feature of features) {
            flags |= feature;
        }
        const bytesU24 = Buffer$1.alloc(3);
        bytesU24.writeUIntBE(flags, 0, 3);
        return Buffer$1.from([this.senderPubKey[0], ...bytesU24]);
    }
    getHeader(maxPriority, features = []) {
        const writer = new BinaryWriter(12);
        writer.writeBytes(this.buildHeader(features));
        writer.writeU64(maxPriority);
        return Buffer$1.from(writer.getBuffer());
    }
    splitBufferIntoChunks(buffer, chunkSize = Generator.DATA_CHUNK_SIZE) {
        const chunks = [];
        for (let i = 0; i < buffer.length; i += chunkSize) {
            const dataLength = Math.min(chunkSize, buffer.length - i);
            const buf2 = Buffer$1.alloc(dataLength);
            for (let j = 0; j < dataLength; j++) {
                buf2.writeUInt8(buffer[i + j], j);
            }
            chunks.push([buf2]);
        }
        return chunks;
    }
    encodeFeature(feature, finalBuffer) {
        switch (feature.opcode) {
            case Features.ACCESS_LIST: {
                return this.encodeAccessListFeature(feature, finalBuffer);
            }
            case Features.EPOCH_SUBMISSION: {
                return this.encodeChallengeSubmission(feature, finalBuffer);
            }
            case Features.MLDSA_LINK_PUBKEY: {
                return this.encodeLinkRequest(feature, finalBuffer);
            }
            default:
                throw new Error(`Unknown feature type: ${feature.opcode}`);
        }
    }
    encodeAccessListFeature(feature, finalBuffer) {
        const writer = new BinaryWriter();
        writer.writeU16(Object.keys(feature.data).length);
        for (const contract in feature.data) {
            const parsedContract = Address.fromString(contract);
            const data = feature.data[contract];
            writer.writeAddress(parsedContract);
            writer.writeU32(data.length);
            for (const pointer of data) {
                const pointerBuffer = Buffer$1.from(pointer, 'base64');
                if (pointerBuffer.length !== 32) {
                    throw new Error(`Invalid pointer length: ${pointerBuffer.length}`);
                }
                writer.writeBytes(pointerBuffer);
            }
        }
        finalBuffer.writeBytesWithLength(Compressor.compress(Buffer$1.from(writer.getBuffer())));
    }
    encodeChallengeSubmission(feature, finalBuffer) {
        if ('verifySignature' in feature.data && !feature.data.verifySignature()) {
            throw new Error('Invalid signature in challenge submission feature');
        }
        const writer = new BinaryWriter();
        writer.writeBytes(feature.data.publicKey.toBuffer());
        writer.writeBytes(feature.data.solution);
        if (feature.data.graffiti) {
            writer.writeBytesWithLength(feature.data.graffiti);
        }
        finalBuffer.writeBytesWithLength(writer.getBuffer());
    }
    encodeLinkRequest(feature, finalBuffer) {
        const data = feature.data;
        const writer = new BinaryWriter();
        writer.writeU8(data.level);
        writer.writeBytes(data.hashedPublicKey);
        writer.writeBoolean(data.verifyRequest);
        if (data.verifyRequest) {
            if (!data.publicKey || !data.mldsaSignature) {
                throw new Error('MLDSA public key and signature required when verifyRequest is true');
            }
            writer.writeBytes(data.publicKey);
            writer.writeBytes(data.mldsaSignature);
        }
        if (!data.legacySignature || data.legacySignature.length !== 64) {
            throw new Error('Legacy signature must be exactly 64 bytes');
        }
        writer.writeBytes(data.legacySignature);
        finalBuffer.writeBytesWithLength(writer.getBuffer());
    }
}
Generator.DATA_CHUNK_SIZE = 512;
Generator.MAGIC = Buffer$1.from('op', 'utf-8');

class CalldataGenerator extends Generator {
    constructor(senderPubKey, contractSaltPubKey, network = bitcoin$1) {
        super(senderPubKey, contractSaltPubKey, network);
    }
    static getPubKeyAsBuffer(witnessKeys, network) {
        let finalBuffer = Buffer$1.alloc(0);
        for (const pubKey of witnessKeys) {
            const key = EcKeyPair.fromPublicKey(pubKey, network);
            if (!key.compressed) {
                throw new Error('Public key must be compressed');
            }
            if (pubKey.byteLength !== 33) {
                throw new Error(`Public key must be 33 bytes, got ${pubKey.byteLength} bytes.`);
            }
            finalBuffer = Buffer$1.concat([finalBuffer, pubKey]);
        }
        const compressed = Compressor.compress(finalBuffer);
        if (compressed.byteLength >= finalBuffer.byteLength) {
            return finalBuffer;
        }
        return compressed;
    }
    compile(calldata, contractSecret, challenge, maxPriority, featuresRaw = []) {
        if (!this.contractSaltPubKey)
            throw new Error('Contract salt public key not set');
        const dataChunks = this.splitBufferIntoChunks(calldata);
        if (!dataChunks.length)
            throw new Error('No data chunks found');
        const featuresList = [];
        const featureData = [];
        if (featuresRaw && featuresRaw.length) {
            const features = featuresRaw.sort((a, b) => a.priority - b.priority);
            const finalBuffer = new BinaryWriter();
            for (let i = 0; i < features.length; i++) {
                const feature = features[i];
                featuresList.push(feature.opcode);
                this.encodeFeature(feature, finalBuffer);
            }
            featureData.push(...this.splitBufferIntoChunks(Buffer$1.from(finalBuffer.getBuffer())));
        }
        let compiledData = [
            this.getHeader(maxPriority, featuresList),
            opcodes.OP_TOALTSTACK,
            challenge.publicKey.toBuffer(),
            opcodes.OP_TOALTSTACK,
            challenge.solution,
            opcodes.OP_TOALTSTACK,
            this.xSenderPubKey,
            opcodes.OP_DUP,
            opcodes.OP_HASH256,
            hash256(this.xSenderPubKey),
            opcodes.OP_EQUALVERIFY,
            opcodes.OP_CHECKSIGVERIFY,
            this.contractSaltPubKey,
            opcodes.OP_CHECKSIGVERIFY,
            opcodes.OP_HASH160,
            hash160(contractSecret),
            opcodes.OP_EQUALVERIFY,
            opcodes.OP_DEPTH,
            opcodes.OP_1,
            opcodes.OP_NUMEQUAL,
            opcodes.OP_IF,
            Generator.MAGIC,
        ];
        compiledData = compiledData.concat(...featureData, ...[opcodes.OP_1NEGATE, ...dataChunks, opcodes.OP_ELSE, opcodes.OP_1, opcodes.OP_ENDIF]);
        const asm = compiledData.flat();
        const compiled = compile(asm);
        const decompiled = decompile(compiled);
        if (!decompiled) {
            throw new Error('Failed to decompile script??');
        }
        return compiled;
    }
}

class CustomGenerator extends Generator {
    constructor(senderPubKey, network = bitcoin$1) {
        super(senderPubKey, undefined, network);
    }
    compile(compiledData) {
        const asm = compiledData.flat();
        const compiled = compile(asm);
        const decompiled = decompile(compiled);
        if (!decompiled) {
            throw new Error('Failed to decompile script??');
        }
        return compiled;
    }
}

const OPNET_DEPLOYMENT_VERSION = 0x00;
const versionBuffer = Buffer$1.from([OPNET_DEPLOYMENT_VERSION]);
class DeploymentGenerator extends Generator {
    constructor(senderPubKey, contractSaltPubKey, network = bitcoin$1) {
        super(senderPubKey, contractSaltPubKey, network);
    }
    compile(contractBytecode, contractSalt, challenge, maxPriority, calldata, features) {
        const asm = this.getAsm(contractBytecode, contractSalt, challenge, maxPriority, calldata, features);
        const compiled = compile(asm);
        const decompiled = decompile(compiled);
        if (!decompiled) {
            throw new Error('Failed to decompile script??');
        }
        return compiled;
    }
    getAsm(contractBytecode, contractSalt, challenge, maxPriority, calldata, featuresRaw) {
        if (!this.contractSaltPubKey)
            throw new Error('Contract salt public key not set');
        const dataChunks = this.splitBufferIntoChunks(contractBytecode);
        const calldataChunks = calldata ? this.splitBufferIntoChunks(calldata) : [];
        const featuresList = [];
        const featureData = [];
        if (featuresRaw && featuresRaw.length) {
            const features = featuresRaw.sort((a, b) => a.priority - b.priority);
            const finalBuffer = new BinaryWriter();
            for (let i = 0; i < features.length; i++) {
                const feature = features[i];
                featuresList.push(feature.opcode);
                this.encodeFeature(feature, finalBuffer);
            }
            featureData.push(...this.splitBufferIntoChunks(Buffer$1.from(finalBuffer.getBuffer())));
        }
        const compiledData = [
            this.getHeader(maxPriority, featuresList),
            opcodes.OP_TOALTSTACK,
            challenge.publicKey.toBuffer(),
            opcodes.OP_TOALTSTACK,
            challenge.solution,
            opcodes.OP_TOALTSTACK,
            this.xSenderPubKey,
            opcodes.OP_DUP,
            opcodes.OP_HASH256,
            hash256(this.xSenderPubKey),
            opcodes.OP_EQUALVERIFY,
            opcodes.OP_CHECKSIGVERIFY,
            this.contractSaltPubKey,
            opcodes.OP_CHECKSIGVERIFY,
            opcodes.OP_HASH256,
            hash256(contractSalt),
            opcodes.OP_EQUALVERIFY,
            opcodes.OP_DEPTH,
            opcodes.OP_1,
            opcodes.OP_NUMEQUAL,
            opcodes.OP_IF,
            Generator.MAGIC,
            ...featureData,
            opcodes.OP_0,
            ...calldataChunks,
            opcodes.OP_1NEGATE,
            ...dataChunks,
            opcodes.OP_ELSE,
            opcodes.OP_1,
            opcodes.OP_ENDIF,
        ];
        return compiledData.flat();
    }
}

function lightenColor(color, percent) {
    color = color.replace('#', '');
    const num = parseInt(color, 16), amt = Math.round(2.55 * percent), R = (num >> 16) + amt, B = ((num >> 8) & 0x00ff) + amt, G = (num & 0x0000ff) + amt;
    return (0x1000000 +
        (R < 255 ? (R < 1 ? 0 : R) : 255) * 0x10000 +
        (B < 255 ? (B < 1 ? 0 : B) : 255) * 0x100 +
        (G < 255 ? (G < 1 ? 0 : G) : 255))
        .toString(16)
        .slice(1);
}

const ANSI_BACKGROUND_OFFSET = 10;

const wrapAnsi16 = (offset = 0) => code => `\u001B[${code + offset}m`;

const wrapAnsi256 = (offset = 0) => code => `\u001B[${38 + offset};5;${code}m`;

const wrapAnsi16m = (offset = 0) => (red, green, blue) => `\u001B[${38 + offset};2;${red};${green};${blue}m`;

const styles$1 = {
	modifier: {
		reset: [0, 0],
		// 21 isn't widely supported and 22 does the same thing
		bold: [1, 22],
		dim: [2, 22],
		italic: [3, 23],
		underline: [4, 24],
		overline: [53, 55],
		inverse: [7, 27],
		hidden: [8, 28],
		strikethrough: [9, 29],
	},
	color: {
		black: [30, 39],
		red: [31, 39],
		green: [32, 39],
		yellow: [33, 39],
		blue: [34, 39],
		magenta: [35, 39],
		cyan: [36, 39],
		white: [37, 39],

		// Bright color
		blackBright: [90, 39],
		gray: [90, 39], // Alias of `blackBright`
		grey: [90, 39], // Alias of `blackBright`
		redBright: [91, 39],
		greenBright: [92, 39],
		yellowBright: [93, 39],
		blueBright: [94, 39],
		magentaBright: [95, 39],
		cyanBright: [96, 39],
		whiteBright: [97, 39],
	},
	bgColor: {
		bgBlack: [40, 49],
		bgRed: [41, 49],
		bgGreen: [42, 49],
		bgYellow: [43, 49],
		bgBlue: [44, 49],
		bgMagenta: [45, 49],
		bgCyan: [46, 49],
		bgWhite: [47, 49],

		// Bright color
		bgBlackBright: [100, 49],
		bgGray: [100, 49], // Alias of `bgBlackBright`
		bgGrey: [100, 49], // Alias of `bgBlackBright`
		bgRedBright: [101, 49],
		bgGreenBright: [102, 49],
		bgYellowBright: [103, 49],
		bgBlueBright: [104, 49],
		bgMagentaBright: [105, 49],
		bgCyanBright: [106, 49],
		bgWhiteBright: [107, 49],
	},
};

Object.keys(styles$1.modifier);
const foregroundColorNames = Object.keys(styles$1.color);
const backgroundColorNames = Object.keys(styles$1.bgColor);
[...foregroundColorNames, ...backgroundColorNames];

function assembleStyles() {
	const codes = new Map();

	for (const [groupName, group] of Object.entries(styles$1)) {
		for (const [styleName, style] of Object.entries(group)) {
			styles$1[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`,
			};

			group[styleName] = styles$1[styleName];

			codes.set(style[0], style[1]);
		}

		Object.defineProperty(styles$1, groupName, {
			value: group,
			enumerable: false,
		});
	}

	Object.defineProperty(styles$1, 'codes', {
		value: codes,
		enumerable: false,
	});

	styles$1.color.close = '\u001B[39m';
	styles$1.bgColor.close = '\u001B[49m';

	styles$1.color.ansi = wrapAnsi16();
	styles$1.color.ansi256 = wrapAnsi256();
	styles$1.color.ansi16m = wrapAnsi16m();
	styles$1.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
	styles$1.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
	styles$1.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);

	// From https://github.com/Qix-/color-convert/blob/3f0e0d4e92e235796ccb17f6e85c72094a651f49/conversions.js
	Object.defineProperties(styles$1, {
		rgbToAnsi256: {
			value(red, green, blue) {
				// We use the extended greyscale palette here, with the exception of
				// black and white. normal palette only has 4 greyscale shades.
				if (red === green && green === blue) {
					if (red < 8) {
						return 16;
					}

					if (red > 248) {
						return 231;
					}

					return Math.round(((red - 8) / 247) * 24) + 232;
				}

				return 16
					+ (36 * Math.round(red / 255 * 5))
					+ (6 * Math.round(green / 255 * 5))
					+ Math.round(blue / 255 * 5);
			},
			enumerable: false,
		},
		hexToRgb: {
			value(hex) {
				const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
				if (!matches) {
					return [0, 0, 0];
				}

				let [colorString] = matches;

				if (colorString.length === 3) {
					colorString = [...colorString].map(character => character + character).join('');
				}

				const integer = Number.parseInt(colorString, 16);

				return [
					/* eslint-disable no-bitwise */
					(integer >> 16) & 0xFF,
					(integer >> 8) & 0xFF,
					integer & 0xFF,
					/* eslint-enable no-bitwise */
				];
			},
			enumerable: false,
		},
		hexToAnsi256: {
			value: hex => styles$1.rgbToAnsi256(...styles$1.hexToRgb(hex)),
			enumerable: false,
		},
		ansi256ToAnsi: {
			value(code) {
				if (code < 8) {
					return 30 + code;
				}

				if (code < 16) {
					return 90 + (code - 8);
				}

				let red;
				let green;
				let blue;

				if (code >= 232) {
					red = (((code - 232) * 10) + 8) / 255;
					green = red;
					blue = red;
				} else {
					code -= 16;

					const remainder = code % 36;

					red = Math.floor(code / 36) / 5;
					green = Math.floor(remainder / 6) / 5;
					blue = (remainder % 6) / 5;
				}

				const value = Math.max(red, green, blue) * 2;

				if (value === 0) {
					return 30;
				}

				// eslint-disable-next-line no-bitwise
				let result = 30 + ((Math.round(blue) << 2) | (Math.round(green) << 1) | Math.round(red));

				if (value === 2) {
					result += 60;
				}

				return result;
			},
			enumerable: false,
		},
		rgbToAnsi: {
			value: (red, green, blue) => styles$1.ansi256ToAnsi(styles$1.rgbToAnsi256(red, green, blue)),
			enumerable: false,
		},
		hexToAnsi: {
			value: hex => styles$1.ansi256ToAnsi(styles$1.hexToAnsi256(hex)),
			enumerable: false,
		},
	});

	return styles$1;
}

const ansiStyles = assembleStyles();

const level = (() => {
  if (!("navigator" in globalThis)) {
    return 0;
  }
  if (globalThis.navigator.userAgentData) {
    const brand = navigator.userAgentData.brands.find(({ brand: brand2 }) => brand2 === "Chromium");
    if (brand && brand.version > 93) {
      return 3;
    }
  }
  if (/\b(Chrome|Chromium)\//.test(globalThis.navigator.userAgent)) {
    return 1;
  }
  return 0;
})();
const colorSupport = level !== 0 && {
  level};
const supportsColor = {
  stdout: colorSupport,
  stderr: colorSupport
};

// TODO: When targeting Node.js 16, use `String.prototype.replaceAll`.
function stringReplaceAll(string, substring, replacer) {
	let index = string.indexOf(substring);
	if (index === -1) {
		return string;
	}

	const substringLength = substring.length;
	let endIndex = 0;
	let returnValue = '';
	do {
		returnValue += string.slice(endIndex, index) + substring + replacer;
		endIndex = index + substringLength;
		index = string.indexOf(substring, endIndex);
	} while (index !== -1);

	returnValue += string.slice(endIndex);
	return returnValue;
}

function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
	let endIndex = 0;
	let returnValue = '';
	do {
		const gotCR = string[index - 1] === '\r';
		returnValue += string.slice(endIndex, (gotCR ? index - 1 : index)) + prefix + (gotCR ? '\r\n' : '\n') + postfix;
		endIndex = index + 1;
		index = string.indexOf('\n', endIndex);
	} while (index !== -1);

	returnValue += string.slice(endIndex);
	return returnValue;
}

const {stdout: stdoutColor, stderr: stderrColor} = supportsColor;

const GENERATOR = Symbol('GENERATOR');
const STYLER = Symbol('STYLER');
const IS_EMPTY = Symbol('IS_EMPTY');

// `supportsColor.level`  `ansiStyles.color[name]` mapping
const levelMapping = [
	'ansi',
	'ansi',
	'ansi256',
	'ansi16m',
];

const styles = Object.create(null);

const applyOptions = (object, options = {}) => {
	if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
		throw new Error('The `level` option should be an integer from 0 to 3');
	}

	// Detect level if not set manually
	const colorLevel = stdoutColor ? stdoutColor.level : 0;
	object.level = options.level === undefined ? colorLevel : options.level;
};

class Chalk {
	constructor(options) {
		// eslint-disable-next-line no-constructor-return
		return chalkFactory(options);
	}
}

const chalkFactory = options => {
	const chalk = (...strings) => strings.join(' ');
	applyOptions(chalk, options);

	Object.setPrototypeOf(chalk, createChalk.prototype);

	return chalk;
};

function createChalk(options) {
	return chalkFactory(options);
}

Object.setPrototypeOf(createChalk.prototype, Function.prototype);

for (const [styleName, style] of Object.entries(ansiStyles)) {
	styles[styleName] = {
		get() {
			const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
			Object.defineProperty(this, styleName, {value: builder});
			return builder;
		},
	};
}

styles.visible = {
	get() {
		const builder = createBuilder(this, this[STYLER], true);
		Object.defineProperty(this, 'visible', {value: builder});
		return builder;
	},
};

const getModelAnsi = (model, level, type, ...arguments_) => {
	if (model === 'rgb') {
		if (level === 'ansi16m') {
			return ansiStyles[type].ansi16m(...arguments_);
		}

		if (level === 'ansi256') {
			return ansiStyles[type].ansi256(ansiStyles.rgbToAnsi256(...arguments_));
		}

		return ansiStyles[type].ansi(ansiStyles.rgbToAnsi(...arguments_));
	}

	if (model === 'hex') {
		return getModelAnsi('rgb', level, type, ...ansiStyles.hexToRgb(...arguments_));
	}

	return ansiStyles[type][model](...arguments_);
};

const usedModels = ['rgb', 'hex', 'ansi256'];

for (const model of usedModels) {
	styles[model] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(getModelAnsi(model, levelMapping[level], 'color', ...arguments_), ansiStyles.color.close, this[STYLER]);
				return createBuilder(this, styler, this[IS_EMPTY]);
			};
		},
	};

	const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
	styles[bgModel] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(getModelAnsi(model, levelMapping[level], 'bgColor', ...arguments_), ansiStyles.bgColor.close, this[STYLER]);
				return createBuilder(this, styler, this[IS_EMPTY]);
			};
		},
	};
}

const proto = Object.defineProperties(() => {}, {
	...styles,
	level: {
		enumerable: true,
		get() {
			return this[GENERATOR].level;
		},
		set(level) {
			this[GENERATOR].level = level;
		},
	},
});

const createStyler = (open, close, parent) => {
	let openAll;
	let closeAll;
	if (parent === undefined) {
		openAll = open;
		closeAll = close;
	} else {
		openAll = parent.openAll + open;
		closeAll = close + parent.closeAll;
	}

	return {
		open,
		close,
		openAll,
		closeAll,
		parent,
	};
};

const createBuilder = (self, _styler, _isEmpty) => {
	// Single argument is hot path, implicit coercion is faster than anything
	// eslint-disable-next-line no-implicit-coercion
	const builder = (...arguments_) => applyStyle(builder, (arguments_.length === 1) ? ('' + arguments_[0]) : arguments_.join(' '));

	// We alter the prototype because we must return a function, but there is
	// no way to create a function with a different prototype
	Object.setPrototypeOf(builder, proto);

	builder[GENERATOR] = self;
	builder[STYLER] = _styler;
	builder[IS_EMPTY] = _isEmpty;

	return builder;
};

const applyStyle = (self, string) => {
	if (self.level <= 0 || !string) {
		return self[IS_EMPTY] ? '' : string;
	}

	let styler = self[STYLER];

	if (styler === undefined) {
		return string;
	}

	const {openAll, closeAll} = styler;
	if (string.includes('\u001B')) {
		while (styler !== undefined) {
			// Replace any instances already present with a re-opening code
			// otherwise only the part of the string until said closing code
			// will be colored, and the rest will simply be 'plain'.
			string = stringReplaceAll(string, styler.close, styler.open);

			styler = styler.parent;
		}
	}

	// We can move both next actions out of loop, because remaining actions in loop won't have
	// any/visible effect on parts we add here. Close the styling before a linebreak and reopen
	// after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
	const lfIndex = string.indexOf('\n');
	if (lfIndex !== -1) {
		string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
	}

	return openAll + string + closeAll;
};

Object.defineProperties(createChalk.prototype, styles);

createChalk();
createChalk({level: stderrColor ? stderrColor.level : 0});

var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SharedLogger_pink, _SharedLogger_lightPink, _SharedLogger_purple, _SharedLogger_lightPurple, _SharedLogger_lighterPurple, _SharedLogger_green, _SharedLogger_lightGreen, _SharedLogger_moca, _SharedLogger_lightMoca, _SharedLogger_orange, _SharedLogger_lightOrange, _SharedLogger_red, _SharedLogger_lightRed, _SharedLogger_white, _SharedLogger_lightWhite, _SharedLogger_darkred, _SharedLogger_lightdarkred;
class SharedLogger {
    constructor(chalk = new Chalk()) {
        this.chalk = chalk;
        this.moduleName = '';
        this.logColor = '#00bfff';
        this.enableLogs = true;
        this.hideLogs = false;
        _SharedLogger_pink.set(this, '#ff00ff');
        _SharedLogger_lightPink.set(this, lightenColor(__classPrivateFieldGet(this, _SharedLogger_pink, "f"), 75));
        _SharedLogger_purple.set(this, '#9400d3');
        _SharedLogger_lightPurple.set(this, lightenColor(__classPrivateFieldGet(this, _SharedLogger_purple, "f"), 15));
        _SharedLogger_lighterPurple.set(this, lightenColor(__classPrivateFieldGet(this, _SharedLogger_lightPurple, "f"), 15));
        _SharedLogger_green.set(this, '#7cfc00');
        _SharedLogger_lightGreen.set(this, lightenColor(__classPrivateFieldGet(this, _SharedLogger_green, "f"), 15));
        _SharedLogger_moca.set(this, '#ffdead');
        _SharedLogger_lightMoca.set(this, lightenColor(__classPrivateFieldGet(this, _SharedLogger_moca, "f"), 15));
        _SharedLogger_orange.set(this, '#ff8c00');
        _SharedLogger_lightOrange.set(this, lightenColor(__classPrivateFieldGet(this, _SharedLogger_orange, "f"), 15));
        _SharedLogger_red.set(this, '#ff4500');
        _SharedLogger_lightRed.set(this, lightenColor(__classPrivateFieldGet(this, _SharedLogger_red, "f"), 15));
        _SharedLogger_white.set(this, '#ffffff');
        _SharedLogger_lightWhite.set(this, lightenColor(__classPrivateFieldGet(this, _SharedLogger_white, "f"), 15));
        _SharedLogger_darkred.set(this, '#8b0000');
        _SharedLogger_lightdarkred.set(this, lightenColor(__classPrivateFieldGet(this, _SharedLogger_darkred, "f"), 15));
        this.prefix = '';
        this.moduleName = this.constructor.name;
    }
    setLogPrefix(prefix) {
        this.prefix = prefix;
    }
    getStartPrefix() {
        return this.prefix;
    }
    disable() {
        this.enableLogs = false;
    }
    enable() {
        this.enableLogs = true;
    }
    fancyLog(msg1, highlight1, msg2, highlight2, msg3) {
        if (!this.enableLogs)
            return;
        console.log(this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_pink, "f"))(`${this.getStartPrefix()}[${this.moduleName} INFO]: `) +
            this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_white, "f"))(msg1) +
            ' ' +
            this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_lightOrange, "f"))(highlight1) +
            ' ' +
            this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_white, "f"))(msg2) +
            ' ' +
            this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_lighterPurple, "f"))(highlight2) +
            ' ' +
            this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_white, "f"))(msg3));
    }
    log(...args) {
        if (!this.enableLogs)
            return;
        if (!this.hideLogs) {
            const light = lightenColor(this.logColor, 15);
            console.log(this.chalk.hex(this.logColor)(`${this.getStartPrefix()}[${this.moduleName} LOG]: `) + this.chalk.hex(light)(...args));
        }
    }
    lightOrangeLog(...args) {
        if (!this.enableLogs)
            return;
        if (!this.hideLogs) {
            console.log(this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_lightOrange, "f"))(`${this.getStartPrefix()}[${this.moduleName} LOG]: `) + this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_white, "f"))(...args));
        }
    }
    error(...args) {
        if (!this.enableLogs)
            return;
        console.log(this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_red, "f"))(`${this.getStartPrefix()}[${this.moduleName} ERROR]: `) +
            this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_lightRed, "f"))(...args));
    }
    warn(...args) {
        if (!this.enableLogs)
            return;
        console.log(this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_orange, "f"))(`${this.getStartPrefix()}[${this.moduleName} WARN]: `) +
            this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_lightOrange, "f"))(...args));
    }
    debug(...args) {
        if (!this.enableLogs)
            return;
        if (!this.hideLogs) {
            console.log(this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_moca, "f"))(`${this.getStartPrefix()}[${this.moduleName} DEBUG]: `) +
                this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_lightMoca, "f"))(...args));
        }
    }
    success(...args) {
        if (!this.enableLogs)
            return;
        if (!this.hideLogs) {
            console.log(this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_green, "f"))(`${this.getStartPrefix()}[${this.moduleName} SUCCESS]: `) + this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_lightGreen, "f"))(...args));
        }
    }
    fail(...args) {
        if (!this.enableLogs)
            return;
        if (!this.hideLogs) {
            console.log(this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_red, "f"))(`${this.getStartPrefix()}[${this.moduleName} FAIL]: `) +
                this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_lightRed, "f"))(...args));
        }
    }
    debugBright(...args) {
        if (!this.enableLogs)
            return;
        if (!this.hideLogs) {
            console.log(this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_purple, "f"))(`${this.getStartPrefix()}[${this.moduleName} DEBUG]: `) + this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_lightPurple, "f"))(...args));
        }
    }
    important(...args) {
        if (!this.enableLogs)
            return;
        console.log(this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_pink, "f"))(`${this.getStartPrefix()}[${this.moduleName} IMPORTANT]: `) +
            this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_lightPink, "f"))(...args));
    }
    panic(...args) {
        if (!this.enableLogs)
            return;
        console.log(this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_darkred, "f"))(`${this.getStartPrefix()}[${this.moduleName} HELP PANIC]: `) + this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_lightdarkred, "f"))(...args));
    }
    info(...args) {
        if (!this.enableLogs)
            return;
        console.log(this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_pink, "f"))(`${this.getStartPrefix()}[${this.moduleName} INFO]: `) +
            this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_white, "f"))(...args));
    }
    securityNotice(...args) {
        if (!this.enableLogs)
            return;
        console.log(this.chalk.hex('#22d8e6')(`${this.getStartPrefix()}[${this.moduleName} SECURITY NOTICE]: `) + this.chalk.hex('#22e3e6')(...args));
    }
    traceLog(...args) {
        if (!this.enableLogs)
            return;
        console.log(this.chalk.hex('#ffffff')(`${this.getStartPrefix()}[${this.moduleName} TRACE LOG]: `) +
            this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_lightWhite, "f"))(...args));
    }
}
_SharedLogger_pink = new WeakMap(), _SharedLogger_lightPink = new WeakMap(), _SharedLogger_purple = new WeakMap(), _SharedLogger_lightPurple = new WeakMap(), _SharedLogger_lighterPurple = new WeakMap(), _SharedLogger_green = new WeakMap(), _SharedLogger_lightGreen = new WeakMap(), _SharedLogger_moca = new WeakMap(), _SharedLogger_lightMoca = new WeakMap(), _SharedLogger_orange = new WeakMap(), _SharedLogger_lightOrange = new WeakMap(), _SharedLogger_red = new WeakMap(), _SharedLogger_lightRed = new WeakMap(), _SharedLogger_white = new WeakMap(), _SharedLogger_lightWhite = new WeakMap(), _SharedLogger_darkred = new WeakMap(), _SharedLogger_lightdarkred = new WeakMap();

class Logger extends SharedLogger {
    constructor() {
        super();
    }
}

var DebugLevel;
(function (DebugLevel) {
    DebugLevel[DebugLevel["NONE"] = 0] = "NONE";
    DebugLevel[DebugLevel["ERROR"] = 1] = "ERROR";
    DebugLevel[DebugLevel["WARN"] = 2] = "WARN";
    DebugLevel[DebugLevel["INFO"] = 3] = "INFO";
    DebugLevel[DebugLevel["DEBUG"] = 4] = "DEBUG";
    DebugLevel[DebugLevel["TRACE"] = 5] = "TRACE";
    DebugLevel[DebugLevel["ALL"] = 6] = "ALL";
})(DebugLevel || (DebugLevel = {}));

class HashCommitmentGenerator extends Logger {
    constructor(publicKey, network = bitcoin$1) {
        super();
        this.logColor = '#4a90d9';
        if (publicKey.length !== 33) {
            throw new Error('Public key must be 33 bytes (compressed)');
        }
        this.publicKey = publicKey;
        this.network = network;
    }
    static calculateMaxInputsPerTx() {
        const txOverhead = 40;
        const outputOverhead = 200;
        const availableWeight = HashCommitmentGenerator.MAX_STANDARD_WEIGHT - txOverhead - outputOverhead;
        return Math.floor(availableWeight / HashCommitmentGenerator.WEIGHT_PER_INPUT);
    }
    static calculateMaxDataPerTx() {
        return (HashCommitmentGenerator.calculateMaxInputsPerTx() *
            HashCommitmentGenerator.MAX_CHUNKS_PER_OUTPUT *
            HashCommitmentGenerator.MAX_CHUNK_SIZE);
    }
    static estimateOutputCount(dataSize) {
        return Math.ceil(dataSize /
            (HashCommitmentGenerator.MAX_CHUNKS_PER_OUTPUT *
                HashCommitmentGenerator.MAX_CHUNK_SIZE));
    }
    static estimateChunkCount(dataSize) {
        return Math.ceil(dataSize / HashCommitmentGenerator.MAX_CHUNK_SIZE);
    }
    static validateHashCommittedScript(witnessScript) {
        try {
            const decompiled = decompile(witnessScript);
            if (!decompiled || decompiled.length < 5) {
                return false;
            }
            const lastIdx = decompiled.length - 1;
            if (decompiled[lastIdx] !== opcodes.OP_CHECKSIG) {
                return false;
            }
            const pubkey = decompiled[lastIdx - 1];
            if (!Buffer$1.isBuffer(pubkey) || pubkey.length !== 33) {
                return false;
            }
            const hashParts = decompiled.slice(0, -2);
            if (hashParts.length % 3 !== 0 || hashParts.length === 0) {
                return false;
            }
            for (let i = 0; i < hashParts.length; i += 3) {
                const hash = hashParts[i + 1];
                if (hashParts[i] !== opcodes.OP_HASH160 ||
                    !Buffer$1.isBuffer(hash) ||
                    hash.length !== 20 ||
                    hashParts[i + 2] !== opcodes.OP_EQUALVERIFY) {
                    return false;
                }
            }
            return true;
        }
        catch {
            return false;
        }
    }
    static extractDataHashes(witnessScript) {
        try {
            const decompiled = decompile(witnessScript);
            if (!decompiled ||
                !HashCommitmentGenerator.validateHashCommittedScript(witnessScript)) {
                return null;
            }
            const hashParts = decompiled.slice(0, -2);
            const hashes = [];
            for (let i = 0; i < hashParts.length; i += 3) {
                hashes.push(hashParts[i + 1]);
            }
            return hashes.reverse();
        }
        catch {
            return null;
        }
    }
    static extractPublicKey(witnessScript) {
        try {
            const decompiled = decompile(witnessScript);
            if (!decompiled ||
                !HashCommitmentGenerator.validateHashCommittedScript(witnessScript)) {
                return null;
            }
            return decompiled[decompiled.length - 2];
        }
        catch {
            return null;
        }
    }
    static verifyChunkCommitments(dataChunks, witnessScript) {
        const committedHashes = HashCommitmentGenerator.extractDataHashes(witnessScript);
        if (!committedHashes || committedHashes.length !== dataChunks.length) {
            return false;
        }
        for (let i = 0; i < dataChunks.length; i++) {
            const actualHash = hash160(dataChunks[i]);
            if (!committedHashes[i].equals(actualHash)) {
                return false;
            }
        }
        return true;
    }
    static estimateFees(dataSize, feeRate, compressionRatio = 0.7) {
        const compressedSize = Math.ceil(dataSize * compressionRatio);
        const outputCount = HashCommitmentGenerator.estimateOutputCount(compressedSize);
        const chunkCount = HashCommitmentGenerator.estimateChunkCount(compressedSize);
        const setupInputVBytes = 2 * 58;
        const setupOutputVBytes = outputCount * 43 + 43;
        const setupOverhead = 11;
        const setupVBytes = setupOverhead + setupInputVBytes + setupOutputVBytes;
        const revealWeight = 40 + outputCount * HashCommitmentGenerator.WEIGHT_PER_INPUT + 200;
        const revealVBytes = Math.ceil(revealWeight / 4);
        const setupFee = BigInt(Math.ceil(setupVBytes * feeRate));
        const revealFee = BigInt(Math.ceil(revealVBytes * feeRate));
        const totalFee = setupFee + revealFee;
        const outputsValue = BigInt(outputCount) * HashCommitmentGenerator.MIN_OUTPUT_VALUE;
        const totalCost = totalFee + outputsValue;
        return {
            compressedSize,
            outputCount,
            chunkCount,
            setupVBytes,
            revealVBytes,
            setupFee,
            revealFee,
            totalFee,
            outputsValue,
            totalCost,
        };
    }
    hashChunk(data) {
        return hash160(data);
    }
    generateWitnessScript(dataHashes) {
        if (dataHashes.length === 0) {
            throw new Error('At least one data hash is required');
        }
        if (dataHashes.length > HashCommitmentGenerator.MAX_CHUNKS_PER_OUTPUT) {
            throw new Error(`Too many chunks: ${dataHashes.length} exceeds limit of ${HashCommitmentGenerator.MAX_CHUNKS_PER_OUTPUT}`);
        }
        for (const hash of dataHashes) {
            if (hash.length !== 20) {
                throw new Error(`HASH160 requires 20-byte hash, got ${hash.length}`);
            }
        }
        const scriptParts = [];
        for (let i = dataHashes.length - 1; i >= 0; i--) {
            scriptParts.push(opcodes.OP_HASH160);
            scriptParts.push(dataHashes[i]);
            scriptParts.push(opcodes.OP_EQUALVERIFY);
        }
        scriptParts.push(this.publicKey);
        scriptParts.push(opcodes.OP_CHECKSIG);
        return compile(scriptParts);
    }
    generateP2WSHAddress(witnessScript) {
        const p2wsh$1 = p2wsh({
            redeem: { output: witnessScript },
            network: this.network,
        });
        if (!p2wsh$1.address || !p2wsh$1.output) {
            throw new Error('Failed to generate P2WSH address');
        }
        return {
            address: p2wsh$1.address,
            witnessScript,
            scriptPubKey: p2wsh$1.output,
        };
    }
    prepareChunks(data, maxChunkSize = HashCommitmentGenerator.MAX_CHUNK_SIZE) {
        if (maxChunkSize > HashCommitmentGenerator.MAX_CHUNK_SIZE) {
            throw new Error(`Chunk size ${maxChunkSize} exceeds P2WSH stack item limit of ${HashCommitmentGenerator.MAX_CHUNK_SIZE}`);
        }
        if (data.length === 0) {
            throw new Error('Data cannot be empty');
        }
        const allChunks = [];
        let offset = 0;
        while (offset < data.length) {
            const chunkSize = Math.min(maxChunkSize, data.length - offset);
            allChunks.push(Buffer$1.from(data.subarray(offset, offset + chunkSize)));
            offset += chunkSize;
        }
        const outputs = [];
        let chunkIndex = 0;
        while (chunkIndex < allChunks.length) {
            const chunksForThisOutput = allChunks.slice(chunkIndex, chunkIndex + HashCommitmentGenerator.MAX_CHUNKS_PER_OUTPUT);
            const dataChunks = chunksForThisOutput;
            const dataHashes = dataChunks.map((chunk) => this.hashChunk(chunk));
            const witnessScript = this.generateWitnessScript(dataHashes);
            const p2wsh = this.generateP2WSHAddress(witnessScript);
            outputs.push({
                address: p2wsh.address,
                witnessScript: p2wsh.witnessScript,
                scriptPubKey: p2wsh.scriptPubKey,
                dataHashes,
                dataChunks,
                chunkStartIndex: chunkIndex,
            });
            chunkIndex += chunksForThisOutput.length;
        }
        const totalChunks = allChunks.length;
        this.log(`Prepared ${outputs.length} P2WSH outputs with ${totalChunks} chunks ` +
            `(${data.length} bytes, ~${Math.ceil(data.length / outputs.length)} bytes/output)`);
        return outputs;
    }
}
HashCommitmentGenerator.MAX_CHUNK_SIZE = 80;
HashCommitmentGenerator.MAX_STACK_ITEMS = 100;
HashCommitmentGenerator.MAX_WITNESS_SIZE = 1650;
HashCommitmentGenerator.MAX_STANDARD_WEIGHT = 400000;
HashCommitmentGenerator.MIN_OUTPUT_VALUE = 330n;
HashCommitmentGenerator.BYTES_PER_COMMITMENT = 23;
HashCommitmentGenerator.SIG_CHECK_BYTES = 35;
HashCommitmentGenerator.WITNESS_FIXED_OVERHEAD = 1 + 73 + 3 + 35;
HashCommitmentGenerator.WITNESS_PER_CHUNK_OVERHEAD = HashCommitmentGenerator.MAX_CHUNK_SIZE + 1 + HashCommitmentGenerator.BYTES_PER_COMMITMENT;
HashCommitmentGenerator.MAX_CHUNKS_PER_OUTPUT = Math.floor((HashCommitmentGenerator.MAX_WITNESS_SIZE -
    HashCommitmentGenerator.WITNESS_FIXED_OVERHEAD) /
    HashCommitmentGenerator.WITNESS_PER_CHUNK_OVERHEAD);
HashCommitmentGenerator.INPUT_BASE_WEIGHT = 164;
HashCommitmentGenerator.INPUT_WITNESS_WEIGHT_MAX = HashCommitmentGenerator.MAX_WITNESS_SIZE;
HashCommitmentGenerator.WEIGHT_PER_INPUT = HashCommitmentGenerator.INPUT_BASE_WEIGHT +
    HashCommitmentGenerator.INPUT_WITNESS_WEIGHT_MAX;

class MultiSignGenerator {
    static compile(vaultPublicKeys, minimumSignatures = 0, internal) {
        if (minimumSignatures < 2) {
            throw new Error('Minimum signatures must be greater than 1');
        }
        if (vaultPublicKeys.length < minimumSignatures) {
            throw new Error('The amount of public keys is lower than the minimum required');
        }
        if (minimumSignatures > MultiSignGenerator.MAXIMUM_SUPPORTED_SIGNATURE) {
            throw new Error(`The maximum amount of signatures is ${MultiSignGenerator.MAXIMUM_SUPPORTED_SIGNATURE}`);
        }
        const minimumRequired = Buffer$1.alloc(1);
        minimumRequired.writeUInt8(minimumSignatures);
        vaultPublicKeys = vaultPublicKeys.filter((buf, index, self) => index === self.findIndex((otherBuf) => buf.equals(otherBuf)));
        vaultPublicKeys = vaultPublicKeys.sort((a, b) => a.compare(b));
        let included = false;
        const data = vaultPublicKeys.map((key) => {
            const newKey = toXOnly(key);
            if (internal && !included)
                included = internal.equals(newKey);
            return newKey;
        });
        if (internal && !included)
            data.push(internal);
        const compiledData = [
            opcodes.OP_0,
            ...data.flatMap((key) => [
                key,
                opcodes.OP_CHECKSIGADD,
            ]),
            minimumRequired,
            opcodes.OP_NUMEQUAL,
        ];
        const asm = compiledData.flat();
        const compiled = compile(asm);
        const decompiled = decompile(compiled);
        if (!decompiled) {
            throw new Error('Failed to decompile script.');
        }
        return compiled;
    }
}
MultiSignGenerator.MAXIMUM_SUPPORTED_SIGNATURE = 255;

class P2WDAGenerator extends Generator {
    constructor(senderPubKey, contractSaltPubKey, network = bitcoin$1) {
        super(senderPubKey, contractSaltPubKey, network);
    }
    static validateWitnessSize(dataSize, maxWitnessFields = 10, maxBytesPerWitness = 80) {
        const signatureSize = 64;
        const compressionRatio = 0.7;
        const totalSize = dataSize + signatureSize;
        const compressedSize = Math.ceil(totalSize * compressionRatio);
        const requiredFields = Math.ceil(compressedSize / maxBytesPerWitness);
        return requiredFields <= maxWitnessFields;
    }
    compile(calldata, contractSecret, challenge, maxPriority, featuresRaw = []) {
        if (!this.contractSaltPubKey) {
            throw new Error('Contract salt public key not set');
        }
        if (contractSecret.length !== 32) {
            throw new Error('Contract secret must be exactly 32 bytes');
        }
        const writer = new BinaryWriter();
        writer.writeU8(P2WDAGenerator.P2WDA_VERSION);
        const features = featuresRaw.sort((a, b) => a.priority - b.priority);
        writer.writeBytes(this.getHeader(maxPriority, features.map((f) => f.opcode)));
        writer.writeBytes(contractSecret);
        writer.writeBytes(challenge.publicKey.toBuffer());
        writer.writeBytes(challenge.solution);
        writer.writeU32(calldata.length);
        writer.writeBytes(calldata);
        this.writeFeatures(writer, features);
        return Buffer$1.from(writer.getBuffer());
    }
    getHeader(maxPriority, features = []) {
        return super.getHeader(maxPriority, features);
    }
    writeFeatures(writer, features) {
        writer.writeU16(features.length);
        for (const feature of features) {
            writer.writeU8(feature.opcode);
            this.encodeFeature(feature, writer);
        }
    }
}
P2WDAGenerator.P2WDA_VERSION = 0x01;

initEccLib(ecc);
class AddressGenerator {
    static generatePKSH(sha256Hash, network) {
        if (sha256Hash.length !== 32)
            throw new Error('Invalid hash length');
        const pkh = ripemd160(sha256Hash);
        return this.toSegwitAddress(pkh, network);
    }
    static generateTaprootAddress(pubKey, network) {
        if (pubKey.length !== 32)
            throw new Error('Invalid public key length');
        const words = distExports$1.bech32m.toWords(pubKey);
        words.unshift(0x01);
        return distExports$1.bech32m.encode(network.bech32, words);
    }
    static toSegwitAddress(pkh, network) {
        const words = distExports$1.bech32.toWords(pkh);
        words.unshift(0x00);
        return distExports$1.bech32.encode(network.bech32, words);
    }
}

initEccLib(ecc);
class TweakedSigner {
    static tweakSigner(signer, opts = {}) {
        let privateKey = signer.privateKey;
        if (!privateKey) {
            throw new Error('Private key is required for tweaking signer!');
        }
        if (signer.publicKey[0] === 3) {
            privateKey = distExports.privateNegate(privateKey);
        }
        const tweakedPrivateKey = distExports.privateAdd(privateKey, tapTweakHash$1(toXOnly(Buffer$1.from(signer.publicKey)), opts.tweakHash));
        if (!tweakedPrivateKey) {
            throw new Error('Invalid tweaked private key!');
        }
        return EcKeyPair.fromPrivateKey(Buffer$1.from(tweakedPrivateKey), opts.network);
    }
}

function isOPWallet(wallet) {
    return (typeof wallet === 'object' &&
        wallet !== null &&
        'web3' in wallet &&
        typeof wallet.web3 === 'object' &&
        'getMLDSAPublicKey' in wallet.web3 &&
        'signMLDSAMessage' in wallet.web3);
}

class MessageSignerBase {
    sha256(message) {
        return sha256$1(Buffer$1.from(message));
    }
    async trySignSchnorrWithOPWallet(message) {
        const wallet = this.getOPWallet();
        if (!wallet) {
            return null;
        }
        const messageBuffer = typeof message === 'string' ? Buffer$1.from(message, 'utf-8') : Buffer$1.from(message);
        const hashedMessage = this.sha256(messageBuffer);
        const messageHex = hashedMessage.toString('hex');
        const signatureHex = await wallet.web3.signSchnorr(messageHex);
        return {
            signature: Buffer$1.from(signatureHex, 'hex'),
            message: hashedMessage,
        };
    }
    async trySignMLDSAWithOPWallet(message) {
        const wallet = this.getOPWallet();
        if (!wallet) {
            return null;
        }
        const messageBuffer = typeof message === 'string' ? Buffer$1.from(message, 'utf-8') : Buffer$1.from(message);
        const hashedMessage = this.sha256(messageBuffer);
        const messageHex = hashedMessage.toString('hex');
        const result = await wallet.web3.signMLDSAMessage(messageHex);
        return {
            signature: Buffer$1.from(result.signature, 'hex'),
            message: hashedMessage,
            publicKey: Buffer$1.from(result.publicKey, 'hex'),
            securityLevel: result.securityLevel,
        };
    }
    async signMessageAuto(message, keypair) {
        if (!keypair) {
            const walletResult = await this.trySignSchnorrWithOPWallet(message);
            if (walletResult) {
                return walletResult;
            }
            throw new Error('No keypair provided and OP_WALLET is not available.');
        }
        return this.signMessage(keypair, message);
    }
    async tweakAndSignMessageAuto(message, keypair, network) {
        if (!keypair) {
            const walletResult = await this.trySignSchnorrWithOPWallet(message);
            if (walletResult) {
                return walletResult;
            }
            throw new Error('No keypair provided and OP_WALLET is not available.');
        }
        if (!network) {
            throw new Error('Network is required when signing with a local keypair.');
        }
        return this.tweakAndSignMessage(keypair, message, network);
    }
    async signMLDSAMessageAuto(message, mldsaKeypair) {
        if (!mldsaKeypair) {
            const walletResult = await this.trySignMLDSAWithOPWallet(message);
            if (walletResult) {
                return walletResult;
            }
            throw new Error('No ML-DSA keypair provided and OP_WALLET is not available.');
        }
        return this.signMLDSAMessage(mldsaKeypair, message);
    }
    async verifyMLDSAWithOPWallet(message, signature) {
        const wallet = this.getOPWallet();
        if (!wallet) {
            return null;
        }
        const messageBuffer = typeof message === 'string' ? Buffer$1.from(message, 'utf-8') : Buffer$1.from(message);
        const hashedMessage = this.sha256(messageBuffer);
        const mldsaSignature = {
            signature: Buffer$1.from(signature.signature).toString('hex'),
            publicKey: Buffer$1.from(signature.publicKey).toString('hex'),
            securityLevel: signature.securityLevel,
            messageHash: hashedMessage.toString('hex'),
        };
        return wallet.web3.verifyMLDSASignature(hashedMessage.toString('hex'), mldsaSignature);
    }
    async getMLDSAPublicKeyFromOPWallet() {
        const wallet = this.getOPWallet();
        if (!wallet) {
            return null;
        }
        const publicKeyHex = await wallet.web3.getMLDSAPublicKey();
        return Buffer$1.from(publicKeyHex, 'hex');
    }
    tweakAndSignMessage(keypair, message, network) {
        const tweaked = TweakedSigner.tweakSigner(keypair, { network });
        return this.signMessage(tweaked, message);
    }
    signMessage(keypair, message) {
        if (typeof message === 'string') {
            message = Buffer$1.from(message, 'utf-8');
        }
        if (!keypair.privateKey) {
            throw new Error('Private key not found in keypair.');
        }
        const hashedMessage = this.sha256(message);
        return {
            signature: distExports.signSchnorr(hashedMessage, keypair.privateKey),
            message: hashedMessage,
        };
    }
    verifySignature(publicKey, message, signature) {
        if (typeof message === 'string') {
            message = Buffer$1.from(message, 'utf-8');
        }
        if (signature.length !== 64) {
            throw new Error('Invalid signature length.');
        }
        const hashedMessage = this.sha256(message);
        return distExports.verifySchnorr(hashedMessage, toXOnly(Buffer$1.from(publicKey)), signature);
    }
    tweakAndVerifySignature(publicKey, message, signature) {
        const tweakedPublicKey = EcKeyPair.tweakPublicKey(Buffer$1.from(publicKey));
        return this.verifySignature(tweakedPublicKey, message, signature);
    }
    signMLDSAMessage(mldsaKeypair, message) {
        if (typeof message === 'string') {
            message = Buffer$1.from(message, 'utf-8');
        }
        if (!mldsaKeypair.privateKey) {
            throw new Error('ML-DSA private key not found in keypair.');
        }
        const hashedMessage = this.sha256(message);
        const signature = mldsaKeypair.sign(hashedMessage);
        return {
            signature: Buffer$1.from(signature),
            message: hashedMessage,
            publicKey: Buffer$1.from(mldsaKeypair.publicKey),
            securityLevel: mldsaKeypair.securityLevel,
        };
    }
    verifyMLDSASignature(mldsaKeypair, message, signature) {
        if (typeof message === 'string') {
            message = Buffer$1.from(message, 'utf-8');
        }
        const hashedMessage = this.sha256(message);
        return mldsaKeypair.verify(hashedMessage, signature);
    }
    isOPWalletAvailable() {
        return this.getOPWallet() !== null;
    }
    getOPWallet() {
        if (typeof window === 'undefined') {
            return null;
        }
        const _window = window;
        if (!_window.opnet || !isOPWallet(_window.opnet)) {
            return null;
        }
        return _window.opnet;
    }
}
const MessageSigner = new MessageSignerBase();

initEccLib(ecc);

var src = {};

var _wordlists = {};

const require$$0 = /* #__PURE__ */ JSON.parse("[\"abdikace\",\"abeceda\",\"adresa\",\"agrese\",\"akce\",\"aktovka\",\"alej\",\"alkohol\",\"amputace\",\"ananas\",\"andulka\",\"anekdota\",\"anketa\",\"antika\",\"anulovat\",\"archa\",\"arogance\",\"asfalt\",\"asistent\",\"aspirace\",\"astma\",\"astronom\",\"atlas\",\"atletika\",\"atol\",\"autobus\",\"azyl\",\"babka\",\"bachor\",\"bacil\",\"baculka\",\"badatel\",\"bageta\",\"bagr\",\"bahno\",\"bakterie\",\"balada\",\"baletka\",\"balkon\",\"balonek\",\"balvan\",\"balza\",\"bambus\",\"bankomat\",\"barbar\",\"baret\",\"barman\",\"baroko\",\"barva\",\"baterka\",\"batoh\",\"bavlna\",\"bazalka\",\"bazilika\",\"bazuka\",\"bedna\",\"beran\",\"beseda\",\"bestie\",\"beton\",\"bezinka\",\"bezmoc\",\"beztak\",\"bicykl\",\"bidlo\",\"biftek\",\"bikiny\",\"bilance\",\"biograf\",\"biolog\",\"bitva\",\"bizon\",\"blahobyt\",\"blatouch\",\"blecha\",\"bledule\",\"blesk\",\"blikat\",\"blizna\",\"blokovat\",\"bloudit\",\"blud\",\"bobek\",\"bobr\",\"bodlina\",\"bodnout\",\"bohatost\",\"bojkot\",\"bojovat\",\"bokorys\",\"bolest\",\"borec\",\"borovice\",\"bota\",\"boubel\",\"bouchat\",\"bouda\",\"boule\",\"bourat\",\"boxer\",\"bradavka\",\"brambora\",\"branka\",\"bratr\",\"brepta\",\"briketa\",\"brko\",\"brloh\",\"bronz\",\"broskev\",\"brunetka\",\"brusinka\",\"brzda\",\"brzy\",\"bublina\",\"bubnovat\",\"buchta\",\"buditel\",\"budka\",\"budova\",\"bufet\",\"bujarost\",\"bukvice\",\"buldok\",\"bulva\",\"bunda\",\"bunkr\",\"burza\",\"butik\",\"buvol\",\"buzola\",\"bydlet\",\"bylina\",\"bytovka\",\"bzukot\",\"capart\",\"carevna\",\"cedr\",\"cedule\",\"cejch\",\"cejn\",\"cela\",\"celer\",\"celkem\",\"celnice\",\"cenina\",\"cennost\",\"cenovka\",\"centrum\",\"cenzor\",\"cestopis\",\"cetka\",\"chalupa\",\"chapadlo\",\"charita\",\"chata\",\"chechtat\",\"chemie\",\"chichot\",\"chirurg\",\"chlad\",\"chleba\",\"chlubit\",\"chmel\",\"chmura\",\"chobot\",\"chochol\",\"chodba\",\"cholera\",\"chomout\",\"chopit\",\"choroba\",\"chov\",\"chrapot\",\"chrlit\",\"chrt\",\"chrup\",\"chtivost\",\"chudina\",\"chutnat\",\"chvat\",\"chvilka\",\"chvost\",\"chyba\",\"chystat\",\"chytit\",\"cibule\",\"cigareta\",\"cihelna\",\"cihla\",\"cinkot\",\"cirkus\",\"cisterna\",\"citace\",\"citrus\",\"cizinec\",\"cizost\",\"clona\",\"cokoliv\",\"couvat\",\"ctitel\",\"ctnost\",\"cudnost\",\"cuketa\",\"cukr\",\"cupot\",\"cvaknout\",\"cval\",\"cvik\",\"cvrkot\",\"cyklista\",\"daleko\",\"dareba\",\"datel\",\"datum\",\"dcera\",\"debata\",\"dechovka\",\"decibel\",\"deficit\",\"deflace\",\"dekl\",\"dekret\",\"demokrat\",\"deprese\",\"derby\",\"deska\",\"detektiv\",\"dikobraz\",\"diktovat\",\"dioda\",\"diplom\",\"disk\",\"displej\",\"divadlo\",\"divoch\",\"dlaha\",\"dlouho\",\"dluhopis\",\"dnes\",\"dobro\",\"dobytek\",\"docent\",\"dochutit\",\"dodnes\",\"dohled\",\"dohoda\",\"dohra\",\"dojem\",\"dojnice\",\"doklad\",\"dokola\",\"doktor\",\"dokument\",\"dolar\",\"doleva\",\"dolina\",\"doma\",\"dominant\",\"domluvit\",\"domov\",\"donutit\",\"dopad\",\"dopis\",\"doplnit\",\"doposud\",\"doprovod\",\"dopustit\",\"dorazit\",\"dorost\",\"dort\",\"dosah\",\"doslov\",\"dostatek\",\"dosud\",\"dosyta\",\"dotaz\",\"dotek\",\"dotknout\",\"doufat\",\"doutnat\",\"dovozce\",\"dozadu\",\"doznat\",\"dozorce\",\"drahota\",\"drak\",\"dramatik\",\"dravec\",\"draze\",\"drdol\",\"drobnost\",\"drogerie\",\"drozd\",\"drsnost\",\"drtit\",\"drzost\",\"duben\",\"duchovno\",\"dudek\",\"duha\",\"duhovka\",\"dusit\",\"dusno\",\"dutost\",\"dvojice\",\"dvorec\",\"dynamit\",\"ekolog\",\"ekonomie\",\"elektron\",\"elipsa\",\"email\",\"emise\",\"emoce\",\"empatie\",\"epizoda\",\"epocha\",\"epopej\",\"epos\",\"esej\",\"esence\",\"eskorta\",\"eskymo\",\"etiketa\",\"euforie\",\"evoluce\",\"exekuce\",\"exkurze\",\"expedice\",\"exploze\",\"export\",\"extrakt\",\"facka\",\"fajfka\",\"fakulta\",\"fanatik\",\"fantazie\",\"farmacie\",\"favorit\",\"fazole\",\"federace\",\"fejeton\",\"fenka\",\"fialka\",\"figurant\",\"filozof\",\"filtr\",\"finance\",\"finta\",\"fixace\",\"fjord\",\"flanel\",\"flirt\",\"flotila\",\"fond\",\"fosfor\",\"fotbal\",\"fotka\",\"foton\",\"frakce\",\"freska\",\"fronta\",\"fukar\",\"funkce\",\"fyzika\",\"galeje\",\"garant\",\"genetika\",\"geolog\",\"gilotina\",\"glazura\",\"glejt\",\"golem\",\"golfista\",\"gotika\",\"graf\",\"gramofon\",\"granule\",\"grep\",\"gril\",\"grog\",\"groteska\",\"guma\",\"hadice\",\"hadr\",\"hala\",\"halenka\",\"hanba\",\"hanopis\",\"harfa\",\"harpuna\",\"havran\",\"hebkost\",\"hejkal\",\"hejno\",\"hejtman\",\"hektar\",\"helma\",\"hematom\",\"herec\",\"herna\",\"heslo\",\"hezky\",\"historik\",\"hladovka\",\"hlasivky\",\"hlava\",\"hledat\",\"hlen\",\"hlodavec\",\"hloh\",\"hloupost\",\"hltat\",\"hlubina\",\"hluchota\",\"hmat\",\"hmota\",\"hmyz\",\"hnis\",\"hnojivo\",\"hnout\",\"hoblina\",\"hoboj\",\"hoch\",\"hodiny\",\"hodlat\",\"hodnota\",\"hodovat\",\"hojnost\",\"hokej\",\"holinka\",\"holka\",\"holub\",\"homole\",\"honitba\",\"honorace\",\"horal\",\"horda\",\"horizont\",\"horko\",\"horlivec\",\"hormon\",\"hornina\",\"horoskop\",\"horstvo\",\"hospoda\",\"hostina\",\"hotovost\",\"houba\",\"houf\",\"houpat\",\"houska\",\"hovor\",\"hradba\",\"hranice\",\"hravost\",\"hrazda\",\"hrbolek\",\"hrdina\",\"hrdlo\",\"hrdost\",\"hrnek\",\"hrobka\",\"hromada\",\"hrot\",\"hrouda\",\"hrozen\",\"hrstka\",\"hrubost\",\"hryzat\",\"hubenost\",\"hubnout\",\"hudba\",\"hukot\",\"humr\",\"husita\",\"hustota\",\"hvozd\",\"hybnost\",\"hydrant\",\"hygiena\",\"hymna\",\"hysterik\",\"idylka\",\"ihned\",\"ikona\",\"iluze\",\"imunita\",\"infekce\",\"inflace\",\"inkaso\",\"inovace\",\"inspekce\",\"internet\",\"invalida\",\"investor\",\"inzerce\",\"ironie\",\"jablko\",\"jachta\",\"jahoda\",\"jakmile\",\"jakost\",\"jalovec\",\"jantar\",\"jarmark\",\"jaro\",\"jasan\",\"jasno\",\"jatka\",\"javor\",\"jazyk\",\"jedinec\",\"jedle\",\"jednatel\",\"jehlan\",\"jekot\",\"jelen\",\"jelito\",\"jemnost\",\"jenom\",\"jepice\",\"jeseter\",\"jevit\",\"jezdec\",\"jezero\",\"jinak\",\"jindy\",\"jinoch\",\"jiskra\",\"jistota\",\"jitrnice\",\"jizva\",\"jmenovat\",\"jogurt\",\"jurta\",\"kabaret\",\"kabel\",\"kabinet\",\"kachna\",\"kadet\",\"kadidlo\",\"kahan\",\"kajak\",\"kajuta\",\"kakao\",\"kaktus\",\"kalamita\",\"kalhoty\",\"kalibr\",\"kalnost\",\"kamera\",\"kamkoliv\",\"kamna\",\"kanibal\",\"kanoe\",\"kantor\",\"kapalina\",\"kapela\",\"kapitola\",\"kapka\",\"kaple\",\"kapota\",\"kapr\",\"kapusta\",\"kapybara\",\"karamel\",\"karotka\",\"karton\",\"kasa\",\"katalog\",\"katedra\",\"kauce\",\"kauza\",\"kavalec\",\"kazajka\",\"kazeta\",\"kazivost\",\"kdekoliv\",\"kdesi\",\"kedluben\",\"kemp\",\"keramika\",\"kino\",\"klacek\",\"kladivo\",\"klam\",\"klapot\",\"klasika\",\"klaun\",\"klec\",\"klenba\",\"klepat\",\"klesnout\",\"klid\",\"klima\",\"klisna\",\"klobouk\",\"klokan\",\"klopa\",\"kloub\",\"klubovna\",\"klusat\",\"kluzkost\",\"kmen\",\"kmitat\",\"kmotr\",\"kniha\",\"knot\",\"koalice\",\"koberec\",\"kobka\",\"kobliha\",\"kobyla\",\"kocour\",\"kohout\",\"kojenec\",\"kokos\",\"koktejl\",\"kolaps\",\"koleda\",\"kolize\",\"kolo\",\"komando\",\"kometa\",\"komik\",\"komnata\",\"komora\",\"kompas\",\"komunita\",\"konat\",\"koncept\",\"kondice\",\"konec\",\"konfese\",\"kongres\",\"konina\",\"konkurs\",\"kontakt\",\"konzerva\",\"kopanec\",\"kopie\",\"kopnout\",\"koprovka\",\"korbel\",\"korektor\",\"kormidlo\",\"koroptev\",\"korpus\",\"koruna\",\"koryto\",\"korzet\",\"kosatec\",\"kostka\",\"kotel\",\"kotleta\",\"kotoul\",\"koukat\",\"koupelna\",\"kousek\",\"kouzlo\",\"kovboj\",\"koza\",\"kozoroh\",\"krabice\",\"krach\",\"krajina\",\"kralovat\",\"krasopis\",\"kravata\",\"kredit\",\"krejcar\",\"kresba\",\"kreveta\",\"kriket\",\"kritik\",\"krize\",\"krkavec\",\"krmelec\",\"krmivo\",\"krocan\",\"krok\",\"kronika\",\"kropit\",\"kroupa\",\"krovka\",\"krtek\",\"kruhadlo\",\"krupice\",\"krutost\",\"krvinka\",\"krychle\",\"krypta\",\"krystal\",\"kryt\",\"kudlanka\",\"kufr\",\"kujnost\",\"kukla\",\"kulajda\",\"kulich\",\"kulka\",\"kulomet\",\"kultura\",\"kuna\",\"kupodivu\",\"kurt\",\"kurzor\",\"kutil\",\"kvalita\",\"kvasinka\",\"kvestor\",\"kynolog\",\"kyselina\",\"kytara\",\"kytice\",\"kytka\",\"kytovec\",\"kyvadlo\",\"labrador\",\"lachtan\",\"ladnost\",\"laik\",\"lakomec\",\"lamela\",\"lampa\",\"lanovka\",\"lasice\",\"laso\",\"lastura\",\"latinka\",\"lavina\",\"lebka\",\"leckdy\",\"leden\",\"lednice\",\"ledovka\",\"ledvina\",\"legenda\",\"legie\",\"legrace\",\"lehce\",\"lehkost\",\"lehnout\",\"lektvar\",\"lenochod\",\"lentilka\",\"lepenka\",\"lepidlo\",\"letadlo\",\"letec\",\"letmo\",\"letokruh\",\"levhart\",\"levitace\",\"levobok\",\"libra\",\"lichotka\",\"lidojed\",\"lidskost\",\"lihovina\",\"lijavec\",\"lilek\",\"limetka\",\"linie\",\"linka\",\"linoleum\",\"listopad\",\"litina\",\"litovat\",\"lobista\",\"lodivod\",\"logika\",\"logoped\",\"lokalita\",\"loket\",\"lomcovat\",\"lopata\",\"lopuch\",\"lord\",\"losos\",\"lotr\",\"loudal\",\"louh\",\"louka\",\"louskat\",\"lovec\",\"lstivost\",\"lucerna\",\"lucifer\",\"lump\",\"lusk\",\"lustrace\",\"lvice\",\"lyra\",\"lyrika\",\"lysina\",\"madam\",\"madlo\",\"magistr\",\"mahagon\",\"majetek\",\"majitel\",\"majorita\",\"makak\",\"makovice\",\"makrela\",\"malba\",\"malina\",\"malovat\",\"malvice\",\"maminka\",\"mandle\",\"manko\",\"marnost\",\"masakr\",\"maskot\",\"masopust\",\"matice\",\"matrika\",\"maturita\",\"mazanec\",\"mazivo\",\"mazlit\",\"mazurka\",\"mdloba\",\"mechanik\",\"meditace\",\"medovina\",\"melasa\",\"meloun\",\"mentolka\",\"metla\",\"metoda\",\"metr\",\"mezera\",\"migrace\",\"mihnout\",\"mihule\",\"mikina\",\"mikrofon\",\"milenec\",\"milimetr\",\"milost\",\"mimika\",\"mincovna\",\"minibar\",\"minomet\",\"minulost\",\"miska\",\"mistr\",\"mixovat\",\"mladost\",\"mlha\",\"mlhovina\",\"mlok\",\"mlsat\",\"mluvit\",\"mnich\",\"mnohem\",\"mobil\",\"mocnost\",\"modelka\",\"modlitba\",\"mohyla\",\"mokro\",\"molekula\",\"momentka\",\"monarcha\",\"monokl\",\"monstrum\",\"montovat\",\"monzun\",\"mosaz\",\"moskyt\",\"most\",\"motivace\",\"motorka\",\"motyka\",\"moucha\",\"moudrost\",\"mozaika\",\"mozek\",\"mozol\",\"mramor\",\"mravenec\",\"mrkev\",\"mrtvola\",\"mrzet\",\"mrzutost\",\"mstitel\",\"mudrc\",\"muflon\",\"mulat\",\"mumie\",\"munice\",\"muset\",\"mutace\",\"muzeum\",\"muzikant\",\"myslivec\",\"mzda\",\"nabourat\",\"nachytat\",\"nadace\",\"nadbytek\",\"nadhoz\",\"nadobro\",\"nadpis\",\"nahlas\",\"nahnat\",\"nahodile\",\"nahradit\",\"naivita\",\"najednou\",\"najisto\",\"najmout\",\"naklonit\",\"nakonec\",\"nakrmit\",\"nalevo\",\"namazat\",\"namluvit\",\"nanometr\",\"naoko\",\"naopak\",\"naostro\",\"napadat\",\"napevno\",\"naplnit\",\"napnout\",\"naposled\",\"naprosto\",\"narodit\",\"naruby\",\"narychlo\",\"nasadit\",\"nasekat\",\"naslepo\",\"nastat\",\"natolik\",\"navenek\",\"navrch\",\"navzdory\",\"nazvat\",\"nebe\",\"nechat\",\"necky\",\"nedaleko\",\"nedbat\",\"neduh\",\"negace\",\"nehet\",\"nehoda\",\"nejen\",\"nejprve\",\"neklid\",\"nelibost\",\"nemilost\",\"nemoc\",\"neochota\",\"neonka\",\"nepokoj\",\"nerost\",\"nerv\",\"nesmysl\",\"nesoulad\",\"netvor\",\"neuron\",\"nevina\",\"nezvykle\",\"nicota\",\"nijak\",\"nikam\",\"nikdy\",\"nikl\",\"nikterak\",\"nitro\",\"nocleh\",\"nohavice\",\"nominace\",\"nora\",\"norek\",\"nositel\",\"nosnost\",\"nouze\",\"noviny\",\"novota\",\"nozdra\",\"nuda\",\"nudle\",\"nuget\",\"nutit\",\"nutnost\",\"nutrie\",\"nymfa\",\"obal\",\"obarvit\",\"obava\",\"obdiv\",\"obec\",\"obehnat\",\"obejmout\",\"obezita\",\"obhajoba\",\"obilnice\",\"objasnit\",\"objekt\",\"obklopit\",\"oblast\",\"oblek\",\"obliba\",\"obloha\",\"obluda\",\"obnos\",\"obohatit\",\"obojek\",\"obout\",\"obrazec\",\"obrna\",\"obruba\",\"obrys\",\"obsah\",\"obsluha\",\"obstarat\",\"obuv\",\"obvaz\",\"obvinit\",\"obvod\",\"obvykle\",\"obyvatel\",\"obzor\",\"ocas\",\"ocel\",\"ocenit\",\"ochladit\",\"ochota\",\"ochrana\",\"ocitnout\",\"odboj\",\"odbyt\",\"odchod\",\"odcizit\",\"odebrat\",\"odeslat\",\"odevzdat\",\"odezva\",\"odhadce\",\"odhodit\",\"odjet\",\"odjinud\",\"odkaz\",\"odkoupit\",\"odliv\",\"odluka\",\"odmlka\",\"odolnost\",\"odpad\",\"odpis\",\"odplout\",\"odpor\",\"odpustit\",\"odpykat\",\"odrazka\",\"odsoudit\",\"odstup\",\"odsun\",\"odtok\",\"odtud\",\"odvaha\",\"odveta\",\"odvolat\",\"odvracet\",\"odznak\",\"ofina\",\"ofsajd\",\"ohlas\",\"ohnisko\",\"ohrada\",\"ohrozit\",\"ohryzek\",\"okap\",\"okenice\",\"oklika\",\"okno\",\"okouzlit\",\"okovy\",\"okrasa\",\"okres\",\"okrsek\",\"okruh\",\"okupant\",\"okurka\",\"okusit\",\"olejnina\",\"olizovat\",\"omak\",\"omeleta\",\"omezit\",\"omladina\",\"omlouvat\",\"omluva\",\"omyl\",\"onehdy\",\"opakovat\",\"opasek\",\"operace\",\"opice\",\"opilost\",\"opisovat\",\"opora\",\"opozice\",\"opravdu\",\"oproti\",\"orbital\",\"orchestr\",\"orgie\",\"orlice\",\"orloj\",\"ortel\",\"osada\",\"oschnout\",\"osika\",\"osivo\",\"oslava\",\"oslepit\",\"oslnit\",\"oslovit\",\"osnova\",\"osoba\",\"osolit\",\"ospalec\",\"osten\",\"ostraha\",\"ostuda\",\"ostych\",\"osvojit\",\"oteplit\",\"otisk\",\"otop\",\"otrhat\",\"otrlost\",\"otrok\",\"otruby\",\"otvor\",\"ovanout\",\"ovar\",\"oves\",\"ovlivnit\",\"ovoce\",\"oxid\",\"ozdoba\",\"pachatel\",\"pacient\",\"padouch\",\"pahorek\",\"pakt\",\"palanda\",\"palec\",\"palivo\",\"paluba\",\"pamflet\",\"pamlsek\",\"panenka\",\"panika\",\"panna\",\"panovat\",\"panstvo\",\"pantofle\",\"paprika\",\"parketa\",\"parodie\",\"parta\",\"paruka\",\"paryba\",\"paseka\",\"pasivita\",\"pastelka\",\"patent\",\"patrona\",\"pavouk\",\"pazneht\",\"pazourek\",\"pecka\",\"pedagog\",\"pejsek\",\"peklo\",\"peloton\",\"penalta\",\"pendrek\",\"penze\",\"periskop\",\"pero\",\"pestrost\",\"petarda\",\"petice\",\"petrolej\",\"pevnina\",\"pexeso\",\"pianista\",\"piha\",\"pijavice\",\"pikle\",\"piknik\",\"pilina\",\"pilnost\",\"pilulka\",\"pinzeta\",\"pipeta\",\"pisatel\",\"pistole\",\"pitevna\",\"pivnice\",\"pivovar\",\"placenta\",\"plakat\",\"plamen\",\"planeta\",\"plastika\",\"platit\",\"plavidlo\",\"plaz\",\"plech\",\"plemeno\",\"plenta\",\"ples\",\"pletivo\",\"plevel\",\"plivat\",\"plnit\",\"plno\",\"plocha\",\"plodina\",\"plomba\",\"plout\",\"pluk\",\"plyn\",\"pobavit\",\"pobyt\",\"pochod\",\"pocit\",\"poctivec\",\"podat\",\"podcenit\",\"podepsat\",\"podhled\",\"podivit\",\"podklad\",\"podmanit\",\"podnik\",\"podoba\",\"podpora\",\"podraz\",\"podstata\",\"podvod\",\"podzim\",\"poezie\",\"pohanka\",\"pohnutka\",\"pohovor\",\"pohroma\",\"pohyb\",\"pointa\",\"pojistka\",\"pojmout\",\"pokazit\",\"pokles\",\"pokoj\",\"pokrok\",\"pokuta\",\"pokyn\",\"poledne\",\"polibek\",\"polknout\",\"poloha\",\"polynom\",\"pomalu\",\"pominout\",\"pomlka\",\"pomoc\",\"pomsta\",\"pomyslet\",\"ponechat\",\"ponorka\",\"ponurost\",\"popadat\",\"popel\",\"popisek\",\"poplach\",\"poprosit\",\"popsat\",\"popud\",\"poradce\",\"porce\",\"porod\",\"porucha\",\"poryv\",\"posadit\",\"posed\",\"posila\",\"poskok\",\"poslanec\",\"posoudit\",\"pospolu\",\"postava\",\"posudek\",\"posyp\",\"potah\",\"potkan\",\"potlesk\",\"potomek\",\"potrava\",\"potupa\",\"potvora\",\"poukaz\",\"pouto\",\"pouzdro\",\"povaha\",\"povidla\",\"povlak\",\"povoz\",\"povrch\",\"povstat\",\"povyk\",\"povzdech\",\"pozdrav\",\"pozemek\",\"poznatek\",\"pozor\",\"pozvat\",\"pracovat\",\"prahory\",\"praktika\",\"prales\",\"praotec\",\"praporek\",\"prase\",\"pravda\",\"princip\",\"prkno\",\"probudit\",\"procento\",\"prodej\",\"profese\",\"prohra\",\"projekt\",\"prolomit\",\"promile\",\"pronikat\",\"propad\",\"prorok\",\"prosba\",\"proton\",\"proutek\",\"provaz\",\"prskavka\",\"prsten\",\"prudkost\",\"prut\",\"prvek\",\"prvohory\",\"psanec\",\"psovod\",\"pstruh\",\"ptactvo\",\"puberta\",\"puch\",\"pudl\",\"pukavec\",\"puklina\",\"pukrle\",\"pult\",\"pumpa\",\"punc\",\"pupen\",\"pusa\",\"pusinka\",\"pustina\",\"putovat\",\"putyka\",\"pyramida\",\"pysk\",\"pytel\",\"racek\",\"rachot\",\"radiace\",\"radnice\",\"radon\",\"raft\",\"ragby\",\"raketa\",\"rakovina\",\"rameno\",\"rampouch\",\"rande\",\"rarach\",\"rarita\",\"rasovna\",\"rastr\",\"ratolest\",\"razance\",\"razidlo\",\"reagovat\",\"reakce\",\"recept\",\"redaktor\",\"referent\",\"reflex\",\"rejnok\",\"reklama\",\"rekord\",\"rekrut\",\"rektor\",\"reputace\",\"revize\",\"revma\",\"revolver\",\"rezerva\",\"riskovat\",\"riziko\",\"robotika\",\"rodokmen\",\"rohovka\",\"rokle\",\"rokoko\",\"romaneto\",\"ropovod\",\"ropucha\",\"rorejs\",\"rosol\",\"rostlina\",\"rotmistr\",\"rotoped\",\"rotunda\",\"roubenka\",\"roucho\",\"roup\",\"roura\",\"rovina\",\"rovnice\",\"rozbor\",\"rozchod\",\"rozdat\",\"rozeznat\",\"rozhodce\",\"rozinka\",\"rozjezd\",\"rozkaz\",\"rozloha\",\"rozmar\",\"rozpad\",\"rozruch\",\"rozsah\",\"roztok\",\"rozum\",\"rozvod\",\"rubrika\",\"ruchadlo\",\"rukavice\",\"rukopis\",\"ryba\",\"rybolov\",\"rychlost\",\"rydlo\",\"rypadlo\",\"rytina\",\"ryzost\",\"sadista\",\"sahat\",\"sako\",\"samec\",\"samizdat\",\"samota\",\"sanitka\",\"sardinka\",\"sasanka\",\"satelit\",\"sazba\",\"sazenice\",\"sbor\",\"schovat\",\"sebranka\",\"secese\",\"sedadlo\",\"sediment\",\"sedlo\",\"sehnat\",\"sejmout\",\"sekera\",\"sekta\",\"sekunda\",\"sekvoje\",\"semeno\",\"seno\",\"servis\",\"sesadit\",\"seshora\",\"seskok\",\"seslat\",\"sestra\",\"sesuv\",\"sesypat\",\"setba\",\"setina\",\"setkat\",\"setnout\",\"setrvat\",\"sever\",\"seznam\",\"shoda\",\"shrnout\",\"sifon\",\"silnice\",\"sirka\",\"sirotek\",\"sirup\",\"situace\",\"skafandr\",\"skalisko\",\"skanzen\",\"skaut\",\"skeptik\",\"skica\",\"skladba\",\"sklenice\",\"sklo\",\"skluz\",\"skoba\",\"skokan\",\"skoro\",\"skripta\",\"skrz\",\"skupina\",\"skvost\",\"skvrna\",\"slabika\",\"sladidlo\",\"slanina\",\"slast\",\"slavnost\",\"sledovat\",\"slepec\",\"sleva\",\"slezina\",\"slib\",\"slina\",\"sliznice\",\"slon\",\"sloupek\",\"slovo\",\"sluch\",\"sluha\",\"slunce\",\"slupka\",\"slza\",\"smaragd\",\"smetana\",\"smilstvo\",\"smlouva\",\"smog\",\"smrad\",\"smrk\",\"smrtka\",\"smutek\",\"smysl\",\"snad\",\"snaha\",\"snob\",\"sobota\",\"socha\",\"sodovka\",\"sokol\",\"sopka\",\"sotva\",\"souboj\",\"soucit\",\"soudce\",\"souhlas\",\"soulad\",\"soumrak\",\"souprava\",\"soused\",\"soutok\",\"souviset\",\"spalovna\",\"spasitel\",\"spis\",\"splav\",\"spodek\",\"spojenec\",\"spolu\",\"sponzor\",\"spornost\",\"spousta\",\"sprcha\",\"spustit\",\"sranda\",\"sraz\",\"srdce\",\"srna\",\"srnec\",\"srovnat\",\"srpen\",\"srst\",\"srub\",\"stanice\",\"starosta\",\"statika\",\"stavba\",\"stehno\",\"stezka\",\"stodola\",\"stolek\",\"stopa\",\"storno\",\"stoupat\",\"strach\",\"stres\",\"strhnout\",\"strom\",\"struna\",\"studna\",\"stupnice\",\"stvol\",\"styk\",\"subjekt\",\"subtropy\",\"suchar\",\"sudost\",\"sukno\",\"sundat\",\"sunout\",\"surikata\",\"surovina\",\"svah\",\"svalstvo\",\"svetr\",\"svatba\",\"svazek\",\"svisle\",\"svitek\",\"svoboda\",\"svodidlo\",\"svorka\",\"svrab\",\"sykavka\",\"sykot\",\"synek\",\"synovec\",\"sypat\",\"sypkost\",\"syrovost\",\"sysel\",\"sytost\",\"tabletka\",\"tabule\",\"tahoun\",\"tajemno\",\"tajfun\",\"tajga\",\"tajit\",\"tajnost\",\"taktika\",\"tamhle\",\"tampon\",\"tancovat\",\"tanec\",\"tanker\",\"tapeta\",\"tavenina\",\"tazatel\",\"technika\",\"tehdy\",\"tekutina\",\"telefon\",\"temnota\",\"tendence\",\"tenista\",\"tenor\",\"teplota\",\"tepna\",\"teprve\",\"terapie\",\"termoska\",\"textil\",\"ticho\",\"tiskopis\",\"titulek\",\"tkadlec\",\"tkanina\",\"tlapka\",\"tleskat\",\"tlukot\",\"tlupa\",\"tmel\",\"toaleta\",\"topinka\",\"topol\",\"torzo\",\"touha\",\"toulec\",\"tradice\",\"traktor\",\"tramp\",\"trasa\",\"traverza\",\"trefit\",\"trest\",\"trezor\",\"trhavina\",\"trhlina\",\"trochu\",\"trojice\",\"troska\",\"trouba\",\"trpce\",\"trpitel\",\"trpkost\",\"trubec\",\"truchlit\",\"truhlice\",\"trus\",\"trvat\",\"tudy\",\"tuhnout\",\"tuhost\",\"tundra\",\"turista\",\"turnaj\",\"tuzemsko\",\"tvaroh\",\"tvorba\",\"tvrdost\",\"tvrz\",\"tygr\",\"tykev\",\"ubohost\",\"uboze\",\"ubrat\",\"ubrousek\",\"ubrus\",\"ubytovna\",\"ucho\",\"uctivost\",\"udivit\",\"uhradit\",\"ujednat\",\"ujistit\",\"ujmout\",\"ukazatel\",\"uklidnit\",\"uklonit\",\"ukotvit\",\"ukrojit\",\"ulice\",\"ulita\",\"ulovit\",\"umyvadlo\",\"unavit\",\"uniforma\",\"uniknout\",\"upadnout\",\"uplatnit\",\"uplynout\",\"upoutat\",\"upravit\",\"uran\",\"urazit\",\"usednout\",\"usilovat\",\"usmrtit\",\"usnadnit\",\"usnout\",\"usoudit\",\"ustlat\",\"ustrnout\",\"utahovat\",\"utkat\",\"utlumit\",\"utonout\",\"utopenec\",\"utrousit\",\"uvalit\",\"uvolnit\",\"uvozovka\",\"uzdravit\",\"uzel\",\"uzenina\",\"uzlina\",\"uznat\",\"vagon\",\"valcha\",\"valoun\",\"vana\",\"vandal\",\"vanilka\",\"varan\",\"varhany\",\"varovat\",\"vcelku\",\"vchod\",\"vdova\",\"vedro\",\"vegetace\",\"vejce\",\"velbloud\",\"veletrh\",\"velitel\",\"velmoc\",\"velryba\",\"venkov\",\"veranda\",\"verze\",\"veselka\",\"veskrze\",\"vesnice\",\"vespodu\",\"vesta\",\"veterina\",\"veverka\",\"vibrace\",\"vichr\",\"videohra\",\"vidina\",\"vidle\",\"vila\",\"vinice\",\"viset\",\"vitalita\",\"vize\",\"vizitka\",\"vjezd\",\"vklad\",\"vkus\",\"vlajka\",\"vlak\",\"vlasec\",\"vlevo\",\"vlhkost\",\"vliv\",\"vlnovka\",\"vloupat\",\"vnucovat\",\"vnuk\",\"voda\",\"vodivost\",\"vodoznak\",\"vodstvo\",\"vojensky\",\"vojna\",\"vojsko\",\"volant\",\"volba\",\"volit\",\"volno\",\"voskovka\",\"vozidlo\",\"vozovna\",\"vpravo\",\"vrabec\",\"vracet\",\"vrah\",\"vrata\",\"vrba\",\"vrcholek\",\"vrhat\",\"vrstva\",\"vrtule\",\"vsadit\",\"vstoupit\",\"vstup\",\"vtip\",\"vybavit\",\"vybrat\",\"vychovat\",\"vydat\",\"vydra\",\"vyfotit\",\"vyhledat\",\"vyhnout\",\"vyhodit\",\"vyhradit\",\"vyhubit\",\"vyjasnit\",\"vyjet\",\"vyjmout\",\"vyklopit\",\"vykonat\",\"vylekat\",\"vymazat\",\"vymezit\",\"vymizet\",\"vymyslet\",\"vynechat\",\"vynikat\",\"vynutit\",\"vypadat\",\"vyplatit\",\"vypravit\",\"vypustit\",\"vyrazit\",\"vyrovnat\",\"vyrvat\",\"vyslovit\",\"vysoko\",\"vystavit\",\"vysunout\",\"vysypat\",\"vytasit\",\"vytesat\",\"vytratit\",\"vyvinout\",\"vyvolat\",\"vyvrhel\",\"vyzdobit\",\"vyznat\",\"vzadu\",\"vzbudit\",\"vzchopit\",\"vzdor\",\"vzduch\",\"vzdychat\",\"vzestup\",\"vzhledem\",\"vzkaz\",\"vzlykat\",\"vznik\",\"vzorek\",\"vzpoura\",\"vztah\",\"vztek\",\"xylofon\",\"zabrat\",\"zabydlet\",\"zachovat\",\"zadarmo\",\"zadusit\",\"zafoukat\",\"zahltit\",\"zahodit\",\"zahrada\",\"zahynout\",\"zajatec\",\"zajet\",\"zajistit\",\"zaklepat\",\"zakoupit\",\"zalepit\",\"zamezit\",\"zamotat\",\"zamyslet\",\"zanechat\",\"zanikat\",\"zaplatit\",\"zapojit\",\"zapsat\",\"zarazit\",\"zastavit\",\"zasunout\",\"zatajit\",\"zatemnit\",\"zatknout\",\"zaujmout\",\"zavalit\",\"zavelet\",\"zavinit\",\"zavolat\",\"zavrtat\",\"zazvonit\",\"zbavit\",\"zbrusu\",\"zbudovat\",\"zbytek\",\"zdaleka\",\"zdarma\",\"zdatnost\",\"zdivo\",\"zdobit\",\"zdroj\",\"zdvih\",\"zdymadlo\",\"zelenina\",\"zeman\",\"zemina\",\"zeptat\",\"zezadu\",\"zezdola\",\"zhatit\",\"zhltnout\",\"zhluboka\",\"zhotovit\",\"zhruba\",\"zima\",\"zimnice\",\"zjemnit\",\"zklamat\",\"zkoumat\",\"zkratka\",\"zkumavka\",\"zlato\",\"zlehka\",\"zloba\",\"zlom\",\"zlost\",\"zlozvyk\",\"zmapovat\",\"zmar\",\"zmatek\",\"zmije\",\"zmizet\",\"zmocnit\",\"zmodrat\",\"zmrzlina\",\"zmutovat\",\"znak\",\"znalost\",\"znamenat\",\"znovu\",\"zobrazit\",\"zotavit\",\"zoubek\",\"zoufale\",\"zplodit\",\"zpomalit\",\"zprava\",\"zprostit\",\"zprudka\",\"zprvu\",\"zrada\",\"zranit\",\"zrcadlo\",\"zrnitost\",\"zrno\",\"zrovna\",\"zrychlit\",\"zrzavost\",\"zticha\",\"ztratit\",\"zubovina\",\"zubr\",\"zvednout\",\"zvenku\",\"zvesela\",\"zvon\",\"zvrat\",\"zvukovod\",\"zvyk\"]");

const require$$1 = /* #__PURE__ */ JSON.parse("[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"]");

const require$$2 = /* #__PURE__ */ JSON.parse("[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"]");

const require$$3 = /* #__PURE__ */ JSON.parse("[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"]");

const require$$4 = /* #__PURE__ */ JSON.parse("[\"abaisser\",\"abandon\",\"abdiquer\",\"abeille\",\"abolir\",\"aborder\",\"aboutir\",\"aboyer\",\"abrasif\",\"abreuver\",\"abriter\",\"abroger\",\"abrupt\",\"absence\",\"absolu\",\"absurde\",\"abusif\",\"abyssal\",\"academie\",\"acajou\",\"acarien\",\"accabler\",\"accepter\",\"acclamer\",\"accolade\",\"accroche\",\"accuser\",\"acerbe\",\"achat\",\"acheter\",\"aciduler\",\"acier\",\"acompte\",\"acquerir\",\"acronyme\",\"acteur\",\"actif\",\"actuel\",\"adepte\",\"adequat\",\"adhesif\",\"adjectif\",\"adjuger\",\"admettre\",\"admirer\",\"adopter\",\"adorer\",\"adoucir\",\"adresse\",\"adroit\",\"adulte\",\"adverbe\",\"aerer\",\"aeronef\",\"affaire\",\"affecter\",\"affiche\",\"affreux\",\"affubler\",\"agacer\",\"agencer\",\"agile\",\"agiter\",\"agrafer\",\"agreable\",\"agrume\",\"aider\",\"aiguille\",\"ailier\",\"aimable\",\"aisance\",\"ajouter\",\"ajuster\",\"alarmer\",\"alchimie\",\"alerte\",\"algebre\",\"algue\",\"aliener\",\"aliment\",\"alleger\",\"alliage\",\"allouer\",\"allumer\",\"alourdir\",\"alpaga\",\"altesse\",\"alveole\",\"amateur\",\"ambigu\",\"ambre\",\"amenager\",\"amertume\",\"amidon\",\"amiral\",\"amorcer\",\"amour\",\"amovible\",\"amphibie\",\"ampleur\",\"amusant\",\"analyse\",\"anaphore\",\"anarchie\",\"anatomie\",\"ancien\",\"aneantir\",\"angle\",\"angoisse\",\"anguleux\",\"animal\",\"annexer\",\"annonce\",\"annuel\",\"anodin\",\"anomalie\",\"anonyme\",\"anormal\",\"antenne\",\"antidote\",\"anxieux\",\"apaiser\",\"aperitif\",\"aplanir\",\"apologie\",\"appareil\",\"appeler\",\"apporter\",\"appuyer\",\"aquarium\",\"aqueduc\",\"arbitre\",\"arbuste\",\"ardeur\",\"ardoise\",\"argent\",\"arlequin\",\"armature\",\"armement\",\"armoire\",\"armure\",\"arpenter\",\"arracher\",\"arriver\",\"arroser\",\"arsenic\",\"arteriel\",\"article\",\"aspect\",\"asphalte\",\"aspirer\",\"assaut\",\"asservir\",\"assiette\",\"associer\",\"assurer\",\"asticot\",\"astre\",\"astuce\",\"atelier\",\"atome\",\"atrium\",\"atroce\",\"attaque\",\"attentif\",\"attirer\",\"attraper\",\"aubaine\",\"auberge\",\"audace\",\"audible\",\"augurer\",\"aurore\",\"automne\",\"autruche\",\"avaler\",\"avancer\",\"avarice\",\"avenir\",\"averse\",\"aveugle\",\"aviateur\",\"avide\",\"avion\",\"aviser\",\"avoine\",\"avouer\",\"avril\",\"axial\",\"axiome\",\"badge\",\"bafouer\",\"bagage\",\"baguette\",\"baignade\",\"balancer\",\"balcon\",\"baleine\",\"balisage\",\"bambin\",\"bancaire\",\"bandage\",\"banlieue\",\"banniere\",\"banquier\",\"barbier\",\"baril\",\"baron\",\"barque\",\"barrage\",\"bassin\",\"bastion\",\"bataille\",\"bateau\",\"batterie\",\"baudrier\",\"bavarder\",\"belette\",\"belier\",\"belote\",\"benefice\",\"berceau\",\"berger\",\"berline\",\"bermuda\",\"besace\",\"besogne\",\"betail\",\"beurre\",\"biberon\",\"bicycle\",\"bidule\",\"bijou\",\"bilan\",\"bilingue\",\"billard\",\"binaire\",\"biologie\",\"biopsie\",\"biotype\",\"biscuit\",\"bison\",\"bistouri\",\"bitume\",\"bizarre\",\"blafard\",\"blague\",\"blanchir\",\"blessant\",\"blinder\",\"blond\",\"bloquer\",\"blouson\",\"bobard\",\"bobine\",\"boire\",\"boiser\",\"bolide\",\"bonbon\",\"bondir\",\"bonheur\",\"bonifier\",\"bonus\",\"bordure\",\"borne\",\"botte\",\"boucle\",\"boueux\",\"bougie\",\"boulon\",\"bouquin\",\"bourse\",\"boussole\",\"boutique\",\"boxeur\",\"branche\",\"brasier\",\"brave\",\"brebis\",\"breche\",\"breuvage\",\"bricoler\",\"brigade\",\"brillant\",\"brioche\",\"brique\",\"brochure\",\"broder\",\"bronzer\",\"brousse\",\"broyeur\",\"brume\",\"brusque\",\"brutal\",\"bruyant\",\"buffle\",\"buisson\",\"bulletin\",\"bureau\",\"burin\",\"bustier\",\"butiner\",\"butoir\",\"buvable\",\"buvette\",\"cabanon\",\"cabine\",\"cachette\",\"cadeau\",\"cadre\",\"cafeine\",\"caillou\",\"caisson\",\"calculer\",\"calepin\",\"calibre\",\"calmer\",\"calomnie\",\"calvaire\",\"camarade\",\"camera\",\"camion\",\"campagne\",\"canal\",\"caneton\",\"canon\",\"cantine\",\"canular\",\"capable\",\"caporal\",\"caprice\",\"capsule\",\"capter\",\"capuche\",\"carabine\",\"carbone\",\"caresser\",\"caribou\",\"carnage\",\"carotte\",\"carreau\",\"carton\",\"cascade\",\"casier\",\"casque\",\"cassure\",\"causer\",\"caution\",\"cavalier\",\"caverne\",\"caviar\",\"cedille\",\"ceinture\",\"celeste\",\"cellule\",\"cendrier\",\"censurer\",\"central\",\"cercle\",\"cerebral\",\"cerise\",\"cerner\",\"cerveau\",\"cesser\",\"chagrin\",\"chaise\",\"chaleur\",\"chambre\",\"chance\",\"chapitre\",\"charbon\",\"chasseur\",\"chaton\",\"chausson\",\"chavirer\",\"chemise\",\"chenille\",\"chequier\",\"chercher\",\"cheval\",\"chien\",\"chiffre\",\"chignon\",\"chimere\",\"chiot\",\"chlorure\",\"chocolat\",\"choisir\",\"chose\",\"chouette\",\"chrome\",\"chute\",\"cigare\",\"cigogne\",\"cimenter\",\"cinema\",\"cintrer\",\"circuler\",\"cirer\",\"cirque\",\"citerne\",\"citoyen\",\"citron\",\"civil\",\"clairon\",\"clameur\",\"claquer\",\"classe\",\"clavier\",\"client\",\"cligner\",\"climat\",\"clivage\",\"cloche\",\"clonage\",\"cloporte\",\"cobalt\",\"cobra\",\"cocasse\",\"cocotier\",\"coder\",\"codifier\",\"coffre\",\"cogner\",\"cohesion\",\"coiffer\",\"coincer\",\"colere\",\"colibri\",\"colline\",\"colmater\",\"colonel\",\"combat\",\"comedie\",\"commande\",\"compact\",\"concert\",\"conduire\",\"confier\",\"congeler\",\"connoter\",\"consonne\",\"contact\",\"convexe\",\"copain\",\"copie\",\"corail\",\"corbeau\",\"cordage\",\"corniche\",\"corpus\",\"correct\",\"cortege\",\"cosmique\",\"costume\",\"coton\",\"coude\",\"coupure\",\"courage\",\"couteau\",\"couvrir\",\"coyote\",\"crabe\",\"crainte\",\"cravate\",\"crayon\",\"creature\",\"crediter\",\"cremeux\",\"creuser\",\"crevette\",\"cribler\",\"crier\",\"cristal\",\"critere\",\"croire\",\"croquer\",\"crotale\",\"crucial\",\"cruel\",\"crypter\",\"cubique\",\"cueillir\",\"cuillere\",\"cuisine\",\"cuivre\",\"culminer\",\"cultiver\",\"cumuler\",\"cupide\",\"curatif\",\"curseur\",\"cyanure\",\"cycle\",\"cylindre\",\"cynique\",\"daigner\",\"damier\",\"danger\",\"danseur\",\"dauphin\",\"debattre\",\"debiter\",\"deborder\",\"debrider\",\"debutant\",\"decaler\",\"decembre\",\"dechirer\",\"decider\",\"declarer\",\"decorer\",\"decrire\",\"decupler\",\"dedale\",\"deductif\",\"deesse\",\"defensif\",\"defiler\",\"defrayer\",\"degager\",\"degivrer\",\"deglutir\",\"degrafer\",\"dejeuner\",\"delice\",\"deloger\",\"demander\",\"demeurer\",\"demolir\",\"denicher\",\"denouer\",\"dentelle\",\"denuder\",\"depart\",\"depenser\",\"dephaser\",\"deplacer\",\"deposer\",\"deranger\",\"derober\",\"desastre\",\"descente\",\"desert\",\"designer\",\"desobeir\",\"dessiner\",\"destrier\",\"detacher\",\"detester\",\"detourer\",\"detresse\",\"devancer\",\"devenir\",\"deviner\",\"devoir\",\"diable\",\"dialogue\",\"diamant\",\"dicter\",\"differer\",\"digerer\",\"digital\",\"digne\",\"diluer\",\"dimanche\",\"diminuer\",\"dioxyde\",\"directif\",\"diriger\",\"discuter\",\"disposer\",\"dissiper\",\"distance\",\"divertir\",\"diviser\",\"docile\",\"docteur\",\"dogme\",\"doigt\",\"domaine\",\"domicile\",\"dompter\",\"donateur\",\"donjon\",\"donner\",\"dopamine\",\"dortoir\",\"dorure\",\"dosage\",\"doseur\",\"dossier\",\"dotation\",\"douanier\",\"double\",\"douceur\",\"douter\",\"doyen\",\"dragon\",\"draper\",\"dresser\",\"dribbler\",\"droiture\",\"duperie\",\"duplexe\",\"durable\",\"durcir\",\"dynastie\",\"eblouir\",\"ecarter\",\"echarpe\",\"echelle\",\"eclairer\",\"eclipse\",\"eclore\",\"ecluse\",\"ecole\",\"economie\",\"ecorce\",\"ecouter\",\"ecraser\",\"ecremer\",\"ecrivain\",\"ecrou\",\"ecume\",\"ecureuil\",\"edifier\",\"eduquer\",\"effacer\",\"effectif\",\"effigie\",\"effort\",\"effrayer\",\"effusion\",\"egaliser\",\"egarer\",\"ejecter\",\"elaborer\",\"elargir\",\"electron\",\"elegant\",\"elephant\",\"eleve\",\"eligible\",\"elitisme\",\"eloge\",\"elucider\",\"eluder\",\"emballer\",\"embellir\",\"embryon\",\"emeraude\",\"emission\",\"emmener\",\"emotion\",\"emouvoir\",\"empereur\",\"employer\",\"emporter\",\"emprise\",\"emulsion\",\"encadrer\",\"enchere\",\"enclave\",\"encoche\",\"endiguer\",\"endosser\",\"endroit\",\"enduire\",\"energie\",\"enfance\",\"enfermer\",\"enfouir\",\"engager\",\"engin\",\"englober\",\"enigme\",\"enjamber\",\"enjeu\",\"enlever\",\"ennemi\",\"ennuyeux\",\"enrichir\",\"enrobage\",\"enseigne\",\"entasser\",\"entendre\",\"entier\",\"entourer\",\"entraver\",\"enumerer\",\"envahir\",\"enviable\",\"envoyer\",\"enzyme\",\"eolien\",\"epaissir\",\"epargne\",\"epatant\",\"epaule\",\"epicerie\",\"epidemie\",\"epier\",\"epilogue\",\"epine\",\"episode\",\"epitaphe\",\"epoque\",\"epreuve\",\"eprouver\",\"epuisant\",\"equerre\",\"equipe\",\"eriger\",\"erosion\",\"erreur\",\"eruption\",\"escalier\",\"espadon\",\"espece\",\"espiegle\",\"espoir\",\"esprit\",\"esquiver\",\"essayer\",\"essence\",\"essieu\",\"essorer\",\"estime\",\"estomac\",\"estrade\",\"etagere\",\"etaler\",\"etanche\",\"etatique\",\"eteindre\",\"etendoir\",\"eternel\",\"ethanol\",\"ethique\",\"ethnie\",\"etirer\",\"etoffer\",\"etoile\",\"etonnant\",\"etourdir\",\"etrange\",\"etroit\",\"etude\",\"euphorie\",\"evaluer\",\"evasion\",\"eventail\",\"evidence\",\"eviter\",\"evolutif\",\"evoquer\",\"exact\",\"exagerer\",\"exaucer\",\"exceller\",\"excitant\",\"exclusif\",\"excuse\",\"executer\",\"exemple\",\"exercer\",\"exhaler\",\"exhorter\",\"exigence\",\"exiler\",\"exister\",\"exotique\",\"expedier\",\"explorer\",\"exposer\",\"exprimer\",\"exquis\",\"extensif\",\"extraire\",\"exulter\",\"fable\",\"fabuleux\",\"facette\",\"facile\",\"facture\",\"faiblir\",\"falaise\",\"fameux\",\"famille\",\"farceur\",\"farfelu\",\"farine\",\"farouche\",\"fasciner\",\"fatal\",\"fatigue\",\"faucon\",\"fautif\",\"faveur\",\"favori\",\"febrile\",\"feconder\",\"federer\",\"felin\",\"femme\",\"femur\",\"fendoir\",\"feodal\",\"fermer\",\"feroce\",\"ferveur\",\"festival\",\"feuille\",\"feutre\",\"fevrier\",\"fiasco\",\"ficeler\",\"fictif\",\"fidele\",\"figure\",\"filature\",\"filetage\",\"filiere\",\"filleul\",\"filmer\",\"filou\",\"filtrer\",\"financer\",\"finir\",\"fiole\",\"firme\",\"fissure\",\"fixer\",\"flairer\",\"flamme\",\"flasque\",\"flatteur\",\"fleau\",\"fleche\",\"fleur\",\"flexion\",\"flocon\",\"flore\",\"fluctuer\",\"fluide\",\"fluvial\",\"folie\",\"fonderie\",\"fongible\",\"fontaine\",\"forcer\",\"forgeron\",\"formuler\",\"fortune\",\"fossile\",\"foudre\",\"fougere\",\"fouiller\",\"foulure\",\"fourmi\",\"fragile\",\"fraise\",\"franchir\",\"frapper\",\"frayeur\",\"fregate\",\"freiner\",\"frelon\",\"fremir\",\"frenesie\",\"frere\",\"friable\",\"friction\",\"frisson\",\"frivole\",\"froid\",\"fromage\",\"frontal\",\"frotter\",\"fruit\",\"fugitif\",\"fuite\",\"fureur\",\"furieux\",\"furtif\",\"fusion\",\"futur\",\"gagner\",\"galaxie\",\"galerie\",\"gambader\",\"garantir\",\"gardien\",\"garnir\",\"garrigue\",\"gazelle\",\"gazon\",\"geant\",\"gelatine\",\"gelule\",\"gendarme\",\"general\",\"genie\",\"genou\",\"gentil\",\"geologie\",\"geometre\",\"geranium\",\"germe\",\"gestuel\",\"geyser\",\"gibier\",\"gicler\",\"girafe\",\"givre\",\"glace\",\"glaive\",\"glisser\",\"globe\",\"gloire\",\"glorieux\",\"golfeur\",\"gomme\",\"gonfler\",\"gorge\",\"gorille\",\"goudron\",\"gouffre\",\"goulot\",\"goupille\",\"gourmand\",\"goutte\",\"graduel\",\"graffiti\",\"graine\",\"grand\",\"grappin\",\"gratuit\",\"gravir\",\"grenat\",\"griffure\",\"griller\",\"grimper\",\"grogner\",\"gronder\",\"grotte\",\"groupe\",\"gruger\",\"grutier\",\"gruyere\",\"guepard\",\"guerrier\",\"guide\",\"guimauve\",\"guitare\",\"gustatif\",\"gymnaste\",\"gyrostat\",\"habitude\",\"hachoir\",\"halte\",\"hameau\",\"hangar\",\"hanneton\",\"haricot\",\"harmonie\",\"harpon\",\"hasard\",\"helium\",\"hematome\",\"herbe\",\"herisson\",\"hermine\",\"heron\",\"hesiter\",\"heureux\",\"hiberner\",\"hibou\",\"hilarant\",\"histoire\",\"hiver\",\"homard\",\"hommage\",\"homogene\",\"honneur\",\"honorer\",\"honteux\",\"horde\",\"horizon\",\"horloge\",\"hormone\",\"horrible\",\"houleux\",\"housse\",\"hublot\",\"huileux\",\"humain\",\"humble\",\"humide\",\"humour\",\"hurler\",\"hydromel\",\"hygiene\",\"hymne\",\"hypnose\",\"idylle\",\"ignorer\",\"iguane\",\"illicite\",\"illusion\",\"image\",\"imbiber\",\"imiter\",\"immense\",\"immobile\",\"immuable\",\"impact\",\"imperial\",\"implorer\",\"imposer\",\"imprimer\",\"imputer\",\"incarner\",\"incendie\",\"incident\",\"incliner\",\"incolore\",\"indexer\",\"indice\",\"inductif\",\"inedit\",\"ineptie\",\"inexact\",\"infini\",\"infliger\",\"informer\",\"infusion\",\"ingerer\",\"inhaler\",\"inhiber\",\"injecter\",\"injure\",\"innocent\",\"inoculer\",\"inonder\",\"inscrire\",\"insecte\",\"insigne\",\"insolite\",\"inspirer\",\"instinct\",\"insulter\",\"intact\",\"intense\",\"intime\",\"intrigue\",\"intuitif\",\"inutile\",\"invasion\",\"inventer\",\"inviter\",\"invoquer\",\"ironique\",\"irradier\",\"irreel\",\"irriter\",\"isoler\",\"ivoire\",\"ivresse\",\"jaguar\",\"jaillir\",\"jambe\",\"janvier\",\"jardin\",\"jauger\",\"jaune\",\"javelot\",\"jetable\",\"jeton\",\"jeudi\",\"jeunesse\",\"joindre\",\"joncher\",\"jongler\",\"joueur\",\"jouissif\",\"journal\",\"jovial\",\"joyau\",\"joyeux\",\"jubiler\",\"jugement\",\"junior\",\"jupon\",\"juriste\",\"justice\",\"juteux\",\"juvenile\",\"kayak\",\"kimono\",\"kiosque\",\"label\",\"labial\",\"labourer\",\"lacerer\",\"lactose\",\"lagune\",\"laine\",\"laisser\",\"laitier\",\"lambeau\",\"lamelle\",\"lampe\",\"lanceur\",\"langage\",\"lanterne\",\"lapin\",\"largeur\",\"larme\",\"laurier\",\"lavabo\",\"lavoir\",\"lecture\",\"legal\",\"leger\",\"legume\",\"lessive\",\"lettre\",\"levier\",\"lexique\",\"lezard\",\"liasse\",\"liberer\",\"libre\",\"licence\",\"licorne\",\"liege\",\"lievre\",\"ligature\",\"ligoter\",\"ligue\",\"limer\",\"limite\",\"limonade\",\"limpide\",\"lineaire\",\"lingot\",\"lionceau\",\"liquide\",\"lisiere\",\"lister\",\"lithium\",\"litige\",\"littoral\",\"livreur\",\"logique\",\"lointain\",\"loisir\",\"lombric\",\"loterie\",\"louer\",\"lourd\",\"loutre\",\"louve\",\"loyal\",\"lubie\",\"lucide\",\"lucratif\",\"lueur\",\"lugubre\",\"luisant\",\"lumiere\",\"lunaire\",\"lundi\",\"luron\",\"lutter\",\"luxueux\",\"machine\",\"magasin\",\"magenta\",\"magique\",\"maigre\",\"maillon\",\"maintien\",\"mairie\",\"maison\",\"majorer\",\"malaxer\",\"malefice\",\"malheur\",\"malice\",\"mallette\",\"mammouth\",\"mandater\",\"maniable\",\"manquant\",\"manteau\",\"manuel\",\"marathon\",\"marbre\",\"marchand\",\"mardi\",\"maritime\",\"marqueur\",\"marron\",\"marteler\",\"mascotte\",\"massif\",\"materiel\",\"matiere\",\"matraque\",\"maudire\",\"maussade\",\"mauve\",\"maximal\",\"mechant\",\"meconnu\",\"medaille\",\"medecin\",\"mediter\",\"meduse\",\"meilleur\",\"melange\",\"melodie\",\"membre\",\"memoire\",\"menacer\",\"mener\",\"menhir\",\"mensonge\",\"mentor\",\"mercredi\",\"merite\",\"merle\",\"messager\",\"mesure\",\"metal\",\"meteore\",\"methode\",\"metier\",\"meuble\",\"miauler\",\"microbe\",\"miette\",\"mignon\",\"migrer\",\"milieu\",\"million\",\"mimique\",\"mince\",\"mineral\",\"minimal\",\"minorer\",\"minute\",\"miracle\",\"miroiter\",\"missile\",\"mixte\",\"mobile\",\"moderne\",\"moelleux\",\"mondial\",\"moniteur\",\"monnaie\",\"monotone\",\"monstre\",\"montagne\",\"monument\",\"moqueur\",\"morceau\",\"morsure\",\"mortier\",\"moteur\",\"motif\",\"mouche\",\"moufle\",\"moulin\",\"mousson\",\"mouton\",\"mouvant\",\"multiple\",\"munition\",\"muraille\",\"murene\",\"murmure\",\"muscle\",\"museum\",\"musicien\",\"mutation\",\"muter\",\"mutuel\",\"myriade\",\"myrtille\",\"mystere\",\"mythique\",\"nageur\",\"nappe\",\"narquois\",\"narrer\",\"natation\",\"nation\",\"nature\",\"naufrage\",\"nautique\",\"navire\",\"nebuleux\",\"nectar\",\"nefaste\",\"negation\",\"negliger\",\"negocier\",\"neige\",\"nerveux\",\"nettoyer\",\"neurone\",\"neutron\",\"neveu\",\"niche\",\"nickel\",\"nitrate\",\"niveau\",\"noble\",\"nocif\",\"nocturne\",\"noirceur\",\"noisette\",\"nomade\",\"nombreux\",\"nommer\",\"normatif\",\"notable\",\"notifier\",\"notoire\",\"nourrir\",\"nouveau\",\"novateur\",\"novembre\",\"novice\",\"nuage\",\"nuancer\",\"nuire\",\"nuisible\",\"numero\",\"nuptial\",\"nuque\",\"nutritif\",\"obeir\",\"objectif\",\"obliger\",\"obscur\",\"observer\",\"obstacle\",\"obtenir\",\"obturer\",\"occasion\",\"occuper\",\"ocean\",\"octobre\",\"octroyer\",\"octupler\",\"oculaire\",\"odeur\",\"odorant\",\"offenser\",\"officier\",\"offrir\",\"ogive\",\"oiseau\",\"oisillon\",\"olfactif\",\"olivier\",\"ombrage\",\"omettre\",\"onctueux\",\"onduler\",\"onereux\",\"onirique\",\"opale\",\"opaque\",\"operer\",\"opinion\",\"opportun\",\"opprimer\",\"opter\",\"optique\",\"orageux\",\"orange\",\"orbite\",\"ordonner\",\"oreille\",\"organe\",\"orgueil\",\"orifice\",\"ornement\",\"orque\",\"ortie\",\"osciller\",\"osmose\",\"ossature\",\"otarie\",\"ouragan\",\"ourson\",\"outil\",\"outrager\",\"ouvrage\",\"ovation\",\"oxyde\",\"oxygene\",\"ozone\",\"paisible\",\"palace\",\"palmares\",\"palourde\",\"palper\",\"panache\",\"panda\",\"pangolin\",\"paniquer\",\"panneau\",\"panorama\",\"pantalon\",\"papaye\",\"papier\",\"papoter\",\"papyrus\",\"paradoxe\",\"parcelle\",\"paresse\",\"parfumer\",\"parler\",\"parole\",\"parrain\",\"parsemer\",\"partager\",\"parure\",\"parvenir\",\"passion\",\"pasteque\",\"paternel\",\"patience\",\"patron\",\"pavillon\",\"pavoiser\",\"payer\",\"paysage\",\"peigne\",\"peintre\",\"pelage\",\"pelican\",\"pelle\",\"pelouse\",\"peluche\",\"pendule\",\"penetrer\",\"penible\",\"pensif\",\"penurie\",\"pepite\",\"peplum\",\"perdrix\",\"perforer\",\"periode\",\"permuter\",\"perplexe\",\"persil\",\"perte\",\"peser\",\"petale\",\"petit\",\"petrir\",\"peuple\",\"pharaon\",\"phobie\",\"phoque\",\"photon\",\"phrase\",\"physique\",\"piano\",\"pictural\",\"piece\",\"pierre\",\"pieuvre\",\"pilote\",\"pinceau\",\"pipette\",\"piquer\",\"pirogue\",\"piscine\",\"piston\",\"pivoter\",\"pixel\",\"pizza\",\"placard\",\"plafond\",\"plaisir\",\"planer\",\"plaque\",\"plastron\",\"plateau\",\"pleurer\",\"plexus\",\"pliage\",\"plomb\",\"plonger\",\"pluie\",\"plumage\",\"pochette\",\"poesie\",\"poete\",\"pointe\",\"poirier\",\"poisson\",\"poivre\",\"polaire\",\"policier\",\"pollen\",\"polygone\",\"pommade\",\"pompier\",\"ponctuel\",\"ponderer\",\"poney\",\"portique\",\"position\",\"posseder\",\"posture\",\"potager\",\"poteau\",\"potion\",\"pouce\",\"poulain\",\"poumon\",\"pourpre\",\"poussin\",\"pouvoir\",\"prairie\",\"pratique\",\"precieux\",\"predire\",\"prefixe\",\"prelude\",\"prenom\",\"presence\",\"pretexte\",\"prevoir\",\"primitif\",\"prince\",\"prison\",\"priver\",\"probleme\",\"proceder\",\"prodige\",\"profond\",\"progres\",\"proie\",\"projeter\",\"prologue\",\"promener\",\"propre\",\"prospere\",\"proteger\",\"prouesse\",\"proverbe\",\"prudence\",\"pruneau\",\"psychose\",\"public\",\"puceron\",\"puiser\",\"pulpe\",\"pulsar\",\"punaise\",\"punitif\",\"pupitre\",\"purifier\",\"puzzle\",\"pyramide\",\"quasar\",\"querelle\",\"question\",\"quietude\",\"quitter\",\"quotient\",\"racine\",\"raconter\",\"radieux\",\"ragondin\",\"raideur\",\"raisin\",\"ralentir\",\"rallonge\",\"ramasser\",\"rapide\",\"rasage\",\"ratisser\",\"ravager\",\"ravin\",\"rayonner\",\"reactif\",\"reagir\",\"realiser\",\"reanimer\",\"recevoir\",\"reciter\",\"reclamer\",\"recolter\",\"recruter\",\"reculer\",\"recycler\",\"rediger\",\"redouter\",\"refaire\",\"reflexe\",\"reformer\",\"refrain\",\"refuge\",\"regalien\",\"region\",\"reglage\",\"regulier\",\"reiterer\",\"rejeter\",\"rejouer\",\"relatif\",\"relever\",\"relief\",\"remarque\",\"remede\",\"remise\",\"remonter\",\"remplir\",\"remuer\",\"renard\",\"renfort\",\"renifler\",\"renoncer\",\"rentrer\",\"renvoi\",\"replier\",\"reporter\",\"reprise\",\"reptile\",\"requin\",\"reserve\",\"resineux\",\"resoudre\",\"respect\",\"rester\",\"resultat\",\"retablir\",\"retenir\",\"reticule\",\"retomber\",\"retracer\",\"reunion\",\"reussir\",\"revanche\",\"revivre\",\"revolte\",\"revulsif\",\"richesse\",\"rideau\",\"rieur\",\"rigide\",\"rigoler\",\"rincer\",\"riposter\",\"risible\",\"risque\",\"rituel\",\"rival\",\"riviere\",\"rocheux\",\"romance\",\"rompre\",\"ronce\",\"rondin\",\"roseau\",\"rosier\",\"rotatif\",\"rotor\",\"rotule\",\"rouge\",\"rouille\",\"rouleau\",\"routine\",\"royaume\",\"ruban\",\"rubis\",\"ruche\",\"ruelle\",\"rugueux\",\"ruiner\",\"ruisseau\",\"ruser\",\"rustique\",\"rythme\",\"sabler\",\"saboter\",\"sabre\",\"sacoche\",\"safari\",\"sagesse\",\"saisir\",\"salade\",\"salive\",\"salon\",\"saluer\",\"samedi\",\"sanction\",\"sanglier\",\"sarcasme\",\"sardine\",\"saturer\",\"saugrenu\",\"saumon\",\"sauter\",\"sauvage\",\"savant\",\"savonner\",\"scalpel\",\"scandale\",\"scelerat\",\"scenario\",\"sceptre\",\"schema\",\"science\",\"scinder\",\"score\",\"scrutin\",\"sculpter\",\"seance\",\"secable\",\"secher\",\"secouer\",\"secreter\",\"sedatif\",\"seduire\",\"seigneur\",\"sejour\",\"selectif\",\"semaine\",\"sembler\",\"semence\",\"seminal\",\"senateur\",\"sensible\",\"sentence\",\"separer\",\"sequence\",\"serein\",\"sergent\",\"serieux\",\"serrure\",\"serum\",\"service\",\"sesame\",\"sevir\",\"sevrage\",\"sextuple\",\"sideral\",\"siecle\",\"sieger\",\"siffler\",\"sigle\",\"signal\",\"silence\",\"silicium\",\"simple\",\"sincere\",\"sinistre\",\"siphon\",\"sirop\",\"sismique\",\"situer\",\"skier\",\"social\",\"socle\",\"sodium\",\"soigneux\",\"soldat\",\"soleil\",\"solitude\",\"soluble\",\"sombre\",\"sommeil\",\"somnoler\",\"sonde\",\"songeur\",\"sonnette\",\"sonore\",\"sorcier\",\"sortir\",\"sosie\",\"sottise\",\"soucieux\",\"soudure\",\"souffle\",\"soulever\",\"soupape\",\"source\",\"soutirer\",\"souvenir\",\"spacieux\",\"spatial\",\"special\",\"sphere\",\"spiral\",\"stable\",\"station\",\"sternum\",\"stimulus\",\"stipuler\",\"strict\",\"studieux\",\"stupeur\",\"styliste\",\"sublime\",\"substrat\",\"subtil\",\"subvenir\",\"succes\",\"sucre\",\"suffixe\",\"suggerer\",\"suiveur\",\"sulfate\",\"superbe\",\"supplier\",\"surface\",\"suricate\",\"surmener\",\"surprise\",\"sursaut\",\"survie\",\"suspect\",\"syllabe\",\"symbole\",\"symetrie\",\"synapse\",\"syntaxe\",\"systeme\",\"tabac\",\"tablier\",\"tactile\",\"tailler\",\"talent\",\"talisman\",\"talonner\",\"tambour\",\"tamiser\",\"tangible\",\"tapis\",\"taquiner\",\"tarder\",\"tarif\",\"tartine\",\"tasse\",\"tatami\",\"tatouage\",\"taupe\",\"taureau\",\"taxer\",\"temoin\",\"temporel\",\"tenaille\",\"tendre\",\"teneur\",\"tenir\",\"tension\",\"terminer\",\"terne\",\"terrible\",\"tetine\",\"texte\",\"theme\",\"theorie\",\"therapie\",\"thorax\",\"tibia\",\"tiede\",\"timide\",\"tirelire\",\"tiroir\",\"tissu\",\"titane\",\"titre\",\"tituber\",\"toboggan\",\"tolerant\",\"tomate\",\"tonique\",\"tonneau\",\"toponyme\",\"torche\",\"tordre\",\"tornade\",\"torpille\",\"torrent\",\"torse\",\"tortue\",\"totem\",\"toucher\",\"tournage\",\"tousser\",\"toxine\",\"traction\",\"trafic\",\"tragique\",\"trahir\",\"train\",\"trancher\",\"travail\",\"trefle\",\"tremper\",\"tresor\",\"treuil\",\"triage\",\"tribunal\",\"tricoter\",\"trilogie\",\"triomphe\",\"tripler\",\"triturer\",\"trivial\",\"trombone\",\"tronc\",\"tropical\",\"troupeau\",\"tuile\",\"tulipe\",\"tumulte\",\"tunnel\",\"turbine\",\"tuteur\",\"tutoyer\",\"tuyau\",\"tympan\",\"typhon\",\"typique\",\"tyran\",\"ubuesque\",\"ultime\",\"ultrason\",\"unanime\",\"unifier\",\"union\",\"unique\",\"unitaire\",\"univers\",\"uranium\",\"urbain\",\"urticant\",\"usage\",\"usine\",\"usuel\",\"usure\",\"utile\",\"utopie\",\"vacarme\",\"vaccin\",\"vagabond\",\"vague\",\"vaillant\",\"vaincre\",\"vaisseau\",\"valable\",\"valise\",\"vallon\",\"valve\",\"vampire\",\"vanille\",\"vapeur\",\"varier\",\"vaseux\",\"vassal\",\"vaste\",\"vecteur\",\"vedette\",\"vegetal\",\"vehicule\",\"veinard\",\"veloce\",\"vendredi\",\"venerer\",\"venger\",\"venimeux\",\"ventouse\",\"verdure\",\"verin\",\"vernir\",\"verrou\",\"verser\",\"vertu\",\"veston\",\"veteran\",\"vetuste\",\"vexant\",\"vexer\",\"viaduc\",\"viande\",\"victoire\",\"vidange\",\"video\",\"vignette\",\"vigueur\",\"vilain\",\"village\",\"vinaigre\",\"violon\",\"vipere\",\"virement\",\"virtuose\",\"virus\",\"visage\",\"viseur\",\"vision\",\"visqueux\",\"visuel\",\"vital\",\"vitesse\",\"viticole\",\"vitrine\",\"vivace\",\"vivipare\",\"vocation\",\"voguer\",\"voile\",\"voisin\",\"voiture\",\"volaille\",\"volcan\",\"voltiger\",\"volume\",\"vorace\",\"vortex\",\"voter\",\"vouloir\",\"voyage\",\"voyelle\",\"wagon\",\"xenon\",\"yacht\",\"zebre\",\"zenith\",\"zeste\",\"zoologie\"]");

const require$$5 = /* #__PURE__ */ JSON.parse("[\"abaco\",\"abbaglio\",\"abbinato\",\"abete\",\"abisso\",\"abolire\",\"abrasivo\",\"abrogato\",\"accadere\",\"accenno\",\"accusato\",\"acetone\",\"achille\",\"acido\",\"acqua\",\"acre\",\"acrilico\",\"acrobata\",\"acuto\",\"adagio\",\"addebito\",\"addome\",\"adeguato\",\"aderire\",\"adipe\",\"adottare\",\"adulare\",\"affabile\",\"affetto\",\"affisso\",\"affranto\",\"aforisma\",\"afoso\",\"africano\",\"agave\",\"agente\",\"agevole\",\"aggancio\",\"agire\",\"agitare\",\"agonismo\",\"agricolo\",\"agrumeto\",\"aguzzo\",\"alabarda\",\"alato\",\"albatro\",\"alberato\",\"albo\",\"albume\",\"alce\",\"alcolico\",\"alettone\",\"alfa\",\"algebra\",\"aliante\",\"alibi\",\"alimento\",\"allagato\",\"allegro\",\"allievo\",\"allodola\",\"allusivo\",\"almeno\",\"alogeno\",\"alpaca\",\"alpestre\",\"altalena\",\"alterno\",\"alticcio\",\"altrove\",\"alunno\",\"alveolo\",\"alzare\",\"amalgama\",\"amanita\",\"amarena\",\"ambito\",\"ambrato\",\"ameba\",\"america\",\"ametista\",\"amico\",\"ammasso\",\"ammenda\",\"ammirare\",\"ammonito\",\"amore\",\"ampio\",\"ampliare\",\"amuleto\",\"anacardo\",\"anagrafe\",\"analista\",\"anarchia\",\"anatra\",\"anca\",\"ancella\",\"ancora\",\"andare\",\"andrea\",\"anello\",\"angelo\",\"angolare\",\"angusto\",\"anima\",\"annegare\",\"annidato\",\"anno\",\"annuncio\",\"anonimo\",\"anticipo\",\"anzi\",\"apatico\",\"apertura\",\"apode\",\"apparire\",\"appetito\",\"appoggio\",\"approdo\",\"appunto\",\"aprile\",\"arabica\",\"arachide\",\"aragosta\",\"araldica\",\"arancio\",\"aratura\",\"arazzo\",\"arbitro\",\"archivio\",\"ardito\",\"arenile\",\"argento\",\"argine\",\"arguto\",\"aria\",\"armonia\",\"arnese\",\"arredato\",\"arringa\",\"arrosto\",\"arsenico\",\"arso\",\"artefice\",\"arzillo\",\"asciutto\",\"ascolto\",\"asepsi\",\"asettico\",\"asfalto\",\"asino\",\"asola\",\"aspirato\",\"aspro\",\"assaggio\",\"asse\",\"assoluto\",\"assurdo\",\"asta\",\"astenuto\",\"astice\",\"astratto\",\"atavico\",\"ateismo\",\"atomico\",\"atono\",\"attesa\",\"attivare\",\"attorno\",\"attrito\",\"attuale\",\"ausilio\",\"austria\",\"autista\",\"autonomo\",\"autunno\",\"avanzato\",\"avere\",\"avvenire\",\"avviso\",\"avvolgere\",\"azione\",\"azoto\",\"azzimo\",\"azzurro\",\"babele\",\"baccano\",\"bacino\",\"baco\",\"badessa\",\"badilata\",\"bagnato\",\"baita\",\"balcone\",\"baldo\",\"balena\",\"ballata\",\"balzano\",\"bambino\",\"bandire\",\"baraonda\",\"barbaro\",\"barca\",\"baritono\",\"barlume\",\"barocco\",\"basilico\",\"basso\",\"batosta\",\"battuto\",\"baule\",\"bava\",\"bavosa\",\"becco\",\"beffa\",\"belgio\",\"belva\",\"benda\",\"benevole\",\"benigno\",\"benzina\",\"bere\",\"berlina\",\"beta\",\"bibita\",\"bici\",\"bidone\",\"bifido\",\"biga\",\"bilancia\",\"bimbo\",\"binocolo\",\"biologo\",\"bipede\",\"bipolare\",\"birbante\",\"birra\",\"biscotto\",\"bisesto\",\"bisnonno\",\"bisonte\",\"bisturi\",\"bizzarro\",\"blando\",\"blatta\",\"bollito\",\"bonifico\",\"bordo\",\"bosco\",\"botanico\",\"bottino\",\"bozzolo\",\"braccio\",\"bradipo\",\"brama\",\"branca\",\"bravura\",\"bretella\",\"brevetto\",\"brezza\",\"briglia\",\"brillante\",\"brindare\",\"broccolo\",\"brodo\",\"bronzina\",\"brullo\",\"bruno\",\"bubbone\",\"buca\",\"budino\",\"buffone\",\"buio\",\"bulbo\",\"buono\",\"burlone\",\"burrasca\",\"bussola\",\"busta\",\"cadetto\",\"caduco\",\"calamaro\",\"calcolo\",\"calesse\",\"calibro\",\"calmo\",\"caloria\",\"cambusa\",\"camerata\",\"camicia\",\"cammino\",\"camola\",\"campale\",\"canapa\",\"candela\",\"cane\",\"canino\",\"canotto\",\"cantina\",\"capace\",\"capello\",\"capitolo\",\"capogiro\",\"cappero\",\"capra\",\"capsula\",\"carapace\",\"carcassa\",\"cardo\",\"carisma\",\"carovana\",\"carretto\",\"cartolina\",\"casaccio\",\"cascata\",\"caserma\",\"caso\",\"cassone\",\"castello\",\"casuale\",\"catasta\",\"catena\",\"catrame\",\"cauto\",\"cavillo\",\"cedibile\",\"cedrata\",\"cefalo\",\"celebre\",\"cellulare\",\"cena\",\"cenone\",\"centesimo\",\"ceramica\",\"cercare\",\"certo\",\"cerume\",\"cervello\",\"cesoia\",\"cespo\",\"ceto\",\"chela\",\"chiaro\",\"chicca\",\"chiedere\",\"chimera\",\"china\",\"chirurgo\",\"chitarra\",\"ciao\",\"ciclismo\",\"cifrare\",\"cigno\",\"cilindro\",\"ciottolo\",\"circa\",\"cirrosi\",\"citrico\",\"cittadino\",\"ciuffo\",\"civetta\",\"civile\",\"classico\",\"clinica\",\"cloro\",\"cocco\",\"codardo\",\"codice\",\"coerente\",\"cognome\",\"collare\",\"colmato\",\"colore\",\"colposo\",\"coltivato\",\"colza\",\"coma\",\"cometa\",\"commando\",\"comodo\",\"computer\",\"comune\",\"conciso\",\"condurre\",\"conferma\",\"congelare\",\"coniuge\",\"connesso\",\"conoscere\",\"consumo\",\"continuo\",\"convegno\",\"coperto\",\"copione\",\"coppia\",\"copricapo\",\"corazza\",\"cordata\",\"coricato\",\"cornice\",\"corolla\",\"corpo\",\"corredo\",\"corsia\",\"cortese\",\"cosmico\",\"costante\",\"cottura\",\"covato\",\"cratere\",\"cravatta\",\"creato\",\"credere\",\"cremoso\",\"crescita\",\"creta\",\"criceto\",\"crinale\",\"crisi\",\"critico\",\"croce\",\"cronaca\",\"crostata\",\"cruciale\",\"crusca\",\"cucire\",\"cuculo\",\"cugino\",\"cullato\",\"cupola\",\"curatore\",\"cursore\",\"curvo\",\"cuscino\",\"custode\",\"dado\",\"daino\",\"dalmata\",\"damerino\",\"daniela\",\"dannoso\",\"danzare\",\"datato\",\"davanti\",\"davvero\",\"debutto\",\"decennio\",\"deciso\",\"declino\",\"decollo\",\"decreto\",\"dedicato\",\"definito\",\"deforme\",\"degno\",\"delegare\",\"delfino\",\"delirio\",\"delta\",\"demenza\",\"denotato\",\"dentro\",\"deposito\",\"derapata\",\"derivare\",\"deroga\",\"descritto\",\"deserto\",\"desiderio\",\"desumere\",\"detersivo\",\"devoto\",\"diametro\",\"dicembre\",\"diedro\",\"difeso\",\"diffuso\",\"digerire\",\"digitale\",\"diluvio\",\"dinamico\",\"dinnanzi\",\"dipinto\",\"diploma\",\"dipolo\",\"diradare\",\"dire\",\"dirotto\",\"dirupo\",\"disagio\",\"discreto\",\"disfare\",\"disgelo\",\"disposto\",\"distanza\",\"disumano\",\"dito\",\"divano\",\"divelto\",\"dividere\",\"divorato\",\"doblone\",\"docente\",\"doganale\",\"dogma\",\"dolce\",\"domato\",\"domenica\",\"dominare\",\"dondolo\",\"dono\",\"dormire\",\"dote\",\"dottore\",\"dovuto\",\"dozzina\",\"drago\",\"druido\",\"dubbio\",\"dubitare\",\"ducale\",\"duna\",\"duomo\",\"duplice\",\"duraturo\",\"ebano\",\"eccesso\",\"ecco\",\"eclissi\",\"economia\",\"edera\",\"edicola\",\"edile\",\"editoria\",\"educare\",\"egemonia\",\"egli\",\"egoismo\",\"egregio\",\"elaborato\",\"elargire\",\"elegante\",\"elencato\",\"eletto\",\"elevare\",\"elfico\",\"elica\",\"elmo\",\"elsa\",\"eluso\",\"emanato\",\"emblema\",\"emesso\",\"emiro\",\"emotivo\",\"emozione\",\"empirico\",\"emulo\",\"endemico\",\"enduro\",\"energia\",\"enfasi\",\"enoteca\",\"entrare\",\"enzima\",\"epatite\",\"epilogo\",\"episodio\",\"epocale\",\"eppure\",\"equatore\",\"erario\",\"erba\",\"erboso\",\"erede\",\"eremita\",\"erigere\",\"ermetico\",\"eroe\",\"erosivo\",\"errante\",\"esagono\",\"esame\",\"esanime\",\"esaudire\",\"esca\",\"esempio\",\"esercito\",\"esibito\",\"esigente\",\"esistere\",\"esito\",\"esofago\",\"esortato\",\"esoso\",\"espanso\",\"espresso\",\"essenza\",\"esso\",\"esteso\",\"estimare\",\"estonia\",\"estroso\",\"esultare\",\"etilico\",\"etnico\",\"etrusco\",\"etto\",\"euclideo\",\"europa\",\"evaso\",\"evidenza\",\"evitato\",\"evoluto\",\"evviva\",\"fabbrica\",\"faccenda\",\"fachiro\",\"falco\",\"famiglia\",\"fanale\",\"fanfara\",\"fango\",\"fantasma\",\"fare\",\"farfalla\",\"farinoso\",\"farmaco\",\"fascia\",\"fastoso\",\"fasullo\",\"faticare\",\"fato\",\"favoloso\",\"febbre\",\"fecola\",\"fede\",\"fegato\",\"felpa\",\"feltro\",\"femmina\",\"fendere\",\"fenomeno\",\"fermento\",\"ferro\",\"fertile\",\"fessura\",\"festivo\",\"fetta\",\"feudo\",\"fiaba\",\"fiducia\",\"fifa\",\"figurato\",\"filo\",\"finanza\",\"finestra\",\"finire\",\"fiore\",\"fiscale\",\"fisico\",\"fiume\",\"flacone\",\"flamenco\",\"flebo\",\"flemma\",\"florido\",\"fluente\",\"fluoro\",\"fobico\",\"focaccia\",\"focoso\",\"foderato\",\"foglio\",\"folata\",\"folclore\",\"folgore\",\"fondente\",\"fonetico\",\"fonia\",\"fontana\",\"forbito\",\"forchetta\",\"foresta\",\"formica\",\"fornaio\",\"foro\",\"fortezza\",\"forzare\",\"fosfato\",\"fosso\",\"fracasso\",\"frana\",\"frassino\",\"fratello\",\"freccetta\",\"frenata\",\"fresco\",\"frigo\",\"frollino\",\"fronde\",\"frugale\",\"frutta\",\"fucilata\",\"fucsia\",\"fuggente\",\"fulmine\",\"fulvo\",\"fumante\",\"fumetto\",\"fumoso\",\"fune\",\"funzione\",\"fuoco\",\"furbo\",\"furgone\",\"furore\",\"fuso\",\"futile\",\"gabbiano\",\"gaffe\",\"galateo\",\"gallina\",\"galoppo\",\"gambero\",\"gamma\",\"garanzia\",\"garbo\",\"garofano\",\"garzone\",\"gasdotto\",\"gasolio\",\"gastrico\",\"gatto\",\"gaudio\",\"gazebo\",\"gazzella\",\"geco\",\"gelatina\",\"gelso\",\"gemello\",\"gemmato\",\"gene\",\"genitore\",\"gennaio\",\"genotipo\",\"gergo\",\"ghepardo\",\"ghiaccio\",\"ghisa\",\"giallo\",\"gilda\",\"ginepro\",\"giocare\",\"gioiello\",\"giorno\",\"giove\",\"girato\",\"girone\",\"gittata\",\"giudizio\",\"giurato\",\"giusto\",\"globulo\",\"glutine\",\"gnomo\",\"gobba\",\"golf\",\"gomito\",\"gommone\",\"gonfio\",\"gonna\",\"governo\",\"gracile\",\"grado\",\"grafico\",\"grammo\",\"grande\",\"grattare\",\"gravoso\",\"grazia\",\"greca\",\"gregge\",\"grifone\",\"grigio\",\"grinza\",\"grotta\",\"gruppo\",\"guadagno\",\"guaio\",\"guanto\",\"guardare\",\"gufo\",\"guidare\",\"ibernato\",\"icona\",\"identico\",\"idillio\",\"idolo\",\"idra\",\"idrico\",\"idrogeno\",\"igiene\",\"ignaro\",\"ignorato\",\"ilare\",\"illeso\",\"illogico\",\"illudere\",\"imballo\",\"imbevuto\",\"imbocco\",\"imbuto\",\"immane\",\"immerso\",\"immolato\",\"impacco\",\"impeto\",\"impiego\",\"importo\",\"impronta\",\"inalare\",\"inarcare\",\"inattivo\",\"incanto\",\"incendio\",\"inchino\",\"incisivo\",\"incluso\",\"incontro\",\"incrocio\",\"incubo\",\"indagine\",\"india\",\"indole\",\"inedito\",\"infatti\",\"infilare\",\"inflitto\",\"ingaggio\",\"ingegno\",\"inglese\",\"ingordo\",\"ingrosso\",\"innesco\",\"inodore\",\"inoltrare\",\"inondato\",\"insano\",\"insetto\",\"insieme\",\"insonnia\",\"insulina\",\"intasato\",\"intero\",\"intonaco\",\"intuito\",\"inumidire\",\"invalido\",\"invece\",\"invito\",\"iperbole\",\"ipnotico\",\"ipotesi\",\"ippica\",\"iride\",\"irlanda\",\"ironico\",\"irrigato\",\"irrorare\",\"isolato\",\"isotopo\",\"isterico\",\"istituto\",\"istrice\",\"italia\",\"iterare\",\"labbro\",\"labirinto\",\"lacca\",\"lacerato\",\"lacrima\",\"lacuna\",\"laddove\",\"lago\",\"lampo\",\"lancetta\",\"lanterna\",\"lardoso\",\"larga\",\"laringe\",\"lastra\",\"latenza\",\"latino\",\"lattuga\",\"lavagna\",\"lavoro\",\"legale\",\"leggero\",\"lembo\",\"lentezza\",\"lenza\",\"leone\",\"lepre\",\"lesivo\",\"lessato\",\"lesto\",\"letterale\",\"leva\",\"levigato\",\"libero\",\"lido\",\"lievito\",\"lilla\",\"limatura\",\"limitare\",\"limpido\",\"lineare\",\"lingua\",\"liquido\",\"lira\",\"lirica\",\"lisca\",\"lite\",\"litigio\",\"livrea\",\"locanda\",\"lode\",\"logica\",\"lombare\",\"londra\",\"longevo\",\"loquace\",\"lorenzo\",\"loto\",\"lotteria\",\"luce\",\"lucidato\",\"lumaca\",\"luminoso\",\"lungo\",\"lupo\",\"luppolo\",\"lusinga\",\"lusso\",\"lutto\",\"macabro\",\"macchina\",\"macero\",\"macinato\",\"madama\",\"magico\",\"maglia\",\"magnete\",\"magro\",\"maiolica\",\"malafede\",\"malgrado\",\"malinteso\",\"malsano\",\"malto\",\"malumore\",\"mana\",\"mancia\",\"mandorla\",\"mangiare\",\"manifesto\",\"mannaro\",\"manovra\",\"mansarda\",\"mantide\",\"manubrio\",\"mappa\",\"maratona\",\"marcire\",\"maretta\",\"marmo\",\"marsupio\",\"maschera\",\"massaia\",\"mastino\",\"materasso\",\"matricola\",\"mattone\",\"maturo\",\"mazurca\",\"meandro\",\"meccanico\",\"mecenate\",\"medesimo\",\"meditare\",\"mega\",\"melassa\",\"melis\",\"melodia\",\"meninge\",\"meno\",\"mensola\",\"mercurio\",\"merenda\",\"merlo\",\"meschino\",\"mese\",\"messere\",\"mestolo\",\"metallo\",\"metodo\",\"mettere\",\"miagolare\",\"mica\",\"micelio\",\"michele\",\"microbo\",\"midollo\",\"miele\",\"migliore\",\"milano\",\"milite\",\"mimosa\",\"minerale\",\"mini\",\"minore\",\"mirino\",\"mirtillo\",\"miscela\",\"missiva\",\"misto\",\"misurare\",\"mitezza\",\"mitigare\",\"mitra\",\"mittente\",\"mnemonico\",\"modello\",\"modifica\",\"modulo\",\"mogano\",\"mogio\",\"mole\",\"molosso\",\"monastero\",\"monco\",\"mondina\",\"monetario\",\"monile\",\"monotono\",\"monsone\",\"montato\",\"monviso\",\"mora\",\"mordere\",\"morsicato\",\"mostro\",\"motivato\",\"motosega\",\"motto\",\"movenza\",\"movimento\",\"mozzo\",\"mucca\",\"mucosa\",\"muffa\",\"mughetto\",\"mugnaio\",\"mulatto\",\"mulinello\",\"multiplo\",\"mummia\",\"munto\",\"muovere\",\"murale\",\"musa\",\"muscolo\",\"musica\",\"mutevole\",\"muto\",\"nababbo\",\"nafta\",\"nanometro\",\"narciso\",\"narice\",\"narrato\",\"nascere\",\"nastrare\",\"naturale\",\"nautica\",\"naviglio\",\"nebulosa\",\"necrosi\",\"negativo\",\"negozio\",\"nemmeno\",\"neofita\",\"neretto\",\"nervo\",\"nessuno\",\"nettuno\",\"neutrale\",\"neve\",\"nevrotico\",\"nicchia\",\"ninfa\",\"nitido\",\"nobile\",\"nocivo\",\"nodo\",\"nome\",\"nomina\",\"nordico\",\"normale\",\"norvegese\",\"nostrano\",\"notare\",\"notizia\",\"notturno\",\"novella\",\"nucleo\",\"nulla\",\"numero\",\"nuovo\",\"nutrire\",\"nuvola\",\"nuziale\",\"oasi\",\"obbedire\",\"obbligo\",\"obelisco\",\"oblio\",\"obolo\",\"obsoleto\",\"occasione\",\"occhio\",\"occidente\",\"occorrere\",\"occultare\",\"ocra\",\"oculato\",\"odierno\",\"odorare\",\"offerta\",\"offrire\",\"offuscato\",\"oggetto\",\"oggi\",\"ognuno\",\"olandese\",\"olfatto\",\"oliato\",\"oliva\",\"ologramma\",\"oltre\",\"omaggio\",\"ombelico\",\"ombra\",\"omega\",\"omissione\",\"ondoso\",\"onere\",\"onice\",\"onnivoro\",\"onorevole\",\"onta\",\"operato\",\"opinione\",\"opposto\",\"oracolo\",\"orafo\",\"ordine\",\"orecchino\",\"orefice\",\"orfano\",\"organico\",\"origine\",\"orizzonte\",\"orma\",\"ormeggio\",\"ornativo\",\"orologio\",\"orrendo\",\"orribile\",\"ortensia\",\"ortica\",\"orzata\",\"orzo\",\"osare\",\"oscurare\",\"osmosi\",\"ospedale\",\"ospite\",\"ossa\",\"ossidare\",\"ostacolo\",\"oste\",\"otite\",\"otre\",\"ottagono\",\"ottimo\",\"ottobre\",\"ovale\",\"ovest\",\"ovino\",\"oviparo\",\"ovocito\",\"ovunque\",\"ovviare\",\"ozio\",\"pacchetto\",\"pace\",\"pacifico\",\"padella\",\"padrone\",\"paese\",\"paga\",\"pagina\",\"palazzina\",\"palesare\",\"pallido\",\"palo\",\"palude\",\"pandoro\",\"pannello\",\"paolo\",\"paonazzo\",\"paprica\",\"parabola\",\"parcella\",\"parere\",\"pargolo\",\"pari\",\"parlato\",\"parola\",\"partire\",\"parvenza\",\"parziale\",\"passivo\",\"pasticca\",\"patacca\",\"patologia\",\"pattume\",\"pavone\",\"peccato\",\"pedalare\",\"pedonale\",\"peggio\",\"peloso\",\"penare\",\"pendice\",\"penisola\",\"pennuto\",\"penombra\",\"pensare\",\"pentola\",\"pepe\",\"pepita\",\"perbene\",\"percorso\",\"perdonato\",\"perforare\",\"pergamena\",\"periodo\",\"permesso\",\"perno\",\"perplesso\",\"persuaso\",\"pertugio\",\"pervaso\",\"pesatore\",\"pesista\",\"peso\",\"pestifero\",\"petalo\",\"pettine\",\"petulante\",\"pezzo\",\"piacere\",\"pianta\",\"piattino\",\"piccino\",\"picozza\",\"piega\",\"pietra\",\"piffero\",\"pigiama\",\"pigolio\",\"pigro\",\"pila\",\"pilifero\",\"pillola\",\"pilota\",\"pimpante\",\"pineta\",\"pinna\",\"pinolo\",\"pioggia\",\"piombo\",\"piramide\",\"piretico\",\"pirite\",\"pirolisi\",\"pitone\",\"pizzico\",\"placebo\",\"planare\",\"plasma\",\"platano\",\"plenario\",\"pochezza\",\"poderoso\",\"podismo\",\"poesia\",\"poggiare\",\"polenta\",\"poligono\",\"pollice\",\"polmonite\",\"polpetta\",\"polso\",\"poltrona\",\"polvere\",\"pomice\",\"pomodoro\",\"ponte\",\"popoloso\",\"porfido\",\"poroso\",\"porpora\",\"porre\",\"portata\",\"posa\",\"positivo\",\"possesso\",\"postulato\",\"potassio\",\"potere\",\"pranzo\",\"prassi\",\"pratica\",\"precluso\",\"predica\",\"prefisso\",\"pregiato\",\"prelievo\",\"premere\",\"prenotare\",\"preparato\",\"presenza\",\"pretesto\",\"prevalso\",\"prima\",\"principe\",\"privato\",\"problema\",\"procura\",\"produrre\",\"profumo\",\"progetto\",\"prolunga\",\"promessa\",\"pronome\",\"proposta\",\"proroga\",\"proteso\",\"prova\",\"prudente\",\"prugna\",\"prurito\",\"psiche\",\"pubblico\",\"pudica\",\"pugilato\",\"pugno\",\"pulce\",\"pulito\",\"pulsante\",\"puntare\",\"pupazzo\",\"pupilla\",\"puro\",\"quadro\",\"qualcosa\",\"quasi\",\"querela\",\"quota\",\"raccolto\",\"raddoppio\",\"radicale\",\"radunato\",\"raffica\",\"ragazzo\",\"ragione\",\"ragno\",\"ramarro\",\"ramingo\",\"ramo\",\"randagio\",\"rantolare\",\"rapato\",\"rapina\",\"rappreso\",\"rasatura\",\"raschiato\",\"rasente\",\"rassegna\",\"rastrello\",\"rata\",\"ravveduto\",\"reale\",\"recepire\",\"recinto\",\"recluta\",\"recondito\",\"recupero\",\"reddito\",\"redimere\",\"regalato\",\"registro\",\"regola\",\"regresso\",\"relazione\",\"remare\",\"remoto\",\"renna\",\"replica\",\"reprimere\",\"reputare\",\"resa\",\"residente\",\"responso\",\"restauro\",\"rete\",\"retina\",\"retorica\",\"rettifica\",\"revocato\",\"riassunto\",\"ribadire\",\"ribelle\",\"ribrezzo\",\"ricarica\",\"ricco\",\"ricevere\",\"riciclato\",\"ricordo\",\"ricreduto\",\"ridicolo\",\"ridurre\",\"rifasare\",\"riflesso\",\"riforma\",\"rifugio\",\"rigare\",\"rigettato\",\"righello\",\"rilassato\",\"rilevato\",\"rimanere\",\"rimbalzo\",\"rimedio\",\"rimorchio\",\"rinascita\",\"rincaro\",\"rinforzo\",\"rinnovo\",\"rinomato\",\"rinsavito\",\"rintocco\",\"rinuncia\",\"rinvenire\",\"riparato\",\"ripetuto\",\"ripieno\",\"riportare\",\"ripresa\",\"ripulire\",\"risata\",\"rischio\",\"riserva\",\"risibile\",\"riso\",\"rispetto\",\"ristoro\",\"risultato\",\"risvolto\",\"ritardo\",\"ritegno\",\"ritmico\",\"ritrovo\",\"riunione\",\"riva\",\"riverso\",\"rivincita\",\"rivolto\",\"rizoma\",\"roba\",\"robotico\",\"robusto\",\"roccia\",\"roco\",\"rodaggio\",\"rodere\",\"roditore\",\"rogito\",\"rollio\",\"romantico\",\"rompere\",\"ronzio\",\"rosolare\",\"rospo\",\"rotante\",\"rotondo\",\"rotula\",\"rovescio\",\"rubizzo\",\"rubrica\",\"ruga\",\"rullino\",\"rumine\",\"rumoroso\",\"ruolo\",\"rupe\",\"russare\",\"rustico\",\"sabato\",\"sabbiare\",\"sabotato\",\"sagoma\",\"salasso\",\"saldatura\",\"salgemma\",\"salivare\",\"salmone\",\"salone\",\"saltare\",\"saluto\",\"salvo\",\"sapere\",\"sapido\",\"saporito\",\"saraceno\",\"sarcasmo\",\"sarto\",\"sassoso\",\"satellite\",\"satira\",\"satollo\",\"saturno\",\"savana\",\"savio\",\"saziato\",\"sbadiglio\",\"sbalzo\",\"sbancato\",\"sbarra\",\"sbattere\",\"sbavare\",\"sbendare\",\"sbirciare\",\"sbloccato\",\"sbocciato\",\"sbrinare\",\"sbruffone\",\"sbuffare\",\"scabroso\",\"scadenza\",\"scala\",\"scambiare\",\"scandalo\",\"scapola\",\"scarso\",\"scatenare\",\"scavato\",\"scelto\",\"scenico\",\"scettro\",\"scheda\",\"schiena\",\"sciarpa\",\"scienza\",\"scindere\",\"scippo\",\"sciroppo\",\"scivolo\",\"sclerare\",\"scodella\",\"scolpito\",\"scomparto\",\"sconforto\",\"scoprire\",\"scorta\",\"scossone\",\"scozzese\",\"scriba\",\"scrollare\",\"scrutinio\",\"scuderia\",\"scultore\",\"scuola\",\"scuro\",\"scusare\",\"sdebitare\",\"sdoganare\",\"seccatura\",\"secondo\",\"sedano\",\"seggiola\",\"segnalato\",\"segregato\",\"seguito\",\"selciato\",\"selettivo\",\"sella\",\"selvaggio\",\"semaforo\",\"sembrare\",\"seme\",\"seminato\",\"sempre\",\"senso\",\"sentire\",\"sepolto\",\"sequenza\",\"serata\",\"serbato\",\"sereno\",\"serio\",\"serpente\",\"serraglio\",\"servire\",\"sestina\",\"setola\",\"settimana\",\"sfacelo\",\"sfaldare\",\"sfamato\",\"sfarzoso\",\"sfaticato\",\"sfera\",\"sfida\",\"sfilato\",\"sfinge\",\"sfocato\",\"sfoderare\",\"sfogo\",\"sfoltire\",\"sforzato\",\"sfratto\",\"sfruttato\",\"sfuggito\",\"sfumare\",\"sfuso\",\"sgabello\",\"sgarbato\",\"sgonfiare\",\"sgorbio\",\"sgrassato\",\"sguardo\",\"sibilo\",\"siccome\",\"sierra\",\"sigla\",\"signore\",\"silenzio\",\"sillaba\",\"simbolo\",\"simpatico\",\"simulato\",\"sinfonia\",\"singolo\",\"sinistro\",\"sino\",\"sintesi\",\"sinusoide\",\"sipario\",\"sisma\",\"sistole\",\"situato\",\"slitta\",\"slogatura\",\"sloveno\",\"smarrito\",\"smemorato\",\"smentito\",\"smeraldo\",\"smilzo\",\"smontare\",\"smottato\",\"smussato\",\"snellire\",\"snervato\",\"snodo\",\"sobbalzo\",\"sobrio\",\"soccorso\",\"sociale\",\"sodale\",\"soffitto\",\"sogno\",\"soldato\",\"solenne\",\"solido\",\"sollazzo\",\"solo\",\"solubile\",\"solvente\",\"somatico\",\"somma\",\"sonda\",\"sonetto\",\"sonnifero\",\"sopire\",\"soppeso\",\"sopra\",\"sorgere\",\"sorpasso\",\"sorriso\",\"sorso\",\"sorteggio\",\"sorvolato\",\"sospiro\",\"sosta\",\"sottile\",\"spada\",\"spalla\",\"spargere\",\"spatola\",\"spavento\",\"spazzola\",\"specie\",\"spedire\",\"spegnere\",\"spelatura\",\"speranza\",\"spessore\",\"spettrale\",\"spezzato\",\"spia\",\"spigoloso\",\"spillato\",\"spinoso\",\"spirale\",\"splendido\",\"sportivo\",\"sposo\",\"spranga\",\"sprecare\",\"spronato\",\"spruzzo\",\"spuntino\",\"squillo\",\"sradicare\",\"srotolato\",\"stabile\",\"stacco\",\"staffa\",\"stagnare\",\"stampato\",\"stantio\",\"starnuto\",\"stasera\",\"statuto\",\"stelo\",\"steppa\",\"sterzo\",\"stiletto\",\"stima\",\"stirpe\",\"stivale\",\"stizzoso\",\"stonato\",\"storico\",\"strappo\",\"stregato\",\"stridulo\",\"strozzare\",\"strutto\",\"stuccare\",\"stufo\",\"stupendo\",\"subentro\",\"succoso\",\"sudore\",\"suggerito\",\"sugo\",\"sultano\",\"suonare\",\"superbo\",\"supporto\",\"surgelato\",\"surrogato\",\"sussurro\",\"sutura\",\"svagare\",\"svedese\",\"sveglio\",\"svelare\",\"svenuto\",\"svezia\",\"sviluppo\",\"svista\",\"svizzera\",\"svolta\",\"svuotare\",\"tabacco\",\"tabulato\",\"tacciare\",\"taciturno\",\"tale\",\"talismano\",\"tampone\",\"tannino\",\"tara\",\"tardivo\",\"targato\",\"tariffa\",\"tarpare\",\"tartaruga\",\"tasto\",\"tattico\",\"taverna\",\"tavolata\",\"tazza\",\"teca\",\"tecnico\",\"telefono\",\"temerario\",\"tempo\",\"temuto\",\"tendone\",\"tenero\",\"tensione\",\"tentacolo\",\"teorema\",\"terme\",\"terrazzo\",\"terzetto\",\"tesi\",\"tesserato\",\"testato\",\"tetro\",\"tettoia\",\"tifare\",\"tigella\",\"timbro\",\"tinto\",\"tipico\",\"tipografo\",\"tiraggio\",\"tiro\",\"titanio\",\"titolo\",\"titubante\",\"tizio\",\"tizzone\",\"toccare\",\"tollerare\",\"tolto\",\"tombola\",\"tomo\",\"tonfo\",\"tonsilla\",\"topazio\",\"topologia\",\"toppa\",\"torba\",\"tornare\",\"torrone\",\"tortora\",\"toscano\",\"tossire\",\"tostatura\",\"totano\",\"trabocco\",\"trachea\",\"trafila\",\"tragedia\",\"tralcio\",\"tramonto\",\"transito\",\"trapano\",\"trarre\",\"trasloco\",\"trattato\",\"trave\",\"treccia\",\"tremolio\",\"trespolo\",\"tributo\",\"tricheco\",\"trifoglio\",\"trillo\",\"trincea\",\"trio\",\"tristezza\",\"triturato\",\"trivella\",\"tromba\",\"trono\",\"troppo\",\"trottola\",\"trovare\",\"truccato\",\"tubatura\",\"tuffato\",\"tulipano\",\"tumulto\",\"tunisia\",\"turbare\",\"turchino\",\"tuta\",\"tutela\",\"ubicato\",\"uccello\",\"uccisore\",\"udire\",\"uditivo\",\"uffa\",\"ufficio\",\"uguale\",\"ulisse\",\"ultimato\",\"umano\",\"umile\",\"umorismo\",\"uncinetto\",\"ungere\",\"ungherese\",\"unicorno\",\"unificato\",\"unisono\",\"unitario\",\"unte\",\"uovo\",\"upupa\",\"uragano\",\"urgenza\",\"urlo\",\"usanza\",\"usato\",\"uscito\",\"usignolo\",\"usuraio\",\"utensile\",\"utilizzo\",\"utopia\",\"vacante\",\"vaccinato\",\"vagabondo\",\"vagliato\",\"valanga\",\"valgo\",\"valico\",\"valletta\",\"valoroso\",\"valutare\",\"valvola\",\"vampata\",\"vangare\",\"vanitoso\",\"vano\",\"vantaggio\",\"vanvera\",\"vapore\",\"varano\",\"varcato\",\"variante\",\"vasca\",\"vedetta\",\"vedova\",\"veduto\",\"vegetale\",\"veicolo\",\"velcro\",\"velina\",\"velluto\",\"veloce\",\"venato\",\"vendemmia\",\"vento\",\"verace\",\"verbale\",\"vergogna\",\"verifica\",\"vero\",\"verruca\",\"verticale\",\"vescica\",\"vessillo\",\"vestale\",\"veterano\",\"vetrina\",\"vetusto\",\"viandante\",\"vibrante\",\"vicenda\",\"vichingo\",\"vicinanza\",\"vidimare\",\"vigilia\",\"vigneto\",\"vigore\",\"vile\",\"villano\",\"vimini\",\"vincitore\",\"viola\",\"vipera\",\"virgola\",\"virologo\",\"virulento\",\"viscoso\",\"visione\",\"vispo\",\"vissuto\",\"visura\",\"vita\",\"vitello\",\"vittima\",\"vivanda\",\"vivido\",\"viziare\",\"voce\",\"voga\",\"volatile\",\"volere\",\"volpe\",\"voragine\",\"vulcano\",\"zampogna\",\"zanna\",\"zappato\",\"zattera\",\"zavorra\",\"zefiro\",\"zelante\",\"zelo\",\"zenzero\",\"zerbino\",\"zibetto\",\"zinco\",\"zircone\",\"zitto\",\"zolla\",\"zotico\",\"zucchero\",\"zufolo\",\"zulu\",\"zuppa\"]");

const require$$6 = /* #__PURE__ */ JSON.parse("[\"abaco\",\"abdomen\",\"abeja\",\"abierto\",\"abogado\",\"abono\",\"aborto\",\"abrazo\",\"abrir\",\"abuelo\",\"abuso\",\"acabar\",\"academia\",\"acceso\",\"accion\",\"aceite\",\"acelga\",\"acento\",\"aceptar\",\"acido\",\"aclarar\",\"acne\",\"acoger\",\"acoso\",\"activo\",\"acto\",\"actriz\",\"actuar\",\"acudir\",\"acuerdo\",\"acusar\",\"adicto\",\"admitir\",\"adoptar\",\"adorno\",\"aduana\",\"adulto\",\"aereo\",\"afectar\",\"aficion\",\"afinar\",\"afirmar\",\"agil\",\"agitar\",\"agonia\",\"agosto\",\"agotar\",\"agregar\",\"agrio\",\"agua\",\"agudo\",\"aguila\",\"aguja\",\"ahogo\",\"ahorro\",\"aire\",\"aislar\",\"ajedrez\",\"ajeno\",\"ajuste\",\"alacran\",\"alambre\",\"alarma\",\"alba\",\"album\",\"alcalde\",\"aldea\",\"alegre\",\"alejar\",\"alerta\",\"aleta\",\"alfiler\",\"alga\",\"algodon\",\"aliado\",\"aliento\",\"alivio\",\"alma\",\"almeja\",\"almibar\",\"altar\",\"alteza\",\"altivo\",\"alto\",\"altura\",\"alumno\",\"alzar\",\"amable\",\"amante\",\"amapola\",\"amargo\",\"amasar\",\"ambar\",\"ambito\",\"ameno\",\"amigo\",\"amistad\",\"amor\",\"amparo\",\"amplio\",\"ancho\",\"anciano\",\"ancla\",\"andar\",\"anden\",\"anemia\",\"angulo\",\"anillo\",\"animo\",\"anis\",\"anotar\",\"antena\",\"antiguo\",\"antojo\",\"anual\",\"anular\",\"anuncio\",\"anadir\",\"anejo\",\"ano\",\"apagar\",\"aparato\",\"apetito\",\"apio\",\"aplicar\",\"apodo\",\"aporte\",\"apoyo\",\"aprender\",\"aprobar\",\"apuesta\",\"apuro\",\"arado\",\"arana\",\"arar\",\"arbitro\",\"arbol\",\"arbusto\",\"archivo\",\"arco\",\"arder\",\"ardilla\",\"arduo\",\"area\",\"arido\",\"aries\",\"armonia\",\"arnes\",\"aroma\",\"arpa\",\"arpon\",\"arreglo\",\"arroz\",\"arruga\",\"arte\",\"artista\",\"asa\",\"asado\",\"asalto\",\"ascenso\",\"asegurar\",\"aseo\",\"asesor\",\"asiento\",\"asilo\",\"asistir\",\"asno\",\"asombro\",\"aspero\",\"astilla\",\"astro\",\"astuto\",\"asumir\",\"asunto\",\"atajo\",\"ataque\",\"atar\",\"atento\",\"ateo\",\"atico\",\"atleta\",\"atomo\",\"atraer\",\"atroz\",\"atun\",\"audaz\",\"audio\",\"auge\",\"aula\",\"aumento\",\"ausente\",\"autor\",\"aval\",\"avance\",\"avaro\",\"ave\",\"avellana\",\"avena\",\"avestruz\",\"avion\",\"aviso\",\"ayer\",\"ayuda\",\"ayuno\",\"azafran\",\"azar\",\"azote\",\"azucar\",\"azufre\",\"azul\",\"baba\",\"babor\",\"bache\",\"bahia\",\"baile\",\"bajar\",\"balanza\",\"balcon\",\"balde\",\"bambu\",\"banco\",\"banda\",\"bano\",\"barba\",\"barco\",\"barniz\",\"barro\",\"bascula\",\"baston\",\"basura\",\"batalla\",\"bateria\",\"batir\",\"batuta\",\"baul\",\"bazar\",\"bebe\",\"bebida\",\"bello\",\"besar\",\"beso\",\"bestia\",\"bicho\",\"bien\",\"bingo\",\"blanco\",\"bloque\",\"blusa\",\"boa\",\"bobina\",\"bobo\",\"boca\",\"bocina\",\"boda\",\"bodega\",\"boina\",\"bola\",\"bolero\",\"bolsa\",\"bomba\",\"bondad\",\"bonito\",\"bono\",\"bonsai\",\"borde\",\"borrar\",\"bosque\",\"bote\",\"botin\",\"boveda\",\"bozal\",\"bravo\",\"brazo\",\"brecha\",\"breve\",\"brillo\",\"brinco\",\"brisa\",\"broca\",\"broma\",\"bronce\",\"brote\",\"bruja\",\"brusco\",\"bruto\",\"buceo\",\"bucle\",\"bueno\",\"buey\",\"bufanda\",\"bufon\",\"buho\",\"buitre\",\"bulto\",\"burbuja\",\"burla\",\"burro\",\"buscar\",\"butaca\",\"buzon\",\"caballo\",\"cabeza\",\"cabina\",\"cabra\",\"cacao\",\"cadaver\",\"cadena\",\"caer\",\"cafe\",\"caida\",\"caiman\",\"caja\",\"cajon\",\"cal\",\"calamar\",\"calcio\",\"caldo\",\"calidad\",\"calle\",\"calma\",\"calor\",\"calvo\",\"cama\",\"cambio\",\"camello\",\"camino\",\"campo\",\"cancer\",\"candil\",\"canela\",\"canguro\",\"canica\",\"canto\",\"cana\",\"canon\",\"caoba\",\"caos\",\"capaz\",\"capitan\",\"capote\",\"captar\",\"capucha\",\"cara\",\"carbon\",\"carcel\",\"careta\",\"carga\",\"carino\",\"carne\",\"carpeta\",\"carro\",\"carta\",\"casa\",\"casco\",\"casero\",\"caspa\",\"castor\",\"catorce\",\"catre\",\"caudal\",\"causa\",\"cazo\",\"cebolla\",\"ceder\",\"cedro\",\"celda\",\"celebre\",\"celoso\",\"celula\",\"cemento\",\"ceniza\",\"centro\",\"cerca\",\"cerdo\",\"cereza\",\"cero\",\"cerrar\",\"certeza\",\"cesped\",\"cetro\",\"chacal\",\"chaleco\",\"champu\",\"chancla\",\"chapa\",\"charla\",\"chico\",\"chiste\",\"chivo\",\"choque\",\"choza\",\"chuleta\",\"chupar\",\"ciclon\",\"ciego\",\"cielo\",\"cien\",\"cierto\",\"cifra\",\"cigarro\",\"cima\",\"cinco\",\"cine\",\"cinta\",\"cipres\",\"circo\",\"ciruela\",\"cisne\",\"cita\",\"ciudad\",\"clamor\",\"clan\",\"claro\",\"clase\",\"clave\",\"cliente\",\"clima\",\"clinica\",\"cobre\",\"coccion\",\"cochino\",\"cocina\",\"coco\",\"codigo\",\"codo\",\"cofre\",\"coger\",\"cohete\",\"cojin\",\"cojo\",\"cola\",\"colcha\",\"colegio\",\"colgar\",\"colina\",\"collar\",\"colmo\",\"columna\",\"combate\",\"comer\",\"comida\",\"comodo\",\"compra\",\"conde\",\"conejo\",\"conga\",\"conocer\",\"consejo\",\"contar\",\"copa\",\"copia\",\"corazon\",\"corbata\",\"corcho\",\"cordon\",\"corona\",\"correr\",\"coser\",\"cosmos\",\"costa\",\"craneo\",\"crater\",\"crear\",\"crecer\",\"creido\",\"crema\",\"cria\",\"crimen\",\"cripta\",\"crisis\",\"cromo\",\"cronica\",\"croqueta\",\"crudo\",\"cruz\",\"cuadro\",\"cuarto\",\"cuatro\",\"cubo\",\"cubrir\",\"cuchara\",\"cuello\",\"cuento\",\"cuerda\",\"cuesta\",\"cueva\",\"cuidar\",\"culebra\",\"culpa\",\"culto\",\"cumbre\",\"cumplir\",\"cuna\",\"cuneta\",\"cuota\",\"cupon\",\"cupula\",\"curar\",\"curioso\",\"curso\",\"curva\",\"cutis\",\"dama\",\"danza\",\"dar\",\"dardo\",\"datil\",\"deber\",\"debil\",\"decada\",\"decir\",\"dedo\",\"defensa\",\"definir\",\"dejar\",\"delfin\",\"delgado\",\"delito\",\"demora\",\"denso\",\"dental\",\"deporte\",\"derecho\",\"derrota\",\"desayuno\",\"deseo\",\"desfile\",\"desnudo\",\"destino\",\"desvio\",\"detalle\",\"detener\",\"deuda\",\"dia\",\"diablo\",\"diadema\",\"diamante\",\"diana\",\"diario\",\"dibujo\",\"dictar\",\"diente\",\"dieta\",\"diez\",\"dificil\",\"digno\",\"dilema\",\"diluir\",\"dinero\",\"directo\",\"dirigir\",\"disco\",\"diseno\",\"disfraz\",\"diva\",\"divino\",\"doble\",\"doce\",\"dolor\",\"domingo\",\"don\",\"donar\",\"dorado\",\"dormir\",\"dorso\",\"dos\",\"dosis\",\"dragon\",\"droga\",\"ducha\",\"duda\",\"duelo\",\"dueno\",\"dulce\",\"duo\",\"duque\",\"durar\",\"dureza\",\"duro\",\"ebano\",\"ebrio\",\"echar\",\"eco\",\"ecuador\",\"edad\",\"edicion\",\"edificio\",\"editor\",\"educar\",\"efecto\",\"eficaz\",\"eje\",\"ejemplo\",\"elefante\",\"elegir\",\"elemento\",\"elevar\",\"elipse\",\"elite\",\"elixir\",\"elogio\",\"eludir\",\"embudo\",\"emitir\",\"emocion\",\"empate\",\"empeno\",\"empleo\",\"empresa\",\"enano\",\"encargo\",\"enchufe\",\"encia\",\"enemigo\",\"enero\",\"enfado\",\"enfermo\",\"engano\",\"enigma\",\"enlace\",\"enorme\",\"enredo\",\"ensayo\",\"ensenar\",\"entero\",\"entrar\",\"envase\",\"envio\",\"epoca\",\"equipo\",\"erizo\",\"escala\",\"escena\",\"escolar\",\"escribir\",\"escudo\",\"esencia\",\"esfera\",\"esfuerzo\",\"espada\",\"espejo\",\"espia\",\"esposa\",\"espuma\",\"esqui\",\"estar\",\"este\",\"estilo\",\"estufa\",\"etapa\",\"eterno\",\"etica\",\"etnia\",\"evadir\",\"evaluar\",\"evento\",\"evitar\",\"exacto\",\"examen\",\"exceso\",\"excusa\",\"exento\",\"exigir\",\"exilio\",\"existir\",\"exito\",\"experto\",\"explicar\",\"exponer\",\"extremo\",\"fabrica\",\"fabula\",\"fachada\",\"facil\",\"factor\",\"faena\",\"faja\",\"falda\",\"fallo\",\"falso\",\"faltar\",\"fama\",\"familia\",\"famoso\",\"faraon\",\"farmacia\",\"farol\",\"farsa\",\"fase\",\"fatiga\",\"fauna\",\"favor\",\"fax\",\"febrero\",\"fecha\",\"feliz\",\"feo\",\"feria\",\"feroz\",\"fertil\",\"fervor\",\"festin\",\"fiable\",\"fianza\",\"fiar\",\"fibra\",\"ficcion\",\"ficha\",\"fideo\",\"fiebre\",\"fiel\",\"fiera\",\"fiesta\",\"figura\",\"fijar\",\"fijo\",\"fila\",\"filete\",\"filial\",\"filtro\",\"fin\",\"finca\",\"fingir\",\"finito\",\"firma\",\"flaco\",\"flauta\",\"flecha\",\"flor\",\"flota\",\"fluir\",\"flujo\",\"fluor\",\"fobia\",\"foca\",\"fogata\",\"fogon\",\"folio\",\"folleto\",\"fondo\",\"forma\",\"forro\",\"fortuna\",\"forzar\",\"fosa\",\"foto\",\"fracaso\",\"fragil\",\"franja\",\"frase\",\"fraude\",\"freir\",\"freno\",\"fresa\",\"frio\",\"frito\",\"fruta\",\"fuego\",\"fuente\",\"fuerza\",\"fuga\",\"fumar\",\"funcion\",\"funda\",\"furgon\",\"furia\",\"fusil\",\"futbol\",\"futuro\",\"gacela\",\"gafas\",\"gaita\",\"gajo\",\"gala\",\"galeria\",\"gallo\",\"gamba\",\"ganar\",\"gancho\",\"ganga\",\"ganso\",\"garaje\",\"garza\",\"gasolina\",\"gastar\",\"gato\",\"gavilan\",\"gemelo\",\"gemir\",\"gen\",\"genero\",\"genio\",\"gente\",\"geranio\",\"gerente\",\"germen\",\"gesto\",\"gigante\",\"gimnasio\",\"girar\",\"giro\",\"glaciar\",\"globo\",\"gloria\",\"gol\",\"golfo\",\"goloso\",\"golpe\",\"goma\",\"gordo\",\"gorila\",\"gorra\",\"gota\",\"goteo\",\"gozar\",\"grada\",\"grafico\",\"grano\",\"grasa\",\"gratis\",\"grave\",\"grieta\",\"grillo\",\"gripe\",\"gris\",\"grito\",\"grosor\",\"grua\",\"grueso\",\"grumo\",\"grupo\",\"guante\",\"guapo\",\"guardia\",\"guerra\",\"guia\",\"guino\",\"guion\",\"guiso\",\"guitarra\",\"gusano\",\"gustar\",\"haber\",\"habil\",\"hablar\",\"hacer\",\"hacha\",\"hada\",\"hallar\",\"hamaca\",\"harina\",\"haz\",\"hazana\",\"hebilla\",\"hebra\",\"hecho\",\"helado\",\"helio\",\"hembra\",\"herir\",\"hermano\",\"heroe\",\"hervir\",\"hielo\",\"hierro\",\"higado\",\"higiene\",\"hijo\",\"himno\",\"historia\",\"hocico\",\"hogar\",\"hoguera\",\"hoja\",\"hombre\",\"hongo\",\"honor\",\"honra\",\"hora\",\"hormiga\",\"horno\",\"hostil\",\"hoyo\",\"hueco\",\"huelga\",\"huerta\",\"hueso\",\"huevo\",\"huida\",\"huir\",\"humano\",\"humedo\",\"humilde\",\"humo\",\"hundir\",\"huracan\",\"hurto\",\"icono\",\"ideal\",\"idioma\",\"idolo\",\"iglesia\",\"iglu\",\"igual\",\"ilegal\",\"ilusion\",\"imagen\",\"iman\",\"imitar\",\"impar\",\"imperio\",\"imponer\",\"impulso\",\"incapaz\",\"indice\",\"inerte\",\"infiel\",\"informe\",\"ingenio\",\"inicio\",\"inmenso\",\"inmune\",\"innato\",\"insecto\",\"instante\",\"interes\",\"intimo\",\"intuir\",\"inutil\",\"invierno\",\"ira\",\"iris\",\"ironia\",\"isla\",\"islote\",\"jabali\",\"jabon\",\"jamon\",\"jarabe\",\"jardin\",\"jarra\",\"jaula\",\"jazmin\",\"jefe\",\"jeringa\",\"jinete\",\"jornada\",\"joroba\",\"joven\",\"joya\",\"juerga\",\"jueves\",\"juez\",\"jugador\",\"jugo\",\"juguete\",\"juicio\",\"junco\",\"jungla\",\"junio\",\"juntar\",\"jupiter\",\"jurar\",\"justo\",\"juvenil\",\"juzgar\",\"kilo\",\"koala\",\"labio\",\"lacio\",\"lacra\",\"lado\",\"ladron\",\"lagarto\",\"lagrima\",\"laguna\",\"laico\",\"lamer\",\"lamina\",\"lampara\",\"lana\",\"lancha\",\"langosta\",\"lanza\",\"lapiz\",\"largo\",\"larva\",\"lastima\",\"lata\",\"latex\",\"latir\",\"laurel\",\"lavar\",\"lazo\",\"leal\",\"leccion\",\"leche\",\"lector\",\"leer\",\"legion\",\"legumbre\",\"lejano\",\"lengua\",\"lento\",\"lena\",\"leon\",\"leopardo\",\"lesion\",\"letal\",\"letra\",\"leve\",\"leyenda\",\"libertad\",\"libro\",\"licor\",\"lider\",\"lidiar\",\"lienzo\",\"liga\",\"ligero\",\"lima\",\"limite\",\"limon\",\"limpio\",\"lince\",\"lindo\",\"linea\",\"lingote\",\"lino\",\"linterna\",\"liquido\",\"liso\",\"lista\",\"litera\",\"litio\",\"litro\",\"llaga\",\"llama\",\"llanto\",\"llave\",\"llegar\",\"llenar\",\"llevar\",\"llorar\",\"llover\",\"lluvia\",\"lobo\",\"locion\",\"loco\",\"locura\",\"logica\",\"logro\",\"lombriz\",\"lomo\",\"lonja\",\"lote\",\"lucha\",\"lucir\",\"lugar\",\"lujo\",\"luna\",\"lunes\",\"lupa\",\"lustro\",\"luto\",\"luz\",\"maceta\",\"macho\",\"madera\",\"madre\",\"maduro\",\"maestro\",\"mafia\",\"magia\",\"mago\",\"maiz\",\"maldad\",\"maleta\",\"malla\",\"malo\",\"mama\",\"mambo\",\"mamut\",\"manco\",\"mando\",\"manejar\",\"manga\",\"maniqui\",\"manjar\",\"mano\",\"manso\",\"manta\",\"manana\",\"mapa\",\"maquina\",\"mar\",\"marco\",\"marea\",\"marfil\",\"margen\",\"marido\",\"marmol\",\"marron\",\"martes\",\"marzo\",\"masa\",\"mascara\",\"masivo\",\"matar\",\"materia\",\"matiz\",\"matriz\",\"maximo\",\"mayor\",\"mazorca\",\"mecha\",\"medalla\",\"medio\",\"medula\",\"mejilla\",\"mejor\",\"melena\",\"melon\",\"memoria\",\"menor\",\"mensaje\",\"mente\",\"menu\",\"mercado\",\"merengue\",\"merito\",\"mes\",\"meson\",\"meta\",\"meter\",\"metodo\",\"metro\",\"mezcla\",\"miedo\",\"miel\",\"miembro\",\"miga\",\"mil\",\"milagro\",\"militar\",\"millon\",\"mimo\",\"mina\",\"minero\",\"minimo\",\"minuto\",\"miope\",\"mirar\",\"misa\",\"miseria\",\"misil\",\"mismo\",\"mitad\",\"mito\",\"mochila\",\"mocion\",\"moda\",\"modelo\",\"moho\",\"mojar\",\"molde\",\"moler\",\"molino\",\"momento\",\"momia\",\"monarca\",\"moneda\",\"monja\",\"monto\",\"mono\",\"morada\",\"morder\",\"moreno\",\"morir\",\"morro\",\"morsa\",\"mortal\",\"mosca\",\"mostrar\",\"motivo\",\"mover\",\"movil\",\"mozo\",\"mucho\",\"mudar\",\"mueble\",\"muela\",\"muerte\",\"muestra\",\"mugre\",\"mujer\",\"mula\",\"muleta\",\"multa\",\"mundo\",\"muneca\",\"mural\",\"muro\",\"musculo\",\"museo\",\"musgo\",\"musica\",\"muslo\",\"nacar\",\"nacion\",\"nadar\",\"naipe\",\"naranja\",\"nariz\",\"narrar\",\"nasal\",\"natal\",\"nativo\",\"natural\",\"nausea\",\"naval\",\"nave\",\"navidad\",\"necio\",\"nectar\",\"negar\",\"negocio\",\"negro\",\"neon\",\"nervio\",\"neto\",\"neutro\",\"nevar\",\"nevera\",\"nicho\",\"nido\",\"niebla\",\"nieto\",\"ninez\",\"nino\",\"nitido\",\"nivel\",\"nobleza\",\"noche\",\"nomina\",\"noria\",\"norma\",\"norte\",\"nota\",\"noticia\",\"novato\",\"novela\",\"novio\",\"nube\",\"nuca\",\"nucleo\",\"nudillo\",\"nudo\",\"nuera\",\"nueve\",\"nuez\",\"nulo\",\"numero\",\"nutria\",\"oasis\",\"obeso\",\"obispo\",\"objeto\",\"obra\",\"obrero\",\"observar\",\"obtener\",\"obvio\",\"oca\",\"ocaso\",\"oceano\",\"ochenta\",\"ocho\",\"ocio\",\"ocre\",\"octavo\",\"octubre\",\"oculto\",\"ocupar\",\"ocurrir\",\"odiar\",\"odio\",\"odisea\",\"oeste\",\"ofensa\",\"oferta\",\"oficio\",\"ofrecer\",\"ogro\",\"oido\",\"oir\",\"ojo\",\"ola\",\"oleada\",\"olfato\",\"olivo\",\"olla\",\"olmo\",\"olor\",\"olvido\",\"ombligo\",\"onda\",\"onza\",\"opaco\",\"opcion\",\"opera\",\"opinar\",\"oponer\",\"optar\",\"optica\",\"opuesto\",\"oracion\",\"orador\",\"oral\",\"orbita\",\"orca\",\"orden\",\"oreja\",\"organo\",\"orgia\",\"orgullo\",\"oriente\",\"origen\",\"orilla\",\"oro\",\"orquesta\",\"oruga\",\"osadia\",\"oscuro\",\"osezno\",\"oso\",\"ostra\",\"otono\",\"otro\",\"oveja\",\"ovulo\",\"oxido\",\"oxigeno\",\"oyente\",\"ozono\",\"pacto\",\"padre\",\"paella\",\"pagina\",\"pago\",\"pais\",\"pajaro\",\"palabra\",\"palco\",\"paleta\",\"palido\",\"palma\",\"paloma\",\"palpar\",\"pan\",\"panal\",\"panico\",\"pantera\",\"panuelo\",\"papa\",\"papel\",\"papilla\",\"paquete\",\"parar\",\"parcela\",\"pared\",\"parir\",\"paro\",\"parpado\",\"parque\",\"parrafo\",\"parte\",\"pasar\",\"paseo\",\"pasion\",\"paso\",\"pasta\",\"pata\",\"patio\",\"patria\",\"pausa\",\"pauta\",\"pavo\",\"payaso\",\"peaton\",\"pecado\",\"pecera\",\"pecho\",\"pedal\",\"pedir\",\"pegar\",\"peine\",\"pelar\",\"peldano\",\"pelea\",\"peligro\",\"pellejo\",\"pelo\",\"peluca\",\"pena\",\"pensar\",\"penon\",\"peon\",\"peor\",\"pepino\",\"pequeno\",\"pera\",\"percha\",\"perder\",\"pereza\",\"perfil\",\"perico\",\"perla\",\"permiso\",\"perro\",\"persona\",\"pesa\",\"pesca\",\"pesimo\",\"pestana\",\"petalo\",\"petroleo\",\"pez\",\"pezuna\",\"picar\",\"pichon\",\"pie\",\"piedra\",\"pierna\",\"pieza\",\"pijama\",\"pilar\",\"piloto\",\"pimienta\",\"pino\",\"pintor\",\"pinza\",\"pina\",\"piojo\",\"pipa\",\"pirata\",\"pisar\",\"piscina\",\"piso\",\"pista\",\"piton\",\"pizca\",\"placa\",\"plan\",\"plata\",\"playa\",\"plaza\",\"pleito\",\"pleno\",\"plomo\",\"pluma\",\"plural\",\"pobre\",\"poco\",\"poder\",\"podio\",\"poema\",\"poesia\",\"poeta\",\"polen\",\"policia\",\"pollo\",\"polvo\",\"pomada\",\"pomelo\",\"pomo\",\"pompa\",\"poner\",\"porcion\",\"portal\",\"posada\",\"poseer\",\"posible\",\"poste\",\"potencia\",\"potro\",\"pozo\",\"prado\",\"precoz\",\"pregunta\",\"premio\",\"prensa\",\"preso\",\"previo\",\"primo\",\"principe\",\"prision\",\"privar\",\"proa\",\"probar\",\"proceso\",\"producto\",\"proeza\",\"profesor\",\"programa\",\"prole\",\"promesa\",\"pronto\",\"propio\",\"proximo\",\"prueba\",\"publico\",\"puchero\",\"pudor\",\"pueblo\",\"puerta\",\"puesto\",\"pulga\",\"pulir\",\"pulmon\",\"pulpo\",\"pulso\",\"puma\",\"punto\",\"punal\",\"puno\",\"pupa\",\"pupila\",\"pure\",\"quedar\",\"queja\",\"quemar\",\"querer\",\"queso\",\"quieto\",\"quimica\",\"quince\",\"quitar\",\"rabano\",\"rabia\",\"rabo\",\"racion\",\"radical\",\"raiz\",\"rama\",\"rampa\",\"rancho\",\"rango\",\"rapaz\",\"rapido\",\"rapto\",\"rasgo\",\"raspa\",\"rato\",\"rayo\",\"raza\",\"razon\",\"reaccion\",\"realidad\",\"rebano\",\"rebote\",\"recaer\",\"receta\",\"rechazo\",\"recoger\",\"recreo\",\"recto\",\"recurso\",\"red\",\"redondo\",\"reducir\",\"reflejo\",\"reforma\",\"refran\",\"refugio\",\"regalo\",\"regir\",\"regla\",\"regreso\",\"rehen\",\"reino\",\"reir\",\"reja\",\"relato\",\"relevo\",\"relieve\",\"relleno\",\"reloj\",\"remar\",\"remedio\",\"remo\",\"rencor\",\"rendir\",\"renta\",\"reparto\",\"repetir\",\"reposo\",\"reptil\",\"res\",\"rescate\",\"resina\",\"respeto\",\"resto\",\"resumen\",\"retiro\",\"retorno\",\"retrato\",\"reunir\",\"reves\",\"revista\",\"rey\",\"rezar\",\"rico\",\"riego\",\"rienda\",\"riesgo\",\"rifa\",\"rigido\",\"rigor\",\"rincon\",\"rinon\",\"rio\",\"riqueza\",\"risa\",\"ritmo\",\"rito\",\"rizo\",\"roble\",\"roce\",\"rociar\",\"rodar\",\"rodeo\",\"rodilla\",\"roer\",\"rojizo\",\"rojo\",\"romero\",\"romper\",\"ron\",\"ronco\",\"ronda\",\"ropa\",\"ropero\",\"rosa\",\"rosca\",\"rostro\",\"rotar\",\"rubi\",\"rubor\",\"rudo\",\"rueda\",\"rugir\",\"ruido\",\"ruina\",\"ruleta\",\"rulo\",\"rumbo\",\"rumor\",\"ruptura\",\"ruta\",\"rutina\",\"sabado\",\"saber\",\"sabio\",\"sable\",\"sacar\",\"sagaz\",\"sagrado\",\"sala\",\"saldo\",\"salero\",\"salir\",\"salmon\",\"salon\",\"salsa\",\"salto\",\"salud\",\"salvar\",\"samba\",\"sancion\",\"sandia\",\"sanear\",\"sangre\",\"sanidad\",\"sano\",\"santo\",\"sapo\",\"saque\",\"sardina\",\"sarten\",\"sastre\",\"satan\",\"sauna\",\"saxofon\",\"seccion\",\"seco\",\"secreto\",\"secta\",\"sed\",\"seguir\",\"seis\",\"sello\",\"selva\",\"semana\",\"semilla\",\"senda\",\"sensor\",\"senal\",\"senor\",\"separar\",\"sepia\",\"sequia\",\"ser\",\"serie\",\"sermon\",\"servir\",\"sesenta\",\"sesion\",\"seta\",\"setenta\",\"severo\",\"sexo\",\"sexto\",\"sidra\",\"siesta\",\"siete\",\"siglo\",\"signo\",\"silaba\",\"silbar\",\"silencio\",\"silla\",\"simbolo\",\"simio\",\"sirena\",\"sistema\",\"sitio\",\"situar\",\"sobre\",\"socio\",\"sodio\",\"sol\",\"solapa\",\"soldado\",\"soledad\",\"solido\",\"soltar\",\"solucion\",\"sombra\",\"sondeo\",\"sonido\",\"sonoro\",\"sonrisa\",\"sopa\",\"soplar\",\"soporte\",\"sordo\",\"sorpresa\",\"sorteo\",\"sosten\",\"sotano\",\"suave\",\"subir\",\"suceso\",\"sudor\",\"suegra\",\"suelo\",\"sueno\",\"suerte\",\"sufrir\",\"sujeto\",\"sultan\",\"sumar\",\"superar\",\"suplir\",\"suponer\",\"supremo\",\"sur\",\"surco\",\"sureno\",\"surgir\",\"susto\",\"sutil\",\"tabaco\",\"tabique\",\"tabla\",\"tabu\",\"taco\",\"tacto\",\"tajo\",\"talar\",\"talco\",\"talento\",\"talla\",\"talon\",\"tamano\",\"tambor\",\"tango\",\"tanque\",\"tapa\",\"tapete\",\"tapia\",\"tapon\",\"taquilla\",\"tarde\",\"tarea\",\"tarifa\",\"tarjeta\",\"tarot\",\"tarro\",\"tarta\",\"tatuaje\",\"tauro\",\"taza\",\"tazon\",\"teatro\",\"techo\",\"tecla\",\"tecnica\",\"tejado\",\"tejer\",\"tejido\",\"tela\",\"telefono\",\"tema\",\"temor\",\"templo\",\"tenaz\",\"tender\",\"tener\",\"tenis\",\"tenso\",\"teoria\",\"terapia\",\"terco\",\"termino\",\"ternura\",\"terror\",\"tesis\",\"tesoro\",\"testigo\",\"tetera\",\"texto\",\"tez\",\"tibio\",\"tiburon\",\"tiempo\",\"tienda\",\"tierra\",\"tieso\",\"tigre\",\"tijera\",\"tilde\",\"timbre\",\"timido\",\"timo\",\"tinta\",\"tio\",\"tipico\",\"tipo\",\"tira\",\"tiron\",\"titan\",\"titere\",\"titulo\",\"tiza\",\"toalla\",\"tobillo\",\"tocar\",\"tocino\",\"todo\",\"toga\",\"toldo\",\"tomar\",\"tono\",\"tonto\",\"topar\",\"tope\",\"toque\",\"torax\",\"torero\",\"tormenta\",\"torneo\",\"toro\",\"torpedo\",\"torre\",\"torso\",\"tortuga\",\"tos\",\"tosco\",\"toser\",\"toxico\",\"trabajo\",\"tractor\",\"traer\",\"trafico\",\"trago\",\"traje\",\"tramo\",\"trance\",\"trato\",\"trauma\",\"trazar\",\"trebol\",\"tregua\",\"treinta\",\"tren\",\"trepar\",\"tres\",\"tribu\",\"trigo\",\"tripa\",\"triste\",\"triunfo\",\"trofeo\",\"trompa\",\"tronco\",\"tropa\",\"trote\",\"trozo\",\"truco\",\"trueno\",\"trufa\",\"tuberia\",\"tubo\",\"tuerto\",\"tumba\",\"tumor\",\"tunel\",\"tunica\",\"turbina\",\"turismo\",\"turno\",\"tutor\",\"ubicar\",\"ulcera\",\"umbral\",\"unidad\",\"unir\",\"universo\",\"uno\",\"untar\",\"una\",\"urbano\",\"urbe\",\"urgente\",\"urna\",\"usar\",\"usuario\",\"util\",\"utopia\",\"uva\",\"vaca\",\"vacio\",\"vacuna\",\"vagar\",\"vago\",\"vaina\",\"vajilla\",\"vale\",\"valido\",\"valle\",\"valor\",\"valvula\",\"vampiro\",\"vara\",\"variar\",\"varon\",\"vaso\",\"vecino\",\"vector\",\"vehiculo\",\"veinte\",\"vejez\",\"vela\",\"velero\",\"veloz\",\"vena\",\"vencer\",\"venda\",\"veneno\",\"vengar\",\"venir\",\"venta\",\"venus\",\"ver\",\"verano\",\"verbo\",\"verde\",\"vereda\",\"verja\",\"verso\",\"verter\",\"via\",\"viaje\",\"vibrar\",\"vicio\",\"victima\",\"vida\",\"video\",\"vidrio\",\"viejo\",\"viernes\",\"vigor\",\"vil\",\"villa\",\"vinagre\",\"vino\",\"vinedo\",\"violin\",\"viral\",\"virgo\",\"virtud\",\"visor\",\"vispera\",\"vista\",\"vitamina\",\"viudo\",\"vivaz\",\"vivero\",\"vivir\",\"vivo\",\"volcan\",\"volumen\",\"volver\",\"voraz\",\"votar\",\"voto\",\"voz\",\"vuelo\",\"vulgar\",\"yacer\",\"yate\",\"yegua\",\"yema\",\"yerno\",\"yeso\",\"yodo\",\"yoga\",\"yogur\",\"zafiro\",\"zanja\",\"zapato\",\"zarza\",\"zona\",\"zorro\",\"zumo\",\"zurdo\"]");

const require$$7 = /* #__PURE__ */ JSON.parse("[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"]");

const require$$8 = /* #__PURE__ */ JSON.parse("[\"abacate\",\"abaixo\",\"abalar\",\"abater\",\"abduzir\",\"abelha\",\"aberto\",\"abismo\",\"abotoar\",\"abranger\",\"abreviar\",\"abrigar\",\"abrupto\",\"absinto\",\"absoluto\",\"absurdo\",\"abutre\",\"acabado\",\"acalmar\",\"acampar\",\"acanhar\",\"acaso\",\"aceitar\",\"acelerar\",\"acenar\",\"acervo\",\"acessar\",\"acetona\",\"achatar\",\"acidez\",\"acima\",\"acionado\",\"acirrar\",\"aclamar\",\"aclive\",\"acolhida\",\"acomodar\",\"acoplar\",\"acordar\",\"acumular\",\"acusador\",\"adaptar\",\"adega\",\"adentro\",\"adepto\",\"adequar\",\"aderente\",\"adesivo\",\"adeus\",\"adiante\",\"aditivo\",\"adjetivo\",\"adjunto\",\"admirar\",\"adorar\",\"adquirir\",\"adubo\",\"adverso\",\"advogado\",\"aeronave\",\"afastar\",\"aferir\",\"afetivo\",\"afinador\",\"afivelar\",\"aflito\",\"afluente\",\"afrontar\",\"agachar\",\"agarrar\",\"agasalho\",\"agenciar\",\"agilizar\",\"agiota\",\"agitado\",\"agora\",\"agradar\",\"agreste\",\"agrupar\",\"aguardar\",\"agulha\",\"ajoelhar\",\"ajudar\",\"ajustar\",\"alameda\",\"alarme\",\"alastrar\",\"alavanca\",\"albergue\",\"albino\",\"alcatra\",\"aldeia\",\"alecrim\",\"alegria\",\"alertar\",\"alface\",\"alfinete\",\"algum\",\"alheio\",\"aliar\",\"alicate\",\"alienar\",\"alinhar\",\"aliviar\",\"almofada\",\"alocar\",\"alpiste\",\"alterar\",\"altitude\",\"alucinar\",\"alugar\",\"aluno\",\"alusivo\",\"alvo\",\"amaciar\",\"amador\",\"amarelo\",\"amassar\",\"ambas\",\"ambiente\",\"ameixa\",\"amenizar\",\"amido\",\"amistoso\",\"amizade\",\"amolador\",\"amontoar\",\"amoroso\",\"amostra\",\"amparar\",\"ampliar\",\"ampola\",\"anagrama\",\"analisar\",\"anarquia\",\"anatomia\",\"andaime\",\"anel\",\"anexo\",\"angular\",\"animar\",\"anjo\",\"anomalia\",\"anotado\",\"ansioso\",\"anterior\",\"anuidade\",\"anunciar\",\"anzol\",\"apagador\",\"apalpar\",\"apanhado\",\"apego\",\"apelido\",\"apertada\",\"apesar\",\"apetite\",\"apito\",\"aplauso\",\"aplicada\",\"apoio\",\"apontar\",\"aposta\",\"aprendiz\",\"aprovar\",\"aquecer\",\"arame\",\"aranha\",\"arara\",\"arcada\",\"ardente\",\"areia\",\"arejar\",\"arenito\",\"aresta\",\"argiloso\",\"argola\",\"arma\",\"arquivo\",\"arraial\",\"arrebate\",\"arriscar\",\"arroba\",\"arrumar\",\"arsenal\",\"arterial\",\"artigo\",\"arvoredo\",\"asfaltar\",\"asilado\",\"aspirar\",\"assador\",\"assinar\",\"assoalho\",\"assunto\",\"astral\",\"atacado\",\"atadura\",\"atalho\",\"atarefar\",\"atear\",\"atender\",\"aterro\",\"ateu\",\"atingir\",\"atirador\",\"ativo\",\"atoleiro\",\"atracar\",\"atrevido\",\"atriz\",\"atual\",\"atum\",\"auditor\",\"aumentar\",\"aura\",\"aurora\",\"autismo\",\"autoria\",\"autuar\",\"avaliar\",\"avante\",\"avaria\",\"avental\",\"avesso\",\"aviador\",\"avisar\",\"avulso\",\"axila\",\"azarar\",\"azedo\",\"azeite\",\"azulejo\",\"babar\",\"babosa\",\"bacalhau\",\"bacharel\",\"bacia\",\"bagagem\",\"baiano\",\"bailar\",\"baioneta\",\"bairro\",\"baixista\",\"bajular\",\"baleia\",\"baliza\",\"balsa\",\"banal\",\"bandeira\",\"banho\",\"banir\",\"banquete\",\"barato\",\"barbado\",\"baronesa\",\"barraca\",\"barulho\",\"baseado\",\"bastante\",\"batata\",\"batedor\",\"batida\",\"batom\",\"batucar\",\"baunilha\",\"beber\",\"beijo\",\"beirada\",\"beisebol\",\"beldade\",\"beleza\",\"belga\",\"beliscar\",\"bendito\",\"bengala\",\"benzer\",\"berimbau\",\"berlinda\",\"berro\",\"besouro\",\"bexiga\",\"bezerro\",\"bico\",\"bicudo\",\"bienal\",\"bifocal\",\"bifurcar\",\"bigorna\",\"bilhete\",\"bimestre\",\"bimotor\",\"biologia\",\"biombo\",\"biosfera\",\"bipolar\",\"birrento\",\"biscoito\",\"bisneto\",\"bispo\",\"bissexto\",\"bitola\",\"bizarro\",\"blindado\",\"bloco\",\"bloquear\",\"boato\",\"bobagem\",\"bocado\",\"bocejo\",\"bochecha\",\"boicotar\",\"bolada\",\"boletim\",\"bolha\",\"bolo\",\"bombeiro\",\"bonde\",\"boneco\",\"bonita\",\"borbulha\",\"borda\",\"boreal\",\"borracha\",\"bovino\",\"boxeador\",\"branco\",\"brasa\",\"braveza\",\"breu\",\"briga\",\"brilho\",\"brincar\",\"broa\",\"brochura\",\"bronzear\",\"broto\",\"bruxo\",\"bucha\",\"budismo\",\"bufar\",\"bule\",\"buraco\",\"busca\",\"busto\",\"buzina\",\"cabana\",\"cabelo\",\"cabide\",\"cabo\",\"cabrito\",\"cacau\",\"cacetada\",\"cachorro\",\"cacique\",\"cadastro\",\"cadeado\",\"cafezal\",\"caiaque\",\"caipira\",\"caixote\",\"cajado\",\"caju\",\"calafrio\",\"calcular\",\"caldeira\",\"calibrar\",\"calmante\",\"calota\",\"camada\",\"cambista\",\"camisa\",\"camomila\",\"campanha\",\"camuflar\",\"canavial\",\"cancelar\",\"caneta\",\"canguru\",\"canhoto\",\"canivete\",\"canoa\",\"cansado\",\"cantar\",\"canudo\",\"capacho\",\"capela\",\"capinar\",\"capotar\",\"capricho\",\"captador\",\"capuz\",\"caracol\",\"carbono\",\"cardeal\",\"careca\",\"carimbar\",\"carneiro\",\"carpete\",\"carreira\",\"cartaz\",\"carvalho\",\"casaco\",\"casca\",\"casebre\",\"castelo\",\"casulo\",\"catarata\",\"cativar\",\"caule\",\"causador\",\"cautelar\",\"cavalo\",\"caverna\",\"cebola\",\"cedilha\",\"cegonha\",\"celebrar\",\"celular\",\"cenoura\",\"censo\",\"centeio\",\"cercar\",\"cerrado\",\"certeiro\",\"cerveja\",\"cetim\",\"cevada\",\"chacota\",\"chaleira\",\"chamado\",\"chapada\",\"charme\",\"chatice\",\"chave\",\"chefe\",\"chegada\",\"cheiro\",\"cheque\",\"chicote\",\"chifre\",\"chinelo\",\"chocalho\",\"chover\",\"chumbo\",\"chutar\",\"chuva\",\"cicatriz\",\"ciclone\",\"cidade\",\"cidreira\",\"ciente\",\"cigana\",\"cimento\",\"cinto\",\"cinza\",\"ciranda\",\"circuito\",\"cirurgia\",\"citar\",\"clareza\",\"clero\",\"clicar\",\"clone\",\"clube\",\"coado\",\"coagir\",\"cobaia\",\"cobertor\",\"cobrar\",\"cocada\",\"coelho\",\"coentro\",\"coeso\",\"cogumelo\",\"coibir\",\"coifa\",\"coiote\",\"colar\",\"coleira\",\"colher\",\"colidir\",\"colmeia\",\"colono\",\"coluna\",\"comando\",\"combinar\",\"comentar\",\"comitiva\",\"comover\",\"complexo\",\"comum\",\"concha\",\"condor\",\"conectar\",\"confuso\",\"congelar\",\"conhecer\",\"conjugar\",\"consumir\",\"contrato\",\"convite\",\"cooperar\",\"copeiro\",\"copiador\",\"copo\",\"coquetel\",\"coragem\",\"cordial\",\"corneta\",\"coronha\",\"corporal\",\"correio\",\"cortejo\",\"coruja\",\"corvo\",\"cosseno\",\"costela\",\"cotonete\",\"couro\",\"couve\",\"covil\",\"cozinha\",\"cratera\",\"cravo\",\"creche\",\"credor\",\"creme\",\"crer\",\"crespo\",\"criada\",\"criminal\",\"crioulo\",\"crise\",\"criticar\",\"crosta\",\"crua\",\"cruzeiro\",\"cubano\",\"cueca\",\"cuidado\",\"cujo\",\"culatra\",\"culminar\",\"culpar\",\"cultura\",\"cumprir\",\"cunhado\",\"cupido\",\"curativo\",\"curral\",\"cursar\",\"curto\",\"cuspir\",\"custear\",\"cutelo\",\"damasco\",\"datar\",\"debater\",\"debitar\",\"deboche\",\"debulhar\",\"decalque\",\"decimal\",\"declive\",\"decote\",\"decretar\",\"dedal\",\"dedicado\",\"deduzir\",\"defesa\",\"defumar\",\"degelo\",\"degrau\",\"degustar\",\"deitado\",\"deixar\",\"delator\",\"delegado\",\"delinear\",\"delonga\",\"demanda\",\"demitir\",\"demolido\",\"dentista\",\"depenado\",\"depilar\",\"depois\",\"depressa\",\"depurar\",\"deriva\",\"derramar\",\"desafio\",\"desbotar\",\"descanso\",\"desenho\",\"desfiado\",\"desgaste\",\"desigual\",\"deslize\",\"desmamar\",\"desova\",\"despesa\",\"destaque\",\"desviar\",\"detalhar\",\"detentor\",\"detonar\",\"detrito\",\"deusa\",\"dever\",\"devido\",\"devotado\",\"dezena\",\"diagrama\",\"dialeto\",\"didata\",\"difuso\",\"digitar\",\"dilatado\",\"diluente\",\"diminuir\",\"dinastia\",\"dinheiro\",\"diocese\",\"direto\",\"discreta\",\"disfarce\",\"disparo\",\"disquete\",\"dissipar\",\"distante\",\"ditador\",\"diurno\",\"diverso\",\"divisor\",\"divulgar\",\"dizer\",\"dobrador\",\"dolorido\",\"domador\",\"dominado\",\"donativo\",\"donzela\",\"dormente\",\"dorsal\",\"dosagem\",\"dourado\",\"doutor\",\"drenagem\",\"drible\",\"drogaria\",\"duelar\",\"duende\",\"dueto\",\"duplo\",\"duquesa\",\"durante\",\"duvidoso\",\"eclodir\",\"ecoar\",\"ecologia\",\"edificar\",\"edital\",\"educado\",\"efeito\",\"efetivar\",\"ejetar\",\"elaborar\",\"eleger\",\"eleitor\",\"elenco\",\"elevador\",\"eliminar\",\"elogiar\",\"embargo\",\"embolado\",\"embrulho\",\"embutido\",\"emenda\",\"emergir\",\"emissor\",\"empatia\",\"empenho\",\"empinado\",\"empolgar\",\"emprego\",\"empurrar\",\"emulador\",\"encaixe\",\"encenado\",\"enchente\",\"encontro\",\"endeusar\",\"endossar\",\"enfaixar\",\"enfeite\",\"enfim\",\"engajado\",\"engenho\",\"englobar\",\"engomado\",\"engraxar\",\"enguia\",\"enjoar\",\"enlatar\",\"enquanto\",\"enraizar\",\"enrolado\",\"enrugar\",\"ensaio\",\"enseada\",\"ensino\",\"ensopado\",\"entanto\",\"enteado\",\"entidade\",\"entortar\",\"entrada\",\"entulho\",\"envergar\",\"enviado\",\"envolver\",\"enxame\",\"enxerto\",\"enxofre\",\"enxuto\",\"epiderme\",\"equipar\",\"ereto\",\"erguido\",\"errata\",\"erva\",\"ervilha\",\"esbanjar\",\"esbelto\",\"escama\",\"escola\",\"escrita\",\"escuta\",\"esfinge\",\"esfolar\",\"esfregar\",\"esfumado\",\"esgrima\",\"esmalte\",\"espanto\",\"espelho\",\"espiga\",\"esponja\",\"espreita\",\"espumar\",\"esquerda\",\"estaca\",\"esteira\",\"esticar\",\"estofado\",\"estrela\",\"estudo\",\"esvaziar\",\"etanol\",\"etiqueta\",\"euforia\",\"europeu\",\"evacuar\",\"evaporar\",\"evasivo\",\"eventual\",\"evidente\",\"evoluir\",\"exagero\",\"exalar\",\"examinar\",\"exato\",\"exausto\",\"excesso\",\"excitar\",\"exclamar\",\"executar\",\"exemplo\",\"exibir\",\"exigente\",\"exonerar\",\"expandir\",\"expelir\",\"expirar\",\"explanar\",\"exposto\",\"expresso\",\"expulsar\",\"externo\",\"extinto\",\"extrato\",\"fabricar\",\"fabuloso\",\"faceta\",\"facial\",\"fada\",\"fadiga\",\"faixa\",\"falar\",\"falta\",\"familiar\",\"fandango\",\"fanfarra\",\"fantoche\",\"fardado\",\"farelo\",\"farinha\",\"farofa\",\"farpa\",\"fartura\",\"fatia\",\"fator\",\"favorita\",\"faxina\",\"fazenda\",\"fechado\",\"feijoada\",\"feirante\",\"felino\",\"feminino\",\"fenda\",\"feno\",\"fera\",\"feriado\",\"ferrugem\",\"ferver\",\"festejar\",\"fetal\",\"feudal\",\"fiapo\",\"fibrose\",\"ficar\",\"ficheiro\",\"figurado\",\"fileira\",\"filho\",\"filme\",\"filtrar\",\"firmeza\",\"fisgada\",\"fissura\",\"fita\",\"fivela\",\"fixador\",\"fixo\",\"flacidez\",\"flamingo\",\"flanela\",\"flechada\",\"flora\",\"flutuar\",\"fluxo\",\"focal\",\"focinho\",\"fofocar\",\"fogo\",\"foguete\",\"foice\",\"folgado\",\"folheto\",\"forjar\",\"formiga\",\"forno\",\"forte\",\"fosco\",\"fossa\",\"fragata\",\"fralda\",\"frango\",\"frasco\",\"fraterno\",\"freira\",\"frente\",\"fretar\",\"frieza\",\"friso\",\"fritura\",\"fronha\",\"frustrar\",\"fruteira\",\"fugir\",\"fulano\",\"fuligem\",\"fundar\",\"fungo\",\"funil\",\"furador\",\"furioso\",\"futebol\",\"gabarito\",\"gabinete\",\"gado\",\"gaiato\",\"gaiola\",\"gaivota\",\"galega\",\"galho\",\"galinha\",\"galocha\",\"ganhar\",\"garagem\",\"garfo\",\"gargalo\",\"garimpo\",\"garoupa\",\"garrafa\",\"gasoduto\",\"gasto\",\"gata\",\"gatilho\",\"gaveta\",\"gazela\",\"gelado\",\"geleia\",\"gelo\",\"gemada\",\"gemer\",\"gemido\",\"generoso\",\"gengiva\",\"genial\",\"genoma\",\"genro\",\"geologia\",\"gerador\",\"germinar\",\"gesso\",\"gestor\",\"ginasta\",\"gincana\",\"gingado\",\"girafa\",\"girino\",\"glacial\",\"glicose\",\"global\",\"glorioso\",\"goela\",\"goiaba\",\"golfe\",\"golpear\",\"gordura\",\"gorjeta\",\"gorro\",\"gostoso\",\"goteira\",\"governar\",\"gracejo\",\"gradual\",\"grafite\",\"gralha\",\"grampo\",\"granada\",\"gratuito\",\"graveto\",\"graxa\",\"grego\",\"grelhar\",\"greve\",\"grilo\",\"grisalho\",\"gritaria\",\"grosso\",\"grotesco\",\"grudado\",\"grunhido\",\"gruta\",\"guache\",\"guarani\",\"guaxinim\",\"guerrear\",\"guiar\",\"guincho\",\"guisado\",\"gula\",\"guloso\",\"guru\",\"habitar\",\"harmonia\",\"haste\",\"haver\",\"hectare\",\"herdar\",\"heresia\",\"hesitar\",\"hiato\",\"hibernar\",\"hidratar\",\"hiena\",\"hino\",\"hipismo\",\"hipnose\",\"hipoteca\",\"hoje\",\"holofote\",\"homem\",\"honesto\",\"honrado\",\"hormonal\",\"hospedar\",\"humorado\",\"iate\",\"ideia\",\"idoso\",\"ignorado\",\"igreja\",\"iguana\",\"ileso\",\"ilha\",\"iludido\",\"iluminar\",\"ilustrar\",\"imagem\",\"imediato\",\"imenso\",\"imersivo\",\"iminente\",\"imitador\",\"imortal\",\"impacto\",\"impedir\",\"implante\",\"impor\",\"imprensa\",\"impune\",\"imunizar\",\"inalador\",\"inapto\",\"inativo\",\"incenso\",\"inchar\",\"incidir\",\"incluir\",\"incolor\",\"indeciso\",\"indireto\",\"indutor\",\"ineficaz\",\"inerente\",\"infantil\",\"infestar\",\"infinito\",\"inflamar\",\"informal\",\"infrator\",\"ingerir\",\"inibido\",\"inicial\",\"inimigo\",\"injetar\",\"inocente\",\"inodoro\",\"inovador\",\"inox\",\"inquieto\",\"inscrito\",\"inseto\",\"insistir\",\"inspetor\",\"instalar\",\"insulto\",\"intacto\",\"integral\",\"intimar\",\"intocado\",\"intriga\",\"invasor\",\"inverno\",\"invicto\",\"invocar\",\"iogurte\",\"iraniano\",\"ironizar\",\"irreal\",\"irritado\",\"isca\",\"isento\",\"isolado\",\"isqueiro\",\"italiano\",\"janeiro\",\"jangada\",\"janta\",\"jararaca\",\"jardim\",\"jarro\",\"jasmim\",\"jato\",\"javali\",\"jazida\",\"jejum\",\"joaninha\",\"joelhada\",\"jogador\",\"joia\",\"jornal\",\"jorrar\",\"jovem\",\"juba\",\"judeu\",\"judoca\",\"juiz\",\"julgador\",\"julho\",\"jurado\",\"jurista\",\"juro\",\"justa\",\"labareda\",\"laboral\",\"lacre\",\"lactante\",\"ladrilho\",\"lagarta\",\"lagoa\",\"laje\",\"lamber\",\"lamentar\",\"laminar\",\"lampejo\",\"lanche\",\"lapidar\",\"lapso\",\"laranja\",\"lareira\",\"largura\",\"lasanha\",\"lastro\",\"lateral\",\"latido\",\"lavanda\",\"lavoura\",\"lavrador\",\"laxante\",\"lazer\",\"lealdade\",\"lebre\",\"legado\",\"legendar\",\"legista\",\"leigo\",\"leiloar\",\"leitura\",\"lembrete\",\"leme\",\"lenhador\",\"lentilha\",\"leoa\",\"lesma\",\"leste\",\"letivo\",\"letreiro\",\"levar\",\"leveza\",\"levitar\",\"liberal\",\"libido\",\"liderar\",\"ligar\",\"ligeiro\",\"limitar\",\"limoeiro\",\"limpador\",\"linda\",\"linear\",\"linhagem\",\"liquidez\",\"listagem\",\"lisura\",\"litoral\",\"livro\",\"lixa\",\"lixeira\",\"locador\",\"locutor\",\"lojista\",\"lombo\",\"lona\",\"longe\",\"lontra\",\"lorde\",\"lotado\",\"loteria\",\"loucura\",\"lousa\",\"louvar\",\"luar\",\"lucidez\",\"lucro\",\"luneta\",\"lustre\",\"lutador\",\"luva\",\"macaco\",\"macete\",\"machado\",\"macio\",\"madeira\",\"madrinha\",\"magnata\",\"magreza\",\"maior\",\"mais\",\"malandro\",\"malha\",\"malote\",\"maluco\",\"mamilo\",\"mamoeiro\",\"mamute\",\"manada\",\"mancha\",\"mandato\",\"manequim\",\"manhoso\",\"manivela\",\"manobrar\",\"mansa\",\"manter\",\"manusear\",\"mapeado\",\"maquinar\",\"marcador\",\"maresia\",\"marfim\",\"margem\",\"marinho\",\"marmita\",\"maroto\",\"marquise\",\"marreco\",\"martelo\",\"marujo\",\"mascote\",\"masmorra\",\"massagem\",\"mastigar\",\"matagal\",\"materno\",\"matinal\",\"matutar\",\"maxilar\",\"medalha\",\"medida\",\"medusa\",\"megafone\",\"meiga\",\"melancia\",\"melhor\",\"membro\",\"memorial\",\"menino\",\"menos\",\"mensagem\",\"mental\",\"merecer\",\"mergulho\",\"mesada\",\"mesclar\",\"mesmo\",\"mesquita\",\"mestre\",\"metade\",\"meteoro\",\"metragem\",\"mexer\",\"mexicano\",\"micro\",\"migalha\",\"migrar\",\"milagre\",\"milenar\",\"milhar\",\"mimado\",\"minerar\",\"minhoca\",\"ministro\",\"minoria\",\"miolo\",\"mirante\",\"mirtilo\",\"misturar\",\"mocidade\",\"moderno\",\"modular\",\"moeda\",\"moer\",\"moinho\",\"moita\",\"moldura\",\"moleza\",\"molho\",\"molinete\",\"molusco\",\"montanha\",\"moqueca\",\"morango\",\"morcego\",\"mordomo\",\"morena\",\"mosaico\",\"mosquete\",\"mostarda\",\"motel\",\"motim\",\"moto\",\"motriz\",\"muda\",\"muito\",\"mulata\",\"mulher\",\"multar\",\"mundial\",\"munido\",\"muralha\",\"murcho\",\"muscular\",\"museu\",\"musical\",\"nacional\",\"nadador\",\"naja\",\"namoro\",\"narina\",\"narrado\",\"nascer\",\"nativa\",\"natureza\",\"navalha\",\"navegar\",\"navio\",\"neblina\",\"nebuloso\",\"negativa\",\"negociar\",\"negrito\",\"nervoso\",\"neta\",\"neural\",\"nevasca\",\"nevoeiro\",\"ninar\",\"ninho\",\"nitidez\",\"nivelar\",\"nobreza\",\"noite\",\"noiva\",\"nomear\",\"nominal\",\"nordeste\",\"nortear\",\"notar\",\"noticiar\",\"noturno\",\"novelo\",\"novilho\",\"novo\",\"nublado\",\"nudez\",\"numeral\",\"nupcial\",\"nutrir\",\"nuvem\",\"obcecado\",\"obedecer\",\"objetivo\",\"obrigado\",\"obscuro\",\"obstetra\",\"obter\",\"obturar\",\"ocidente\",\"ocioso\",\"ocorrer\",\"oculista\",\"ocupado\",\"ofegante\",\"ofensiva\",\"oferenda\",\"oficina\",\"ofuscado\",\"ogiva\",\"olaria\",\"oleoso\",\"olhar\",\"oliveira\",\"ombro\",\"omelete\",\"omisso\",\"omitir\",\"ondulado\",\"oneroso\",\"ontem\",\"opcional\",\"operador\",\"oponente\",\"oportuno\",\"oposto\",\"orar\",\"orbitar\",\"ordem\",\"ordinal\",\"orfanato\",\"orgasmo\",\"orgulho\",\"oriental\",\"origem\",\"oriundo\",\"orla\",\"ortodoxo\",\"orvalho\",\"oscilar\",\"ossada\",\"osso\",\"ostentar\",\"otimismo\",\"ousadia\",\"outono\",\"outubro\",\"ouvido\",\"ovelha\",\"ovular\",\"oxidar\",\"oxigenar\",\"pacato\",\"paciente\",\"pacote\",\"pactuar\",\"padaria\",\"padrinho\",\"pagar\",\"pagode\",\"painel\",\"pairar\",\"paisagem\",\"palavra\",\"palestra\",\"palheta\",\"palito\",\"palmada\",\"palpitar\",\"pancada\",\"panela\",\"panfleto\",\"panqueca\",\"pantanal\",\"papagaio\",\"papelada\",\"papiro\",\"parafina\",\"parcial\",\"pardal\",\"parede\",\"partida\",\"pasmo\",\"passado\",\"pastel\",\"patamar\",\"patente\",\"patinar\",\"patrono\",\"paulada\",\"pausar\",\"peculiar\",\"pedalar\",\"pedestre\",\"pediatra\",\"pedra\",\"pegada\",\"peitoral\",\"peixe\",\"pele\",\"pelicano\",\"penca\",\"pendurar\",\"peneira\",\"penhasco\",\"pensador\",\"pente\",\"perceber\",\"perfeito\",\"pergunta\",\"perito\",\"permitir\",\"perna\",\"perplexo\",\"persiana\",\"pertence\",\"peruca\",\"pescado\",\"pesquisa\",\"pessoa\",\"petiscar\",\"piada\",\"picado\",\"piedade\",\"pigmento\",\"pilastra\",\"pilhado\",\"pilotar\",\"pimenta\",\"pincel\",\"pinguim\",\"pinha\",\"pinote\",\"pintar\",\"pioneiro\",\"pipoca\",\"piquete\",\"piranha\",\"pires\",\"pirueta\",\"piscar\",\"pistola\",\"pitanga\",\"pivete\",\"planta\",\"plaqueta\",\"platina\",\"plebeu\",\"plumagem\",\"pluvial\",\"pneu\",\"poda\",\"poeira\",\"poetisa\",\"polegada\",\"policiar\",\"poluente\",\"polvilho\",\"pomar\",\"pomba\",\"ponderar\",\"pontaria\",\"populoso\",\"porta\",\"possuir\",\"postal\",\"pote\",\"poupar\",\"pouso\",\"povoar\",\"praia\",\"prancha\",\"prato\",\"praxe\",\"prece\",\"predador\",\"prefeito\",\"premiar\",\"prensar\",\"preparar\",\"presilha\",\"pretexto\",\"prevenir\",\"prezar\",\"primata\",\"princesa\",\"prisma\",\"privado\",\"processo\",\"produto\",\"profeta\",\"proibido\",\"projeto\",\"prometer\",\"propagar\",\"prosa\",\"protetor\",\"provador\",\"publicar\",\"pudim\",\"pular\",\"pulmonar\",\"pulseira\",\"punhal\",\"punir\",\"pupilo\",\"pureza\",\"puxador\",\"quadra\",\"quantia\",\"quarto\",\"quase\",\"quebrar\",\"queda\",\"queijo\",\"quente\",\"querido\",\"quimono\",\"quina\",\"quiosque\",\"rabanada\",\"rabisco\",\"rachar\",\"racionar\",\"radial\",\"raiar\",\"rainha\",\"raio\",\"raiva\",\"rajada\",\"ralado\",\"ramal\",\"ranger\",\"ranhura\",\"rapadura\",\"rapel\",\"rapidez\",\"raposa\",\"raquete\",\"raridade\",\"rasante\",\"rascunho\",\"rasgar\",\"raspador\",\"rasteira\",\"rasurar\",\"ratazana\",\"ratoeira\",\"realeza\",\"reanimar\",\"reaver\",\"rebaixar\",\"rebelde\",\"rebolar\",\"recado\",\"recente\",\"recheio\",\"recibo\",\"recordar\",\"recrutar\",\"recuar\",\"rede\",\"redimir\",\"redonda\",\"reduzida\",\"reenvio\",\"refinar\",\"refletir\",\"refogar\",\"refresco\",\"refugiar\",\"regalia\",\"regime\",\"regra\",\"reinado\",\"reitor\",\"rejeitar\",\"relativo\",\"remador\",\"remendo\",\"remorso\",\"renovado\",\"reparo\",\"repelir\",\"repleto\",\"repolho\",\"represa\",\"repudiar\",\"requerer\",\"resenha\",\"resfriar\",\"resgatar\",\"residir\",\"resolver\",\"respeito\",\"ressaca\",\"restante\",\"resumir\",\"retalho\",\"reter\",\"retirar\",\"retomada\",\"retratar\",\"revelar\",\"revisor\",\"revolta\",\"riacho\",\"rica\",\"rigidez\",\"rigoroso\",\"rimar\",\"ringue\",\"risada\",\"risco\",\"risonho\",\"robalo\",\"rochedo\",\"rodada\",\"rodeio\",\"rodovia\",\"roedor\",\"roleta\",\"romano\",\"roncar\",\"rosado\",\"roseira\",\"rosto\",\"rota\",\"roteiro\",\"rotina\",\"rotular\",\"rouco\",\"roupa\",\"roxo\",\"rubro\",\"rugido\",\"rugoso\",\"ruivo\",\"rumo\",\"rupestre\",\"russo\",\"sabor\",\"saciar\",\"sacola\",\"sacudir\",\"sadio\",\"safira\",\"saga\",\"sagrada\",\"saibro\",\"salada\",\"saleiro\",\"salgado\",\"saliva\",\"salpicar\",\"salsicha\",\"saltar\",\"salvador\",\"sambar\",\"samurai\",\"sanar\",\"sanfona\",\"sangue\",\"sanidade\",\"sapato\",\"sarda\",\"sargento\",\"sarjeta\",\"saturar\",\"saudade\",\"saxofone\",\"sazonal\",\"secar\",\"secular\",\"seda\",\"sedento\",\"sediado\",\"sedoso\",\"sedutor\",\"segmento\",\"segredo\",\"segundo\",\"seiva\",\"seleto\",\"selvagem\",\"semanal\",\"semente\",\"senador\",\"senhor\",\"sensual\",\"sentado\",\"separado\",\"sereia\",\"seringa\",\"serra\",\"servo\",\"setembro\",\"setor\",\"sigilo\",\"silhueta\",\"silicone\",\"simetria\",\"simpatia\",\"simular\",\"sinal\",\"sincero\",\"singular\",\"sinopse\",\"sintonia\",\"sirene\",\"siri\",\"situado\",\"soberano\",\"sobra\",\"socorro\",\"sogro\",\"soja\",\"solda\",\"soletrar\",\"solteiro\",\"sombrio\",\"sonata\",\"sondar\",\"sonegar\",\"sonhador\",\"sono\",\"soprano\",\"soquete\",\"sorrir\",\"sorteio\",\"sossego\",\"sotaque\",\"soterrar\",\"sovado\",\"sozinho\",\"suavizar\",\"subida\",\"submerso\",\"subsolo\",\"subtrair\",\"sucata\",\"sucesso\",\"suco\",\"sudeste\",\"sufixo\",\"sugador\",\"sugerir\",\"sujeito\",\"sulfato\",\"sumir\",\"suor\",\"superior\",\"suplicar\",\"suposto\",\"suprimir\",\"surdina\",\"surfista\",\"surpresa\",\"surreal\",\"surtir\",\"suspiro\",\"sustento\",\"tabela\",\"tablete\",\"tabuada\",\"tacho\",\"tagarela\",\"talher\",\"talo\",\"talvez\",\"tamanho\",\"tamborim\",\"tampa\",\"tangente\",\"tanto\",\"tapar\",\"tapioca\",\"tardio\",\"tarefa\",\"tarja\",\"tarraxa\",\"tatuagem\",\"taurino\",\"taxativo\",\"taxista\",\"teatral\",\"tecer\",\"tecido\",\"teclado\",\"tedioso\",\"teia\",\"teimar\",\"telefone\",\"telhado\",\"tempero\",\"tenente\",\"tensor\",\"tentar\",\"termal\",\"terno\",\"terreno\",\"tese\",\"tesoura\",\"testado\",\"teto\",\"textura\",\"texugo\",\"tiara\",\"tigela\",\"tijolo\",\"timbrar\",\"timidez\",\"tingido\",\"tinteiro\",\"tiragem\",\"titular\",\"toalha\",\"tocha\",\"tolerar\",\"tolice\",\"tomada\",\"tomilho\",\"tonel\",\"tontura\",\"topete\",\"tora\",\"torcido\",\"torneio\",\"torque\",\"torrada\",\"torto\",\"tostar\",\"touca\",\"toupeira\",\"toxina\",\"trabalho\",\"tracejar\",\"tradutor\",\"trafegar\",\"trajeto\",\"trama\",\"trancar\",\"trapo\",\"traseiro\",\"tratador\",\"travar\",\"treino\",\"tremer\",\"trepidar\",\"trevo\",\"triagem\",\"tribo\",\"triciclo\",\"tridente\",\"trilogia\",\"trindade\",\"triplo\",\"triturar\",\"triunfal\",\"trocar\",\"trombeta\",\"trova\",\"trunfo\",\"truque\",\"tubular\",\"tucano\",\"tudo\",\"tulipa\",\"tupi\",\"turbo\",\"turma\",\"turquesa\",\"tutelar\",\"tutorial\",\"uivar\",\"umbigo\",\"unha\",\"unidade\",\"uniforme\",\"urologia\",\"urso\",\"urtiga\",\"urubu\",\"usado\",\"usina\",\"usufruir\",\"vacina\",\"vadiar\",\"vagaroso\",\"vaidoso\",\"vala\",\"valente\",\"validade\",\"valores\",\"vantagem\",\"vaqueiro\",\"varanda\",\"vareta\",\"varrer\",\"vascular\",\"vasilha\",\"vassoura\",\"vazar\",\"vazio\",\"veado\",\"vedar\",\"vegetar\",\"veicular\",\"veleiro\",\"velhice\",\"veludo\",\"vencedor\",\"vendaval\",\"venerar\",\"ventre\",\"verbal\",\"verdade\",\"vereador\",\"vergonha\",\"vermelho\",\"verniz\",\"versar\",\"vertente\",\"vespa\",\"vestido\",\"vetorial\",\"viaduto\",\"viagem\",\"viajar\",\"viatura\",\"vibrador\",\"videira\",\"vidraria\",\"viela\",\"viga\",\"vigente\",\"vigiar\",\"vigorar\",\"vilarejo\",\"vinco\",\"vinheta\",\"vinil\",\"violeta\",\"virada\",\"virtude\",\"visitar\",\"visto\",\"vitral\",\"viveiro\",\"vizinho\",\"voador\",\"voar\",\"vogal\",\"volante\",\"voleibol\",\"voltagem\",\"volumoso\",\"vontade\",\"vulto\",\"vuvuzela\",\"xadrez\",\"xarope\",\"xeque\",\"xeretar\",\"xerife\",\"xingar\",\"zangado\",\"zarpar\",\"zebu\",\"zelador\",\"zombar\",\"zoologia\",\"zumbido\"]");

const require$$9 = /* #__PURE__ */ JSON.parse("[\"abandon\",\"ability\",\"able\",\"about\",\"above\",\"absent\",\"absorb\",\"abstract\",\"absurd\",\"abuse\",\"access\",\"accident\",\"account\",\"accuse\",\"achieve\",\"acid\",\"acoustic\",\"acquire\",\"across\",\"act\",\"action\",\"actor\",\"actress\",\"actual\",\"adapt\",\"add\",\"addict\",\"address\",\"adjust\",\"admit\",\"adult\",\"advance\",\"advice\",\"aerobic\",\"affair\",\"afford\",\"afraid\",\"again\",\"age\",\"agent\",\"agree\",\"ahead\",\"aim\",\"air\",\"airport\",\"aisle\",\"alarm\",\"album\",\"alcohol\",\"alert\",\"alien\",\"all\",\"alley\",\"allow\",\"almost\",\"alone\",\"alpha\",\"already\",\"also\",\"alter\",\"always\",\"amateur\",\"amazing\",\"among\",\"amount\",\"amused\",\"analyst\",\"anchor\",\"ancient\",\"anger\",\"angle\",\"angry\",\"animal\",\"ankle\",\"announce\",\"annual\",\"another\",\"answer\",\"antenna\",\"antique\",\"anxiety\",\"any\",\"apart\",\"apology\",\"appear\",\"apple\",\"approve\",\"april\",\"arch\",\"arctic\",\"area\",\"arena\",\"argue\",\"arm\",\"armed\",\"armor\",\"army\",\"around\",\"arrange\",\"arrest\",\"arrive\",\"arrow\",\"art\",\"artefact\",\"artist\",\"artwork\",\"ask\",\"aspect\",\"assault\",\"asset\",\"assist\",\"assume\",\"asthma\",\"athlete\",\"atom\",\"attack\",\"attend\",\"attitude\",\"attract\",\"auction\",\"audit\",\"august\",\"aunt\",\"author\",\"auto\",\"autumn\",\"average\",\"avocado\",\"avoid\",\"awake\",\"aware\",\"away\",\"awesome\",\"awful\",\"awkward\",\"axis\",\"baby\",\"bachelor\",\"bacon\",\"badge\",\"bag\",\"balance\",\"balcony\",\"ball\",\"bamboo\",\"banana\",\"banner\",\"bar\",\"barely\",\"bargain\",\"barrel\",\"base\",\"basic\",\"basket\",\"battle\",\"beach\",\"bean\",\"beauty\",\"because\",\"become\",\"beef\",\"before\",\"begin\",\"behave\",\"behind\",\"believe\",\"below\",\"belt\",\"bench\",\"benefit\",\"best\",\"betray\",\"better\",\"between\",\"beyond\",\"bicycle\",\"bid\",\"bike\",\"bind\",\"biology\",\"bird\",\"birth\",\"bitter\",\"black\",\"blade\",\"blame\",\"blanket\",\"blast\",\"bleak\",\"bless\",\"blind\",\"blood\",\"blossom\",\"blouse\",\"blue\",\"blur\",\"blush\",\"board\",\"boat\",\"body\",\"boil\",\"bomb\",\"bone\",\"bonus\",\"book\",\"boost\",\"border\",\"boring\",\"borrow\",\"boss\",\"bottom\",\"bounce\",\"box\",\"boy\",\"bracket\",\"brain\",\"brand\",\"brass\",\"brave\",\"bread\",\"breeze\",\"brick\",\"bridge\",\"brief\",\"bright\",\"bring\",\"brisk\",\"broccoli\",\"broken\",\"bronze\",\"broom\",\"brother\",\"brown\",\"brush\",\"bubble\",\"buddy\",\"budget\",\"buffalo\",\"build\",\"bulb\",\"bulk\",\"bullet\",\"bundle\",\"bunker\",\"burden\",\"burger\",\"burst\",\"bus\",\"business\",\"busy\",\"butter\",\"buyer\",\"buzz\",\"cabbage\",\"cabin\",\"cable\",\"cactus\",\"cage\",\"cake\",\"call\",\"calm\",\"camera\",\"camp\",\"can\",\"canal\",\"cancel\",\"candy\",\"cannon\",\"canoe\",\"canvas\",\"canyon\",\"capable\",\"capital\",\"captain\",\"car\",\"carbon\",\"card\",\"cargo\",\"carpet\",\"carry\",\"cart\",\"case\",\"cash\",\"casino\",\"castle\",\"casual\",\"cat\",\"catalog\",\"catch\",\"category\",\"cattle\",\"caught\",\"cause\",\"caution\",\"cave\",\"ceiling\",\"celery\",\"cement\",\"census\",\"century\",\"cereal\",\"certain\",\"chair\",\"chalk\",\"champion\",\"change\",\"chaos\",\"chapter\",\"charge\",\"chase\",\"chat\",\"cheap\",\"check\",\"cheese\",\"chef\",\"cherry\",\"chest\",\"chicken\",\"chief\",\"child\",\"chimney\",\"choice\",\"choose\",\"chronic\",\"chuckle\",\"chunk\",\"churn\",\"cigar\",\"cinnamon\",\"circle\",\"citizen\",\"city\",\"civil\",\"claim\",\"clap\",\"clarify\",\"claw\",\"clay\",\"clean\",\"clerk\",\"clever\",\"click\",\"client\",\"cliff\",\"climb\",\"clinic\",\"clip\",\"clock\",\"clog\",\"close\",\"cloth\",\"cloud\",\"clown\",\"club\",\"clump\",\"cluster\",\"clutch\",\"coach\",\"coast\",\"coconut\",\"code\",\"coffee\",\"coil\",\"coin\",\"collect\",\"color\",\"column\",\"combine\",\"come\",\"comfort\",\"comic\",\"common\",\"company\",\"concert\",\"conduct\",\"confirm\",\"congress\",\"connect\",\"consider\",\"control\",\"convince\",\"cook\",\"cool\",\"copper\",\"copy\",\"coral\",\"core\",\"corn\",\"correct\",\"cost\",\"cotton\",\"couch\",\"country\",\"couple\",\"course\",\"cousin\",\"cover\",\"coyote\",\"crack\",\"cradle\",\"craft\",\"cram\",\"crane\",\"crash\",\"crater\",\"crawl\",\"crazy\",\"cream\",\"credit\",\"creek\",\"crew\",\"cricket\",\"crime\",\"crisp\",\"critic\",\"crop\",\"cross\",\"crouch\",\"crowd\",\"crucial\",\"cruel\",\"cruise\",\"crumble\",\"crunch\",\"crush\",\"cry\",\"crystal\",\"cube\",\"culture\",\"cup\",\"cupboard\",\"curious\",\"current\",\"curtain\",\"curve\",\"cushion\",\"custom\",\"cute\",\"cycle\",\"dad\",\"damage\",\"damp\",\"dance\",\"danger\",\"daring\",\"dash\",\"daughter\",\"dawn\",\"day\",\"deal\",\"debate\",\"debris\",\"decade\",\"december\",\"decide\",\"decline\",\"decorate\",\"decrease\",\"deer\",\"defense\",\"define\",\"defy\",\"degree\",\"delay\",\"deliver\",\"demand\",\"demise\",\"denial\",\"dentist\",\"deny\",\"depart\",\"depend\",\"deposit\",\"depth\",\"deputy\",\"derive\",\"describe\",\"desert\",\"design\",\"desk\",\"despair\",\"destroy\",\"detail\",\"detect\",\"develop\",\"device\",\"devote\",\"diagram\",\"dial\",\"diamond\",\"diary\",\"dice\",\"diesel\",\"diet\",\"differ\",\"digital\",\"dignity\",\"dilemma\",\"dinner\",\"dinosaur\",\"direct\",\"dirt\",\"disagree\",\"discover\",\"disease\",\"dish\",\"dismiss\",\"disorder\",\"display\",\"distance\",\"divert\",\"divide\",\"divorce\",\"dizzy\",\"doctor\",\"document\",\"dog\",\"doll\",\"dolphin\",\"domain\",\"donate\",\"donkey\",\"donor\",\"door\",\"dose\",\"double\",\"dove\",\"draft\",\"dragon\",\"drama\",\"drastic\",\"draw\",\"dream\",\"dress\",\"drift\",\"drill\",\"drink\",\"drip\",\"drive\",\"drop\",\"drum\",\"dry\",\"duck\",\"dumb\",\"dune\",\"during\",\"dust\",\"dutch\",\"duty\",\"dwarf\",\"dynamic\",\"eager\",\"eagle\",\"early\",\"earn\",\"earth\",\"easily\",\"east\",\"easy\",\"echo\",\"ecology\",\"economy\",\"edge\",\"edit\",\"educate\",\"effort\",\"egg\",\"eight\",\"either\",\"elbow\",\"elder\",\"electric\",\"elegant\",\"element\",\"elephant\",\"elevator\",\"elite\",\"else\",\"embark\",\"embody\",\"embrace\",\"emerge\",\"emotion\",\"employ\",\"empower\",\"empty\",\"enable\",\"enact\",\"end\",\"endless\",\"endorse\",\"enemy\",\"energy\",\"enforce\",\"engage\",\"engine\",\"enhance\",\"enjoy\",\"enlist\",\"enough\",\"enrich\",\"enroll\",\"ensure\",\"enter\",\"entire\",\"entry\",\"envelope\",\"episode\",\"equal\",\"equip\",\"era\",\"erase\",\"erode\",\"erosion\",\"error\",\"erupt\",\"escape\",\"essay\",\"essence\",\"estate\",\"eternal\",\"ethics\",\"evidence\",\"evil\",\"evoke\",\"evolve\",\"exact\",\"example\",\"excess\",\"exchange\",\"excite\",\"exclude\",\"excuse\",\"execute\",\"exercise\",\"exhaust\",\"exhibit\",\"exile\",\"exist\",\"exit\",\"exotic\",\"expand\",\"expect\",\"expire\",\"explain\",\"expose\",\"express\",\"extend\",\"extra\",\"eye\",\"eyebrow\",\"fabric\",\"face\",\"faculty\",\"fade\",\"faint\",\"faith\",\"fall\",\"false\",\"fame\",\"family\",\"famous\",\"fan\",\"fancy\",\"fantasy\",\"farm\",\"fashion\",\"fat\",\"fatal\",\"father\",\"fatigue\",\"fault\",\"favorite\",\"feature\",\"february\",\"federal\",\"fee\",\"feed\",\"feel\",\"female\",\"fence\",\"festival\",\"fetch\",\"fever\",\"few\",\"fiber\",\"fiction\",\"field\",\"figure\",\"file\",\"film\",\"filter\",\"final\",\"find\",\"fine\",\"finger\",\"finish\",\"fire\",\"firm\",\"first\",\"fiscal\",\"fish\",\"fit\",\"fitness\",\"fix\",\"flag\",\"flame\",\"flash\",\"flat\",\"flavor\",\"flee\",\"flight\",\"flip\",\"float\",\"flock\",\"floor\",\"flower\",\"fluid\",\"flush\",\"fly\",\"foam\",\"focus\",\"fog\",\"foil\",\"fold\",\"follow\",\"food\",\"foot\",\"force\",\"forest\",\"forget\",\"fork\",\"fortune\",\"forum\",\"forward\",\"fossil\",\"foster\",\"found\",\"fox\",\"fragile\",\"frame\",\"frequent\",\"fresh\",\"friend\",\"fringe\",\"frog\",\"front\",\"frost\",\"frown\",\"frozen\",\"fruit\",\"fuel\",\"fun\",\"funny\",\"furnace\",\"fury\",\"future\",\"gadget\",\"gain\",\"galaxy\",\"gallery\",\"game\",\"gap\",\"garage\",\"garbage\",\"garden\",\"garlic\",\"garment\",\"gas\",\"gasp\",\"gate\",\"gather\",\"gauge\",\"gaze\",\"general\",\"genius\",\"genre\",\"gentle\",\"genuine\",\"gesture\",\"ghost\",\"giant\",\"gift\",\"giggle\",\"ginger\",\"giraffe\",\"girl\",\"give\",\"glad\",\"glance\",\"glare\",\"glass\",\"glide\",\"glimpse\",\"globe\",\"gloom\",\"glory\",\"glove\",\"glow\",\"glue\",\"goat\",\"goddess\",\"gold\",\"good\",\"goose\",\"gorilla\",\"gospel\",\"gossip\",\"govern\",\"gown\",\"grab\",\"grace\",\"grain\",\"grant\",\"grape\",\"grass\",\"gravity\",\"great\",\"green\",\"grid\",\"grief\",\"grit\",\"grocery\",\"group\",\"grow\",\"grunt\",\"guard\",\"guess\",\"guide\",\"guilt\",\"guitar\",\"gun\",\"gym\",\"habit\",\"hair\",\"half\",\"hammer\",\"hamster\",\"hand\",\"happy\",\"harbor\",\"hard\",\"harsh\",\"harvest\",\"hat\",\"have\",\"hawk\",\"hazard\",\"head\",\"health\",\"heart\",\"heavy\",\"hedgehog\",\"height\",\"hello\",\"helmet\",\"help\",\"hen\",\"hero\",\"hidden\",\"high\",\"hill\",\"hint\",\"hip\",\"hire\",\"history\",\"hobby\",\"hockey\",\"hold\",\"hole\",\"holiday\",\"hollow\",\"home\",\"honey\",\"hood\",\"hope\",\"horn\",\"horror\",\"horse\",\"hospital\",\"host\",\"hotel\",\"hour\",\"hover\",\"hub\",\"huge\",\"human\",\"humble\",\"humor\",\"hundred\",\"hungry\",\"hunt\",\"hurdle\",\"hurry\",\"hurt\",\"husband\",\"hybrid\",\"ice\",\"icon\",\"idea\",\"identify\",\"idle\",\"ignore\",\"ill\",\"illegal\",\"illness\",\"image\",\"imitate\",\"immense\",\"immune\",\"impact\",\"impose\",\"improve\",\"impulse\",\"inch\",\"include\",\"income\",\"increase\",\"index\",\"indicate\",\"indoor\",\"industry\",\"infant\",\"inflict\",\"inform\",\"inhale\",\"inherit\",\"initial\",\"inject\",\"injury\",\"inmate\",\"inner\",\"innocent\",\"input\",\"inquiry\",\"insane\",\"insect\",\"inside\",\"inspire\",\"install\",\"intact\",\"interest\",\"into\",\"invest\",\"invite\",\"involve\",\"iron\",\"island\",\"isolate\",\"issue\",\"item\",\"ivory\",\"jacket\",\"jaguar\",\"jar\",\"jazz\",\"jealous\",\"jeans\",\"jelly\",\"jewel\",\"job\",\"join\",\"joke\",\"journey\",\"joy\",\"judge\",\"juice\",\"jump\",\"jungle\",\"junior\",\"junk\",\"just\",\"kangaroo\",\"keen\",\"keep\",\"ketchup\",\"key\",\"kick\",\"kid\",\"kidney\",\"kind\",\"kingdom\",\"kiss\",\"kit\",\"kitchen\",\"kite\",\"kitten\",\"kiwi\",\"knee\",\"knife\",\"knock\",\"know\",\"lab\",\"label\",\"labor\",\"ladder\",\"lady\",\"lake\",\"lamp\",\"language\",\"laptop\",\"large\",\"later\",\"latin\",\"laugh\",\"laundry\",\"lava\",\"law\",\"lawn\",\"lawsuit\",\"layer\",\"lazy\",\"leader\",\"leaf\",\"learn\",\"leave\",\"lecture\",\"left\",\"leg\",\"legal\",\"legend\",\"leisure\",\"lemon\",\"lend\",\"length\",\"lens\",\"leopard\",\"lesson\",\"letter\",\"level\",\"liar\",\"liberty\",\"library\",\"license\",\"life\",\"lift\",\"light\",\"like\",\"limb\",\"limit\",\"link\",\"lion\",\"liquid\",\"list\",\"little\",\"live\",\"lizard\",\"load\",\"loan\",\"lobster\",\"local\",\"lock\",\"logic\",\"lonely\",\"long\",\"loop\",\"lottery\",\"loud\",\"lounge\",\"love\",\"loyal\",\"lucky\",\"luggage\",\"lumber\",\"lunar\",\"lunch\",\"luxury\",\"lyrics\",\"machine\",\"mad\",\"magic\",\"magnet\",\"maid\",\"mail\",\"main\",\"major\",\"make\",\"mammal\",\"man\",\"manage\",\"mandate\",\"mango\",\"mansion\",\"manual\",\"maple\",\"marble\",\"march\",\"margin\",\"marine\",\"market\",\"marriage\",\"mask\",\"mass\",\"master\",\"match\",\"material\",\"math\",\"matrix\",\"matter\",\"maximum\",\"maze\",\"meadow\",\"mean\",\"measure\",\"meat\",\"mechanic\",\"medal\",\"media\",\"melody\",\"melt\",\"member\",\"memory\",\"mention\",\"menu\",\"mercy\",\"merge\",\"merit\",\"merry\",\"mesh\",\"message\",\"metal\",\"method\",\"middle\",\"midnight\",\"milk\",\"million\",\"mimic\",\"mind\",\"minimum\",\"minor\",\"minute\",\"miracle\",\"mirror\",\"misery\",\"miss\",\"mistake\",\"mix\",\"mixed\",\"mixture\",\"mobile\",\"model\",\"modify\",\"mom\",\"moment\",\"monitor\",\"monkey\",\"monster\",\"month\",\"moon\",\"moral\",\"more\",\"morning\",\"mosquito\",\"mother\",\"motion\",\"motor\",\"mountain\",\"mouse\",\"move\",\"movie\",\"much\",\"muffin\",\"mule\",\"multiply\",\"muscle\",\"museum\",\"mushroom\",\"music\",\"must\",\"mutual\",\"myself\",\"mystery\",\"myth\",\"naive\",\"name\",\"napkin\",\"narrow\",\"nasty\",\"nation\",\"nature\",\"near\",\"neck\",\"need\",\"negative\",\"neglect\",\"neither\",\"nephew\",\"nerve\",\"nest\",\"net\",\"network\",\"neutral\",\"never\",\"news\",\"next\",\"nice\",\"night\",\"noble\",\"noise\",\"nominee\",\"noodle\",\"normal\",\"north\",\"nose\",\"notable\",\"note\",\"nothing\",\"notice\",\"novel\",\"now\",\"nuclear\",\"number\",\"nurse\",\"nut\",\"oak\",\"obey\",\"object\",\"oblige\",\"obscure\",\"observe\",\"obtain\",\"obvious\",\"occur\",\"ocean\",\"october\",\"odor\",\"off\",\"offer\",\"office\",\"often\",\"oil\",\"okay\",\"old\",\"olive\",\"olympic\",\"omit\",\"once\",\"one\",\"onion\",\"online\",\"only\",\"open\",\"opera\",\"opinion\",\"oppose\",\"option\",\"orange\",\"orbit\",\"orchard\",\"order\",\"ordinary\",\"organ\",\"orient\",\"original\",\"orphan\",\"ostrich\",\"other\",\"outdoor\",\"outer\",\"output\",\"outside\",\"oval\",\"oven\",\"over\",\"own\",\"owner\",\"oxygen\",\"oyster\",\"ozone\",\"pact\",\"paddle\",\"page\",\"pair\",\"palace\",\"palm\",\"panda\",\"panel\",\"panic\",\"panther\",\"paper\",\"parade\",\"parent\",\"park\",\"parrot\",\"party\",\"pass\",\"patch\",\"path\",\"patient\",\"patrol\",\"pattern\",\"pause\",\"pave\",\"payment\",\"peace\",\"peanut\",\"pear\",\"peasant\",\"pelican\",\"pen\",\"penalty\",\"pencil\",\"people\",\"pepper\",\"perfect\",\"permit\",\"person\",\"pet\",\"phone\",\"photo\",\"phrase\",\"physical\",\"piano\",\"picnic\",\"picture\",\"piece\",\"pig\",\"pigeon\",\"pill\",\"pilot\",\"pink\",\"pioneer\",\"pipe\",\"pistol\",\"pitch\",\"pizza\",\"place\",\"planet\",\"plastic\",\"plate\",\"play\",\"please\",\"pledge\",\"pluck\",\"plug\",\"plunge\",\"poem\",\"poet\",\"point\",\"polar\",\"pole\",\"police\",\"pond\",\"pony\",\"pool\",\"popular\",\"portion\",\"position\",\"possible\",\"post\",\"potato\",\"pottery\",\"poverty\",\"powder\",\"power\",\"practice\",\"praise\",\"predict\",\"prefer\",\"prepare\",\"present\",\"pretty\",\"prevent\",\"price\",\"pride\",\"primary\",\"print\",\"priority\",\"prison\",\"private\",\"prize\",\"problem\",\"process\",\"produce\",\"profit\",\"program\",\"project\",\"promote\",\"proof\",\"property\",\"prosper\",\"protect\",\"proud\",\"provide\",\"public\",\"pudding\",\"pull\",\"pulp\",\"pulse\",\"pumpkin\",\"punch\",\"pupil\",\"puppy\",\"purchase\",\"purity\",\"purpose\",\"purse\",\"push\",\"put\",\"puzzle\",\"pyramid\",\"quality\",\"quantum\",\"quarter\",\"question\",\"quick\",\"quit\",\"quiz\",\"quote\",\"rabbit\",\"raccoon\",\"race\",\"rack\",\"radar\",\"radio\",\"rail\",\"rain\",\"raise\",\"rally\",\"ramp\",\"ranch\",\"random\",\"range\",\"rapid\",\"rare\",\"rate\",\"rather\",\"raven\",\"raw\",\"razor\",\"ready\",\"real\",\"reason\",\"rebel\",\"rebuild\",\"recall\",\"receive\",\"recipe\",\"record\",\"recycle\",\"reduce\",\"reflect\",\"reform\",\"refuse\",\"region\",\"regret\",\"regular\",\"reject\",\"relax\",\"release\",\"relief\",\"rely\",\"remain\",\"remember\",\"remind\",\"remove\",\"render\",\"renew\",\"rent\",\"reopen\",\"repair\",\"repeat\",\"replace\",\"report\",\"require\",\"rescue\",\"resemble\",\"resist\",\"resource\",\"response\",\"result\",\"retire\",\"retreat\",\"return\",\"reunion\",\"reveal\",\"review\",\"reward\",\"rhythm\",\"rib\",\"ribbon\",\"rice\",\"rich\",\"ride\",\"ridge\",\"rifle\",\"right\",\"rigid\",\"ring\",\"riot\",\"ripple\",\"risk\",\"ritual\",\"rival\",\"river\",\"road\",\"roast\",\"robot\",\"robust\",\"rocket\",\"romance\",\"roof\",\"rookie\",\"room\",\"rose\",\"rotate\",\"rough\",\"round\",\"route\",\"royal\",\"rubber\",\"rude\",\"rug\",\"rule\",\"run\",\"runway\",\"rural\",\"sad\",\"saddle\",\"sadness\",\"safe\",\"sail\",\"salad\",\"salmon\",\"salon\",\"salt\",\"salute\",\"same\",\"sample\",\"sand\",\"satisfy\",\"satoshi\",\"sauce\",\"sausage\",\"save\",\"say\",\"scale\",\"scan\",\"scare\",\"scatter\",\"scene\",\"scheme\",\"school\",\"science\",\"scissors\",\"scorpion\",\"scout\",\"scrap\",\"screen\",\"script\",\"scrub\",\"sea\",\"search\",\"season\",\"seat\",\"second\",\"secret\",\"section\",\"security\",\"seed\",\"seek\",\"segment\",\"select\",\"sell\",\"seminar\",\"senior\",\"sense\",\"sentence\",\"series\",\"service\",\"session\",\"settle\",\"setup\",\"seven\",\"shadow\",\"shaft\",\"shallow\",\"share\",\"shed\",\"shell\",\"sheriff\",\"shield\",\"shift\",\"shine\",\"ship\",\"shiver\",\"shock\",\"shoe\",\"shoot\",\"shop\",\"short\",\"shoulder\",\"shove\",\"shrimp\",\"shrug\",\"shuffle\",\"shy\",\"sibling\",\"sick\",\"side\",\"siege\",\"sight\",\"sign\",\"silent\",\"silk\",\"silly\",\"silver\",\"similar\",\"simple\",\"since\",\"sing\",\"siren\",\"sister\",\"situate\",\"six\",\"size\",\"skate\",\"sketch\",\"ski\",\"skill\",\"skin\",\"skirt\",\"skull\",\"slab\",\"slam\",\"sleep\",\"slender\",\"slice\",\"slide\",\"slight\",\"slim\",\"slogan\",\"slot\",\"slow\",\"slush\",\"small\",\"smart\",\"smile\",\"smoke\",\"smooth\",\"snack\",\"snake\",\"snap\",\"sniff\",\"snow\",\"soap\",\"soccer\",\"social\",\"sock\",\"soda\",\"soft\",\"solar\",\"soldier\",\"solid\",\"solution\",\"solve\",\"someone\",\"song\",\"soon\",\"sorry\",\"sort\",\"soul\",\"sound\",\"soup\",\"source\",\"south\",\"space\",\"spare\",\"spatial\",\"spawn\",\"speak\",\"special\",\"speed\",\"spell\",\"spend\",\"sphere\",\"spice\",\"spider\",\"spike\",\"spin\",\"spirit\",\"split\",\"spoil\",\"sponsor\",\"spoon\",\"sport\",\"spot\",\"spray\",\"spread\",\"spring\",\"spy\",\"square\",\"squeeze\",\"squirrel\",\"stable\",\"stadium\",\"staff\",\"stage\",\"stairs\",\"stamp\",\"stand\",\"start\",\"state\",\"stay\",\"steak\",\"steel\",\"stem\",\"step\",\"stereo\",\"stick\",\"still\",\"sting\",\"stock\",\"stomach\",\"stone\",\"stool\",\"story\",\"stove\",\"strategy\",\"street\",\"strike\",\"strong\",\"struggle\",\"student\",\"stuff\",\"stumble\",\"style\",\"subject\",\"submit\",\"subway\",\"success\",\"such\",\"sudden\",\"suffer\",\"sugar\",\"suggest\",\"suit\",\"summer\",\"sun\",\"sunny\",\"sunset\",\"super\",\"supply\",\"supreme\",\"sure\",\"surface\",\"surge\",\"surprise\",\"surround\",\"survey\",\"suspect\",\"sustain\",\"swallow\",\"swamp\",\"swap\",\"swarm\",\"swear\",\"sweet\",\"swift\",\"swim\",\"swing\",\"switch\",\"sword\",\"symbol\",\"symptom\",\"syrup\",\"system\",\"table\",\"tackle\",\"tag\",\"tail\",\"talent\",\"talk\",\"tank\",\"tape\",\"target\",\"task\",\"taste\",\"tattoo\",\"taxi\",\"teach\",\"team\",\"tell\",\"ten\",\"tenant\",\"tennis\",\"tent\",\"term\",\"test\",\"text\",\"thank\",\"that\",\"theme\",\"then\",\"theory\",\"there\",\"they\",\"thing\",\"this\",\"thought\",\"three\",\"thrive\",\"throw\",\"thumb\",\"thunder\",\"ticket\",\"tide\",\"tiger\",\"tilt\",\"timber\",\"time\",\"tiny\",\"tip\",\"tired\",\"tissue\",\"title\",\"toast\",\"tobacco\",\"today\",\"toddler\",\"toe\",\"together\",\"toilet\",\"token\",\"tomato\",\"tomorrow\",\"tone\",\"tongue\",\"tonight\",\"tool\",\"tooth\",\"top\",\"topic\",\"topple\",\"torch\",\"tornado\",\"tortoise\",\"toss\",\"total\",\"tourist\",\"toward\",\"tower\",\"town\",\"toy\",\"track\",\"trade\",\"traffic\",\"tragic\",\"train\",\"transfer\",\"trap\",\"trash\",\"travel\",\"tray\",\"treat\",\"tree\",\"trend\",\"trial\",\"tribe\",\"trick\",\"trigger\",\"trim\",\"trip\",\"trophy\",\"trouble\",\"truck\",\"true\",\"truly\",\"trumpet\",\"trust\",\"truth\",\"try\",\"tube\",\"tuition\",\"tumble\",\"tuna\",\"tunnel\",\"turkey\",\"turn\",\"turtle\",\"twelve\",\"twenty\",\"twice\",\"twin\",\"twist\",\"two\",\"type\",\"typical\",\"ugly\",\"umbrella\",\"unable\",\"unaware\",\"uncle\",\"uncover\",\"under\",\"undo\",\"unfair\",\"unfold\",\"unhappy\",\"uniform\",\"unique\",\"unit\",\"universe\",\"unknown\",\"unlock\",\"until\",\"unusual\",\"unveil\",\"update\",\"upgrade\",\"uphold\",\"upon\",\"upper\",\"upset\",\"urban\",\"urge\",\"usage\",\"use\",\"used\",\"useful\",\"useless\",\"usual\",\"utility\",\"vacant\",\"vacuum\",\"vague\",\"valid\",\"valley\",\"valve\",\"van\",\"vanish\",\"vapor\",\"various\",\"vast\",\"vault\",\"vehicle\",\"velvet\",\"vendor\",\"venture\",\"venue\",\"verb\",\"verify\",\"version\",\"very\",\"vessel\",\"veteran\",\"viable\",\"vibrant\",\"vicious\",\"victory\",\"video\",\"view\",\"village\",\"vintage\",\"violin\",\"virtual\",\"virus\",\"visa\",\"visit\",\"visual\",\"vital\",\"vivid\",\"vocal\",\"voice\",\"void\",\"volcano\",\"volume\",\"vote\",\"voyage\",\"wage\",\"wagon\",\"wait\",\"walk\",\"wall\",\"walnut\",\"want\",\"warfare\",\"warm\",\"warrior\",\"wash\",\"wasp\",\"waste\",\"water\",\"wave\",\"way\",\"wealth\",\"weapon\",\"wear\",\"weasel\",\"weather\",\"web\",\"wedding\",\"weekend\",\"weird\",\"welcome\",\"west\",\"wet\",\"whale\",\"what\",\"wheat\",\"wheel\",\"when\",\"where\",\"whip\",\"whisper\",\"wide\",\"width\",\"wife\",\"wild\",\"will\",\"win\",\"window\",\"wine\",\"wing\",\"wink\",\"winner\",\"winter\",\"wire\",\"wisdom\",\"wise\",\"wish\",\"witness\",\"wolf\",\"woman\",\"wonder\",\"wood\",\"wool\",\"word\",\"work\",\"world\",\"worry\",\"worth\",\"wrap\",\"wreck\",\"wrestle\",\"wrist\",\"write\",\"wrong\",\"yard\",\"year\",\"yellow\",\"you\",\"young\",\"youth\",\"zebra\",\"zero\",\"zone\",\"zoo\"]");

var hasRequired_wordlists;

function require_wordlists () {
	if (hasRequired_wordlists) return _wordlists;
	hasRequired_wordlists = 1;
	Object.defineProperty(_wordlists, "__esModule", { value: true });
	// browserify by default only pulls in files that are hard coded in requires
	// In order of last to first in this file, the default wordlist will be chosen
	// based on what is present. (Bundles may remove wordlists they don't need)
	const wordlists = {};
	_wordlists.wordlists = wordlists;
	let _default;
	_wordlists._default = _default;
	try {
	    _wordlists._default = _default = require$$0;
	    wordlists.czech = _default;
	}
	catch (err) { }
	try {
	    _wordlists._default = _default = require$$1;
	    wordlists.chinese_simplified = _default;
	}
	catch (err) { }
	try {
	    _wordlists._default = _default = require$$2;
	    wordlists.chinese_traditional = _default;
	}
	catch (err) { }
	try {
	    _wordlists._default = _default = require$$3;
	    wordlists.korean = _default;
	}
	catch (err) { }
	try {
	    _wordlists._default = _default = require$$4;
	    wordlists.french = _default;
	}
	catch (err) { }
	try {
	    _wordlists._default = _default = require$$5;
	    wordlists.italian = _default;
	}
	catch (err) { }
	try {
	    _wordlists._default = _default = require$$6;
	    wordlists.spanish = _default;
	}
	catch (err) { }
	try {
	    _wordlists._default = _default = require$$7;
	    wordlists.japanese = _default;
	    wordlists.JA = _default;
	}
	catch (err) { }
	try {
	    _wordlists._default = _default = require$$8;
	    wordlists.portuguese = _default;
	}
	catch (err) { }
	try {
	    _wordlists._default = _default = require$$9;
	    wordlists.english = _default;
	    wordlists.EN = _default;
	}
	catch (err) { }
	return _wordlists;
}

var hasRequiredSrc;

function requireSrc () {
	if (hasRequiredSrc) return src;
	hasRequiredSrc = 1;
	Object.defineProperty(src, "__esModule", { value: true });
	const sha256_1 = /*@__PURE__*/ requireSha256$1();
	const sha512_1 = /*@__PURE__*/ requireSha512$1();
	const pbkdf2_1 = /*@__PURE__*/ requirePbkdf2();
	const utils_1 = /*@__PURE__*/ requireUtils$2();
	const _wordlists_1 = require_wordlists();
	let DEFAULT_WORDLIST = _wordlists_1._default;
	const INVALID_MNEMONIC = 'Invalid mnemonic';
	const INVALID_ENTROPY = 'Invalid entropy';
	const INVALID_CHECKSUM = 'Invalid mnemonic checksum';
	const WORDLIST_REQUIRED = 'A wordlist is required but a default could not be found.\n' +
	    'Please pass a 2048 word array explicitly.';
	function normalize(str) {
	    return (str || '').normalize('NFKD');
	}
	function lpad(str, padString, length) {
	    while (str.length < length) {
	        str = padString + str;
	    }
	    return str;
	}
	function binaryToByte(bin) {
	    return parseInt(bin, 2);
	}
	function bytesToBinary(bytes) {
	    return bytes.map((x) => lpad(x.toString(2), '0', 8)).join('');
	}
	function deriveChecksumBits(entropyBuffer) {
	    const ENT = entropyBuffer.length * 8;
	    const CS = ENT / 32;
	    const hash = sha256_1.sha256(Uint8Array.from(entropyBuffer));
	    return bytesToBinary(Array.from(hash)).slice(0, CS);
	}
	function salt(password) {
	    return 'mnemonic' + (password || '');
	}
	function mnemonicToSeedSync(mnemonic, password) {
	    const mnemonicBuffer = Uint8Array.from(Buffer$1.from(normalize(mnemonic), 'utf8'));
	    const saltBuffer = Uint8Array.from(Buffer$1.from(salt(normalize(password)), 'utf8'));
	    const res = pbkdf2_1.pbkdf2(sha512_1.sha512, mnemonicBuffer, saltBuffer, {
	        c: 2048,
	        dkLen: 64,
	    });
	    return Buffer$1.from(res);
	}
	src.mnemonicToSeedSync = mnemonicToSeedSync;
	function mnemonicToSeed(mnemonic, password) {
	    const mnemonicBuffer = Uint8Array.from(Buffer$1.from(normalize(mnemonic), 'utf8'));
	    const saltBuffer = Uint8Array.from(Buffer$1.from(salt(normalize(password)), 'utf8'));
	    return pbkdf2_1.pbkdf2Async(sha512_1.sha512, mnemonicBuffer, saltBuffer, {
	        c: 2048,
	        dkLen: 64,
	    }).then((res) => Buffer$1.from(res));
	}
	src.mnemonicToSeed = mnemonicToSeed;
	function mnemonicToEntropy(mnemonic, wordlist) {
	    wordlist = wordlist || DEFAULT_WORDLIST;
	    if (!wordlist) {
	        throw new Error(WORDLIST_REQUIRED);
	    }
	    const words = normalize(mnemonic).split(' ');
	    if (words.length % 3 !== 0) {
	        throw new Error(INVALID_MNEMONIC);
	    }
	    // convert word indices to 11 bit binary strings
	    const bits = words
	        .map((word) => {
	        const index = wordlist.indexOf(word);
	        if (index === -1) {
	            throw new Error(INVALID_MNEMONIC);
	        }
	        return lpad(index.toString(2), '0', 11);
	    })
	        .join('');
	    // split the binary string into ENT/CS
	    const dividerIndex = Math.floor(bits.length / 33) * 32;
	    const entropyBits = bits.slice(0, dividerIndex);
	    const checksumBits = bits.slice(dividerIndex);
	    // calculate the checksum and compare
	    const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);
	    if (entropyBytes.length < 16) {
	        throw new Error(INVALID_ENTROPY);
	    }
	    if (entropyBytes.length > 32) {
	        throw new Error(INVALID_ENTROPY);
	    }
	    if (entropyBytes.length % 4 !== 0) {
	        throw new Error(INVALID_ENTROPY);
	    }
	    const entropy = Buffer$1.from(entropyBytes);
	    const newChecksum = deriveChecksumBits(entropy);
	    if (newChecksum !== checksumBits) {
	        throw new Error(INVALID_CHECKSUM);
	    }
	    return entropy.toString('hex');
	}
	src.mnemonicToEntropy = mnemonicToEntropy;
	function entropyToMnemonic(entropy, wordlist) {
	    if (!Buffer$1.isBuffer(entropy)) {
	        entropy = Buffer$1.from(entropy, 'hex');
	    }
	    wordlist = wordlist || DEFAULT_WORDLIST;
	    if (!wordlist) {
	        throw new Error(WORDLIST_REQUIRED);
	    }
	    // 128 <= ENT <= 256
	    if (entropy.length < 16) {
	        throw new TypeError(INVALID_ENTROPY);
	    }
	    if (entropy.length > 32) {
	        throw new TypeError(INVALID_ENTROPY);
	    }
	    if (entropy.length % 4 !== 0) {
	        throw new TypeError(INVALID_ENTROPY);
	    }
	    const entropyBits = bytesToBinary(Array.from(entropy));
	    const checksumBits = deriveChecksumBits(entropy);
	    const bits = entropyBits + checksumBits;
	    const chunks = bits.match(/(.{1,11})/g);
	    const words = chunks.map((binary) => {
	        const index = binaryToByte(binary);
	        return wordlist[index];
	    });
	    return wordlist[0] === '\u3042\u3044\u3053\u304f\u3057\u3093' // Japanese wordlist
	        ? words.join('\u3000')
	        : words.join(' ');
	}
	src.entropyToMnemonic = entropyToMnemonic;
	function generateMnemonic(strength, rng, wordlist) {
	    strength = strength || 128;
	    if (strength % 32 !== 0) {
	        throw new TypeError(INVALID_ENTROPY);
	    }
	    rng = rng || ((size) => Buffer$1.from(utils_1.randomBytes(size)));
	    return entropyToMnemonic(rng(strength / 8), wordlist);
	}
	src.generateMnemonic = generateMnemonic;
	function validateMnemonic(mnemonic, wordlist) {
	    try {
	        mnemonicToEntropy(mnemonic, wordlist);
	    }
	    catch (e) {
	        return false;
	    }
	    return true;
	}
	src.validateMnemonic = validateMnemonic;
	function setDefaultWordlist(language) {
	    const result = _wordlists_1.wordlists[language];
	    if (result) {
	        DEFAULT_WORDLIST = result;
	    }
	    else {
	        throw new Error('Could not find wordlist for language "' + language + '"');
	    }
	}
	src.setDefaultWordlist = setDefaultWordlist;
	function getDefaultWordlist() {
	    if (!DEFAULT_WORDLIST) {
	        throw new Error('No Default Wordlist set');
	    }
	    return Object.keys(_wordlists_1.wordlists).filter((lang) => {
	        if (lang === 'JA' || lang === 'EN') {
	            return false;
	        }
	        return _wordlists_1.wordlists[lang].every((word, index) => word === DEFAULT_WORDLIST[index]);
	    })[0];
	}
	src.getDefaultWordlist = getDefaultWordlist;
	var _wordlists_2 = require_wordlists();
	src.wordlists = _wordlists_2.wordlists;
	return src;
}

requireSrc();

var MnemonicStrength;
(function (MnemonicStrength) {
    MnemonicStrength[MnemonicStrength["MINIMUM"] = 128] = "MINIMUM";
    MnemonicStrength[MnemonicStrength["LOW"] = 160] = "LOW";
    MnemonicStrength[MnemonicStrength["MEDIUM"] = 192] = "MEDIUM";
    MnemonicStrength[MnemonicStrength["HIGH"] = 224] = "HIGH";
    MnemonicStrength[MnemonicStrength["MAXIMUM"] = 256] = "MAXIMUM";
})(MnemonicStrength || (MnemonicStrength = {}));

var BIPStandard;
(function (BIPStandard) {
    BIPStandard[BIPStandard["BIP44"] = 44] = "BIP44";
    BIPStandard[BIPStandard["BIP49"] = 49] = "BIP49";
    BIPStandard[BIPStandard["BIP84"] = 84] = "BIP84";
    BIPStandard[BIPStandard["BIP86"] = 86] = "BIP86";
})(BIPStandard || (BIPStandard = {}));

initEccLib(ecc);
cjsExports.BIP32Factory(ecc);

var MLDSAPublicKeyMetadata;
(function (MLDSAPublicKeyMetadata) {
    MLDSAPublicKeyMetadata[MLDSAPublicKeyMetadata["MLDSA44"] = 1312] = "MLDSA44";
    MLDSAPublicKeyMetadata[MLDSAPublicKeyMetadata["MLDSA65"] = 1952] = "MLDSA65";
    MLDSAPublicKeyMetadata[MLDSAPublicKeyMetadata["MLDSA87"] = 2592] = "MLDSA87";
})(MLDSAPublicKeyMetadata || (MLDSAPublicKeyMetadata = {}));
function getLevelFromPublicKeyLength(length) {
    switch (length) {
        case MLDSAPublicKeyMetadata.MLDSA44:
            return cjsExports.MLDSASecurityLevel.LEVEL2;
        case MLDSAPublicKeyMetadata.MLDSA65:
            return cjsExports.MLDSASecurityLevel.LEVEL3;
        case MLDSAPublicKeyMetadata.MLDSA87:
            return cjsExports.MLDSASecurityLevel.LEVEL5;
        default:
            throw new Error(`Invalid MLDSA public key length: ${length}`);
    }
}

var ChainId;
(function (ChainId) {
    ChainId[ChainId["Bitcoin"] = 0] = "Bitcoin";
    ChainId[ChainId["Fractal"] = 1] = "Fractal";
})(ChainId || (ChainId = {}));

var TransactionType;
(function (TransactionType) {
    TransactionType[TransactionType["GENERIC"] = 0] = "GENERIC";
    TransactionType[TransactionType["FUNDING"] = 1] = "FUNDING";
    TransactionType[TransactionType["DEPLOYMENT"] = 2] = "DEPLOYMENT";
    TransactionType[TransactionType["INTERACTION"] = 3] = "INTERACTION";
    TransactionType[TransactionType["MULTI_SIG"] = 4] = "MULTI_SIG";
    TransactionType[TransactionType["CUSTOM_CODE"] = 5] = "CUSTOM_CODE";
    TransactionType[TransactionType["CANCEL"] = 6] = "CANCEL";
    TransactionType[TransactionType["CONSOLIDATED_SETUP"] = 7] = "CONSOLIDATED_SETUP";
    TransactionType[TransactionType["CONSOLIDATED_REVEAL"] = 8] = "CONSOLIDATED_REVEAL";
})(TransactionType || (TransactionType = {}));

var Consensus;
(function (Consensus) {
    Consensus[Consensus["Roswell"] = 0] = "Roswell";
    Consensus[Consensus["Rachel"] = 1] = "Rachel";
    Consensus[Consensus["Kecksburg"] = 2] = "Kecksburg";
    Consensus[Consensus["Phoenix"] = 3] = "Phoenix";
    Consensus[Consensus["Aurora"] = 4] = "Aurora";
    Consensus[Consensus["Rendlesham"] = 5] = "Rendlesham";
    Consensus[Consensus["Lazar"] = 6] = "Lazar";
    Consensus[Consensus["ShagHarbor"] = 7] = "ShagHarbor";
    Consensus[Consensus["Exeter"] = 8] = "Exeter";
    Consensus[Consensus["Stephenville"] = 9] = "Stephenville";
    Consensus[Consensus["Valensole"] = 10] = "Valensole";
    Consensus[Consensus["Socorro"] = 11] = "Socorro";
    Consensus[Consensus["Pascagoula"] = 12] = "Pascagoula";
    Consensus[Consensus["Tehran"] = 13] = "Tehran";
    Consensus[Consensus["Westall"] = 14] = "Westall";
    Consensus[Consensus["Hopkinsville"] = 15] = "Hopkinsville";
    Consensus[Consensus["Belgium"] = 16] = "Belgium";
    Consensus[Consensus["Breeze"] = 17] = "Breeze";
    Consensus[Consensus["Flatwoods"] = 18] = "Flatwoods";
    Consensus[Consensus["Maury"] = 20] = "Maury";
    Consensus[Consensus["Varginha"] = 21] = "Varginha";
    Consensus[Consensus["Trindade"] = 22] = "Trindade";
    Consensus[Consensus["Levelland"] = 23] = "Levelland";
    Consensus[Consensus["Wanaque"] = 24] = "Wanaque";
    Consensus[Consensus["Coyame"] = 25] = "Coyame";
    Consensus[Consensus["Delphos"] = 26] = "Delphos";
})(Consensus || (Consensus = {}));

const RoswellConsensus = {
    CONSENSUS: Consensus.Roswell};

({
    [Consensus.Roswell]: RoswellConsensus,
});
const currentConsensus = Consensus.Roswell;

function witnessStackToScriptWitness(witness) {
    let buffer = Buffer$1.allocUnsafe(0);
    function writeSlice(slice) {
        buffer = Buffer$1.concat([buffer, Buffer$1.from(slice)]);
    }
    function writeVarInt(i) {
        const currentLen = buffer.length;
        const varintLen = encodingLength(i);
        buffer = Buffer$1.concat([buffer, Buffer$1.allocUnsafe(varintLen)]);
        encode(i, buffer, currentLen);
    }
    function writeVarSlice(slice) {
        writeVarInt(slice.length);
        writeSlice(slice);
    }
    function writeVector(vector) {
        writeVarInt(vector.length);
        vector.forEach(writeVarSlice);
    }
    writeVector(witness);
    return buffer;
}

function isTaprootInput(input) {
    return (input &&
        !!(input.tapInternalKey ||
            input.tapMerkleRoot ||
            (input.tapLeafScript && input.tapLeafScript.length) ||
            (input.tapBip32Derivation && input.tapBip32Derivation.length) ||
            (input.witnessUtxo && isP2TR(input.witnessUtxo.script))));
}
function getInputRelevantScript(input) {
    if (input.redeemScript) {
        return input.redeemScript;
    }
    if (input.witnessScript) {
        return input.witnessScript;
    }
    if (input.witnessUtxo) {
        return input.witnessUtxo.script;
    }
    if (input.nonWitnessUtxo) ;
    return null;
}
function canSignNonTaprootInput(input, publicKey) {
    if ((input.nonWitnessUtxo &&
        !input.redeemScript &&
        !input.witnessScript &&
        !input.witnessUtxo) ||
        input.redeemScript) {
        return true;
    }
    const script = getInputRelevantScript(input);
    if (script) {
        return pubkeyInScript(publicKey, script);
    }
    return false;
}
function pubkeyInScript(pubkey, script) {
    return pubkeyPositionInScript(pubkey, script) !== -1;
}

var TransactionSequence;
(function (TransactionSequence) {
    TransactionSequence[TransactionSequence["REPLACE_BY_FEE"] = 4294967293] = "REPLACE_BY_FEE";
    TransactionSequence[TransactionSequence["FINAL"] = 4294967295] = "FINAL";
})(TransactionSequence || (TransactionSequence = {}));
var CSVModes;
(function (CSVModes) {
    CSVModes[CSVModes["BLOCKS"] = 0] = "BLOCKS";
    CSVModes[CSVModes["TIMESTAMPS"] = 1] = "TIMESTAMPS";
})(CSVModes || (CSVModes = {}));
class TweakedTransaction extends Logger {
    constructor(data) {
        super();
        this.logColor = '#00ffe1';
        this.finalized = false;
        this.signed = false;
        this.scriptData = null;
        this.tapData = null;
        this.inputs = [];
        this.sequence = TransactionSequence.REPLACE_BY_FEE;
        this.tapLeafScript = null;
        this.isBrowser = false;
        this.csvInputIndices = new Set();
        this.anchorInputIndices = new Set();
        this.regenerated = false;
        this.ignoreSignatureErrors = false;
        this.noSignatures = false;
        this.txVersion = 2;
        this._mldsaSigner = null;
        this._hashedPublicKey = null;
        this.addressRotationEnabled = false;
        this.signerMap = new Map();
        this.inputSignerMap = new Map();
        this.tweakedSignerCache = new Map();
        this.customFinalizerP2SH = (inputIndex, input, scriptA, isSegwit, isP2SH, isP2WSH) => {
            const inputDecoded = this.inputs[inputIndex];
            if (isP2SH && input.partialSig && inputDecoded && inputDecoded.redeemScript) {
                const signatures = input.partialSig.map((sig) => sig.signature) || [];
                const scriptSig = compile([...signatures, inputDecoded.redeemScript]);
                return {
                    finalScriptSig: scriptSig,
                    finalScriptWitness: undefined,
                };
            }
            if (this.anchorInputIndices.has(inputIndex)) {
                return {
                    finalScriptSig: undefined,
                    finalScriptWitness: Buffer$1$1.from([0]),
                };
            }
            if (isP2WSH && isSegwit && input.witnessScript) {
                if (!input.partialSig || input.partialSig.length === 0) {
                    throw new Error(`No signatures for P2WSH input #${inputIndex}`);
                }
                const isP2WDA = P2WDADetector.isP2WDAWitnessScript(input.witnessScript);
                if (isP2WDA) {
                    return this.finalizeSecondaryP2WDA(inputIndex, input);
                }
                const isCSVInput = this.csvInputIndices.has(inputIndex);
                if (isCSVInput) {
                    const witnessStack = [input.partialSig[0].signature, input.witnessScript];
                    return {
                        finalScriptSig: undefined,
                        finalScriptWitness: witnessStackToScriptWitness(witnessStack),
                    };
                }
            }
            return getFinalScripts(inputIndex, input, scriptA, isSegwit, isP2SH, isP2WSH, true, this.unlockScript);
        };
        this.signer = data.signer;
        this.network = data.network;
        this.noSignatures = data.noSignatures || false;
        this.nonWitnessUtxo = data.nonWitnessUtxo;
        this.unlockScript = data.unlockScript;
        this.isBrowser = typeof window !== 'undefined';
        if (data.txVersion) {
            this.txVersion = data.txVersion;
        }
        if (data.mldsaSigner) {
            this._mldsaSigner = data.mldsaSigner;
            this._hashedPublicKey = MessageSigner.sha256(this._mldsaSigner.publicKey);
        }
        if (data.addressRotation?.enabled) {
            this.addressRotationEnabled = true;
            this.signerMap = data.addressRotation.signerMap;
        }
    }
    get mldsaSigner() {
        if (!this._mldsaSigner) {
            throw new Error('MLDSA Signer is not set');
        }
        return this._mldsaSigner;
    }
    get hashedPublicKey() {
        if (!this._hashedPublicKey) {
            throw new Error('Hashed public key is not set');
        }
        return this._hashedPublicKey;
    }
    static readScriptWitnessToWitnessStack(buffer) {
        let offset = 0;
        function readSlice(n) {
            const slice = Buffer$1$1.from(buffer.subarray(offset, offset + n));
            offset += n;
            return slice;
        }
        function readVarInt() {
            const varint = decode(buffer, offset);
            offset += varint.bytes;
            return varint.numberValue || 0;
        }
        function readVarSlice() {
            const len = readVarInt();
            return readSlice(len);
        }
        function readVector() {
            const count = readVarInt();
            const vector = [];
            for (let i = 0; i < count; i++) {
                vector.push(readVarSlice());
            }
            return vector;
        }
        return readVector();
    }
    static preEstimateTaprootTransactionFees(feeRate, numInputs, numOutputs, numWitnessElements, witnessElementSize, emptyWitness, taprootControlWitnessSize = 32n, taprootScriptSize = 139n) {
        const txHeaderSize = 10n;
        const inputBaseSize = 41n;
        const outputSize = 68n;
        const taprootWitnessBaseSize = 1n;
        const baseTxSize = txHeaderSize + inputBaseSize * numInputs + outputSize * numOutputs;
        const witnessSize = numInputs * taprootWitnessBaseSize +
            numWitnessElements * witnessElementSize +
            taprootControlWitnessSize * numInputs +
            taprootScriptSize * numInputs +
            emptyWitness;
        const weight = baseTxSize * 3n + (baseTxSize + witnessSize);
        const vSize = weight / 4n;
        return vSize * feeRate;
    }
    static signInput(transaction, input, i, signer, sighashTypes) {
        if (sighashTypes && sighashTypes[0])
            input.sighashType = sighashTypes[0];
        transaction.signInput(i, signer, sighashTypes.length ? sighashTypes : undefined);
    }
    static calculateSignHash(sighashTypes) {
        if (!sighashTypes) {
            throw new Error('Sighash types are required');
        }
        let signHash = 0;
        for (const sighashType of sighashTypes) {
            signHash |= sighashType;
        }
        return signHash || 0;
    }
    isAddressRotationEnabled() {
        return this.addressRotationEnabled;
    }
    ignoreSignatureError() {
        this.ignoreSignatureErrors = true;
    }
    getScriptAddress() {
        if (!this.scriptData || !this.scriptData.address) {
            throw new Error('Tap data is required');
        }
        return this.scriptData.address;
    }
    getTransaction() {
        return this.transaction.extractTransaction(false);
    }
    getTapAddress() {
        if (!this.tapData || !this.tapData.address) {
            throw new Error('Tap data is required');
        }
        return this.tapData.address;
    }
    disableRBF() {
        if (this.signed)
            throw new Error('Transaction is already signed');
        this.sequence = TransactionSequence.FINAL;
        for (const input of this.inputs) {
            if (this.csvInputIndices.has(this.inputs.indexOf(input))) {
                continue;
            }
            input.sequence = TransactionSequence.FINAL;
        }
    }
    getTweakerHash() {
        return this.tapData?.hash;
    }
    preEstimateTransactionFees(feeRate, numInputs, numOutputs, numSignatures, numPubkeys) {
        const txHeaderSize = 10n;
        const inputBaseSize = 41n;
        const outputSize = 68n;
        const signatureSize = 144n;
        const pubkeySize = 34n;
        const baseTxSize = txHeaderSize + inputBaseSize * numInputs + outputSize * numOutputs;
        const redeemScriptSize = 1n + numPubkeys * (1n + pubkeySize) + 1n + numSignatures;
        const witnessSize = numSignatures * signatureSize + numPubkeys * pubkeySize + redeemScriptSize;
        const weight = baseTxSize * 3n + (baseTxSize + witnessSize);
        const vSize = weight / 4n;
        return vSize * feeRate;
    }
    getSignerForInput(inputIndex) {
        if (this.addressRotationEnabled) {
            const inputSigner = this.inputSignerMap.get(inputIndex);
            if (inputSigner) {
                return inputSigner;
            }
        }
        return this.signer;
    }
    registerInputSigner(inputIndex, utxo) {
        if (!this.addressRotationEnabled) {
            return;
        }
        if (utxo.signer) {
            this.inputSignerMap.set(inputIndex, utxo.signer);
            return;
        }
        const address = utxo.scriptPubKey?.address;
        if (address && this.signerMap.has(address)) {
            const signer = this.signerMap.get(address);
            if (signer) {
                this.inputSignerMap.set(inputIndex, signer);
                return;
            }
        }
    }
    internalPubKeyToXOnlyForInput(inputIndex) {
        const signer = this.getSignerForInput(inputIndex);
        return toXOnly(Buffer$1$1.from(signer.publicKey));
    }
    getTweakedSignerForInput(inputIndex, useTweakedHash = false) {
        if (!this.addressRotationEnabled) {
            if (useTweakedHash) {
                this.tweakSigner();
                return this.tweakedSigner;
            }
            return this.getTweakedSigner(useTweakedHash);
        }
        const cacheKey = inputIndex * 2 + (useTweakedHash ? 1 : 0);
        if (this.tweakedSignerCache.has(cacheKey)) {
            return this.tweakedSignerCache.get(cacheKey);
        }
        const signer = this.getSignerForInput(inputIndex);
        const tweaked = this.getTweakedSigner(useTweakedHash, signer);
        this.tweakedSignerCache.set(cacheKey, tweaked);
        return tweaked;
    }
    generateTapData() {
        return {
            internalPubkey: this.internalPubKeyToXOnly(),
            network: this.network,
            name: PaymentType.P2TR,
        };
    }
    generateScriptAddress() {
        return {
            internalPubkey: this.internalPubKeyToXOnly(),
            network: this.network,
            name: PaymentType.P2TR,
        };
    }
    getSignerKey() {
        return this.signer;
    }
    async signInput(transaction, input, i, signer, reverse = false, errored = false) {
        if (this.anchorInputIndices.has(i))
            return;
        const publicKey = signer.publicKey;
        let isTaproot = isTaprootInput(input);
        if (reverse) {
            isTaproot = !isTaproot;
        }
        let signed = false;
        let didError = false;
        if (isTaproot) {
            try {
                await this.attemptSignTaproot(transaction, input, i, signer, publicKey);
                signed = true;
            }
            catch (e) {
                this.error(`Failed to sign Taproot script path input ${i} (reverse: ${reverse}): ${e.message}`);
                didError = true;
            }
        }
        else {
            if (!reverse ? canSignNonTaprootInput(input, publicKey) : true) {
                try {
                    await this.signNonTaprootInput(signer, transaction, i);
                    signed = true;
                }
                catch (e) {
                    this.error(`Failed to sign non-Taproot input ${i}: ${e.stack}`);
                    didError = true;
                }
            }
        }
        if (!signed) {
            if (didError && errored) {
                throw new Error(`Failed to sign input ${i} with the provided signer.`);
            }
            try {
                await this.signInput(transaction, input, i, signer, true, didError);
            }
            catch {
                throw new Error(`Cannot sign input ${i} with the provided signer.`);
            }
        }
    }
    splitArray(arr, chunkSize) {
        if (chunkSize <= 0) {
            throw new Error('Chunk size must be greater than 0.');
        }
        const result = [];
        for (let i = 0; i < arr.length; i += chunkSize) {
            result.push(arr.slice(i, i + chunkSize));
        }
        return result;
    }
    async signInputs(transaction) {
        if ('multiSignPsbt' in this.signer) {
            await this.signInputsWalletBased(transaction);
            return;
        }
        await this.signInputsNonWalletBased(transaction);
    }
    async signInputsNonWalletBased(transaction) {
        const txs = transaction.data.inputs;
        const batchSize = 20;
        const batches = this.splitArray(txs, batchSize);
        if (!this.noSignatures) {
            for (let i = 0; i < batches.length; i++) {
                const batch = batches[i];
                const promises = [];
                const offset = i * batchSize;
                for (let j = 0; j < batch.length; j++) {
                    const index = offset + j;
                    const input = batch[j];
                    try {
                        const inputSigner = this.getSignerForInput(index);
                        promises.push(this.signInput(transaction, input, index, inputSigner));
                    }
                    catch (e) {
                        this.log(`Failed to sign input ${index}: ${e.stack}`);
                    }
                }
                await Promise.all(promises);
            }
        }
        for (let i = 0; i < transaction.data.inputs.length; i++) {
            transaction.finalizeInput(i, this.customFinalizerP2SH.bind(this));
        }
        this.finalized = true;
    }
    internalPubKeyToXOnly() {
        return toXOnly(Buffer$1$1.from(this.signer.publicKey));
    }
    internalInit() {
        this.scriptData = p2tr(this.generateScriptAddress());
        this.tapData = p2tr(this.generateTapData());
    }
    tweakSigner() {
        if (this.tweakedSigner)
            return;
        this.tweakedSigner = this.getTweakedSigner(true);
    }
    getTweakedSigner(useTweakedHash = false, signer = this.signer) {
        const settings = {
            network: this.network,
        };
        if (useTweakedHash) {
            settings.tweakHash = this.getTweakerHash();
        }
        if (!('privateKey' in signer)) {
            return;
        }
        return TweakedSigner.tweakSigner(signer, settings);
    }
    generateP2SHRedeemScript(customWitnessScript) {
        const p2wsh$1 = p2wsh({
            redeem: { output: customWitnessScript },
            network: this.network,
        });
        const p2sh$1 = p2sh({
            redeem: p2wsh$1,
            network: this.network,
        });
        return p2sh$1.output;
    }
    generateP2SHRedeemScriptLegacy(inputAddr) {
        const pubKeyHash = hash160(this.signer.publicKey);
        const redeemScript = compile([
            opcodes.OP_DUP,
            opcodes.OP_HASH160,
            pubKeyHash,
            opcodes.OP_EQUALVERIFY,
            opcodes.OP_CHECKSIG,
        ]);
        const redeemScriptHash = hash160(redeemScript);
        const outputScript = compile([
            opcodes.OP_HASH160,
            redeemScriptHash,
            opcodes.OP_EQUAL,
        ]);
        const p2wsh$1 = p2wsh({
            redeem: { output: redeemScript },
            network: this.network,
        });
        const p2sh$1 = p2sh({
            redeem: p2wsh$1,
            network: this.network,
        });
        const address = fromOutputScript(outputScript, this.network);
        if (address === inputAddr && p2sh$1.redeem && p2sh$1.redeem.output) {
            return {
                redeemScript,
                outputScript: p2sh$1.redeem.output,
            };
        }
        return;
    }
    generateP2SHP2PKHRedeemScript(inputAddr, inputIndex) {
        const signer = this.addressRotationEnabled && inputIndex !== undefined
            ? this.getSignerForInput(inputIndex)
            : this.signer;
        const pubkey = Buffer$1$1.isBuffer(signer.publicKey)
            ? signer.publicKey
            : Buffer$1$1.from(signer.publicKey, 'hex');
        const w = p2wpkh({
            pubkey: pubkey,
            network: this.network,
        });
        const p = p2sh({
            redeem: w,
            network: this.network,
        });
        const address = p.address;
        const redeemScript = p.redeem?.output;
        if (!redeemScript) {
            throw new Error('Failed to generate P2SH-P2WPKH redeem script');
        }
        if (address === inputAddr && p.redeem && p.redeem.output && p.output) {
            return {
                redeemScript: p.redeem.output,
                outputScript: p.output,
            };
        }
        return;
    }
    generatePsbtInputExtended(utxo, i, _extra = false) {
        const scriptPub = Buffer$1$1.from(utxo.scriptPubKey.hex, 'hex');
        const input = {
            hash: utxo.transactionId,
            index: utxo.outputIndex,
            sequence: this.sequence,
            witnessUtxo: {
                value: Number(utxo.value),
                script: scriptPub,
            },
        };
        if (isP2PKH(scriptPub)) {
            if (utxo.nonWitnessUtxo) {
                input.nonWitnessUtxo = Buffer$1$1.isBuffer(utxo.nonWitnessUtxo)
                    ? utxo.nonWitnessUtxo
                    : Buffer$1$1.from(utxo.nonWitnessUtxo, 'hex');
            }
            else {
                throw new Error('Missing nonWitnessUtxo for P2PKH UTXO');
            }
        }
        else if (isP2WPKH(scriptPub) || isUnknownSegwitVersion(scriptPub)) ;
        else if (isP2WSHScript(scriptPub)) {
            this.processP2WSHInput(utxo, input, i);
        }
        else if (isP2SHScript(scriptPub)) {
            let redeemScriptBuf;
            if (utxo.redeemScript) {
                redeemScriptBuf = Buffer$1$1.isBuffer(utxo.redeemScript)
                    ? utxo.redeemScript
                    : Buffer$1$1.from(utxo.redeemScript, 'hex');
            }
            else {
                if (!utxo.scriptPubKey.address) {
                    throw new Error('Missing redeemScript and no address to regenerate it for P2SH UTXO');
                }
                const legacyScripts = this.generateP2SHP2PKHRedeemScript(utxo.scriptPubKey.address, i);
                if (!legacyScripts) {
                    throw new Error('Missing redeemScript for P2SH UTXO and unable to regenerate');
                }
                redeemScriptBuf = legacyScripts.redeemScript;
            }
            input.redeemScript = redeemScriptBuf;
            const payment = p2sh({ redeem: { output: input.redeemScript } });
            if (!payment.redeem) {
                throw new Error('Failed to extract redeem script from P2SH UTXO');
            }
            const redeemOutput = payment.redeem.output;
            if (!redeemOutput) {
                throw new Error('Failed to extract redeem output from P2SH UTXO');
            }
            if (utxo.nonWitnessUtxo) {
                input.nonWitnessUtxo = Buffer$1$1.isBuffer(utxo.nonWitnessUtxo)
                    ? utxo.nonWitnessUtxo
                    : Buffer$1$1.from(utxo.nonWitnessUtxo, 'hex');
            }
            if (isP2WPKH(redeemOutput)) {
                delete input.nonWitnessUtxo;
            }
            else if (isP2WSHScript(redeemOutput)) {
                delete input.nonWitnessUtxo;
                this.processP2WSHInput(utxo, input, i);
            }
            else {
                delete input.witnessUtxo;
            }
        }
        else if (isP2TR(scriptPub)) {
            if (this.sighashTypes) {
                const inputSign = TweakedTransaction.calculateSignHash(this.sighashTypes);
                if (inputSign)
                    input.sighashType = inputSign;
            }
            if (this.addressRotationEnabled) {
                input.tapInternalKey = this.internalPubKeyToXOnlyForInput(i);
            }
            else {
                this.tweakSigner();
                input.tapInternalKey = this.internalPubKeyToXOnly();
            }
        }
        else if (isP2A(scriptPub)) {
            this.anchorInputIndices.add(i);
            input.isPayToAnchor = true;
        }
        else if (isP2PK(scriptPub) || isP2MS(scriptPub)) {
            if (utxo.nonWitnessUtxo) {
                input.nonWitnessUtxo = Buffer$1$1.isBuffer(utxo.nonWitnessUtxo)
                    ? utxo.nonWitnessUtxo
                    : Buffer$1$1.from(utxo.nonWitnessUtxo, 'hex');
            }
            else {
                throw new Error('Missing nonWitnessUtxo for P2PK or P2MS UTXO');
            }
        }
        else {
            this.error(`Unknown or unsupported script type for output: ${utxo.scriptPubKey.hex}`);
        }
        if (i === 0) {
            if (this.tapLeafScript) {
                input.tapLeafScript = [this.tapLeafScript];
            }
            if (this.nonWitnessUtxo) {
                input.nonWitnessUtxo = this.nonWitnessUtxo;
            }
        }
        return input;
    }
    processP2WSHInput(utxo, input, i) {
        if (!utxo.witnessScript) {
            throw new Error('Missing witnessScript for P2WSH UTXO');
        }
        input.witnessScript = Buffer$1$1.isBuffer(utxo.witnessScript)
            ? utxo.witnessScript
            : Buffer$1$1.from(utxo.witnessScript, 'hex');
        const decompiled = decompile(input.witnessScript);
        if (decompiled && this.isCSVScript(decompiled)) {
            const decompiled = decompile(input.witnessScript);
            if (decompiled && this.isCSVScript(decompiled)) {
                this.csvInputIndices.add(i);
                const csvBlocks = this.extractCSVBlocks(decompiled);
                input.sequence = this.setCSVSequence(csvBlocks, this.sequence);
            }
        }
    }
    secondsToCSVTimeUnits(seconds) {
        return Math.floor(seconds / 512);
    }
    createTimeBasedCSV(seconds) {
        const timeUnits = this.secondsToCSVTimeUnits(seconds);
        if (timeUnits > 0xffff) {
            throw new Error(`Time units ${timeUnits} exceeds maximum of 65,535`);
        }
        return timeUnits | (1 << 22);
    }
    isCSVEnabled(sequence) {
        return (sequence & (1 << 31)) === 0;
    }
    extractCSVValue(sequence) {
        return sequence & 0x0000ffff;
    }
    finalizeSecondaryP2WDA(inputIndex, input) {
        if (!input.partialSig || input.partialSig.length === 0) {
            throw new Error(`No signature for P2WDA input #${inputIndex}`);
        }
        if (!input.witnessScript) {
            throw new Error(`No witness script for P2WDA input #${inputIndex}`);
        }
        const witnessStack = P2WDADetector.createSimpleP2WDAWitness(input.partialSig[0].signature, input.witnessScript);
        return {
            finalScriptSig: undefined,
            finalScriptWitness: witnessStackToScriptWitness(witnessStack),
        };
    }
    async signInputsWalletBased(transaction) {
        const signer = this.signer;
        await signer.multiSignPsbt([transaction]);
        for (let i = 0; i < transaction.data.inputs.length; i++) {
            transaction.finalizeInput(i, this.customFinalizerP2SH.bind(this));
        }
        this.finalized = true;
    }
    isCSVScript(decompiled) {
        return decompiled.some((op) => op === opcodes.OP_CHECKSEQUENCEVERIFY);
    }
    setCSVSequence(csvBlocks, currentSequence) {
        if (this.txVersion < 2) {
            throw new Error('CSV requires transaction version 2 or higher');
        }
        if (csvBlocks > 0xffff) {
            throw new Error(`CSV blocks ${csvBlocks} exceeds maximum of 65,535`);
        }
        const isTimeBased = (csvBlocks & (1 << 22)) !== 0;
        let sequence = csvBlocks & 0x0000ffff;
        if (isTimeBased) {
            sequence |= 1 << 22;
        }
        if (currentSequence === TransactionSequence.REPLACE_BY_FEE) {
            sequence |= 1 << 25;
        }
        sequence = sequence & 0x7fffffff;
        return sequence;
    }
    getCSVType(csvValue) {
        return csvValue & (1 << 22) ? CSVModes.TIMESTAMPS : CSVModes.BLOCKS;
    }
    extractCSVBlocks(decompiled) {
        for (let i = 0; i < decompiled.length; i++) {
            if (decompiled[i] === opcodes.OP_CHECKSEQUENCEVERIFY && i > 0) {
                const csvValue = decompiled[i - 1];
                if (Buffer$1$1.isBuffer(csvValue)) {
                    return number.decode(csvValue);
                }
                else if (typeof csvValue === 'number') {
                    if (csvValue === opcodes.OP_0 || csvValue === opcodes.OP_FALSE) {
                        return 0;
                    }
                    else if (csvValue === opcodes.OP_1NEGATE) {
                        return -1;
                    }
                    else if (csvValue >= opcodes.OP_1 && csvValue <= opcodes.OP_16) {
                        return csvValue - opcodes.OP_1 + 1;
                    }
                    else {
                        throw new Error(`Unexpected raw number in script: ${csvValue}`);
                    }
                }
            }
        }
        return 0;
    }
    async attemptSignTaproot(transaction, input, i, signer, publicKey) {
        const isScriptSpend = this.isTaprootScriptSpend(input, publicKey);
        if (isScriptSpend) {
            await this.signTaprootInput(signer, transaction, i);
        }
        else {
            let tweakedSigner;
            if (signer !== this.signer) {
                tweakedSigner = this.getTweakedSigner(true, signer);
            }
            else {
                if (!this.tweakedSigner)
                    this.tweakSigner();
                tweakedSigner = this.tweakedSigner;
            }
            if (tweakedSigner) {
                try {
                    await this.signTaprootInput(tweakedSigner, transaction, i);
                }
                catch (e) {
                    tweakedSigner = this.getTweakedSigner(false, this.signer);
                    if (!tweakedSigner) {
                        throw new Error(`Failed to obtain tweaked signer for input ${i}.`);
                    }
                    await this.signTaprootInput(tweakedSigner, transaction, i);
                }
            }
            else {
                this.error(`Failed to obtain tweaked signer for input ${i}.`);
            }
        }
    }
    isTaprootScriptSpend(input, publicKey) {
        if (input.tapLeafScript && input.tapLeafScript.length > 0) {
            for (const tapLeafScript of input.tapLeafScript) {
                if (pubkeyInScript(publicKey, tapLeafScript.script)) {
                    return true;
                }
            }
        }
        return false;
    }
    async signTaprootInput(signer, transaction, i, tapLeafHash) {
        if ('signTaprootInput' in signer) {
            try {
                await signer.signTaprootInput(transaction, i, tapLeafHash);
            }
            catch {
                throw new Error('Failed to sign Taproot input with provided signer.');
            }
        }
        else {
            transaction.signTaprootInput(i, signer);
        }
    }
    async signNonTaprootInput(signer, transaction, i) {
        if ('signInput' in signer) {
            await signer.signInput(transaction, i);
        }
        else {
            transaction.signInput(i, signer);
        }
    }
}

function objectEqual(obj1, obj2) {
    return JSON.stringify(obj1) === JSON.stringify(obj2);
}
function getChainIdHex(network) {
    if (objectEqual(network, bitcoin$1)) {
        return '000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f';
    }
    if (objectEqual(network, testnet)) {
        return '000000000933ea01ad0ee984209779baaec3ced90fa3f408719526f8d77f4943';
    }
    if (objectEqual(network, regtest)) {
        return '0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206';
    }
    throw new Error('Unsupported network for chain ID retrieval');
}
function getChainId(network) {
    return Uint8Array.from(Buffer$1.from(getChainIdHex(network), 'hex'));
}
const BITCOIN_PROTOCOL_ID = Uint8Array.from(Buffer$1.from('e784995a412d773988c4b8e333d7b39dfb3cabf118d0d645411a916ca2407939', 'hex'));

initEccLib(ecc);
const MINIMUM_AMOUNT_REWARD = 330n;
const MINIMUM_AMOUNT_CA = 297n;
const ANCHOR_SCRIPT = Buffer$1.from('51024e73', 'hex');
class TransactionBuilder extends TweakedTransaction {
    constructor(parameters) {
        super(parameters);
        this.logColor = '#785def';
        this.debugFees = false;
        this.overflowFees = 0n;
        this.transactionFee = 0n;
        this.estimatedFees = 0n;
        this.updateInputs = [];
        this.outputs = [];
        this.feeOutput = null;
        this._maximumFeeRate = 100000000;
        this.optionalOutputsAdded = false;
        if (parameters.estimatedFees) {
            this.estimatedFees = parameters.estimatedFees;
        }
        this.signer = parameters.signer;
        this.network = parameters.network;
        this.feeRate = parameters.feeRate;
        this.priorityFee = parameters.priorityFee ?? 0n;
        this.gasSatFee = parameters.gasSatFee ?? 0n;
        this.utxos = parameters.utxos;
        this.optionalInputs = parameters.optionalInputs || [];
        this.to = parameters.to || undefined;
        this.debugFees = parameters.debugFees || false;
        this.LOCK_LEAF_SCRIPT = this.defineLockScript();
        if (parameters.note) {
            if (typeof parameters.note === 'string') {
                this.note = Buffer$1.from(parameters.note, 'utf8');
            }
            else {
                this.note = parameters.note;
            }
        }
        this.anchor = parameters.anchor ?? false;
        this.isPubKeyDestination = this.to
            ? AddressVerificator.isValidPublicKey(this.to, this.network)
            : false;
        this.optionalOutputs = parameters.optionalOutputs;
        this.from = TransactionBuilder.getFrom(parameters.from, this.signer, this.network);
        this.totalInputAmount = this.calculateTotalUTXOAmount();
        const totalVOut = this.calculateTotalVOutAmount();
        if (totalVOut < this.totalInputAmount) {
            throw new Error(`Vout value is less than the value to send`);
        }
        this.transaction = new Psbt({
            network: this.network,
            version: this.txVersion,
        });
    }
    static getFrom(from, keypair, network) {
        return from || EcKeyPair.getTaprootAddress(keypair, network);
    }
    static witnessStackToScriptWitness(witness) {
        return witnessStackToScriptWitness(witness);
    }
    addOPReturn(buffer) {
        const compileScript = compile([opcodes.OP_RETURN, buffer]);
        this.addOutput({
            value: 0,
            script: compileScript,
        });
    }
    addAnchor() {
        this.addOutput({
            value: 0,
            script: ANCHOR_SCRIPT,
        });
    }
    async getFundingTransactionParameters() {
        if (!this.estimatedFees) {
            this.estimatedFees = await this.estimateTransactionFees();
        }
        return {
            utxos: this.utxos,
            to: this.getScriptAddress(),
            signer: this.signer,
            network: this.network,
            feeRate: this.feeRate,
            priorityFee: this.priorityFee ?? 0n,
            gasSatFee: this.gasSatFee ?? 0n,
            from: this.from,
            amount: this.estimatedFees,
            optionalOutputs: this.optionalOutputs,
            optionalInputs: this.optionalInputs,
            mldsaSigner: null,
        };
    }
    setDestinationAddress(address) {
        this.to = address;
    }
    setMaximumFeeRate(feeRate) {
        this._maximumFeeRate = feeRate;
    }
    async signTransaction() {
        if (!this.utxos.length) {
            throw new Error('No UTXOs specified');
        }
        if (this.to &&
            !this.isPubKeyDestination &&
            !EcKeyPair.verifyContractAddress(this.to, this.network)) {
            throw new Error('Invalid contract address. The contract address must be a taproot address.');
        }
        if (this.signed)
            throw new Error('Transaction is already signed');
        this.signed = true;
        await this.buildTransaction();
        const builtTx = await this.internalBuildTransaction(this.transaction);
        if (builtTx) {
            if (this.regenerated) {
                throw new Error('Transaction was regenerated');
            }
            return this.transaction.extractTransaction(true, true);
        }
        throw new Error('Could not sign transaction');
    }
    async generateTransactionMinimalSignatures(checkPartialSigs = false) {
        if (this.to &&
            !this.isPubKeyDestination &&
            !EcKeyPair.verifyContractAddress(this.to, this.network)) {
            throw new Error('Invalid contract address. The contract address must be a taproot address.');
        }
        await this.buildTransaction();
        if (this.transaction.data.inputs.length === 0) {
            const inputs = this.getInputs();
            const outputs = this.getOutputs();
            this.transaction.setMaximumFeeRate(this._maximumFeeRate);
            this.transaction.addInputs(inputs, checkPartialSigs);
            for (let i = 0; i < this.updateInputs.length; i++) {
                this.transaction.updateInput(i, this.updateInputs[i]);
            }
            this.transaction.addOutputs(outputs);
        }
    }
    async signPSBT() {
        if (await this.signTransaction()) {
            return this.transaction;
        }
        throw new Error('Could not sign transaction');
    }
    addInput(input) {
        this.inputs.push(input);
    }
    addOutput(output, bypassMinCheck = false) {
        if (output.value === 0) {
            const script = output;
            if (!script.script || script.script.length === 0) {
                throw new Error('Output value is 0 and no script provided');
            }
            if (script.script.length < 2) {
                throw new Error('Output script is too short');
            }
            if (script.script[0] !== opcodes.OP_RETURN && !script.script.equals(ANCHOR_SCRIPT)) {
                throw new Error('Output script must start with OP_RETURN or be an ANCHOR when value is 0');
            }
        }
        else if (!bypassMinCheck && output.value < TransactionBuilder.MINIMUM_DUST) {
            throw new Error(`Output value is less than the minimum dust ${output.value} < ${TransactionBuilder.MINIMUM_DUST}`);
        }
        this.outputs.push(output);
    }
    getTotalOutputValue() {
        return this.outputs.reduce((total, output) => total + BigInt(output.value), 0n);
    }
    toAddress() {
        return this.to;
    }
    address() {
        return this.tapData?.address;
    }
    async estimateTransactionFees() {
        await Promise.resolve();
        const fakeTx = new Psbt({ network: this.network });
        const inputs = this.getInputs();
        const outputs = this.getOutputs();
        fakeTx.addInputs(inputs);
        fakeTx.addOutputs(outputs);
        const dummySchnorrSig = Buffer$1.alloc(64, 0);
        const dummyEcdsaSig = Buffer$1.alloc(72, 0);
        const dummyCompressedPubkey = Buffer$1.alloc(33, 2);
        const finalizer = (inputIndex, input) => {
            if (input.isPayToAnchor || this.anchorInputIndices.has(inputIndex)) {
                return {
                    finalScriptSig: undefined,
                    finalScriptWitness: Buffer$1.from([0]),
                };
            }
            if (input.witnessScript && P2WDADetector.isP2WDAWitnessScript(input.witnessScript)) {
                const dummyDataSlots = [];
                for (let i = 0; i < 10; i++) {
                    dummyDataSlots.push(Buffer$1.alloc(0));
                }
                const dummyEcdsaSig = Buffer$1.alloc(72, 0);
                return {
                    finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness([
                        ...dummyDataSlots,
                        dummyEcdsaSig,
                        input.witnessScript,
                    ]),
                };
            }
            if (inputIndex === 0 && this.tapLeafScript) {
                const dummySecret = Buffer$1.alloc(32, 0);
                const dummyScript = this.tapLeafScript.script;
                const dummyControlBlock = Buffer$1.alloc(1 + 32 + 32, 0);
                return {
                    finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness([
                        dummySecret,
                        dummySchnorrSig,
                        dummySchnorrSig,
                        dummyScript,
                        dummyControlBlock,
                    ]),
                };
            }
            if (input.witnessUtxo) {
                const script = input.witnessUtxo.script;
                const decompiled = bitcoin.script.decompile(script);
                if (decompiled &&
                    decompiled.length === 5 &&
                    decompiled[0] === opcodes.OP_DUP &&
                    decompiled[1] === opcodes.OP_HASH160 &&
                    decompiled[3] === opcodes.OP_EQUALVERIFY &&
                    decompiled[4] === opcodes.OP_CHECKSIG) {
                    return {
                        finalScriptSig: bitcoin.script.compile([
                            dummyEcdsaSig,
                            dummyCompressedPubkey,
                        ]),
                        finalScriptWitness: undefined,
                    };
                }
            }
            if (input.witnessScript) {
                if (this.csvInputIndices.has(inputIndex)) {
                    return {
                        finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness([
                            dummyEcdsaSig,
                            input.witnessScript,
                        ]),
                    };
                }
                if (input.redeemScript) {
                    const dummyWitness = [dummyEcdsaSig, input.witnessScript];
                    return {
                        finalScriptSig: input.redeemScript,
                        finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness(dummyWitness),
                    };
                }
                const decompiled = bitcoin.script.decompile(input.witnessScript);
                if (decompiled && decompiled.length >= 4) {
                    const firstOp = decompiled[0];
                    const lastOp = decompiled[decompiled.length - 1];
                    if (typeof firstOp === 'number' &&
                        firstOp >= opcodes.OP_1 &&
                        lastOp === opcodes.OP_CHECKMULTISIG) {
                        const m = firstOp - opcodes.OP_1 + 1;
                        const signatures = [];
                        for (let i = 0; i < m; i++) {
                            signatures.push(dummyEcdsaSig);
                        }
                        return {
                            finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness([
                                Buffer$1.alloc(0),
                                ...signatures,
                                input.witnessScript,
                            ]),
                        };
                    }
                }
                return {
                    finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness([
                        dummyEcdsaSig,
                        input.witnessScript,
                    ]),
                };
            }
            else if (input.redeemScript) {
                const decompiled = bitcoin.script.decompile(input.redeemScript);
                if (decompiled &&
                    decompiled.length === 2 &&
                    decompiled[0] === opcodes.OP_0 &&
                    Buffer$1.isBuffer(decompiled[1]) &&
                    decompiled[1].length === 20) {
                    return {
                        finalScriptSig: input.redeemScript,
                        finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness([
                            dummyEcdsaSig,
                            dummyCompressedPubkey,
                        ]),
                    };
                }
            }
            if (input.redeemScript && !input.witnessScript && !input.witnessUtxo) {
                return {
                    finalScriptSig: bitcoin.script.compile([dummyEcdsaSig, input.redeemScript]),
                    finalScriptWitness: undefined,
                };
            }
            const script = input.witnessUtxo?.script;
            if (!script)
                return { finalScriptSig: undefined, finalScriptWitness: undefined };
            if (input.tapInternalKey) {
                return {
                    finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness([
                        dummySchnorrSig,
                    ]),
                };
            }
            if (script.length === 22 && script[0] === opcodes.OP_0) {
                return {
                    finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness([
                        dummyEcdsaSig,
                        dummyCompressedPubkey,
                    ]),
                };
            }
            if (input.redeemScript?.length === 22 && input.redeemScript[0] === opcodes.OP_0) {
                return {
                    finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness([
                        dummyEcdsaSig,
                        dummyCompressedPubkey,
                    ]),
                };
            }
            return getFinalScripts(inputIndex, input, script, true, !!input.redeemScript, !!input.witnessScript);
        };
        try {
            for (let i = 0; i < fakeTx.data.inputs.length; i++) {
                const fullInput = inputs[i];
                if (fullInput) {
                    fakeTx.finalizeInput(i, (idx) => finalizer(idx, fullInput));
                }
            }
        }
        catch (e) {
            this.warn(`Could not finalize dummy tx: ${e.message}`);
        }
        const tx = fakeTx.extractTransaction(true, true);
        const size = tx.virtualSize();
        const fee = this.feeRate * size;
        const finalFee = BigInt(Math.ceil(fee));
        if (this.debugFees) {
            this.log(`Estimating fees: feeRate=${this.feeRate}, accurate_vSize=${size}, fee=${finalFee}n`);
        }
        return finalFee;
    }
    async rebuildFromBase64(base64) {
        this.transaction = Psbt.fromBase64(base64, {
            network: this.network,
            version: this.txVersion,
        });
        this.signed = false;
        this.sighashTypes = [Transaction.SIGHASH_ANYONECANPAY, Transaction.SIGHASH_ALL];
        return await this.signPSBT();
    }
    setPSBT(psbt) {
        this.transaction = psbt;
    }
    getInputs() {
        return this.inputs;
    }
    getOutputs() {
        const outputs = [...this.outputs];
        if (this.feeOutput)
            outputs.push(this.feeOutput);
        return outputs;
    }
    getOptionalOutputValue() {
        if (!this.optionalOutputs)
            return 0n;
        let total = 0n;
        for (let i = 0; i < this.optionalOutputs.length; i++) {
            total += BigInt(this.optionalOutputs[i].value);
        }
        return total;
    }
    async addRefundOutput(amountSpent, expectRefund = false) {
        if (this.note) {
            this.addOPReturn(this.note);
        }
        if (this.anchor) {
            this.addAnchor();
        }
        let previousFee = -1n;
        let estimatedFee = 0n;
        let iterations = 0;
        const maxIterations = 5;
        let sendBackAmount = 0n;
        while (iterations < maxIterations && estimatedFee !== previousFee) {
            previousFee = estimatedFee;
            estimatedFee = await this.estimateTransactionFees();
            const totalSpent = amountSpent + estimatedFee;
            sendBackAmount = this.totalInputAmount - totalSpent;
            if (this.debugFees) {
                this.log(`Iteration ${iterations + 1}: inputAmount=${this.totalInputAmount}, totalSpent=${totalSpent}, sendBackAmount=${sendBackAmount}`);
            }
            if (sendBackAmount >= TransactionBuilder.MINIMUM_DUST) {
                if (AddressVerificator.isValidP2TRAddress(this.from, this.network)) {
                    this.feeOutput = {
                        value: Number(sendBackAmount),
                        address: this.from,
                        tapInternalKey: this.internalPubKeyToXOnly(),
                    };
                }
                else if (AddressVerificator.isValidPublicKey(this.from, this.network)) {
                    const pubKeyScript = compile([
                        Buffer$1.from(this.from.replace('0x', ''), 'hex'),
                        opcodes.OP_CHECKSIG,
                    ]);
                    this.feeOutput = {
                        value: Number(sendBackAmount),
                        script: pubKeyScript,
                    };
                }
                else {
                    this.feeOutput = {
                        value: Number(sendBackAmount),
                        address: this.from,
                    };
                }
                this.overflowFees = sendBackAmount;
            }
            else {
                this.feeOutput = null;
                this.overflowFees = 0n;
                if (sendBackAmount < 0n && iterations === maxIterations) {
                    throw new Error(`Insufficient funds: need ${totalSpent} sats but only have ${this.totalInputAmount} sats`);
                }
                if (this.debugFees) {
                    this.warn(`Amount to send back (${sendBackAmount} sat) is less than minimum dust...`);
                }
            }
            iterations++;
        }
        if (expectRefund && sendBackAmount < 0n) {
            throw new Error(`Insufficient funds: need at least ${-sendBackAmount} more sats to cover fees.`);
        }
        if (iterations >= maxIterations) {
            this.warn(`Fee calculation did not stabilize after ${maxIterations} iterations`);
        }
        this.transactionFee = estimatedFee;
        if (this.debugFees) {
            this.log(`Final fee: ${estimatedFee} sats, Change output: ${this.feeOutput ? `${this.feeOutput.value} sats` : 'none'}`);
        }
    }
    defineLockScript() {
        return compile([toXOnly(Buffer$1.from(this.signer.publicKey)), opcodes.OP_CHECKSIG]);
    }
    addValueToToOutput(value) {
        if (value < TransactionBuilder.MINIMUM_DUST) {
            throw new Error(`Value to send is less than the minimum dust ${value} < ${TransactionBuilder.MINIMUM_DUST}`);
        }
        for (const output of this.outputs) {
            if ('address' in output && output.address === this.to) {
                output.value += Number(value);
                return;
            }
        }
        throw new Error('Output not found');
    }
    generateLegacySignature() {
        this.tweakSigner();
        if (!this.tweakedSigner) {
            throw new Error('Tweaked signer is not defined');
        }
        const tweakedKey = toXOnly(this.tweakedSigner.publicKey);
        const originalKey = this.signer.publicKey;
        if (originalKey.length !== 33) {
            throw new Error('Original public key must be compressed (33 bytes)');
        }
        const chainId = getChainId(this.network);
        const writer = new BinaryWriter();
        writer.writeU8(cjsExports.MLDSASecurityLevel.LEVEL2);
        writer.writeBytes(this.hashedPublicKey);
        writer.writeBytes(tweakedKey);
        writer.writeBytes(originalKey);
        writer.writeBytes(BITCOIN_PROTOCOL_ID);
        writer.writeBytes(chainId);
        const message = writer.getBuffer();
        const signature = MessageSigner.signMessage(this.tweakedSigner, message);
        const isValid = MessageSigner.verifySignature(tweakedKey, message, signature.signature);
        if (!isValid) {
            throw new Error('Could not verify generated legacy signature for MLDSA link request');
        }
        return Buffer$1.from(signature.signature);
    }
    generateMLDSASignature() {
        if (!this.mldsaSigner) {
            throw new Error('MLDSA signer is not defined');
        }
        this.tweakSigner();
        if (!this.tweakedSigner) {
            throw new Error('Tweaked signer is not defined');
        }
        const tweakedKey = toXOnly(this.tweakedSigner.publicKey);
        const originalKey = this.signer.publicKey;
        if (originalKey.length !== 33) {
            throw new Error('Original public key must be compressed (33 bytes)');
        }
        const chainId = getChainId(this.network);
        const level = getLevelFromPublicKeyLength(this.mldsaSigner.publicKey.length);
        if (level !== cjsExports.MLDSASecurityLevel.LEVEL2) {
            throw new Error('Only MLDSA level 2 is supported for link requests');
        }
        const writer = new BinaryWriter();
        writer.writeU8(level);
        writer.writeBytes(this.hashedPublicKey);
        writer.writeBytes(this.mldsaSigner.publicKey);
        writer.writeBytes(tweakedKey);
        writer.writeBytes(originalKey);
        writer.writeBytes(BITCOIN_PROTOCOL_ID);
        writer.writeBytes(chainId);
        const message = writer.getBuffer();
        const signature = MessageSigner.signMLDSAMessage(this.mldsaSigner, message);
        const isValid = MessageSigner.verifyMLDSASignature(this.mldsaSigner, message, signature.signature);
        if (!isValid) {
            throw new Error('Could not verify generated MLDSA signature for link request');
        }
        return Buffer$1.from(signature.signature);
    }
    generateMLDSALinkRequest(parameters, features) {
        const mldsaSigner = this.mldsaSigner;
        const legacySignature = this.generateLegacySignature();
        let mldsaSignature = null;
        if (parameters.revealMLDSAPublicKey) {
            mldsaSignature = this.generateMLDSASignature();
        }
        const mldsaRequest = {
            priority: FeaturePriority.MLDSA_LINK_PUBKEY,
            opcode: Features.MLDSA_LINK_PUBKEY,
            data: {
                verifyRequest: !!parameters.revealMLDSAPublicKey,
                publicKey: mldsaSigner.publicKey,
                hashedPublicKey: this.hashedPublicKey,
                level: getLevelFromPublicKeyLength(mldsaSigner.publicKey.length),
                legacySignature: legacySignature,
                mldsaSignature: mldsaSignature,
            },
        };
        features.push(mldsaRequest);
    }
    getTransactionOPNetFee() {
        const totalFee = this.priorityFee + this.gasSatFee;
        if (totalFee > TransactionBuilder.MINIMUM_DUST) {
            return totalFee;
        }
        return TransactionBuilder.MINIMUM_DUST;
    }
    calculateTotalUTXOAmount() {
        let total = 0n;
        for (const utxo of this.utxos) {
            total += utxo.value;
        }
        for (const utxo of this.optionalInputs) {
            total += utxo.value;
        }
        return total;
    }
    calculateTotalVOutAmount() {
        let total = 0n;
        for (const utxo of this.utxos) {
            total += utxo.value;
        }
        for (const utxo of this.optionalInputs) {
            total += utxo.value;
        }
        return total;
    }
    addOptionalOutputsAndGetAmount() {
        if (!this.optionalOutputs || this.optionalOutputsAdded)
            return 0n;
        let refundedFromOptionalOutputs = 0n;
        for (let i = 0; i < this.optionalOutputs.length; i++) {
            this.addOutput(this.optionalOutputs[i]);
            refundedFromOptionalOutputs += BigInt(this.optionalOutputs[i].value);
        }
        this.optionalOutputsAdded = true;
        return refundedFromOptionalOutputs;
    }
    addInputsFromUTXO() {
        if (this.utxos.length) {
            if (this.totalInputAmount < TransactionBuilder.MINIMUM_DUST) {
                throw new Error(`Total input amount is ${this.totalInputAmount} sat which is less than the minimum dust ${TransactionBuilder.MINIMUM_DUST} sat.`);
            }
            for (let i = 0; i < this.utxos.length; i++) {
                const utxo = this.utxos[i];
                this.registerInputSigner(i, utxo);
                const input = this.generatePsbtInputExtended(utxo, i);
                this.addInput(input);
            }
        }
        if (this.optionalInputs) {
            for (let i = this.utxos.length; i < this.optionalInputs.length + this.utxos.length; i++) {
                const utxo = this.optionalInputs[i - this.utxos.length];
                this.registerInputSigner(i, utxo);
                const input = this.generatePsbtInputExtended(utxo, i, true);
                this.addInput(input);
            }
        }
    }
    internalInit() {
        this.verifyUTXOValidity();
        super.internalInit();
    }
    updateInput(input) {
        this.updateInputs.push(input);
    }
    addFeeToOutput(amountSpent, contractAddress, epochChallenge, addContractOutput) {
        if (addContractOutput) {
            let amountToCA;
            if (amountSpent > MINIMUM_AMOUNT_REWARD + MINIMUM_AMOUNT_CA) {
                amountToCA = MINIMUM_AMOUNT_CA;
            }
            else {
                amountToCA = amountSpent;
            }
            this.addOutput({
                value: Number(amountToCA),
                address: contractAddress,
            }, true);
            if (amountToCA === MINIMUM_AMOUNT_CA &&
                amountSpent - MINIMUM_AMOUNT_CA > MINIMUM_AMOUNT_REWARD) {
                this.addOutput({
                    value: Number(amountSpent - amountToCA),
                    address: epochChallenge.address,
                }, true);
            }
        }
        else {
            const amountToEpoch = amountSpent < MINIMUM_AMOUNT_REWARD ? MINIMUM_AMOUNT_REWARD : amountSpent;
            this.addOutput({
                value: Number(amountToEpoch),
                address: epochChallenge.address,
            }, true);
        }
    }
    getWitness() {
        if (!this.tapData || !this.tapData.witness) {
            throw new Error('Witness is required');
        }
        if (this.tapData.witness.length === 0) {
            throw new Error('Witness is empty');
        }
        return this.tapData.witness[this.tapData.witness.length - 1];
    }
    getTapOutput() {
        if (!this.tapData || !this.tapData.output) {
            throw new Error('Tap data is required');
        }
        return this.tapData.output;
    }
    verifyUTXOValidity() {
        for (const utxo of this.utxos) {
            if (!utxo.scriptPubKey) {
                throw new Error('Address is required');
            }
        }
        for (const utxo of this.optionalInputs) {
            if (!utxo.scriptPubKey) {
                throw new Error('Address is required');
            }
        }
    }
    async setFeeOutput(output) {
        const initialValue = output.value;
        this.feeOutput = null;
        let estimatedFee = 0n;
        let lastFee = -1n;
        this.log(`setFeeOutput: Starting fee calculation for change. Initial available value: ${initialValue} sats.`);
        for (let i = 0; i < 3 && estimatedFee !== lastFee; i++) {
            lastFee = estimatedFee;
            estimatedFee = await this.estimateTransactionFees();
            const valueLeft = BigInt(initialValue) - estimatedFee;
            if (this.debugFees) {
                this.log(` -> Iteration ${i + 1}: Estimated fee is ${estimatedFee} sats. Value left for change: ${valueLeft} sats.`);
            }
            if (valueLeft >= TransactionBuilder.MINIMUM_DUST) {
                this.feeOutput = { ...output, value: Number(valueLeft) };
                this.overflowFees = valueLeft;
            }
            else {
                this.feeOutput = null;
                this.overflowFees = 0n;
                estimatedFee = await this.estimateTransactionFees();
                if (this.debugFees) {
                    this.log(` -> Change is less than dust. Final fee without change output: ${estimatedFee} sats.`);
                }
            }
        }
        const finalValueLeft = BigInt(initialValue) - estimatedFee;
        if (finalValueLeft < 0) {
            throw new Error(`setFeeOutput: Insufficient funds to pay the fees. Required fee: ${estimatedFee}, Available: ${initialValue}. Total input: ${this.totalInputAmount} sat`);
        }
        if (finalValueLeft >= TransactionBuilder.MINIMUM_DUST) {
            this.feeOutput = { ...output, value: Number(finalValueLeft) };
            this.overflowFees = finalValueLeft;
            if (this.debugFees) {
                this.log(`setFeeOutput: Final change output set to ${finalValueLeft} sats. Final fee: ${estimatedFee} sats.`);
            }
        }
        else {
            this.warn(`Amount to send back (${finalValueLeft} sat) is less than the minimum dust (${TransactionBuilder.MINIMUM_DUST} sat), it will be consumed in fees instead.`);
            this.feeOutput = null;
            this.overflowFees = 0n;
        }
    }
    async internalBuildTransaction(transaction, checkPartialSigs = false) {
        if (transaction.data.inputs.length === 0) {
            const inputs = this.getInputs();
            const outputs = this.getOutputs();
            transaction.setMaximumFeeRate(this._maximumFeeRate);
            transaction.addInputs(inputs, checkPartialSigs);
            for (let i = 0; i < this.updateInputs.length; i++) {
                transaction.updateInput(i, this.updateInputs[i]);
            }
            transaction.addOutputs(outputs);
        }
        try {
            await this.signInputs(transaction);
            if (this.finalized) {
                this.transactionFee = BigInt(transaction.getFee());
            }
            return true;
        }
        catch (e) {
            const err = e;
            this.error(`[internalBuildTransaction] Something went wrong while getting building the transaction: ${err.stack}`);
        }
        return false;
    }
}
TransactionBuilder.MINIMUM_DUST = 330n;

class CustomScriptTransaction extends TransactionBuilder {
    constructor(parameters) {
        super(parameters);
        this.type = TransactionType.CUSTOM_CODE;
        this.tapLeafScript = null;
        this.targetScriptRedeem = null;
        this.leftOverFundsScriptRedeem = null;
        this.customFinalizer = (_inputIndex, input) => {
            if (!this.tapLeafScript) {
                throw new Error('Tap leaf script is required');
            }
            const scriptSolution = this.getScriptSolution(input);
            const witness = scriptSolution
                .concat(this.tapLeafScript.script)
                .concat(this.tapLeafScript.controlBlock);
            if (this.annexData && this.annexData.length > 0) {
                const annex = this.annexData[0] === 0x50
                    ? this.annexData
                    : Buffer$1.concat([Buffer$1.from([0x50]), this.annexData]);
                witness.push(annex);
            }
            return {
                finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness(witness),
            };
        };
        if (!parameters.script)
            throw new Error('Bitcoin script is required');
        if (!parameters.witnesses)
            throw new Error('Witness(es) are required');
        this.witnesses = parameters.witnesses;
        this.randomBytes = parameters.randomBytes || BitcoinUtils.rndBytes();
        this.LOCK_LEAF_SCRIPT = this.defineLockScript();
        this.scriptSeed = this.getContractSeed();
        this.contractSigner = EcKeyPair.fromSeedKeyPair(this.scriptSeed, this.network);
        this.generator = new CustomGenerator(this.internalPubKeyToXOnly(), this.network);
        this.compiledTargetScript = this.generator.compile(parameters.script);
        this.scriptTree = this.getScriptTree();
        this.internalInit();
        this._scriptAddress = AddressGenerator.generatePKSH(this.scriptSeed, this.network);
    }
    get scriptAddress() {
        return this._scriptAddress;
    }
    get p2trAddress() {
        return this.to || this.getScriptAddress();
    }
    exportCompiledTargetScript() {
        return this.compiledTargetScript;
    }
    getRndBytes() {
        return this.randomBytes;
    }
    contractSignerXOnlyPubKey() {
        return toXOnly(Buffer$1.from(this.contractSigner.publicKey));
    }
    async buildTransaction() {
        if (!this.to) {
            this.to = this.getScriptAddress();
        }
        const selectedRedeem = this.contractSigner
            ? this.targetScriptRedeem
            : this.leftOverFundsScriptRedeem;
        if (!selectedRedeem) {
            throw new Error('Left over funds script redeem is required');
        }
        if (!selectedRedeem.redeemVersion) {
            throw new Error('Left over funds script redeem version is required');
        }
        if (!selectedRedeem.output) {
            throw new Error('Left over funds script redeem output is required');
        }
        this.tapLeafScript = {
            leafVersion: selectedRedeem.redeemVersion,
            script: selectedRedeem.output,
            controlBlock: this.getWitness(),
        };
        this.addInputsFromUTXO();
        const amountSpent = this.getTransactionOPNetFee();
        this.addOutput({
            value: Number(amountSpent),
            address: this.to,
        });
        await this.addRefundOutput(amountSpent + this.addOptionalOutputsAndGetAmount());
    }
    async signInputs(transaction) {
        if (!this.contractSigner) {
            await super.signInputs(transaction);
            return;
        }
        for (let i = 0; i < transaction.data.inputs.length; i++) {
            if (i === 0) {
                try {
                    transaction.signInput(0, this.contractSigner);
                }
                catch (e) { }
                transaction.signInput(0, this.getSignerKey());
                transaction.finalizeInput(0, this.customFinalizer);
            }
            else {
                transaction.signInput(i, this.getSignerKey());
                transaction.finalizeInput(i);
            }
        }
    }
    generateScriptAddress() {
        return {
            internalPubkey: this.internalPubKeyToXOnly(),
            network: this.network,
            scriptTree: this.scriptTree,
            name: PaymentType.P2TR,
        };
    }
    generateTapData() {
        const selectedRedeem = this.contractSigner
            ? this.targetScriptRedeem
            : this.leftOverFundsScriptRedeem;
        if (!selectedRedeem) {
            throw new Error('Left over funds script redeem is required');
        }
        if (!this.scriptTree) {
            throw new Error('Script tree is required');
        }
        return {
            internalPubkey: this.internalPubKeyToXOnly(),
            network: this.network,
            scriptTree: this.scriptTree,
            redeem: selectedRedeem,
            name: PaymentType.P2TR,
        };
    }
    getScriptSolution(input) {
        if (!input.tapScriptSig) {
            throw new Error('Tap script signature is required');
        }
        const witnesses = [...this.witnesses];
        if (input.tapScriptSig) {
            for (const sig of input.tapScriptSig) {
                witnesses.push(sig.signature);
            }
        }
        return witnesses;
    }
    getContractSeed() {
        return hash256(this.randomBytes);
    }
    getPubKeys() {
        const pubkeys = [Buffer$1.from(this.signer.publicKey)];
        if (this.contractSigner) {
            pubkeys.push(Buffer$1.from(this.contractSigner.publicKey));
        }
        return pubkeys;
    }
    generateRedeemScripts() {
        this.targetScriptRedeem = {
            name: PaymentType.P2TR,
            output: this.compiledTargetScript,
            redeemVersion: 192,
        };
        this.leftOverFundsScriptRedeem = {
            name: PaymentType.P2TR,
            output: this.getLeafScript(),
            redeemVersion: 192,
        };
    }
    getLeafScript() {
        return this.LOCK_LEAF_SCRIPT;
    }
    getScriptTree() {
        this.generateRedeemScripts();
        return [
            {
                output: this.compiledTargetScript,
                version: 192,
            },
            {
                output: this.getLeafScript(),
                version: 192,
            },
        ];
    }
}

class SharedInteractionTransaction extends TransactionBuilder {
    constructor(parameters) {
        super(parameters);
        this.targetScriptRedeem = null;
        this.leftOverFundsScriptRedeem = null;
        this.customFinalizer = (_inputIndex, input) => {
            if (!this.tapLeafScript) {
                throw new Error('Tap leaf script is required');
            }
            if (!this.contractSecret) {
                throw new Error('Contract secret is required');
            }
            const scriptSolution = this.getScriptSolution(input);
            const witness = scriptSolution
                .concat(this.tapLeafScript.script)
                .concat(this.tapLeafScript.controlBlock);
            return {
                finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness(witness),
            };
        };
        if (!parameters.calldata) {
            throw new Error('Calldata is required');
        }
        if (!parameters.challenge) {
            throw new Error('Challenge solution is required');
        }
        this.challenge = parameters.challenge;
        this.LOCK_LEAF_SCRIPT = this.defineLockScript();
        this.disableAutoRefund = parameters.disableAutoRefund || false;
        this.epochChallenge = TimeLockGenerator.generateTimeLockAddress(this.challenge.publicKey.originalPublicKeyBuffer(), this.network);
        this.calldata = Compressor.compress(parameters.calldata);
        this.randomBytes = parameters.randomBytes || BitcoinUtils.rndBytes();
        this.scriptSigner = this.generateKeyPairFromSeed();
        this.calldataGenerator = new CalldataGenerator(Buffer$1.from(this.signer.publicKey), this.scriptSignerXOnlyPubKey(), this.network);
    }
    exportCompiledTargetScript() {
        return this.compiledTargetScript;
    }
    getContractSecret() {
        return this.contractSecret;
    }
    getRndBytes() {
        return this.randomBytes;
    }
    getChallenge() {
        return this.challenge;
    }
    scriptSignerXOnlyPubKey() {
        return toXOnly(Buffer$1.from(this.scriptSigner.publicKey));
    }
    generateKeyPairFromSeed() {
        return EcKeyPair.fromSeedKeyPair(this.randomBytes, this.network);
    }
    async buildTransaction() {
        const selectedRedeem = this.scriptSigner
            ? this.targetScriptRedeem
            : this.leftOverFundsScriptRedeem;
        if (!selectedRedeem) {
            throw new Error('Left over funds script redeem is required');
        }
        if (!selectedRedeem.redeemVersion) {
            throw new Error('Left over funds script redeem version is required');
        }
        if (!selectedRedeem.output) {
            throw new Error('Left over funds script redeem output is required');
        }
        this.tapLeafScript = {
            leafVersion: selectedRedeem.redeemVersion,
            script: selectedRedeem.output,
            controlBlock: this.getWitness(),
        };
        if (!this.regenerated) {
            this.addInputsFromUTXO();
        }
        await this.createMineableRewardOutputs();
    }
    async signInputs(transaction) {
        if (!this.scriptSigner) {
            await super.signInputs(transaction);
            return;
        }
        if ('multiSignPsbt' in this.signer) {
            await this.signInputsWalletBased(transaction);
        }
        else {
            await this.signInputsNonWalletBased(transaction);
        }
    }
    generateScriptAddress() {
        return {
            internalPubkey: this.internalPubKeyToXOnly(),
            network: this.network,
            scriptTree: this.scriptTree,
            name: PaymentType.P2TR,
        };
    }
    generateTapData() {
        const selectedRedeem = this.scriptSigner
            ? this.targetScriptRedeem
            : this.leftOverFundsScriptRedeem;
        if (!selectedRedeem) {
            throw new Error('Left over funds script redeem is required');
        }
        if (!this.scriptTree) {
            throw new Error('Script tree is required');
        }
        return {
            internalPubkey: this.internalPubKeyToXOnly(),
            network: this.network,
            scriptTree: this.scriptTree,
            redeem: selectedRedeem,
            name: PaymentType.P2TR,
        };
    }
    getScriptSolution(input) {
        if (!input.tapScriptSig) {
            throw new Error('Tap script signature is required');
        }
        return [
            this.contractSecret,
            input.tapScriptSig[0].signature,
            input.tapScriptSig[1].signature,
        ];
    }
    getScriptTree() {
        if (!this.calldata) {
            throw new Error('Calldata is required');
        }
        this.generateRedeemScripts();
        return [
            {
                output: this.compiledTargetScript,
                version: 192,
            },
            {
                output: this.LOCK_LEAF_SCRIPT,
                version: 192,
            },
        ];
    }
    async signInputsWalletBased(transaction) {
        const signer = this.signer;
        await this.signInput(transaction, transaction.data.inputs[0], 0, this.scriptSigner);
        await signer.multiSignPsbt([transaction]);
        for (let i = 0; i < transaction.data.inputs.length; i++) {
            if (i === 0) {
                transaction.finalizeInput(i, this.customFinalizer.bind(this));
            }
            else {
                try {
                    transaction.finalizeInput(i, this.customFinalizerP2SH.bind(this));
                }
                catch (e) {
                    transaction.finalizeInput(i);
                }
            }
        }
    }
    async signInputsNonWalletBased(transaction) {
        for (let i = 0; i < transaction.data.inputs.length; i++) {
            if (i === 0) {
                await this.signInput(transaction, transaction.data.inputs[i], i, this.scriptSigner);
                await this.signInput(transaction, transaction.data.inputs[i], i, this.getSignerKey());
                transaction.finalizeInput(0, this.customFinalizer.bind(this));
            }
            else {
                await this.signInput(transaction, transaction.data.inputs[i], i, this.signer);
                try {
                    transaction.finalizeInput(i, this.customFinalizerP2SH.bind(this));
                }
                catch (e) {
                    transaction.finalizeInput(i);
                }
            }
        }
    }
    async createMineableRewardOutputs() {
        if (!this.to)
            throw new Error('To address is required');
        const opnetFee = this.getTransactionOPNetFee();
        this.addFeeToOutput(opnetFee, this.to, this.epochChallenge, false);
        const actualOutputAmount = opnetFee < MINIMUM_AMOUNT_REWARD ? MINIMUM_AMOUNT_REWARD : opnetFee;
        const optionalAmount = this.addOptionalOutputsAndGetAmount();
        if (!this.disableAutoRefund) {
            await this.addRefundOutput(actualOutputAmount + optionalAmount);
        }
    }
    getPubKeys() {
        const pubKeys = [Buffer$1.from(this.signer.publicKey)];
        if (this.scriptSigner) {
            pubKeys.push(Buffer$1.from(this.scriptSigner.publicKey));
        }
        return pubKeys;
    }
    generateRedeemScripts() {
        this.targetScriptRedeem = {
            name: PaymentType.P2TR,
            output: this.compiledTargetScript,
            redeemVersion: 192,
        };
        this.leftOverFundsScriptRedeem = {
            name: PaymentType.P2TR,
            output: this.LOCK_LEAF_SCRIPT,
            redeemVersion: 192,
        };
    }
}
SharedInteractionTransaction.MAXIMUM_CALLDATA_SIZE = 1024 * 1024;

class DeploymentTransaction extends TransactionBuilder {
    constructor(parameters) {
        super(parameters);
        this.type = TransactionType.DEPLOYMENT;
        this.tapLeafScript = null;
        this.deploymentVersion = 0x00;
        this.targetScriptRedeem = null;
        this.leftOverFundsScriptRedeem = null;
        this.customFinalizer = (_inputIndex, input) => {
            if (!this.tapLeafScript) {
                throw new Error('Tap leaf script is required');
            }
            if (!input.tapScriptSig) {
                throw new Error('Tap script signature is required');
            }
            const scriptSolution = [
                this.randomBytes,
                input.tapScriptSig[0].signature,
                input.tapScriptSig[1].signature,
            ];
            const witness = scriptSolution
                .concat(this.tapLeafScript.script)
                .concat(this.tapLeafScript.controlBlock);
            return {
                finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness(witness),
            };
        };
        if (!this.hashedPublicKey) {
            throw new Error('MLDSA signer must be defined to deploy a contract.');
        }
        this.bytecode = Compressor.compress(Buffer$1.concat([versionBuffer, parameters.bytecode]));
        this.verifyBytecode();
        if (parameters.calldata) {
            this.calldata = parameters.calldata;
            this.verifyCalldata();
        }
        if (!parameters.challenge)
            throw new Error('Challenge solution is required');
        this.randomBytes = parameters.randomBytes || BitcoinUtils.rndBytes();
        this.challenge = parameters.challenge;
        this.LOCK_LEAF_SCRIPT = this.defineLockScript();
        this.epochChallenge = TimeLockGenerator.generateTimeLockAddress(this.challenge.publicKey.originalPublicKeyBuffer(), this.network);
        this.contractSeed = this.getContractSeed();
        this.contractSigner = EcKeyPair.fromSeedKeyPair(this.contractSeed, this.network);
        this.deploymentGenerator = new DeploymentGenerator(Buffer$1.from(this.signer.publicKey), this.contractSignerXOnlyPubKey(), this.network);
        if (parameters.compiledTargetScript) {
            if (Buffer$1.isBuffer(parameters.compiledTargetScript)) {
                this.compiledTargetScript = parameters.compiledTargetScript;
            }
            else if (typeof parameters.compiledTargetScript === 'string') {
                this.compiledTargetScript = Buffer$1.from(parameters.compiledTargetScript, 'hex');
            }
            else {
                throw new Error('Invalid compiled target script format.');
            }
        }
        else {
            this.compiledTargetScript = this.deploymentGenerator.compile(this.bytecode, this.randomBytes, this.challenge, this.priorityFee, this.calldata, this.generateFeatures(parameters));
        }
        this.scriptTree = this.getScriptTree();
        this.internalInit();
        this._contractPubKey = '0x' + this.contractSeed.toString('hex');
        this._contractAddress = new Address(this.contractSeed);
    }
    get contractPubKey() {
        return this._contractPubKey;
    }
    get contractAddress() {
        return this._contractAddress;
    }
    get p2trAddress() {
        return this.to || this.getScriptAddress();
    }
    exportCompiledTargetScript() {
        return this.compiledTargetScript;
    }
    getRndBytes() {
        return this.randomBytes;
    }
    getChallenge() {
        return this.challenge;
    }
    getContractAddress() {
        if (this._computedAddress) {
            return this._computedAddress;
        }
        this._computedAddress = EcKeyPair.p2op(this.contractSeed, this.network, this.deploymentVersion);
        return this._computedAddress;
    }
    contractSignerXOnlyPubKey() {
        return toXOnly(Buffer$1.from(this.contractSigner.publicKey));
    }
    async buildTransaction() {
        if (!this.to) {
            this.to = this.getScriptAddress();
        }
        const selectedRedeem = this.contractSigner
            ? this.targetScriptRedeem
            : this.leftOverFundsScriptRedeem;
        if (!selectedRedeem) {
            throw new Error('Left over funds script redeem is required');
        }
        if (!selectedRedeem.redeemVersion) {
            throw new Error('Left over funds script redeem version is required');
        }
        if (!selectedRedeem.output) {
            throw new Error('Left over funds script redeem output is required');
        }
        this.tapLeafScript = {
            leafVersion: selectedRedeem.redeemVersion,
            script: selectedRedeem.output,
            controlBlock: this.getWitness(),
        };
        this.addInputsFromUTXO();
        const amountSpent = this.getTransactionOPNetFee();
        this.addFeeToOutput(amountSpent, this.getContractAddress(), this.epochChallenge, true);
        await this.addRefundOutput(amountSpent + this.addOptionalOutputsAndGetAmount());
    }
    async signInputsWalletBased(transaction) {
        const signer = this.signer;
        await this.signInput(transaction, transaction.data.inputs[0], 0, this.contractSigner);
        await signer.multiSignPsbt([transaction]);
        for (let i = 0; i < transaction.data.inputs.length; i++) {
            if (i === 0) {
                transaction.finalizeInput(i, this.customFinalizer.bind(this));
            }
            else {
                try {
                    transaction.finalizeInput(i, this.customFinalizerP2SH.bind(this));
                }
                catch (e) {
                    transaction.finalizeInput(i);
                }
            }
        }
    }
    async signInputs(transaction) {
        if (!this.contractSigner) {
            await super.signInputs(transaction);
            return;
        }
        if ('multiSignPsbt' in this.signer) {
            await this.signInputsWalletBased(transaction);
            return;
        }
        for (let i = 0; i < transaction.data.inputs.length; i++) {
            if (i === 0) {
                transaction.signInput(0, this.contractSigner);
                transaction.signInput(0, this.getSignerKey());
                transaction.finalizeInput(0, this.customFinalizer.bind(this));
            }
            else {
                transaction.signInput(i, this.getSignerKey());
                try {
                    transaction.finalizeInput(i, this.customFinalizerP2SH.bind(this));
                }
                catch (e) {
                    transaction.finalizeInput(i);
                }
            }
        }
    }
    generateScriptAddress() {
        return {
            name: PaymentType.P2TR,
            internalPubkey: this.internalPubKeyToXOnly(),
            network: this.network,
            scriptTree: this.scriptTree,
        };
    }
    generateTapData() {
        const selectedRedeem = this.contractSigner
            ? this.targetScriptRedeem
            : this.leftOverFundsScriptRedeem;
        if (!selectedRedeem) {
            throw new Error('Left over funds script redeem is required');
        }
        if (!this.scriptTree) {
            throw new Error('Script tree is required');
        }
        return {
            name: PaymentType.P2TR,
            internalPubkey: this.internalPubKeyToXOnly(),
            network: this.network,
            scriptTree: this.scriptTree,
            redeem: selectedRedeem,
        };
    }
    generateFeatures(parameters) {
        const features = [];
        const submission = parameters.challenge.getSubmission();
        if (submission) {
            features.push({
                priority: FeaturePriority.MLDSA_LINK_PUBKEY,
                opcode: Features.EPOCH_SUBMISSION,
                data: submission,
            });
        }
        if (parameters.revealMLDSAPublicKey && !parameters.linkMLDSAPublicKeyToAddress) {
            throw new Error('To reveal the MLDSA public key, you must set linkMLDSAPublicKeyToAddress to true.');
        }
        if (parameters.linkMLDSAPublicKeyToAddress) {
            this.generateMLDSALinkRequest(parameters, features);
        }
        return features;
    }
    verifyCalldata() {
        if (this.calldata &&
            this.calldata.length > SharedInteractionTransaction.MAXIMUM_CALLDATA_SIZE) {
            throw new Error('Calldata size overflow.');
        }
    }
    verifyBytecode() {
        if (!this.bytecode)
            throw new Error('Bytecode is required');
        if (this.bytecode.length > DeploymentTransaction.MAXIMUM_CONTRACT_SIZE) {
            throw new Error('Contract size overflow.');
        }
    }
    getContractSeed() {
        if (!this.bytecode) {
            throw new Error('Bytecode is required');
        }
        const deployerPubKey = this.internalPubKeyToXOnly();
        const salt = hash256(this.randomBytes);
        const sha256OfBytecode = hash256(this.bytecode);
        const buf = Buffer$1.concat([deployerPubKey, salt, sha256OfBytecode]);
        return hash256(buf);
    }
    getPubKeys() {
        const pubkeys = [Buffer$1.from(this.signer.publicKey)];
        if (this.contractSigner) {
            pubkeys.push(Buffer$1.from(this.contractSigner.publicKey));
        }
        return pubkeys;
    }
    generateRedeemScripts() {
        this.targetScriptRedeem = {
            name: PaymentType.P2TR,
            output: this.compiledTargetScript,
            redeemVersion: 192,
        };
        this.leftOverFundsScriptRedeem = {
            name: PaymentType.P2TR,
            output: this.getLeafScript(),
            redeemVersion: 192,
        };
    }
    getLeafScript() {
        return this.LOCK_LEAF_SCRIPT;
    }
    getScriptTree() {
        if (!this.bytecode) {
            throw new Error('Contract bytecode is required');
        }
        this.generateRedeemScripts();
        return [
            {
                output: this.compiledTargetScript,
                version: 192,
            },
            {
                output: this.getLeafScript(),
                version: 192,
            },
        ];
    }
}
DeploymentTransaction.MAXIMUM_CONTRACT_SIZE = 128 * 1024;

class FundingTransaction extends TransactionBuilder {
    constructor(parameters) {
        super(parameters);
        this.type = TransactionType.FUNDING;
        this.amount = parameters.amount;
        this.splitInputsInto = parameters.splitInputsInto ?? 1;
        this.internalInit();
    }
    async buildTransaction() {
        if (!this.to) {
            throw new Error('Recipient address is required');
        }
        this.addInputsFromUTXO();
        if (this.splitInputsInto > 1) {
            this.splitInputs(this.amount);
        }
        else if (this.isPubKeyDestination) {
            const pubKeyScript = compile([
                Buffer$1.from(this.to.replace('0x', ''), 'hex'),
                opcodes.OP_CHECKSIG,
            ]);
            this.addOutput({
                value: Number(this.amount),
                script: pubKeyScript,
            });
        }
        else {
            this.addOutput({
                value: Number(this.amount),
                address: this.to,
            });
        }
        const totalOutputAmount = this.amount + this.addOptionalOutputsAndGetAmount();
        await this.addRefundOutput(totalOutputAmount);
    }
    splitInputs(amountSpent) {
        if (!this.to) {
            throw new Error('Recipient address is required');
        }
        const splitAmount = amountSpent / BigInt(this.splitInputsInto);
        for (let i = 0; i < this.splitInputsInto; i++) {
            if (this.isPubKeyDestination) {
                this.addOutput({
                    value: Number(splitAmount),
                    script: Buffer$1.from(this.to.slice(2), 'hex'),
                });
            }
            else {
                this.addOutput({
                    value: Number(splitAmount),
                    address: this.to,
                });
            }
        }
    }
    getSignerKey() {
        return this.signer;
    }
}

class InteractionTransaction extends SharedInteractionTransaction {
    constructor(parameters) {
        super(parameters);
        this.type = TransactionType.INTERACTION;
        this.tapLeafScript = null;
        if (!parameters.contract) {
            throw new Error('parameters.contract is required for interaction transaction.');
        }
        this.contractSecret = Buffer$1.from(parameters.contract.replace('0x', ''), 'hex');
        if (this.contractSecret.length !== 32) {
            throw new Error('Invalid contract secret length. Expected 32 bytes.');
        }
        if (parameters.compiledTargetScript) {
            if (Buffer$1.isBuffer(parameters.compiledTargetScript)) {
                this.compiledTargetScript = parameters.compiledTargetScript;
            }
            else if (typeof parameters.compiledTargetScript === 'string') {
                this.compiledTargetScript = Buffer$1.from(parameters.compiledTargetScript, 'hex');
            }
            else {
                throw new Error('Invalid compiled target script format.');
            }
        }
        else {
            this.compiledTargetScript = this.calldataGenerator.compile(this.calldata, this.contractSecret, this.challenge, this.priorityFee, this.generateFeatures(parameters));
        }
        this.scriptTree = this.getScriptTree();
        this.internalInit();
    }
    generateFeatures(parameters) {
        const features = [];
        if (parameters.loadedStorage) {
            features.push({
                priority: FeaturePriority.ACCESS_LIST,
                opcode: Features.ACCESS_LIST,
                data: parameters.loadedStorage,
            });
        }
        const submission = parameters.challenge.getSubmission();
        if (submission) {
            features.push({
                priority: FeaturePriority.EPOCH_SUBMISSION,
                opcode: Features.EPOCH_SUBMISSION,
                data: submission,
            });
        }
        if (parameters.revealMLDSAPublicKey && !parameters.linkMLDSAPublicKeyToAddress) {
            throw new Error('To reveal the MLDSA public key, you must set linkMLDSAPublicKeyToAddress to true.');
        }
        if (parameters.linkMLDSAPublicKeyToAddress) {
            this.generateMLDSALinkRequest(parameters, features);
        }
        return features;
    }
}

class InteractionTransactionP2WDA extends TransactionBuilder {
    constructor(parameters) {
        super(parameters);
        this.type = TransactionType.INTERACTION;
        this.p2wdaInputIndices = new Set();
        this.compiledOperationData = null;
        if (!parameters.to) {
            throw new Error('Contract address (to) is required');
        }
        if (!parameters.contract) {
            throw new Error('Contract secret is required');
        }
        if (!parameters.calldata) {
            throw new Error('Calldata is required');
        }
        if (!parameters.challenge) {
            throw new Error('Challenge solution is required');
        }
        this.disableAutoRefund = parameters.disableAutoRefund || false;
        this.contractAddress = parameters.to;
        this.contractSecret = Buffer$1$1.from(parameters.contract.replace('0x', ''), 'hex');
        this.calldata = Compressor.compress(parameters.calldata);
        this.challenge = parameters.challenge;
        this.randomBytes = parameters.randomBytes || BitcoinUtils.rndBytes();
        this.scriptSigner = this.generateKeyPairFromSeed();
        this.p2wdaGenerator = new P2WDAGenerator(Buffer$1$1.from(this.signer.publicKey), this.scriptSignerXOnlyPubKey(), this.network);
        if (this.contractSecret.length !== 32) {
            throw new Error('Invalid contract secret length. Expected 32 bytes.');
        }
        this.epochChallenge = TimeLockGenerator.generateTimeLockAddress(this.challenge.publicKey.originalPublicKeyBuffer(), this.network);
        this.validateP2WDAInputs();
        if (parameters.compiledTargetScript) {
            if (Buffer$1$1.isBuffer(parameters.compiledTargetScript)) {
                this.compiledOperationData = parameters.compiledTargetScript;
            }
            else if (typeof parameters.compiledTargetScript === 'string') {
                this.compiledOperationData = Buffer$1$1.from(parameters.compiledTargetScript, 'hex');
            }
            else {
                throw new Error('Invalid compiled target script format.');
            }
        }
        else {
            this.compiledOperationData = this.p2wdaGenerator.compile(this.calldata, this.contractSecret, this.challenge, this.priorityFee, this.generateFeatures(parameters));
        }
        this.validateOperationDataSize();
        this.internalInit();
    }
    getRndBytes() {
        return this.randomBytes;
    }
    getChallenge() {
        return this.challenge;
    }
    getContractSecret() {
        return this.contractSecret;
    }
    async buildTransaction() {
        if (!this.regenerated) {
            this.addInputsFromUTXO();
        }
        await this.createMineableRewardOutputs();
    }
    async createMineableRewardOutputs() {
        if (!this.to)
            throw new Error('To address is required');
        const amountSpent = this.getTransactionOPNetFee();
        this.addFeeToOutput(amountSpent, this.to, this.epochChallenge, false);
        const amount = this.addOptionalOutputsAndGetAmount();
        if (!this.disableAutoRefund) {
            await this.addRefundOutput(amountSpent + amount);
        }
    }
    async signInputs(transaction) {
        for (let i = 0; i < transaction.data.inputs.length; i++) {
            await this.signInput(transaction, transaction.data.inputs[i], i, this.signer);
        }
        for (let i = 0; i < transaction.data.inputs.length; i++) {
            if (this.p2wdaInputIndices.has(i)) {
                if (i === 0) {
                    transaction.finalizeInput(i, this.finalizePrimaryP2WDA.bind(this));
                }
                else {
                    transaction.finalizeInput(i, this.finalizeSecondaryP2WDA.bind(this));
                }
            }
            else {
                transaction.finalizeInput(i, this.customFinalizerP2SH.bind(this));
            }
        }
        this.finalized = true;
    }
    generateFeatures(parameters) {
        const features = [];
        if (parameters.loadedStorage) {
            features.push({
                priority: FeaturePriority.ACCESS_LIST,
                opcode: Features.ACCESS_LIST,
                data: parameters.loadedStorage,
            });
        }
        const submission = parameters.challenge.getSubmission();
        if (submission) {
            features.push({
                priority: FeaturePriority.EPOCH_SUBMISSION,
                opcode: Features.EPOCH_SUBMISSION,
                data: submission,
            });
        }
        return features;
    }
    generateKeyPairFromSeed() {
        return EcKeyPair.fromSeedKeyPair(this.randomBytes, this.network);
    }
    scriptSignerXOnlyPubKey() {
        return toXOnly(Buffer$1$1.from(this.scriptSigner.publicKey));
    }
    validateP2WDAInputs() {
        if (this.utxos.length === 0 || !P2WDADetector.isP2WDAUTXO(this.utxos[0])) {
            throw new Error('Input 0 must be a P2WDA UTXO');
        }
        for (let i = 0; i < this.utxos.length; i++) {
            if (P2WDADetector.isP2WDAUTXO(this.utxos[i])) {
                this.p2wdaInputIndices.add(i);
            }
        }
        for (let i = 0; i < this.optionalInputs.length; i++) {
            const actualIndex = this.utxos.length + i;
            if (P2WDADetector.isP2WDAUTXO(this.optionalInputs[i])) {
                this.p2wdaInputIndices.add(actualIndex);
            }
        }
    }
    validateOperationDataSize() {
        if (!this.compiledOperationData) {
            throw new Error('Operation data not compiled');
        }
        const estimatedSize = this.compiledOperationData.length;
        if (!P2WDAGenerator.validateWitnessSize(estimatedSize)) {
            const signatureSize = 64;
            const totalSize = estimatedSize + signatureSize;
            const compressedEstimate = Math.ceil(totalSize * 0.7);
            const requiredFields = Math.ceil(compressedEstimate / InteractionTransactionP2WDA.MAX_BYTES_PER_WITNESS);
            throw new Error(`Please dont use P2WDA for this operation. Data too large. Raw size: ${estimatedSize} bytes, ` +
                `estimated compressed: ${compressedEstimate} bytes, ` +
                `needs ${requiredFields} witness fields, max is ${InteractionTransactionP2WDA.MAX_WITNESS_FIELDS}`);
        }
    }
    finalizePrimaryP2WDA(inputIndex, input) {
        if (!input.partialSig || input.partialSig.length === 0) {
            throw new Error(`No signature for P2WDA input #${inputIndex}`);
        }
        if (!input.witnessScript) {
            throw new Error(`No witness script for P2WDA input #${inputIndex}`);
        }
        if (!this.compiledOperationData) {
            throw new Error('Operation data not compiled');
        }
        const txSignature = input.partialSig[0].signature;
        const messageToSign = Buffer$1$1.concat([txSignature, this.compiledOperationData]);
        const signedMessage = MessageSigner.signMessage(this.signer, messageToSign);
        const schnorrSignature = Buffer$1$1.from(signedMessage.signature);
        const fullData = Buffer$1$1.concat([schnorrSignature, this.compiledOperationData]);
        const compressedData = Compressor.compress(fullData);
        const chunks = this.splitIntoWitnessChunks(compressedData);
        if (chunks.length > InteractionTransactionP2WDA.MAX_WITNESS_FIELDS) {
            throw new Error(`Compressed data needs ${chunks.length} witness fields, max is ${InteractionTransactionP2WDA.MAX_WITNESS_FIELDS}`);
        }
        const witnessStack = [txSignature];
        for (let i = 0; i < InteractionTransactionP2WDA.MAX_WITNESS_FIELDS; i++) {
            witnessStack.push(i < chunks.length ? chunks[i] : Buffer$1$1.alloc(0));
        }
        witnessStack.push(input.witnessScript);
        return {
            finalScriptSig: undefined,
            finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness(witnessStack),
        };
    }
    splitIntoWitnessChunks(data) {
        const chunks = [];
        let offset = 0;
        while (offset < data.length) {
            const size = Math.min(InteractionTransactionP2WDA.MAX_BYTES_PER_WITNESS, data.length - offset);
            chunks.push(Buffer$1$1.from(data.subarray(offset, offset + size)));
            offset += size;
        }
        return chunks;
    }
}
InteractionTransactionP2WDA.MAX_WITNESS_FIELDS = 10;
InteractionTransactionP2WDA.MAX_BYTES_PER_WITNESS = 80;

class CancelTransaction extends TransactionBuilder {
    constructor(parameters) {
        super({
            ...parameters,
            gasSatFee: 1n,
            isCancellation: true,
            priorityFee: 1n,
            calldata: Buffer$1.alloc(0),
        });
        this.type = TransactionType.CANCEL;
        this.tapLeafScript = null;
        this.leftOverFundsScriptRedeem = null;
        this.customFinalizer = (_inputIndex, input) => {
            if (!this.tapLeafScript) {
                throw new Error('Tap leaf script is required');
            }
            if (!input.tapScriptSig || input.tapScriptSig.length === 0) {
                throw new Error('Tap script signature is required');
            }
            const scriptSolution = [input.tapScriptSig[0].signature];
            const witness = scriptSolution
                .concat(this.tapLeafScript.script)
                .concat(this.tapLeafScript.controlBlock);
            return {
                finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness(witness),
            };
        };
        this.contractSecret = Buffer$1.alloc(0);
        if (Buffer$1.isBuffer(parameters.compiledTargetScript)) {
            this.compiledTargetScript = parameters.compiledTargetScript;
        }
        else {
            this.compiledTargetScript = Buffer$1.from(parameters.compiledTargetScript, 'hex');
        }
        this.scriptTree = this.getMinimalScriptTree();
        this.internalInit();
    }
    async buildTransaction() {
        if (!this.from) {
            throw new Error('From address is required');
        }
        if (!this.leftOverFundsScriptRedeem) {
            throw new Error('Left over funds script redeem is required');
        }
        if (!this.leftOverFundsScriptRedeem.redeemVersion) {
            throw new Error('Left over funds script redeem version is required');
        }
        if (!this.leftOverFundsScriptRedeem.output) {
            throw new Error('Left over funds script redeem output is required');
        }
        this.tapLeafScript = {
            leafVersion: this.leftOverFundsScriptRedeem.redeemVersion,
            script: this.leftOverFundsScriptRedeem.output,
            controlBlock: this.getWitness(),
        };
        this.addInputsFromUTXO();
        await this.addRefundOutput(0n, true);
        if (!this.feeOutput) {
            throw new Error('Must add extra UTXOs to cancel this transaction');
        }
    }
    generateScriptAddress() {
        return {
            internalPubkey: this.internalPubKeyToXOnly(),
            network: this.network,
            scriptTree: this.scriptTree,
            name: PaymentType.P2TR,
        };
    }
    generateTapData() {
        const selectedRedeem = this.leftOverFundsScriptRedeem;
        if (!selectedRedeem) {
            throw new Error('Left over funds script redeem is required');
        }
        if (!this.scriptTree) {
            throw new Error('Script tree is required');
        }
        return {
            internalPubkey: this.internalPubKeyToXOnly(),
            network: this.network,
            scriptTree: this.scriptTree,
            redeem: selectedRedeem,
            name: PaymentType.P2TR,
        };
    }
    async signInputs(transaction) {
        if ('multiSignPsbt' in this.signer) {
            await this.signInputsWalletBased(transaction);
        }
        else {
            await this.signInputsNonWalletBased(transaction);
        }
    }
    async signInputsWalletBased(transaction) {
        const signer = this.signer;
        await signer.multiSignPsbt([transaction]);
        for (let i = 0; i < transaction.data.inputs.length; i++) {
            if (i === 0) {
                transaction.finalizeInput(i, this.customFinalizer.bind(this));
            }
            else {
                try {
                    transaction.finalizeInput(i, this.customFinalizerP2SH.bind(this));
                }
                catch (e) {
                    transaction.finalizeInput(i);
                }
            }
        }
    }
    async signInputsNonWalletBased(transaction) {
        for (let i = 0; i < transaction.data.inputs.length; i++) {
            if (i === 0) {
                await this.signInput(transaction, transaction.data.inputs[i], i, this.getSignerKey());
                transaction.finalizeInput(0, this.customFinalizer.bind(this));
            }
            else {
                await this.signInput(transaction, transaction.data.inputs[i], i, this.signer);
                try {
                    transaction.finalizeInput(i, this.customFinalizerP2SH.bind(this));
                }
                catch (e) {
                    transaction.finalizeInput(i);
                }
            }
        }
    }
    getMinimalScriptTree() {
        this.generateLeftoverFundsRedeem();
        if (!this.leftOverFundsScriptRedeem || !this.leftOverFundsScriptRedeem.output) {
            throw new Error('Failed to generate leftover funds redeem script');
        }
        return [
            {
                output: this.compiledTargetScript,
                version: 192,
            },
            {
                output: this.leftOverFundsScriptRedeem.output,
                version: 192,
            },
        ];
    }
    generateLeftoverFundsRedeem() {
        this.leftOverFundsScriptRedeem = {
            name: PaymentType.P2TR,
            output: this.LOCK_LEAF_SCRIPT,
            redeemVersion: 192,
        };
    }
}

class ConsolidatedInteractionTransaction extends TransactionBuilder {
    constructor(parameters) {
        super(parameters);
        this.type = TransactionType.INTERACTION;
        this.cachedValuePerOutput = null;
        if (!parameters.to) {
            throw new Error('Contract address (to) is required');
        }
        if (!parameters.contract) {
            throw new Error('Contract secret (contract) is required');
        }
        if (!parameters.calldata) {
            throw new Error('Calldata is required');
        }
        if (!parameters.challenge) {
            throw new Error('Challenge solution is required');
        }
        this.contractAddress = parameters.to;
        this.contractSecret = Buffer$1$1.from(parameters.contract.replace('0x', ''), 'hex');
        this.disableAutoRefund = parameters.disableAutoRefund || false;
        this.maxChunkSize = parameters.maxChunkSize ?? HashCommitmentGenerator.MAX_CHUNK_SIZE;
        if (this.contractSecret.length !== 32) {
            throw new Error('Invalid contract secret length. Expected 32 bytes.');
        }
        this.calldata = Compressor.compress(parameters.calldata);
        this.randomBytes = parameters.randomBytes || BitcoinUtils.rndBytes();
        this.scriptSigner = EcKeyPair.fromSeedKeyPair(this.randomBytes, this.network);
        this.challenge = parameters.challenge;
        this.epochChallenge = TimeLockGenerator.generateTimeLockAddress(this.challenge.publicKey.originalPublicKeyBuffer(), this.network);
        this.calldataGenerator = new CalldataGenerator(Buffer$1$1.from(this.signer.publicKey), toXOnly(Buffer$1$1.from(this.scriptSigner.publicKey)), this.network);
        if (parameters.compiledTargetScript) {
            if (Buffer$1$1.isBuffer(parameters.compiledTargetScript)) {
                this.compiledTargetScript = parameters.compiledTargetScript;
            }
            else if (typeof parameters.compiledTargetScript === 'string') {
                this.compiledTargetScript = Buffer$1$1.from(parameters.compiledTargetScript, 'hex');
            }
            else {
                throw new Error('Invalid compiled target script format.');
            }
        }
        else {
            this.compiledTargetScript = this.calldataGenerator.compile(this.calldata, this.contractSecret, this.challenge, this.priorityFee, this.generateFeatures(parameters));
        }
        this.hashCommitmentGenerator = new HashCommitmentGenerator(Buffer$1$1.from(this.signer.publicKey), this.network);
        this.commitmentOutputs = this.hashCommitmentGenerator.prepareChunks(this.compiledTargetScript, this.maxChunkSize);
        this.validateOutputCount();
        const totalChunks = this.commitmentOutputs.reduce((sum, output) => sum + output.dataChunks.length, 0);
        this.log(`ConsolidatedInteractionTransaction: ${this.commitmentOutputs.length} outputs, ` +
            `${totalChunks} chunks from ${this.compiledTargetScript.length} bytes compiled data`);
        this.internalInit();
    }
    exportCompiledTargetScript() {
        return this.compiledTargetScript;
    }
    getContractSecret() {
        return this.contractSecret;
    }
    getRndBytes() {
        return this.randomBytes;
    }
    getChallenge() {
        return this.challenge;
    }
    getCommitmentOutputs() {
        return this.commitmentOutputs;
    }
    getOutputCount() {
        return this.commitmentOutputs.length;
    }
    getTotalChunkCount() {
        return this.commitmentOutputs.reduce((sum, output) => sum + output.dataChunks.length, 0);
    }
    async build() {
        const setupTx = await this.signTransaction();
        const setupTxId = setupTx.getId();
        const setup = {
            txHex: setupTx.toHex(),
            txId: setupTxId,
            outputs: this.commitmentOutputs,
            feesPaid: this.transactionFee,
            chunkCount: this.getTotalChunkCount(),
            totalDataSize: this.compiledTargetScript.length,
        };
        this.log(`Setup transaction: ${setup.txId}`);
        const reveal = this.buildRevealTransaction(setupTxId);
        return {
            setup,
            reveal,
            totalFees: setup.feesPaid + reveal.feesPaid,
        };
    }
    buildRevealTransaction(setupTxId) {
        const revealPsbt = new Psbt({ network: this.network });
        const valuePerOutput = this.calculateValuePerOutput();
        for (let i = 0; i < this.commitmentOutputs.length; i++) {
            const commitment = this.commitmentOutputs[i];
            revealPsbt.addInput({
                hash: setupTxId,
                index: i,
                witnessUtxo: {
                    script: commitment.scriptPubKey,
                    value: Number(valuePerOutput),
                },
                witnessScript: commitment.witnessScript,
            });
        }
        const inputValue = BigInt(this.commitmentOutputs.length) * valuePerOutput;
        const opnetFee = this.getTransactionOPNetFee();
        const feeAmount = opnetFee < MINIMUM_AMOUNT_REWARD ? MINIMUM_AMOUNT_REWARD : opnetFee;
        revealPsbt.addOutput({
            address: this.epochChallenge.address,
            value: Number(feeAmount),
        });
        const estimatedVBytes = this.estimateRevealVBytes();
        const revealFee = BigInt(Math.ceil(estimatedVBytes * this.feeRate));
        const changeValue = inputValue - feeAmount - revealFee;
        if (changeValue > TransactionBuilder.MINIMUM_DUST) {
            const refundAddress = this.getRefundAddress();
            revealPsbt.addOutput({
                address: refundAddress,
                value: Number(changeValue),
            });
        }
        for (let i = 0; i < this.commitmentOutputs.length; i++) {
            revealPsbt.signInput(i, this.signer);
        }
        for (let i = 0; i < this.commitmentOutputs.length; i++) {
            const commitment = this.commitmentOutputs[i];
            revealPsbt.finalizeInput(i, (_inputIndex, input) => {
                return this.finalizeCommitmentInput(input, commitment);
            });
        }
        const revealTx = revealPsbt.extractTransaction();
        const result = {
            txHex: revealTx.toHex(),
            txId: revealTx.getId(),
            dataSize: this.compiledTargetScript.length,
            feesPaid: revealFee,
            inputCount: this.commitmentOutputs.length,
        };
        this.log(`Reveal transaction: ${result.txId}`);
        return result;
    }
    getValuePerOutput() {
        return this.calculateValuePerOutput();
    }
    async buildTransaction() {
        this.addInputsFromUTXO();
        const valuePerOutput = this.calculateValuePerOutput();
        for (const commitment of this.commitmentOutputs) {
            this.addOutput({
                value: Number(valuePerOutput),
                address: commitment.address,
            });
        }
        const totalCommitmentValue = BigInt(this.commitmentOutputs.length) * valuePerOutput;
        const optionalAmount = this.addOptionalOutputsAndGetAmount();
        await this.addRefundOutput(totalCommitmentValue + optionalAmount);
    }
    finalizeCommitmentInput(input, commitment) {
        if (!input.partialSig || input.partialSig.length === 0) {
            throw new Error('No signature for commitment input');
        }
        if (!input.witnessScript) {
            throw new Error('No witness script for commitment input');
        }
        const witnessStack = [
            input.partialSig[0].signature,
            ...commitment.dataChunks,
            input.witnessScript,
        ];
        return {
            finalScriptSig: undefined,
            finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness(witnessStack),
        };
    }
    estimateRevealVBytes() {
        this.commitmentOutputs.length;
        let witnessWeight = 0;
        for (const commitment of this.commitmentOutputs) {
            const numChunks = commitment.dataChunks.length;
            const chunkDataWeight = numChunks * 80;
            const scriptWeight = numChunks * 23 + 35;
            const sigWeight = 72;
            const overheadWeight = 20;
            witnessWeight += 164 + chunkDataWeight + scriptWeight + sigWeight + overheadWeight;
        }
        const weight = 40 + witnessWeight + 200;
        return Math.ceil(weight / 4);
    }
    calculateValuePerOutput() {
        if (this.cachedValuePerOutput !== null) {
            return this.cachedValuePerOutput;
        }
        const numOutputs = this.commitmentOutputs.length;
        const opnetFee = this.getTransactionOPNetFee();
        const feeAmount = opnetFee < MINIMUM_AMOUNT_REWARD ? MINIMUM_AMOUNT_REWARD : opnetFee;
        const estimatedVBytes = this.estimateRevealVBytes();
        const revealFee = BigInt(Math.ceil(estimatedVBytes * this.feeRate));
        const totalNeeded = feeAmount + revealFee + TransactionBuilder.MINIMUM_DUST;
        const valuePerOutput = BigInt(Math.ceil(Number(totalNeeded) / numOutputs));
        const minValue = HashCommitmentGenerator.MIN_OUTPUT_VALUE;
        this.cachedValuePerOutput = valuePerOutput > minValue ? valuePerOutput : minValue;
        return this.cachedValuePerOutput;
    }
    getRefundAddress() {
        if (this.from) {
            return this.from;
        }
        return AddressGenerator.generatePKSH(this.signer.publicKey, this.network);
    }
    generateFeatures(parameters) {
        const features = [];
        if (parameters.loadedStorage) {
            features.push({
                priority: FeaturePriority.ACCESS_LIST,
                opcode: Features.ACCESS_LIST,
                data: parameters.loadedStorage,
            });
        }
        const submission = parameters.challenge.getSubmission();
        if (submission) {
            features.push({
                priority: FeaturePriority.EPOCH_SUBMISSION,
                opcode: Features.EPOCH_SUBMISSION,
                data: submission,
            });
        }
        if (parameters.revealMLDSAPublicKey && !parameters.linkMLDSAPublicKeyToAddress) {
            throw new Error('To reveal the MLDSA public key, you must set linkMLDSAPublicKeyToAddress to true.');
        }
        if (parameters.linkMLDSAPublicKeyToAddress) {
            this.generateMLDSALinkRequest(parameters, features);
        }
        return features;
    }
    validateOutputCount() {
        const maxInputs = HashCommitmentGenerator.calculateMaxInputsPerTx();
        if (this.commitmentOutputs.length > maxInputs) {
            const maxData = HashCommitmentGenerator.calculateMaxDataPerTx();
            throw new Error(`Data too large: ${this.commitmentOutputs.length} P2WSH outputs needed, ` +
                `max ${maxInputs} per standard transaction (~${Math.floor(maxData / 1024)}KB). ` +
                `Compiled data: ${this.compiledTargetScript.length} bytes.`);
        }
    }
}

class TransactionFactory {
    constructor() {
        this.debug = false;
        this.DUMMY_PUBKEY = Buffer$1.alloc(32, 1);
        this.P2TR_SCRIPT = Buffer$1.concat([Buffer$1.from([0x51, 0x20]), this.DUMMY_PUBKEY]);
        this.INITIAL_FUNDING_ESTIMATE = 2000n;
        this.MAX_ITERATIONS = 10;
    }
    async createCancellableTransaction(params) {
        if (!params.to) {
            throw new Error('Field "to" not provided.');
        }
        if (!params.from) {
            throw new Error('Field "from" not provided.');
        }
        if (!params.utxos[0]) {
            throw new Error('Missing at least one UTXO.');
        }
        const opWalletCancel = await this.detectCancelOPWallet(params);
        if (opWalletCancel) {
            return opWalletCancel;
        }
        if (!('signer' in params)) {
            throw new Error('Field "signer" not provided, OP_WALLET not detected.');
        }
        const cancel = new CancelTransaction(params);
        const signed = await cancel.signTransaction();
        const rawTx = signed.toHex();
        return {
            transaction: rawTx,
            nextUTXOs: this.getUTXOAsTransaction(signed, params.from, 0),
            inputUtxos: params.utxos,
        };
    }
    async createCustomScriptTransaction(interactionParameters) {
        if (!interactionParameters.to) {
            throw new Error('Field "to" not provided.');
        }
        if (!interactionParameters.from) {
            throw new Error('Field "from" not provided.');
        }
        if (!interactionParameters.utxos[0]) {
            throw new Error('Missing at least one UTXO.');
        }
        if (!('signer' in interactionParameters)) {
            throw new Error('Field "signer" not provided, OP_WALLET not detected.');
        }
        const inputs = this.parseOptionalInputs(interactionParameters.optionalInputs);
        const { finalTransaction, estimatedAmount, challenge } = await this.iterateFundingAmount({ ...interactionParameters, optionalInputs: inputs }, CustomScriptTransaction, async (tx) => {
            const fee = await tx.estimateTransactionFees();
            const priorityFee = this.getPriorityFee(interactionParameters);
            const optionalValue = tx.getOptionalOutputValue();
            return fee + priorityFee + optionalValue;
        }, 'CustomScript');
        const parameters = await finalTransaction.getFundingTransactionParameters();
        parameters.utxos = interactionParameters.utxos;
        parameters.amount = estimatedAmount;
        const feeEstimationFunding = await this.createFundTransaction({
            ...parameters,
            optionalOutputs: [],
            optionalInputs: [],
        });
        if (!feeEstimationFunding) {
            throw new Error('Could not sign funding transaction.');
        }
        parameters.estimatedFees = feeEstimationFunding.estimatedFees;
        const signedTransaction = await this.createFundTransaction({
            ...parameters,
            optionalOutputs: [],
            optionalInputs: [],
        });
        if (!signedTransaction) {
            throw new Error('Could not sign funding transaction.');
        }
        const newParams = {
            ...interactionParameters,
            utxos: this.getUTXOAsTransaction(signedTransaction.tx, interactionParameters.to, 0),
            randomBytes: finalTransaction.getRndBytes(),
            nonWitnessUtxo: signedTransaction.tx.toBuffer(),
            estimatedFees: finalTransaction.estimatedFees,
            compiledTargetScript: finalTransaction.exportCompiledTargetScript(),
            optionalInputs: inputs,
        };
        const customTransaction = new CustomScriptTransaction(newParams);
        const outTx = await customTransaction.signTransaction();
        return [
            signedTransaction.tx.toHex(),
            outTx.toHex(),
            this.getUTXOAsTransaction(signedTransaction.tx, interactionParameters.from, 1),
            interactionParameters.utxos,
        ];
    }
    async signInteraction(interactionParameters) {
        if (!interactionParameters.to) {
            throw new Error('Field "to" not provided.');
        }
        if (!interactionParameters.from) {
            throw new Error('Field "from" not provided.');
        }
        if (!interactionParameters.utxos[0]) {
            throw new Error('Missing at least one UTXO.');
        }
        const opWalletInteraction = await this.detectInteractionOPWallet(interactionParameters);
        if (opWalletInteraction) {
            return opWalletInteraction;
        }
        if (!('signer' in interactionParameters)) {
            throw new Error('Field "signer" not provided, OP_WALLET not detected.');
        }
        const useP2WDA = this.hasP2WDAInputs(interactionParameters.utxos);
        if (useP2WDA) {
            return this.signP2WDAInteraction(interactionParameters);
        }
        const inputs = this.parseOptionalInputs(interactionParameters.optionalInputs);
        const { finalTransaction, estimatedAmount, challenge } = await this.iterateFundingAmount({ ...interactionParameters, optionalInputs: inputs }, InteractionTransaction, async (tx) => {
            const fee = await tx.estimateTransactionFees();
            const outputsValue = tx.getTotalOutputValue();
            return fee + outputsValue;
        }, 'Interaction');
        if (!challenge) {
            throw new Error('Failed to get challenge from interaction transaction');
        }
        const parameters = await finalTransaction.getFundingTransactionParameters();
        parameters.utxos = interactionParameters.utxos;
        parameters.amount = estimatedAmount;
        const feeEstimationFunding = await this.createFundTransaction({
            ...parameters,
            optionalOutputs: [],
            optionalInputs: [],
        });
        if (!feeEstimationFunding) {
            throw new Error('Could not sign funding transaction.');
        }
        parameters.estimatedFees = feeEstimationFunding.estimatedFees;
        const signedTransaction = await this.createFundTransaction({
            ...parameters,
            optionalOutputs: [],
            optionalInputs: [],
        });
        if (!signedTransaction) {
            throw new Error('Could not sign funding transaction.');
        }
        const fundingUTXO = this.getUTXOAsTransaction(signedTransaction.tx, finalTransaction.getScriptAddress(), 0);
        const newParams = {
            ...interactionParameters,
            utxos: fundingUTXO,
            randomBytes: finalTransaction.getRndBytes(),
            challenge: challenge,
            compiledTargetScript: finalTransaction.exportCompiledTargetScript(),
            nonWitnessUtxo: signedTransaction.tx.toBuffer(),
            estimatedFees: finalTransaction.estimatedFees,
            optionalInputs: inputs,
        };
        const interactionTx = new InteractionTransaction(newParams);
        const outTx = await interactionTx.signTransaction();
        return {
            interactionAddress: finalTransaction.getScriptAddress(),
            fundingTransaction: signedTransaction.tx.toHex(),
            interactionTransaction: outTx.toHex(),
            estimatedFees: interactionTx.transactionFee,
            nextUTXOs: this.getUTXOAsTransaction(signedTransaction.tx, interactionParameters.from, 1),
            challenge: challenge.toRaw(),
            fundingUTXOs: fundingUTXO,
            fundingInputUtxos: interactionParameters.utxos,
            compiledTargetScript: interactionTx.exportCompiledTargetScript().toString('hex'),
        };
    }
    async signConsolidatedInteraction(interactionParameters) {
        if (!interactionParameters.to) {
            throw new Error('Field "to" not provided.');
        }
        if (!interactionParameters.from) {
            throw new Error('Field "from" not provided.');
        }
        if (!interactionParameters.utxos[0]) {
            throw new Error('Missing at least one UTXO.');
        }
        if (!('signer' in interactionParameters)) {
            throw new Error('Field "signer" not provided.');
        }
        if (!interactionParameters.challenge) {
            throw new Error('Field "challenge" not provided.');
        }
        const inputs = this.parseOptionalInputs(interactionParameters.optionalInputs);
        const consolidatedTx = new ConsolidatedInteractionTransaction({
            ...interactionParameters,
            optionalInputs: inputs,
        });
        const result = await consolidatedTx.build();
        return {
            setupTransaction: result.setup.txHex,
            revealTransaction: result.reveal.txHex,
            setupTxId: result.setup.txId,
            revealTxId: result.reveal.txId,
            totalFees: result.totalFees,
            chunkCount: result.setup.chunkCount,
            dataSize: result.setup.totalDataSize,
            challenge: consolidatedTx.getChallenge().toRaw(),
            inputUtxos: interactionParameters.utxos,
            compiledTargetScript: consolidatedTx.exportCompiledTargetScript().toString('hex'),
        };
    }
    async signDeployment(deploymentParameters) {
        const opWalletDeployment = await this.detectDeploymentOPWallet(deploymentParameters);
        if (opWalletDeployment) {
            return opWalletDeployment;
        }
        if (!('signer' in deploymentParameters)) {
            throw new Error('Field "signer" not provided, OP_WALLET not detected.');
        }
        const inputs = this.parseOptionalInputs(deploymentParameters.optionalInputs);
        const { finalTransaction, estimatedAmount, challenge } = await this.iterateFundingAmount({ ...deploymentParameters, optionalInputs: inputs }, DeploymentTransaction, async (tx) => {
            const fee = await tx.estimateTransactionFees();
            const priorityFee = this.getPriorityFee(deploymentParameters);
            const optionalValue = tx.getOptionalOutputValue();
            return fee + priorityFee + optionalValue;
        }, 'Deployment');
        if (!challenge) {
            throw new Error('Failed to get challenge from deployment transaction');
        }
        const parameters = await finalTransaction.getFundingTransactionParameters();
        parameters.utxos = deploymentParameters.utxos;
        parameters.amount = estimatedAmount;
        const feeEstimationFunding = await this.createFundTransaction({
            ...parameters,
            optionalOutputs: [],
            optionalInputs: [],
        });
        if (!feeEstimationFunding) {
            throw new Error('Could not sign funding transaction.');
        }
        parameters.estimatedFees = feeEstimationFunding.estimatedFees;
        const fundingTransaction = new FundingTransaction({
            ...parameters,
            optionalInputs: [],
            optionalOutputs: [],
        });
        const signedTransaction = await fundingTransaction.signTransaction();
        if (!signedTransaction) {
            throw new Error('Could not sign funding transaction.');
        }
        const out = signedTransaction.outs[0];
        const newUtxo = {
            transactionId: signedTransaction.getId(),
            outputIndex: 0,
            scriptPubKey: {
                hex: out.script.toString('hex'),
                address: finalTransaction.getScriptAddress(),
            },
            value: BigInt(out.value),
        };
        const newParams = {
            ...deploymentParameters,
            utxos: [newUtxo],
            randomBytes: finalTransaction.getRndBytes(),
            compiledTargetScript: finalTransaction.exportCompiledTargetScript(),
            challenge: challenge,
            nonWitnessUtxo: signedTransaction.toBuffer(),
            estimatedFees: finalTransaction.estimatedFees,
            optionalInputs: inputs,
        };
        const deploymentTx = new DeploymentTransaction(newParams);
        const outTx = await deploymentTx.signTransaction();
        const out2 = signedTransaction.outs[1];
        const refundUTXO = {
            transactionId: signedTransaction.getId(),
            outputIndex: 1,
            scriptPubKey: {
                hex: out2.script.toString('hex'),
                address: deploymentParameters.from,
            },
            value: BigInt(out2.value),
        };
        return {
            transaction: [signedTransaction.toHex(), outTx.toHex()],
            contractAddress: deploymentTx.getContractAddress(),
            contractPubKey: deploymentTx.contractPubKey,
            utxos: [refundUTXO],
            challenge: challenge.toRaw(),
            inputUtxos: deploymentParameters.utxos,
        };
    }
    async createBTCTransfer(parameters) {
        if (!parameters.from) {
            throw new Error('Field "from" not provided.');
        }
        const resp = await this.createFundTransaction(parameters);
        return {
            estimatedFees: resp.estimatedFees,
            original: resp.original,
            tx: resp.tx.toHex(),
            nextUTXOs: this.getAllNewUTXOs(resp.original, resp.tx, parameters.from),
            inputUtxos: parameters.utxos,
        };
    }
    getAllNewUTXOs(original, tx, to) {
        const outputs = original.getOutputs();
        const utxos = [];
        for (let i = 0; i < tx.outs.length; i++) {
            const output = outputs[i];
            if ('address' in output) {
                if (output.address !== to)
                    continue;
            }
            else {
                continue;
            }
            utxos.push(...this.getUTXOAsTransaction(tx, to, i));
        }
        return utxos;
    }
    parseOptionalInputs(optionalInputs) {
        return (optionalInputs || []).map((input) => {
            let nonWitness = input.nonWitnessUtxo;
            if (nonWitness &&
                !(nonWitness instanceof Uint8Array) &&
                typeof nonWitness === 'object') {
                nonWitness = Buffer$1.from(Uint8Array.from(Object.values(input.nonWitnessUtxo)));
            }
            return {
                ...input,
                nonWitnessUtxo: nonWitness,
            };
        });
    }
    async detectCancelOPWallet(interactionParameters) {
        if (typeof window === 'undefined') {
            return null;
        }
        const _window = window;
        if (!_window || !_window.opnet || !_window.opnet.web3) {
            return null;
        }
        const opnet = _window.opnet.web3;
        const interaction = await opnet.cancelTransaction({
            ...interactionParameters,
            signer: undefined,
        });
        if (!interaction) {
            throw new Error('Could not sign interaction transaction.');
        }
        return {
            ...interaction,
            inputUtxos: interaction.inputUtxos ?? interactionParameters.utxos,
        };
    }
    async detectInteractionOPWallet(interactionParameters) {
        if (typeof window === 'undefined') {
            return null;
        }
        const _window = window;
        if (!_window || !_window.opnet || !_window.opnet.web3) {
            return null;
        }
        const opnet = _window.opnet.web3;
        const interaction = await opnet.signInteraction({
            ...interactionParameters,
            signer: undefined,
        });
        if (!interaction) {
            throw new Error('Could not sign interaction transaction.');
        }
        return {
            ...interaction,
            fundingInputUtxos: interaction.fundingInputUtxos ?? interactionParameters.utxos,
        };
    }
    async detectDeploymentOPWallet(deploymentParameters) {
        if (typeof window === 'undefined') {
            return null;
        }
        const _window = window;
        if (!_window || !_window.opnet || !_window.opnet.web3) {
            return null;
        }
        const opnet = _window.opnet.web3;
        const deployment = await opnet.deployContract({
            ...deploymentParameters,
            signer: undefined,
        });
        if (!deployment) {
            throw new Error('Could not sign interaction transaction.');
        }
        return {
            ...deployment,
            inputUtxos: deployment.inputUtxos ?? deploymentParameters.utxos,
        };
    }
    async createFundTransaction(parameters) {
        if (!parameters.to)
            throw new Error('Field "to" not provided.');
        const fundingTransaction = new FundingTransaction(parameters);
        const signedTransaction = await fundingTransaction.signTransaction();
        if (!signedTransaction) {
            throw new Error('Could not sign funding transaction.');
        }
        return {
            tx: signedTransaction,
            original: fundingTransaction,
            estimatedFees: fundingTransaction.estimatedFees,
            nextUTXOs: this.getUTXOAsTransaction(signedTransaction, parameters.to, 0),
            inputUtxos: parameters.utxos,
        };
    }
    hasP2WDAInputs(utxos) {
        return utxos.some((utxo) => P2WDADetector.isP2WDAUTXO(utxo));
    }
    writePSBTHeader(type, psbt) {
        const buf = Buffer$1.from(psbt, 'base64');
        const header = Buffer$1.alloc(2);
        header.writeUInt8(type, 0);
        header.writeUInt8(currentConsensus, 1);
        return Buffer$1.concat([header, buf]).toString('hex');
    }
    async signP2WDAInteraction(interactionParameters) {
        if (!interactionParameters.from) {
            throw new Error('Field "from" not provided.');
        }
        if (!('signer' in interactionParameters)) {
            throw new Error('P2WDA interactions require a signer. OP_WALLET is not supported for P2WDA.');
        }
        const inputs = this.parseOptionalInputs(interactionParameters.optionalInputs);
        const p2wdaTransaction = new InteractionTransactionP2WDA({
            ...interactionParameters,
            optionalInputs: inputs,
        });
        const signedTx = await p2wdaTransaction.signTransaction();
        const txHex = signedTx.toHex();
        return {
            interactionAddress: null,
            fundingTransaction: null,
            interactionTransaction: txHex,
            estimatedFees: p2wdaTransaction.estimatedFees,
            nextUTXOs: this.getUTXOAsTransaction(signedTx, interactionParameters.from, signedTx.outs.length - 1),
            fundingUTXOs: [...interactionParameters.utxos, ...inputs],
            fundingInputUtxos: interactionParameters.utxos,
            challenge: interactionParameters.challenge.toRaw(),
            compiledTargetScript: null,
        };
    }
    getPriorityFee(params) {
        const totalFee = params.priorityFee + params.gasSatFee;
        if (totalFee < TransactionBuilder.MINIMUM_DUST) {
            return TransactionBuilder.MINIMUM_DUST;
        }
        return totalFee;
    }
    async iterateFundingAmount(params, TransactionClass, calculateAmount, debugPrefix) {
        const randomBytes = 'randomBytes' in params
            ? (params.randomBytes ?? BitcoinUtils.rndBytes())
            : BitcoinUtils.rndBytes();
        const dummyAddress = Address.dead().p2tr(params.network);
        let estimatedFundingAmount = this.INITIAL_FUNDING_ESTIMATE;
        let previousAmount = 0n;
        let iterations = 0;
        let finalPreTransaction = null;
        let challenge = null;
        while (iterations < this.MAX_ITERATIONS && estimatedFundingAmount !== previousAmount) {
            previousAmount = estimatedFundingAmount;
            const dummyTx = new Transaction();
            dummyTx.addOutput(this.P2TR_SCRIPT, Number(estimatedFundingAmount));
            const simulatedFundedUtxo = {
                transactionId: Buffer$1.alloc(32, 0).toString('hex'),
                outputIndex: 0,
                scriptPubKey: {
                    hex: this.P2TR_SCRIPT.toString('hex'),
                    address: dummyAddress,
                },
                value: estimatedFundingAmount,
                nonWitnessUtxo: dummyTx.toBuffer(),
            };
            let txParams;
            if ('challenge' in params && params.challenge) {
                const withChallenge = {
                    ...params,
                    utxos: [simulatedFundedUtxo],
                    randomBytes: randomBytes,
                    challenge: challenge ?? params.challenge,
                };
                txParams = withChallenge;
            }
            else {
                const withoutChallenge = {
                    ...params,
                    utxos: [simulatedFundedUtxo],
                    randomBytes: randomBytes,
                };
                txParams = withoutChallenge;
            }
            const preTransaction = new TransactionClass(txParams);
            try {
                await preTransaction.generateTransactionMinimalSignatures();
                estimatedFundingAmount = await calculateAmount(preTransaction);
            }
            catch (error) {
                if (error instanceof Error) {
                    const match = error.message.match(/need (\d+) sats but only have (\d+) sats/);
                    if (match) {
                        estimatedFundingAmount = BigInt(match[1]);
                        if (this.debug) {
                            console.log(`${debugPrefix}: Caught insufficient funds, updating to ${estimatedFundingAmount}`);
                        }
                    }
                    else {
                        throw error;
                    }
                }
                else {
                    throw new Error('Unknown error during fee estimation');
                }
            }
            finalPreTransaction = preTransaction;
            if ('getChallenge' in preTransaction &&
                typeof preTransaction.getChallenge === 'function') {
                challenge = preTransaction.getChallenge();
            }
            iterations++;
            if (this.debug) {
                console.log(`${debugPrefix} Iteration ${iterations}: Previous=${previousAmount}, New=${estimatedFundingAmount}`);
            }
        }
        if (!finalPreTransaction) {
            throw new Error(`Failed to converge on ${debugPrefix} funding amount`);
        }
        return {
            finalTransaction: finalPreTransaction,
            estimatedAmount: estimatedFundingAmount,
            challenge,
        };
    }
    getUTXOAsTransaction(tx, to, index) {
        if (!tx.outs[index])
            return [];
        const out = tx.outs[index];
        const newUtxo = {
            transactionId: tx.getId(),
            outputIndex: index,
            scriptPubKey: {
                hex: out.script.toString('hex'),
                address: to,
            },
            value: BigInt(out.value),
        };
        return [newUtxo];
    }
}

class MultiSignTransaction extends TransactionBuilder {
    constructor(parameters) {
        if (!parameters.refundVault) {
            throw new Error('Refund vault is required');
        }
        if (!parameters.requestedAmount) {
            throw new Error('Requested amount is required');
        }
        if (!parameters.receiver) {
            throw new Error('Receiver is required');
        }
        super({
            ...parameters,
            signer: EcKeyPair.fromPrivateKey(sha256$1(Buffer$1.from('aaaaaaaa', 'utf-8'))),
            priorityFee: 0n,
            gasSatFee: 0n,
        });
        this.type = TransactionType.MULTI_SIG;
        this.targetScriptRedeem = null;
        this.leftOverFundsScriptRedeem = null;
        this.originalInputCount = 0;
        this.sighashTypes = MultiSignTransaction.signHashTypesArray;
        this.customFinalizer = (_inputIndex, input) => {
            if (!this.tapLeafScript) {
                throw new Error('Tap leaf script is required');
            }
            const scriptSolution = this.getScriptSolution(input);
            const witness = scriptSolution
                .concat(this.tapLeafScript.script)
                .concat(this.tapLeafScript.controlBlock);
            return {
                finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness(witness),
            };
        };
        if (!parameters.pubkeys) {
            throw new Error('Pubkeys are required');
        }
        if (parameters.psbt) {
            this.log(`Using provided PSBT.`);
            this.transaction = parameters.psbt;
            this.originalInputCount = this.transaction.data.inputs.length;
        }
        this.refundVault = parameters.refundVault;
        this.requestedAmount = parameters.requestedAmount;
        this.receiver = parameters.receiver;
        this.publicKeys = parameters.pubkeys;
        this.minimumSignatures = parameters.minimumSignatures;
        this.compiledTargetScript = MultiSignGenerator.compile(parameters.pubkeys, this.minimumSignatures);
        this.scriptTree = this.getScriptTree();
        this.internalInit();
    }
    static fromBase64(params) {
        const psbt = Psbt.fromBase64(params.psbt, { network: params.network });
        return new MultiSignTransaction({
            ...params,
            psbt,
        });
    }
    static verifyIfSigned(psbt, signerPubKey) {
        let alreadySigned = false;
        for (let i = 1; i < psbt.data.inputs.length; i++) {
            const input = psbt.data.inputs[i];
            if (!input.finalScriptWitness) {
                continue;
            }
            const decoded = TransactionBuilder.readScriptWitnessToWitnessStack(input.finalScriptWitness);
            if (decoded.length < 3) {
                continue;
            }
            for (let j = 0; j < decoded.length - 2; j += 3) {
                const pubKey = decoded[j + 2];
                if (pubKey.equals(signerPubKey)) {
                    alreadySigned = true;
                    break;
                }
            }
        }
        return alreadySigned;
    }
    static signPartial(psbt, signer, originalInputCount, minimums) {
        let signed = false;
        let final = true;
        for (let i = originalInputCount; i < psbt.data.inputs.length; i++) {
            const input = psbt.data.inputs[i];
            if (!input.tapInternalKey) {
                input.tapInternalKey = toXOnly(MultiSignTransaction.numsPoint);
            }
            const partialSignatures = [];
            if (input.finalScriptWitness) {
                const decoded = TransactionBuilder.readScriptWitnessToWitnessStack(input.finalScriptWitness);
                input.tapLeafScript = [
                    {
                        leafVersion: 192,
                        script: decoded[decoded.length - 2],
                        controlBlock: decoded[decoded.length - 1],
                    },
                ];
                for (let j = 0; j < decoded.length - 2; j += 3) {
                    partialSignatures.push({
                        signature: decoded[j],
                        leafHash: decoded[j + 1],
                        pubkey: decoded[j + 2],
                    });
                }
                input.tapScriptSig = (input.tapScriptSig || []).concat(partialSignatures);
            }
            delete input.finalScriptWitness;
            const signHashTypes = MultiSignTransaction.signHashTypesArray
                ? [MultiSignTransaction.calculateSignHash(MultiSignTransaction.signHashTypesArray)]
                : [];
            try {
                MultiSignTransaction.signInput(psbt, input, i, signer, signHashTypes);
                signed = true;
            }
            catch (e) {
                console.log(e);
            }
            if (signed) {
                if (!input.tapScriptSig)
                    throw new Error('No new signatures for input');
                if (input.tapScriptSig.length !== minimums[i - originalInputCount]) {
                    final = false;
                }
            }
        }
        return {
            signed,
            final: !signed ? false : final,
        };
    }
    static dedupeSignatures(original, partial) {
        const signatures = new Map();
        for (const sig of original) {
            signatures.set(sig.pubkey.toString('hex'), sig);
        }
        for (const sig of partial) {
            if (!signatures.has(sig.pubkey.toString('hex'))) {
                signatures.set(sig.pubkey.toString('hex'), sig);
            }
        }
        return Array.from(signatures.values());
    }
    static attemptFinalizeInputs(psbt, startIndex, orderedPubKeys, isFinal) {
        let finalizedInputs = 0;
        for (let i = startIndex; i < psbt.data.inputs.length; i++) {
            try {
                const input = psbt.data.inputs[i];
                if (!input.tapInternalKey) {
                    input.tapInternalKey = toXOnly(MultiSignTransaction.numsPoint);
                }
                const partialSignatures = [];
                if (input.finalScriptWitness) {
                    const decoded = TransactionBuilder.readScriptWitnessToWitnessStack(input.finalScriptWitness);
                    for (let j = 0; j < decoded.length - 2; j += 3) {
                        partialSignatures.push({
                            signature: decoded[j],
                            leafHash: decoded[j + 1],
                            pubkey: decoded[j + 2],
                        });
                    }
                    input.tapLeafScript = [
                        {
                            leafVersion: 192,
                            script: decoded[decoded.length - 2],
                            controlBlock: decoded[decoded.length - 1],
                        },
                    ];
                    input.tapScriptSig = MultiSignTransaction.dedupeSignatures(input.tapScriptSig || [], partialSignatures);
                }
                delete input.finalScriptWitness;
                psbt.finalizeInput(i, (inputIndex, input) => {
                    return MultiSignTransaction.partialFinalizer(inputIndex, input, [], orderedPubKeys[i - startIndex], isFinal);
                });
                finalizedInputs++;
            }
            catch (e) { }
        }
        return finalizedInputs === psbt.data.inputs.length - startIndex;
    }
    finalizeTransactionInputs() {
        let finalized = false;
        try {
            for (let i = this.originalInputCount; i < this.transaction.data.inputs.length; i++) {
                this.transaction.finalizeInput(i, this.customFinalizer.bind(this));
            }
            finalized = true;
        }
        catch (e) {
            this.error(`Error finalizing transaction inputs: ${e.stack}`);
        }
        return finalized;
    }
    async signPSBT() {
        if (await this.signTransaction()) {
            return this.transaction;
        }
        throw new Error('Could not sign transaction');
    }
    async buildTransaction() {
        const selectedRedeem = this.targetScriptRedeem;
        if (!selectedRedeem) {
            throw new Error('Left over funds script redeem is required');
        }
        if (!selectedRedeem.redeemVersion) {
            throw new Error('Left over funds script redeem version is required');
        }
        if (!selectedRedeem.output) {
            throw new Error('Left over funds script redeem output is required');
        }
        this.tapLeafScript = {
            leafVersion: selectedRedeem.redeemVersion,
            script: selectedRedeem.output,
            controlBlock: this.getWitness(),
        };
        this.addInputsFromUTXO();
        const outputLeftAmount = this.calculateOutputLeftAmountFromVaults(this.utxos);
        if (outputLeftAmount < 0) {
            throw new Error(`Output value left is negative ${outputLeftAmount}.`);
        }
        this.addOutput({
            address: this.refundVault,
            value: Number(outputLeftAmount),
        });
        this.addOutput({
            address: this.receiver,
            value: Number(this.requestedAmount),
        });
    }
    async internalBuildTransaction(transaction, checkPartialSigs = false) {
        const inputs = this.getInputs();
        const outputs = this.getOutputs();
        transaction.setMaximumFeeRate(this._maximumFeeRate);
        transaction.addInputs(inputs, checkPartialSigs);
        for (let i = 0; i < this.updateInputs.length; i++) {
            transaction.updateInput(i, this.updateInputs[i]);
        }
        transaction.addOutputs(outputs);
        try {
            await this.signInputs(transaction);
            return this.finalizeTransactionInputs();
        }
        catch (e) {
            const err = e;
            this.error(`[internalBuildTransaction] Something went wrong while getting building the transaction: ${err.stack}`);
        }
        return false;
    }
    async signInputs(_transaction) { }
    generateScriptAddress() {
        return {
            internalPubkey: toXOnly(MultiSignTransaction.numsPoint),
            network: this.network,
            scriptTree: this.scriptTree,
            name: PaymentType.P2TR,
        };
    }
    generateTapData() {
        const selectedRedeem = this.targetScriptRedeem;
        if (!selectedRedeem) {
            throw new Error('Left over funds script redeem is required');
        }
        if (!this.scriptTree) {
            throw new Error('Script tree is required');
        }
        return {
            internalPubkey: toXOnly(MultiSignTransaction.numsPoint),
            network: this.network,
            scriptTree: this.scriptTree,
            redeem: selectedRedeem,
            name: PaymentType.P2TR,
        };
    }
    getScriptSolution(input) {
        if (!input.tapScriptSig) {
            return [];
        }
        return input.tapScriptSig.map((sig) => {
            return sig.signature;
        });
    }
    getScriptTree() {
        this.generateRedeemScripts();
        return [
            {
                output: this.compiledTargetScript,
                version: 192,
            },
            {
                output: MultiSignTransaction.LOCK_LEAF_SCRIPT,
                version: 192,
            },
        ];
    }
    getTotalOutputAmount(utxos) {
        let total = 0n;
        for (const utxo of utxos) {
            total += utxo.value;
        }
        return total;
    }
    calculateOutputLeftAmountFromVaults(utxos) {
        const total = this.getTotalOutputAmount(utxos);
        return total - this.requestedAmount;
    }
    generateRedeemScripts() {
        this.targetScriptRedeem = {
            name: PaymentType.P2TR,
            output: this.compiledTargetScript,
            redeemVersion: 192,
        };
        this.leftOverFundsScriptRedeem = {
            name: PaymentType.P2TR,
            output: MultiSignTransaction.LOCK_LEAF_SCRIPT,
            redeemVersion: 192,
        };
    }
}
MultiSignTransaction.LOCK_LEAF_SCRIPT = compile([
    opcodes.OP_XOR,
    opcodes.OP_NOP,
    opcodes.OP_CODESEPARATOR,
]);
MultiSignTransaction.signHashTypesArray = [];
MultiSignTransaction.numsPoint = Buffer$1.from('50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0', 'hex');
MultiSignTransaction.partialFinalizer = (inputIndex, input, partialSignatures, orderedPubKeys, isFinal) => {
    if (!input.tapLeafScript ||
        !input.tapLeafScript[0].script ||
        !input.tapLeafScript[0].controlBlock) {
        throw new Error('Tap leaf script is required');
    }
    if (!input.tapScriptSig) {
        throw new Error(`No new signatures for input ${inputIndex}.`);
    }
    let scriptSolution = [];
    if (!isFinal) {
        scriptSolution = input.tapScriptSig
            .map((sig) => {
            return [sig.signature, sig.leafHash, sig.pubkey];
        })
            .flat();
    }
    else {
        for (const pubKey of orderedPubKeys) {
            let found = false;
            for (const sig of input.tapScriptSig) {
                if (sig.pubkey.equals(toXOnly(pubKey))) {
                    scriptSolution.push(sig.signature);
                    found = true;
                }
            }
            if (!found) {
                scriptSolution.push(Buffer$1.alloc(0));
            }
        }
        scriptSolution = scriptSolution.reverse();
    }
    if (partialSignatures.length > 0) {
        scriptSolution = scriptSolution.concat(partialSignatures);
    }
    const witness = scriptSolution
        .concat(input.tapLeafScript[0].script)
        .concat(input.tapLeafScript[0].controlBlock);
    return {
        finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness(witness),
    };
};

function stringToBuffer(str) {
    return Buffer$1.from(str.replace('0x', ''), 'hex');
}

class EpochValidator {
    static bufferToUint8Array(buffer) {
        return new Uint8Array(buffer);
    }
    static uint8ArrayToBuffer(array) {
        return Buffer$1.from(array);
    }
    static sha1(data) {
        return sha1$1(Buffer$1.isBuffer(data) ? data : Buffer$1.from(data));
    }
    static calculatePreimage(checksumRoot, publicKey, salt) {
        if (checksumRoot.length !== 32 || publicKey.length !== 32 || salt.length !== 32) {
            throw new Error('All inputs must be 32 bytes');
        }
        const preimage = Buffer$1.alloc(32);
        for (let i = 0; i < 32; i++) {
            preimage[i] = checksumRoot[i] ^ publicKey[i] ^ salt[i];
        }
        return preimage;
    }
    static countMatchingBits(hash1, hash2) {
        let matchingBits = 0;
        if (hash1.length !== hash2.length) {
            throw new Error('Hashes must be of the same length');
        }
        const minLength = Math.min(hash1.length, hash2.length);
        for (let i = 0; i < minLength; i++) {
            const byte1 = hash1[i];
            const byte2 = hash2[i];
            if (byte1 === byte2) {
                matchingBits += 8;
            }
            else {
                for (let bit = 7; bit >= 0; bit--) {
                    if (((byte1 >> bit) & 1) === ((byte2 >> bit) & 1)) {
                        matchingBits++;
                    }
                    else {
                        return matchingBits;
                    }
                }
            }
        }
        return matchingBits;
    }
    static verifySolution(challenge, log = false) {
        try {
            const verification = challenge.verification;
            const calculatedPreimage = this.calculatePreimage(verification.targetChecksum, challenge.publicKey.toBuffer(), challenge.salt);
            const computedSolution = this.sha1(calculatedPreimage);
            const computedSolutionBuffer = this.uint8ArrayToBuffer(computedSolution);
            if (!computedSolutionBuffer.equals(challenge.solution)) {
                return false;
            }
            const matchingBits = this.countMatchingBits(computedSolutionBuffer, verification.targetHash);
            if (matchingBits !== challenge.difficulty) {
                return false;
            }
            const expectedStartBlock = challenge.epochNumber * this.BLOCKS_PER_EPOCH;
            const expectedEndBlock = expectedStartBlock + this.BLOCKS_PER_EPOCH - 1n;
            return !(verification.startBlock !== expectedStartBlock ||
                verification.endBlock !== expectedEndBlock);
        }
        catch (error) {
            if (log)
                console.error('Verification error:', error);
            return false;
        }
    }
    static getMiningTargetBlock(epochNumber) {
        if (epochNumber === 0n) {
            return null;
        }
        return epochNumber * this.BLOCKS_PER_EPOCH - 1n;
    }
    static validateEpochWinner(epochData) {
        try {
            const epochNumber = BigInt(epochData.epochNumber);
            const publicKey = Address.fromString(epochData.mldsaPublicKey, epochData.legacyPublicKey);
            const solution = stringToBuffer(epochData.solution);
            const salt = stringToBuffer(epochData.salt);
            const difficulty = epochData.difficulty;
            const verification = {
                epochHash: stringToBuffer(epochData.verification.epochHash),
                epochRoot: stringToBuffer(epochData.verification.epochRoot),
                targetHash: stringToBuffer(epochData.verification.targetHash),
                targetChecksum: stringToBuffer(epochData.verification.targetChecksum),
                startBlock: BigInt(epochData.verification.startBlock),
                endBlock: BigInt(epochData.verification.endBlock),
                proofs: Object.freeze(epochData.verification.proofs.map((p) => stringToBuffer(p))),
            };
            const calculatedPreimage = this.calculatePreimage(verification.targetChecksum, publicKey.toBuffer(), salt);
            const computedSolution = this.sha1(calculatedPreimage);
            const computedSolutionBuffer = this.uint8ArrayToBuffer(computedSolution);
            if (!computedSolutionBuffer.equals(solution)) {
                return false;
            }
            const matchingBits = this.countMatchingBits(computedSolutionBuffer, verification.targetHash);
            if (matchingBits !== difficulty) {
                return false;
            }
            const expectedStartBlock = epochNumber * this.BLOCKS_PER_EPOCH;
            const expectedEndBlock = expectedStartBlock + this.BLOCKS_PER_EPOCH - 1n;
            return !(verification.startBlock !== expectedStartBlock ||
                verification.endBlock !== expectedEndBlock);
        }
        catch {
            return false;
        }
    }
    static validateChallengeSolution(challenge) {
        return this.verifySolution(challenge);
    }
    static calculateSolution(targetChecksum, publicKey, salt) {
        const preimage = this.calculatePreimage(targetChecksum, publicKey, salt);
        const hash = this.sha1(this.bufferToUint8Array(preimage));
        return this.uint8ArrayToBuffer(hash);
    }
    static checkDifficulty(solution, targetHash, minDifficulty) {
        const difficulty = this.countMatchingBits(solution, targetHash);
        return {
            valid: difficulty >= minDifficulty,
            difficulty,
        };
    }
}
EpochValidator.BLOCKS_PER_EPOCH = 5n;

class ChallengeVerification {
    constructor(data) {
        this.epochHash = stringToBuffer(data.epochHash);
        this.epochRoot = stringToBuffer(data.epochRoot);
        this.targetHash = stringToBuffer(data.targetHash);
        this.targetChecksum = stringToBuffer(data.targetChecksum);
        this.startBlock = BigInt(data.startBlock);
        this.endBlock = BigInt(data.endBlock);
        this.proofs = Object.freeze(data.proofs.map((proof) => stringToBuffer(proof)));
    }
}
class ChallengeSubmission {
    constructor(data, epochNumber) {
        this.epochNumber = epochNumber;
        this.publicKey = Address.fromString(data.mldsaPublicKey, data.legacyPublicKey);
        this.solution = stringToBuffer(data.solution);
        this.graffiti = data.graffiti ? stringToBuffer(data.graffiti) : undefined;
        this.signature = stringToBuffer(data.signature);
    }
    verifySignature() {
        const signatureDataWriter = new BinaryWriter();
        signatureDataWriter.writeAddress(this.publicKey);
        signatureDataWriter.writeU64(this.epochNumber);
        signatureDataWriter.writeBytes(this.solution);
        if (this.graffiti) {
            signatureDataWriter.writeBytes(this.graffiti);
        }
        const buffer = signatureDataWriter.getBuffer();
        return MessageSigner.verifySignature(this.publicKey.tweakedPublicKeyToBuffer(), buffer, this.signature);
    }
}
class ChallengeSolution {
    constructor(data) {
        this.epochNumber = BigInt(data.epochNumber);
        this.publicKey = Address.fromString(data.mldsaPublicKey, data.legacyPublicKey);
        this.solution = stringToBuffer(data.solution);
        this.salt = stringToBuffer(data.salt);
        this.graffiti = stringToBuffer(data.graffiti);
        this.difficulty = data.difficulty;
        this.verification = new ChallengeVerification(data.verification);
        this.submission = data.submission
            ? new ChallengeSubmission(data.submission, this.epochNumber + 2n)
            : data.submission;
    }
    static validateRaw(data) {
        return EpochValidator.validateEpochWinner(data);
    }
    verifySubmissionSignature() {
        if (!this.submission) {
            throw new Error('No submission provided in request.');
        }
        return this.submission.verifySignature();
    }
    getSubmission() {
        if (!this.submission) {
            return;
        }
        if (!this.verifySubmissionSignature()) {
            throw new Error('Invalid submission signature.');
        }
        return this.submission;
    }
    verify() {
        return EpochValidator.validateChallengeSolution(this);
    }
    toBuffer() {
        return this.solution;
    }
    toHex() {
        return '0x' + this.solution.toString('hex');
    }
    toRaw() {
        return {
            epochNumber: this.epochNumber.toString(),
            mldsaPublicKey: this.publicKey.toHex(),
            legacyPublicKey: this.publicKey.tweakedToHex(),
            solution: this.toHex(),
            salt: '0x' + this.salt.toString('hex'),
            graffiti: '0x' + this.graffiti.toString('hex'),
            difficulty: this.difficulty,
            verification: {
                epochHash: '0x' + this.verification.epochHash.toString('hex'),
                epochRoot: '0x' + this.verification.epochRoot.toString('hex'),
                targetHash: '0x' + this.verification.targetHash.toString('hex'),
                targetChecksum: '0x' + this.verification.targetChecksum.toString('hex'),
                startBlock: this.verification.startBlock.toString(),
                endBlock: this.verification.endBlock.toString(),
                proofs: this.verification.proofs.map((p) => '0x' + p.toString('hex')),
            },
        };
    }
    calculateSolution() {
        return EpochValidator.calculateSolution(this.verification.targetChecksum, this.publicKey.toBuffer(), this.salt);
    }
    checkDifficulty(minDifficulty) {
        return EpochValidator.checkDifficulty(this.solution, this.verification.targetHash, minDifficulty);
    }
    getMiningTargetBlock() {
        return EpochValidator.getMiningTargetBlock(this.epochNumber);
    }
}

var PSBTTypes;
(function (PSBTTypes) {
    PSBTTypes[PSBTTypes["UNWRAP"] = 0] = "UNWRAP";
})(PSBTTypes || (PSBTTypes = {}));

var sha_js = {exports: {}};

var inherits = {exports: {}};

function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var browser = { exports: {} };
var process = browser.exports = {};
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    if (typeof setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e2) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e2) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
process.nextTick = function(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = true;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop() {
}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
  return [];
};
process.binding = function(name) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(dir) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports = browser.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);

var util = {};

var types = {};

var shams$1;
var hasRequiredShams$1;

function requireShams$1 () {
	if (hasRequiredShams$1) return shams$1;
	hasRequiredShams$1 = 1;

	/** @type {import('./shams')} */
	/* eslint complexity: [2, 18], max-statements: [2, 33] */
	shams$1 = function hasSymbols() {
		if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
		if (typeof Symbol.iterator === 'symbol') { return true; }

		/** @type {{ [k in symbol]?: unknown }} */
		var obj = {};
		var sym = Symbol('test');
		var symObj = Object(sym);
		if (typeof sym === 'string') { return false; }

		if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
		if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

		// temp disabled per https://github.com/ljharb/object.assign/issues/17
		// if (sym instanceof Symbol) { return false; }
		// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
		// if (!(symObj instanceof Symbol)) { return false; }

		// if (typeof Symbol.prototype.toString !== 'function') { return false; }
		// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

		var symVal = 42;
		obj[sym] = symVal;
		for (var _ in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
		if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

		if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

		var syms = Object.getOwnPropertySymbols(obj);
		if (syms.length !== 1 || syms[0] !== sym) { return false; }

		if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

		if (typeof Object.getOwnPropertyDescriptor === 'function') {
			// eslint-disable-next-line no-extra-parens
			var descriptor = /** @type {PropertyDescriptor} */ (Object.getOwnPropertyDescriptor(obj, sym));
			if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
		}

		return true;
	};
	return shams$1;
}

var shams;
var hasRequiredShams;

function requireShams () {
	if (hasRequiredShams) return shams;
	hasRequiredShams = 1;

	var hasSymbols = requireShams$1();

	/** @type {import('.')} */
	shams = function hasToStringTagShams() {
		return hasSymbols() && !!Symbol.toStringTag;
	};
	return shams;
}

var esObjectAtoms;
var hasRequiredEsObjectAtoms;

function requireEsObjectAtoms () {
	if (hasRequiredEsObjectAtoms) return esObjectAtoms;
	hasRequiredEsObjectAtoms = 1;

	/** @type {import('.')} */
	esObjectAtoms = Object;
	return esObjectAtoms;
}

var esErrors;
var hasRequiredEsErrors;

function requireEsErrors () {
	if (hasRequiredEsErrors) return esErrors;
	hasRequiredEsErrors = 1;

	/** @type {import('.')} */
	esErrors = Error;
	return esErrors;
}

var _eval;
var hasRequired_eval;

function require_eval () {
	if (hasRequired_eval) return _eval;
	hasRequired_eval = 1;

	/** @type {import('./eval')} */
	_eval = EvalError;
	return _eval;
}

var range;
var hasRequiredRange;

function requireRange () {
	if (hasRequiredRange) return range;
	hasRequiredRange = 1;

	/** @type {import('./range')} */
	range = RangeError;
	return range;
}

var ref;
var hasRequiredRef;

function requireRef () {
	if (hasRequiredRef) return ref;
	hasRequiredRef = 1;

	/** @type {import('./ref')} */
	ref = ReferenceError;
	return ref;
}

var syntax;
var hasRequiredSyntax;

function requireSyntax () {
	if (hasRequiredSyntax) return syntax;
	hasRequiredSyntax = 1;

	/** @type {import('./syntax')} */
	syntax = SyntaxError;
	return syntax;
}

var type;
var hasRequiredType;

function requireType () {
	if (hasRequiredType) return type;
	hasRequiredType = 1;

	/** @type {import('./type')} */
	type = TypeError;
	return type;
}

var uri;
var hasRequiredUri;

function requireUri () {
	if (hasRequiredUri) return uri;
	hasRequiredUri = 1;

	/** @type {import('./uri')} */
	uri = URIError;
	return uri;
}

var abs;
var hasRequiredAbs;

function requireAbs () {
	if (hasRequiredAbs) return abs;
	hasRequiredAbs = 1;

	/** @type {import('./abs')} */
	abs = Math.abs;
	return abs;
}

var floor;
var hasRequiredFloor;

function requireFloor () {
	if (hasRequiredFloor) return floor;
	hasRequiredFloor = 1;

	/** @type {import('./floor')} */
	floor = Math.floor;
	return floor;
}

var max;
var hasRequiredMax;

function requireMax () {
	if (hasRequiredMax) return max;
	hasRequiredMax = 1;

	/** @type {import('./max')} */
	max = Math.max;
	return max;
}

var min;
var hasRequiredMin;

function requireMin () {
	if (hasRequiredMin) return min;
	hasRequiredMin = 1;

	/** @type {import('./min')} */
	min = Math.min;
	return min;
}

var pow;
var hasRequiredPow;

function requirePow () {
	if (hasRequiredPow) return pow;
	hasRequiredPow = 1;

	/** @type {import('./pow')} */
	pow = Math.pow;
	return pow;
}

var round;
var hasRequiredRound;

function requireRound () {
	if (hasRequiredRound) return round;
	hasRequiredRound = 1;

	/** @type {import('./round')} */
	round = Math.round;
	return round;
}

var _isNaN;
var hasRequired_isNaN;

function require_isNaN () {
	if (hasRequired_isNaN) return _isNaN;
	hasRequired_isNaN = 1;

	/** @type {import('./isNaN')} */
	_isNaN = Number.isNaN || function isNaN(a) {
		return a !== a;
	};
	return _isNaN;
}

var sign;
var hasRequiredSign;

function requireSign () {
	if (hasRequiredSign) return sign;
	hasRequiredSign = 1;

	var $isNaN = /*@__PURE__*/ require_isNaN();

	/** @type {import('./sign')} */
	sign = function sign(number) {
		if ($isNaN(number) || number === 0) {
			return number;
		}
		return number < 0 ? -1 : 1;
	};
	return sign;
}

var gOPD;
var hasRequiredGOPD;

function requireGOPD () {
	if (hasRequiredGOPD) return gOPD;
	hasRequiredGOPD = 1;

	/** @type {import('./gOPD')} */
	gOPD = Object.getOwnPropertyDescriptor;
	return gOPD;
}

var gopd;
var hasRequiredGopd;

function requireGopd () {
	if (hasRequiredGopd) return gopd;
	hasRequiredGopd = 1;

	/** @type {import('.')} */
	var $gOPD = /*@__PURE__*/ requireGOPD();

	if ($gOPD) {
		try {
			$gOPD([], 'length');
		} catch (e) {
			// IE 8 has a broken gOPD
			$gOPD = null;
		}
	}

	gopd = $gOPD;
	return gopd;
}

var esDefineProperty;
var hasRequiredEsDefineProperty;

function requireEsDefineProperty () {
	if (hasRequiredEsDefineProperty) return esDefineProperty;
	hasRequiredEsDefineProperty = 1;

	/** @type {import('.')} */
	var $defineProperty = Object.defineProperty || false;
	if ($defineProperty) {
		try {
			$defineProperty({}, 'a', { value: 1 });
		} catch (e) {
			// IE 8 has a broken defineProperty
			$defineProperty = false;
		}
	}

	esDefineProperty = $defineProperty;
	return esDefineProperty;
}

var hasSymbols;
var hasRequiredHasSymbols;

function requireHasSymbols () {
	if (hasRequiredHasSymbols) return hasSymbols;
	hasRequiredHasSymbols = 1;

	var origSymbol = typeof Symbol !== 'undefined' && Symbol;
	var hasSymbolSham = requireShams$1();

	/** @type {import('.')} */
	hasSymbols = function hasNativeSymbols() {
		if (typeof origSymbol !== 'function') { return false; }
		if (typeof Symbol !== 'function') { return false; }
		if (typeof origSymbol('foo') !== 'symbol') { return false; }
		if (typeof Symbol('bar') !== 'symbol') { return false; }

		return hasSymbolSham();
	};
	return hasSymbols;
}

var Reflect_getPrototypeOf;
var hasRequiredReflect_getPrototypeOf;

function requireReflect_getPrototypeOf () {
	if (hasRequiredReflect_getPrototypeOf) return Reflect_getPrototypeOf;
	hasRequiredReflect_getPrototypeOf = 1;

	/** @type {import('./Reflect.getPrototypeOf')} */
	Reflect_getPrototypeOf = (typeof Reflect !== 'undefined' && Reflect.getPrototypeOf) || null;
	return Reflect_getPrototypeOf;
}

var Object_getPrototypeOf;
var hasRequiredObject_getPrototypeOf;

function requireObject_getPrototypeOf () {
	if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
	hasRequiredObject_getPrototypeOf = 1;

	var $Object = /*@__PURE__*/ requireEsObjectAtoms();

	/** @type {import('./Object.getPrototypeOf')} */
	Object_getPrototypeOf = $Object.getPrototypeOf || null;
	return Object_getPrototypeOf;
}

var implementation;
var hasRequiredImplementation;

function requireImplementation () {
	if (hasRequiredImplementation) return implementation;
	hasRequiredImplementation = 1;

	/* eslint no-invalid-this: 1 */

	var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
	var toStr = Object.prototype.toString;
	var max = Math.max;
	var funcType = '[object Function]';

	var concatty = function concatty(a, b) {
	    var arr = [];

	    for (var i = 0; i < a.length; i += 1) {
	        arr[i] = a[i];
	    }
	    for (var j = 0; j < b.length; j += 1) {
	        arr[j + a.length] = b[j];
	    }

	    return arr;
	};

	var slicy = function slicy(arrLike, offset) {
	    var arr = [];
	    for (var i = offset, j = 0; i < arrLike.length; i += 1, j += 1) {
	        arr[j] = arrLike[i];
	    }
	    return arr;
	};

	var joiny = function (arr, joiner) {
	    var str = '';
	    for (var i = 0; i < arr.length; i += 1) {
	        str += arr[i];
	        if (i + 1 < arr.length) {
	            str += joiner;
	        }
	    }
	    return str;
	};

	implementation = function bind(that) {
	    var target = this;
	    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
	        throw new TypeError(ERROR_MESSAGE + target);
	    }
	    var args = slicy(arguments, 1);

	    var bound;
	    var binder = function () {
	        if (this instanceof bound) {
	            var result = target.apply(
	                this,
	                concatty(args, arguments)
	            );
	            if (Object(result) === result) {
	                return result;
	            }
	            return this;
	        }
	        return target.apply(
	            that,
	            concatty(args, arguments)
	        );

	    };

	    var boundLength = max(0, target.length - args.length);
	    var boundArgs = [];
	    for (var i = 0; i < boundLength; i++) {
	        boundArgs[i] = '$' + i;
	    }

	    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

	    if (target.prototype) {
	        var Empty = function Empty() {};
	        Empty.prototype = target.prototype;
	        bound.prototype = new Empty();
	        Empty.prototype = null;
	    }

	    return bound;
	};
	return implementation;
}

var functionBind;
var hasRequiredFunctionBind;

function requireFunctionBind () {
	if (hasRequiredFunctionBind) return functionBind;
	hasRequiredFunctionBind = 1;

	var implementation = requireImplementation();

	functionBind = Function.prototype.bind || implementation;
	return functionBind;
}

var functionCall;
var hasRequiredFunctionCall;

function requireFunctionCall () {
	if (hasRequiredFunctionCall) return functionCall;
	hasRequiredFunctionCall = 1;

	/** @type {import('./functionCall')} */
	functionCall = Function.prototype.call;
	return functionCall;
}

var functionApply;
var hasRequiredFunctionApply;

function requireFunctionApply () {
	if (hasRequiredFunctionApply) return functionApply;
	hasRequiredFunctionApply = 1;

	/** @type {import('./functionApply')} */
	functionApply = Function.prototype.apply;
	return functionApply;
}

var reflectApply;
var hasRequiredReflectApply;

function requireReflectApply () {
	if (hasRequiredReflectApply) return reflectApply;
	hasRequiredReflectApply = 1;

	/** @type {import('./reflectApply')} */
	reflectApply = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;
	return reflectApply;
}

var actualApply;
var hasRequiredActualApply;

function requireActualApply () {
	if (hasRequiredActualApply) return actualApply;
	hasRequiredActualApply = 1;

	var bind = requireFunctionBind();

	var $apply = requireFunctionApply();
	var $call = requireFunctionCall();
	var $reflectApply = requireReflectApply();

	/** @type {import('./actualApply')} */
	actualApply = $reflectApply || bind.call($call, $apply);
	return actualApply;
}

var callBindApplyHelpers;
var hasRequiredCallBindApplyHelpers;

function requireCallBindApplyHelpers () {
	if (hasRequiredCallBindApplyHelpers) return callBindApplyHelpers;
	hasRequiredCallBindApplyHelpers = 1;

	var bind = requireFunctionBind();
	var $TypeError = /*@__PURE__*/ requireType();

	var $call = requireFunctionCall();
	var $actualApply = requireActualApply();

	/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */
	callBindApplyHelpers = function callBindBasic(args) {
		if (args.length < 1 || typeof args[0] !== 'function') {
			throw new $TypeError('a function is required');
		}
		return $actualApply(bind, $call, args);
	};
	return callBindApplyHelpers;
}

var get;
var hasRequiredGet;

function requireGet () {
	if (hasRequiredGet) return get;
	hasRequiredGet = 1;

	var callBind = requireCallBindApplyHelpers();
	var gOPD = /*@__PURE__*/ requireGopd();

	var hasProtoAccessor;
	try {
		// eslint-disable-next-line no-extra-parens, no-proto
		hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ ([]).__proto__ === Array.prototype;
	} catch (e) {
		if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
			throw e;
		}
	}

	// eslint-disable-next-line no-extra-parens
	var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, /** @type {keyof typeof Object.prototype} */ ('__proto__'));

	var $Object = Object;
	var $getPrototypeOf = $Object.getPrototypeOf;

	/** @type {import('./get')} */
	get = desc && typeof desc.get === 'function'
		? callBind([desc.get])
		: typeof $getPrototypeOf === 'function'
			? /** @type {import('./get')} */ function getDunder(value) {
				// eslint-disable-next-line eqeqeq
				return $getPrototypeOf(value == null ? value : $Object(value));
			}
			: false;
	return get;
}

var getProto;
var hasRequiredGetProto;

function requireGetProto () {
	if (hasRequiredGetProto) return getProto;
	hasRequiredGetProto = 1;

	var reflectGetProto = requireReflect_getPrototypeOf();
	var originalGetProto = requireObject_getPrototypeOf();

	var getDunderProto = /*@__PURE__*/ requireGet();

	/** @type {import('.')} */
	getProto = reflectGetProto
		? function getProto(O) {
			// @ts-expect-error TS can't narrow inside a closure, for some reason
			return reflectGetProto(O);
		}
		: originalGetProto
			? function getProto(O) {
				if (!O || (typeof O !== 'object' && typeof O !== 'function')) {
					throw new TypeError('getProto: not an object');
				}
				// @ts-expect-error TS can't narrow inside a closure, for some reason
				return originalGetProto(O);
			}
			: getDunderProto
				? function getProto(O) {
					// @ts-expect-error TS can't narrow inside a closure, for some reason
					return getDunderProto(O);
				}
				: null;
	return getProto;
}

var hasown;
var hasRequiredHasown;

function requireHasown () {
	if (hasRequiredHasown) return hasown;
	hasRequiredHasown = 1;

	var call = Function.prototype.call;
	var $hasOwn = Object.prototype.hasOwnProperty;
	var bind = requireFunctionBind();

	/** @type {import('.')} */
	hasown = bind.call(call, $hasOwn);
	return hasown;
}

var getIntrinsic;
var hasRequiredGetIntrinsic;

function requireGetIntrinsic () {
	if (hasRequiredGetIntrinsic) return getIntrinsic;
	hasRequiredGetIntrinsic = 1;

	var undefined$1;

	var $Object = /*@__PURE__*/ requireEsObjectAtoms();

	var $Error = /*@__PURE__*/ requireEsErrors();
	var $EvalError = /*@__PURE__*/ require_eval();
	var $RangeError = /*@__PURE__*/ requireRange();
	var $ReferenceError = /*@__PURE__*/ requireRef();
	var $SyntaxError = /*@__PURE__*/ requireSyntax();
	var $TypeError = /*@__PURE__*/ requireType();
	var $URIError = /*@__PURE__*/ requireUri();

	var abs = /*@__PURE__*/ requireAbs();
	var floor = /*@__PURE__*/ requireFloor();
	var max = /*@__PURE__*/ requireMax();
	var min = /*@__PURE__*/ requireMin();
	var pow = /*@__PURE__*/ requirePow();
	var round = /*@__PURE__*/ requireRound();
	var sign = /*@__PURE__*/ requireSign();

	var $Function = Function;

	// eslint-disable-next-line consistent-return
	var getEvalledConstructor = function (expressionSyntax) {
		try {
			return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
		} catch (e) {}
	};

	var $gOPD = /*@__PURE__*/ requireGopd();
	var $defineProperty = /*@__PURE__*/ requireEsDefineProperty();

	var throwTypeError = function () {
		throw new $TypeError();
	};
	var ThrowTypeError = $gOPD
		? (function () {
			try {
				// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
				arguments.callee; // IE 8 does not throw here
				return throwTypeError;
			} catch (calleeThrows) {
				try {
					// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
					return $gOPD(arguments, 'callee').get;
				} catch (gOPDthrows) {
					return throwTypeError;
				}
			}
		}())
		: throwTypeError;

	var hasSymbols = requireHasSymbols()();

	var getProto = requireGetProto();
	var $ObjectGPO = requireObject_getPrototypeOf();
	var $ReflectGPO = requireReflect_getPrototypeOf();

	var $apply = requireFunctionApply();
	var $call = requireFunctionCall();

	var needsEval = {};

	var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined$1 : getProto(Uint8Array);

	var INTRINSICS = {
		__proto__: null,
		'%AggregateError%': typeof AggregateError === 'undefined' ? undefined$1 : AggregateError,
		'%Array%': Array,
		'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer,
		'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
		'%AsyncFromSyncIteratorPrototype%': undefined$1,
		'%AsyncFunction%': needsEval,
		'%AsyncGenerator%': needsEval,
		'%AsyncGeneratorFunction%': needsEval,
		'%AsyncIteratorPrototype%': needsEval,
		'%Atomics%': typeof Atomics === 'undefined' ? undefined$1 : Atomics,
		'%BigInt%': typeof BigInt === 'undefined' ? undefined$1 : BigInt,
		'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined$1 : BigInt64Array,
		'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined$1 : BigUint64Array,
		'%Boolean%': Boolean,
		'%DataView%': typeof DataView === 'undefined' ? undefined$1 : DataView,
		'%Date%': Date,
		'%decodeURI%': decodeURI,
		'%decodeURIComponent%': decodeURIComponent,
		'%encodeURI%': encodeURI,
		'%encodeURIComponent%': encodeURIComponent,
		'%Error%': $Error,
		'%eval%': eval, // eslint-disable-line no-eval
		'%EvalError%': $EvalError,
		'%Float16Array%': typeof Float16Array === 'undefined' ? undefined$1 : Float16Array,
		'%Float32Array%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array,
		'%Float64Array%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array,
		'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined$1 : FinalizationRegistry,
		'%Function%': $Function,
		'%GeneratorFunction%': needsEval,
		'%Int8Array%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array,
		'%Int16Array%': typeof Int16Array === 'undefined' ? undefined$1 : Int16Array,
		'%Int32Array%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array,
		'%isFinite%': isFinite,
		'%isNaN%': isNaN,
		'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
		'%JSON%': typeof JSON === 'object' ? JSON : undefined$1,
		'%Map%': typeof Map === 'undefined' ? undefined$1 : Map,
		'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined$1 : getProto(new Map()[Symbol.iterator]()),
		'%Math%': Math,
		'%Number%': Number,
		'%Object%': $Object,
		'%Object.getOwnPropertyDescriptor%': $gOPD,
		'%parseFloat%': parseFloat,
		'%parseInt%': parseInt,
		'%Promise%': typeof Promise === 'undefined' ? undefined$1 : Promise,
		'%Proxy%': typeof Proxy === 'undefined' ? undefined$1 : Proxy,
		'%RangeError%': $RangeError,
		'%ReferenceError%': $ReferenceError,
		'%Reflect%': typeof Reflect === 'undefined' ? undefined$1 : Reflect,
		'%RegExp%': RegExp,
		'%Set%': typeof Set === 'undefined' ? undefined$1 : Set,
		'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined$1 : getProto(new Set()[Symbol.iterator]()),
		'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer,
		'%String%': String,
		'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined$1,
		'%Symbol%': hasSymbols ? Symbol : undefined$1,
		'%SyntaxError%': $SyntaxError,
		'%ThrowTypeError%': ThrowTypeError,
		'%TypedArray%': TypedArray,
		'%TypeError%': $TypeError,
		'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array,
		'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray,
		'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array,
		'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array,
		'%URIError%': $URIError,
		'%WeakMap%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap,
		'%WeakRef%': typeof WeakRef === 'undefined' ? undefined$1 : WeakRef,
		'%WeakSet%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet,

		'%Function.prototype.call%': $call,
		'%Function.prototype.apply%': $apply,
		'%Object.defineProperty%': $defineProperty,
		'%Object.getPrototypeOf%': $ObjectGPO,
		'%Math.abs%': abs,
		'%Math.floor%': floor,
		'%Math.max%': max,
		'%Math.min%': min,
		'%Math.pow%': pow,
		'%Math.round%': round,
		'%Math.sign%': sign,
		'%Reflect.getPrototypeOf%': $ReflectGPO
	};

	if (getProto) {
		try {
			null.error; // eslint-disable-line no-unused-expressions
		} catch (e) {
			// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
			var errorProto = getProto(getProto(e));
			INTRINSICS['%Error.prototype%'] = errorProto;
		}
	}

	var doEval = function doEval(name) {
		var value;
		if (name === '%AsyncFunction%') {
			value = getEvalledConstructor('async function () {}');
		} else if (name === '%GeneratorFunction%') {
			value = getEvalledConstructor('function* () {}');
		} else if (name === '%AsyncGeneratorFunction%') {
			value = getEvalledConstructor('async function* () {}');
		} else if (name === '%AsyncGenerator%') {
			var fn = doEval('%AsyncGeneratorFunction%');
			if (fn) {
				value = fn.prototype;
			}
		} else if (name === '%AsyncIteratorPrototype%') {
			var gen = doEval('%AsyncGenerator%');
			if (gen && getProto) {
				value = getProto(gen.prototype);
			}
		}

		INTRINSICS[name] = value;

		return value;
	};

	var LEGACY_ALIASES = {
		__proto__: null,
		'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
		'%ArrayPrototype%': ['Array', 'prototype'],
		'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
		'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
		'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
		'%ArrayProto_values%': ['Array', 'prototype', 'values'],
		'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
		'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
		'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
		'%BooleanPrototype%': ['Boolean', 'prototype'],
		'%DataViewPrototype%': ['DataView', 'prototype'],
		'%DatePrototype%': ['Date', 'prototype'],
		'%ErrorPrototype%': ['Error', 'prototype'],
		'%EvalErrorPrototype%': ['EvalError', 'prototype'],
		'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
		'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
		'%FunctionPrototype%': ['Function', 'prototype'],
		'%Generator%': ['GeneratorFunction', 'prototype'],
		'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
		'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
		'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
		'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
		'%JSONParse%': ['JSON', 'parse'],
		'%JSONStringify%': ['JSON', 'stringify'],
		'%MapPrototype%': ['Map', 'prototype'],
		'%NumberPrototype%': ['Number', 'prototype'],
		'%ObjectPrototype%': ['Object', 'prototype'],
		'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
		'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
		'%PromisePrototype%': ['Promise', 'prototype'],
		'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
		'%Promise_all%': ['Promise', 'all'],
		'%Promise_reject%': ['Promise', 'reject'],
		'%Promise_resolve%': ['Promise', 'resolve'],
		'%RangeErrorPrototype%': ['RangeError', 'prototype'],
		'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
		'%RegExpPrototype%': ['RegExp', 'prototype'],
		'%SetPrototype%': ['Set', 'prototype'],
		'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
		'%StringPrototype%': ['String', 'prototype'],
		'%SymbolPrototype%': ['Symbol', 'prototype'],
		'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
		'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
		'%TypeErrorPrototype%': ['TypeError', 'prototype'],
		'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
		'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
		'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
		'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
		'%URIErrorPrototype%': ['URIError', 'prototype'],
		'%WeakMapPrototype%': ['WeakMap', 'prototype'],
		'%WeakSetPrototype%': ['WeakSet', 'prototype']
	};

	var bind = requireFunctionBind();
	var hasOwn = /*@__PURE__*/ requireHasown();
	var $concat = bind.call($call, Array.prototype.concat);
	var $spliceApply = bind.call($apply, Array.prototype.splice);
	var $replace = bind.call($call, String.prototype.replace);
	var $strSlice = bind.call($call, String.prototype.slice);
	var $exec = bind.call($call, RegExp.prototype.exec);

	/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
	var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
	var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
	var stringToPath = function stringToPath(string) {
		var first = $strSlice(string, 0, 1);
		var last = $strSlice(string, -1);
		if (first === '%' && last !== '%') {
			throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
		} else if (last === '%' && first !== '%') {
			throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
		}
		var result = [];
		$replace(string, rePropName, function (match, number, quote, subString) {
			result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
		});
		return result;
	};
	/* end adaptation */

	var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
		var intrinsicName = name;
		var alias;
		if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
			alias = LEGACY_ALIASES[intrinsicName];
			intrinsicName = '%' + alias[0] + '%';
		}

		if (hasOwn(INTRINSICS, intrinsicName)) {
			var value = INTRINSICS[intrinsicName];
			if (value === needsEval) {
				value = doEval(intrinsicName);
			}
			if (typeof value === 'undefined' && !allowMissing) {
				throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
			}

			return {
				alias: alias,
				name: intrinsicName,
				value: value
			};
		}

		throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
	};

	getIntrinsic = function GetIntrinsic(name, allowMissing) {
		if (typeof name !== 'string' || name.length === 0) {
			throw new $TypeError('intrinsic name must be a non-empty string');
		}
		if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
			throw new $TypeError('"allowMissing" argument must be a boolean');
		}

		if ($exec(/^%?[^%]*%?$/, name) === null) {
			throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
		}
		var parts = stringToPath(name);
		var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

		var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
		var intrinsicRealName = intrinsic.name;
		var value = intrinsic.value;
		var skipFurtherCaching = false;

		var alias = intrinsic.alias;
		if (alias) {
			intrinsicBaseName = alias[0];
			$spliceApply(parts, $concat([0, 1], alias));
		}

		for (var i = 1, isOwn = true; i < parts.length; i += 1) {
			var part = parts[i];
			var first = $strSlice(part, 0, 1);
			var last = $strSlice(part, -1);
			if (
				(
					(first === '"' || first === "'" || first === '`')
					|| (last === '"' || last === "'" || last === '`')
				)
				&& first !== last
			) {
				throw new $SyntaxError('property names with quotes must have matching quotes');
			}
			if (part === 'constructor' || !isOwn) {
				skipFurtherCaching = true;
			}

			intrinsicBaseName += '.' + part;
			intrinsicRealName = '%' + intrinsicBaseName + '%';

			if (hasOwn(INTRINSICS, intrinsicRealName)) {
				value = INTRINSICS[intrinsicRealName];
			} else if (value != null) {
				if (!(part in value)) {
					if (!allowMissing) {
						throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
					}
					return void undefined$1;
				}
				if ($gOPD && (i + 1) >= parts.length) {
					var desc = $gOPD(value, part);
					isOwn = !!desc;

					// By convention, when a data property is converted to an accessor
					// property to emulate a data property that does not suffer from
					// the override mistake, that accessor's getter is marked with
					// an `originalValue` property. Here, when we detect this, we
					// uphold the illusion by pretending to see that original data
					// property, i.e., returning the value rather than the getter
					// itself.
					if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
						value = desc.get;
					} else {
						value = value[part];
					}
				} else {
					isOwn = hasOwn(value, part);
					value = value[part];
				}

				if (isOwn && !skipFurtherCaching) {
					INTRINSICS[intrinsicRealName] = value;
				}
			}
		}
		return value;
	};
	return getIntrinsic;
}

var callBound;
var hasRequiredCallBound;

function requireCallBound () {
	if (hasRequiredCallBound) return callBound;
	hasRequiredCallBound = 1;

	var GetIntrinsic = /*@__PURE__*/ requireGetIntrinsic();

	var callBindBasic = requireCallBindApplyHelpers();

	/** @type {(thisArg: string, searchString: string, position?: number) => number} */
	var $indexOf = callBindBasic([GetIntrinsic('%String.prototype.indexOf%')]);

	/** @type {import('.')} */
	callBound = function callBoundIntrinsic(name, allowMissing) {
		/* eslint no-extra-parens: 0 */

		var intrinsic = /** @type {(this: unknown, ...args: unknown[]) => unknown} */ (GetIntrinsic(name, !!allowMissing));
		if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
			return callBindBasic(/** @type {const} */ ([intrinsic]));
		}
		return intrinsic;
	};
	return callBound;
}

var isArguments;
var hasRequiredIsArguments;

function requireIsArguments () {
	if (hasRequiredIsArguments) return isArguments;
	hasRequiredIsArguments = 1;

	var hasToStringTag = requireShams()();
	var callBound = /*@__PURE__*/ requireCallBound();

	var $toString = callBound('Object.prototype.toString');

	/** @type {import('.')} */
	var isStandardArguments = function isArguments(value) {
		if (
			hasToStringTag
			&& value
			&& typeof value === 'object'
			&& Symbol.toStringTag in value
		) {
			return false;
		}
		return $toString(value) === '[object Arguments]';
	};

	/** @type {import('.')} */
	var isLegacyArguments = function isArguments(value) {
		if (isStandardArguments(value)) {
			return true;
		}
		return value !== null
			&& typeof value === 'object'
			&& 'length' in value
			&& typeof value.length === 'number'
			&& value.length >= 0
			&& $toString(value) !== '[object Array]'
			&& 'callee' in value
			&& $toString(value.callee) === '[object Function]';
	};

	var supportsStandardArguments = (function () {
		return isStandardArguments(arguments);
	}());

	// @ts-expect-error TODO make this not error
	isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

	/** @type {import('.')} */
	isArguments = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
	return isArguments;
}

var isRegex;
var hasRequiredIsRegex;

function requireIsRegex () {
	if (hasRequiredIsRegex) return isRegex;
	hasRequiredIsRegex = 1;

	var callBound = /*@__PURE__*/ requireCallBound();
	var hasToStringTag = requireShams()();
	var hasOwn = /*@__PURE__*/ requireHasown();
	var gOPD = /*@__PURE__*/ requireGopd();

	/** @type {import('.')} */
	var fn;

	if (hasToStringTag) {
		/** @type {(receiver: ThisParameterType<typeof RegExp.prototype.exec>, ...args: Parameters<typeof RegExp.prototype.exec>) => ReturnType<typeof RegExp.prototype.exec>} */
		var $exec = callBound('RegExp.prototype.exec');
		/** @type {object} */
		var isRegexMarker = {};

		var throwRegexMarker = function () {
			throw isRegexMarker;
		};
		/** @type {{ toString(): never, valueOf(): never, [Symbol.toPrimitive]?(): never }} */
		var badStringifier = {
			toString: throwRegexMarker,
			valueOf: throwRegexMarker
		};

		if (typeof Symbol.toPrimitive === 'symbol') {
			badStringifier[Symbol.toPrimitive] = throwRegexMarker;
		}

		/** @type {import('.')} */
		// @ts-expect-error TS can't figure out that the $exec call always throws
		// eslint-disable-next-line consistent-return
		fn = function isRegex(value) {
			if (!value || typeof value !== 'object') {
				return false;
			}

			// eslint-disable-next-line no-extra-parens
			var descriptor = /** @type {NonNullable<typeof gOPD>} */ (gOPD)(/** @type {{ lastIndex?: unknown }} */ (value), 'lastIndex');
			var hasLastIndexDataProperty = descriptor && hasOwn(descriptor, 'value');
			if (!hasLastIndexDataProperty) {
				return false;
			}

			try {
				// eslint-disable-next-line no-extra-parens
				$exec(value, /** @type {string} */ (/** @type {unknown} */ (badStringifier)));
			} catch (e) {
				return e === isRegexMarker;
			}
		};
	} else {
		/** @type {(receiver: ThisParameterType<typeof Object.prototype.toString>, ...args: Parameters<typeof Object.prototype.toString>) => ReturnType<typeof Object.prototype.toString>} */
		var $toString = callBound('Object.prototype.toString');
		/** @const @type {'[object RegExp]'} */
		var regexClass = '[object RegExp]';

		/** @type {import('.')} */
		fn = function isRegex(value) {
			// In older browsers, typeof regex incorrectly returns 'function'
			if (!value || (typeof value !== 'object' && typeof value !== 'function')) {
				return false;
			}

			return $toString(value) === regexClass;
		};
	}

	isRegex = fn;
	return isRegex;
}

var safeRegexTest;
var hasRequiredSafeRegexTest;

function requireSafeRegexTest () {
	if (hasRequiredSafeRegexTest) return safeRegexTest;
	hasRequiredSafeRegexTest = 1;

	var callBound = /*@__PURE__*/ requireCallBound();
	var isRegex = requireIsRegex();

	var $exec = callBound('RegExp.prototype.exec');
	var $TypeError = /*@__PURE__*/ requireType();

	/** @type {import('.')} */
	safeRegexTest = function regexTester(regex) {
		if (!isRegex(regex)) {
			throw new $TypeError('`regex` must be a RegExp');
		}
		return function test(s) {
			return $exec(regex, s) !== null;
		};
	};
	return safeRegexTest;
}

var generatorFunction;
var hasRequiredGeneratorFunction;

function requireGeneratorFunction () {
	if (hasRequiredGeneratorFunction) return generatorFunction;
	hasRequiredGeneratorFunction = 1;

	// eslint-disable-next-line no-extra-parens, no-empty-function
	const cached = /** @type {GeneratorFunctionConstructor} */ (function* () {}.constructor);

	/** @type {import('.')} */
	generatorFunction = () => cached;
	return generatorFunction;
}

var isGeneratorFunction;
var hasRequiredIsGeneratorFunction;

function requireIsGeneratorFunction () {
	if (hasRequiredIsGeneratorFunction) return isGeneratorFunction;
	hasRequiredIsGeneratorFunction = 1;

	var callBound = /*@__PURE__*/ requireCallBound();
	var safeRegexTest = /*@__PURE__*/ requireSafeRegexTest();
	var isFnRegex = safeRegexTest(/^\s*(?:function)?\*/);
	var hasToStringTag = requireShams()();
	var getProto = requireGetProto();

	var toStr = callBound('Object.prototype.toString');
	var fnToStr = callBound('Function.prototype.toString');

	var getGeneratorFunction = /*@__PURE__*/ requireGeneratorFunction();

	/** @type {import('.')} */
	isGeneratorFunction = function isGeneratorFunction(fn) {
		if (typeof fn !== 'function') {
			return false;
		}
		if (isFnRegex(fnToStr(fn))) {
			return true;
		}
		if (!hasToStringTag) {
			var str = toStr(fn);
			return str === '[object GeneratorFunction]';
		}
		if (!getProto) {
			return false;
		}
		var GeneratorFunction = getGeneratorFunction();
		return GeneratorFunction && getProto(fn) === GeneratorFunction.prototype;
	};
	return isGeneratorFunction;
}

var isCallable;
var hasRequiredIsCallable;

function requireIsCallable () {
	if (hasRequiredIsCallable) return isCallable;
	hasRequiredIsCallable = 1;
	var fnToStr = Function.prototype.toString;
	var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
	var badArrayLike;
	var isCallableMarker;
	if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
	  try {
	    badArrayLike = Object.defineProperty({}, "length", {
	      get: function() {
	        throw isCallableMarker;
	      }
	    });
	    isCallableMarker = {};
	    reflectApply(function() {
	      throw 42;
	    }, null, badArrayLike);
	  } catch (_) {
	    if (_ !== isCallableMarker) {
	      reflectApply = null;
	    }
	  }
	} else {
	  reflectApply = null;
	}
	var constructorRegex = /^\s*class\b/;
	var isES6ClassFn = function isES6ClassFunction(value) {
	  try {
	    var fnStr = fnToStr.call(value);
	    return constructorRegex.test(fnStr);
	  } catch (e) {
	    return false;
	  }
	};
	var tryFunctionObject = function tryFunctionToStr(value) {
	  try {
	    if (isES6ClassFn(value)) {
	      return false;
	    }
	    fnToStr.call(value);
	    return true;
	  } catch (e) {
	    return false;
	  }
	};
	var toStr = Object.prototype.toString;
	var objectClass = "[object Object]";
	var fnClass = "[object Function]";
	var genClass = "[object GeneratorFunction]";
	var ddaClass = "[object HTMLAllCollection]";
	var ddaClass2 = "[object HTML document.all class]";
	var ddaClass3 = "[object HTMLCollection]";
	var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
	var isIE68 = !(0 in [,]);
	var isDDA = function isDocumentDotAll() {
	  return false;
	};
	if (typeof document === "object") {
	  var all = document.all;
	  if (toStr.call(all) === toStr.call(document.all)) {
	    isDDA = function isDocumentDotAll2(value) {
	      if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
	        try {
	          var str = toStr.call(value);
	          return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
	        } catch (e) {
	        }
	      }
	      return false;
	    };
	  }
	}
	isCallable = reflectApply ? function isCallable(value) {
	  if (isDDA(value)) {
	    return true;
	  }
	  if (!value) {
	    return false;
	  }
	  if (typeof value !== "function" && typeof value !== "object") {
	    return false;
	  }
	  try {
	    reflectApply(value, null, badArrayLike);
	  } catch (e) {
	    if (e !== isCallableMarker) {
	      return false;
	    }
	  }
	  return !isES6ClassFn(value) && tryFunctionObject(value);
	} : function isCallable2(value) {
	  if (isDDA(value)) {
	    return true;
	  }
	  if (!value) {
	    return false;
	  }
	  if (typeof value !== "function" && typeof value !== "object") {
	    return false;
	  }
	  if (hasToStringTag) {
	    return tryFunctionObject(value);
	  }
	  if (isES6ClassFn(value)) {
	    return false;
	  }
	  var strClass = toStr.call(value);
	  if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
	    return false;
	  }
	  return tryFunctionObject(value);
	};
	return isCallable;
}

var forEach;
var hasRequiredForEach;

function requireForEach () {
	if (hasRequiredForEach) return forEach;
	hasRequiredForEach = 1;

	var isCallable = requireIsCallable();

	var toStr = Object.prototype.toString;
	var hasOwnProperty = Object.prototype.hasOwnProperty;

	/** @type {<This, A extends readonly unknown[]>(arr: A, iterator: (this: This | void, value: A[number], index: number, arr: A) => void, receiver: This | undefined) => void} */
	var forEachArray = function forEachArray(array, iterator, receiver) {
	    for (var i = 0, len = array.length; i < len; i++) {
	        if (hasOwnProperty.call(array, i)) {
	            if (receiver == null) {
	                iterator(array[i], i, array);
	            } else {
	                iterator.call(receiver, array[i], i, array);
	            }
	        }
	    }
	};

	/** @type {<This, S extends string>(string: S, iterator: (this: This | void, value: S[number], index: number, string: S) => void, receiver: This | undefined) => void} */
	var forEachString = function forEachString(string, iterator, receiver) {
	    for (var i = 0, len = string.length; i < len; i++) {
	        // no such thing as a sparse string.
	        if (receiver == null) {
	            iterator(string.charAt(i), i, string);
	        } else {
	            iterator.call(receiver, string.charAt(i), i, string);
	        }
	    }
	};

	/** @type {<This, O>(obj: O, iterator: (this: This | void, value: O[keyof O], index: keyof O, obj: O) => void, receiver: This | undefined) => void} */
	var forEachObject = function forEachObject(object, iterator, receiver) {
	    for (var k in object) {
	        if (hasOwnProperty.call(object, k)) {
	            if (receiver == null) {
	                iterator(object[k], k, object);
	            } else {
	                iterator.call(receiver, object[k], k, object);
	            }
	        }
	    }
	};

	/** @type {(x: unknown) => x is readonly unknown[]} */
	function isArray(x) {
	    return toStr.call(x) === '[object Array]';
	}

	/** @type {import('.')._internal} */
	forEach = function forEach(list, iterator, thisArg) {
	    if (!isCallable(iterator)) {
	        throw new TypeError('iterator must be a function');
	    }

	    var receiver;
	    if (arguments.length >= 3) {
	        receiver = thisArg;
	    }

	    if (isArray(list)) {
	        forEachArray(list, iterator, receiver);
	    } else if (typeof list === 'string') {
	        forEachString(list, iterator, receiver);
	    } else {
	        forEachObject(list, iterator, receiver);
	    }
	};
	return forEach;
}

var possibleTypedArrayNames;
var hasRequiredPossibleTypedArrayNames;

function requirePossibleTypedArrayNames () {
	if (hasRequiredPossibleTypedArrayNames) return possibleTypedArrayNames;
	hasRequiredPossibleTypedArrayNames = 1;

	/** @type {import('.')} */
	possibleTypedArrayNames = [
		'Float16Array',
		'Float32Array',
		'Float64Array',
		'Int8Array',
		'Int16Array',
		'Int32Array',
		'Uint8Array',
		'Uint8ClampedArray',
		'Uint16Array',
		'Uint32Array',
		'BigInt64Array',
		'BigUint64Array'
	];
	return possibleTypedArrayNames;
}

var availableTypedArrays;
var hasRequiredAvailableTypedArrays;

function requireAvailableTypedArrays () {
	if (hasRequiredAvailableTypedArrays) return availableTypedArrays;
	hasRequiredAvailableTypedArrays = 1;
	var possibleNames = /*@__PURE__*/ requirePossibleTypedArrayNames();
	var g = typeof globalThis === "undefined" ? globalThis : globalThis;
	availableTypedArrays = function availableTypedArrays() {
	  var out = [];
	  for (var i = 0; i < possibleNames.length; i++) {
	    if (typeof g[possibleNames[i]] === "function") {
	      out[out.length] = possibleNames[i];
	    }
	  }
	  return out;
	};
	return availableTypedArrays;
}

var callBind = {exports: {}};

var defineDataProperty;
var hasRequiredDefineDataProperty;

function requireDefineDataProperty () {
	if (hasRequiredDefineDataProperty) return defineDataProperty;
	hasRequiredDefineDataProperty = 1;

	var $defineProperty = /*@__PURE__*/ requireEsDefineProperty();

	var $SyntaxError = /*@__PURE__*/ requireSyntax();
	var $TypeError = /*@__PURE__*/ requireType();

	var gopd = /*@__PURE__*/ requireGopd();

	/** @type {import('.')} */
	defineDataProperty = function defineDataProperty(
		obj,
		property,
		value
	) {
		if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
			throw new $TypeError('`obj` must be an object or a function`');
		}
		if (typeof property !== 'string' && typeof property !== 'symbol') {
			throw new $TypeError('`property` must be a string or a symbol`');
		}
		if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
			throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
		}
		if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
			throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
		}
		if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
			throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
		}
		if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
			throw new $TypeError('`loose`, if provided, must be a boolean');
		}

		var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
		var nonWritable = arguments.length > 4 ? arguments[4] : null;
		var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
		var loose = arguments.length > 6 ? arguments[6] : false;

		/* @type {false | TypedPropertyDescriptor<unknown>} */
		var desc = !!gopd && gopd(obj, property);

		if ($defineProperty) {
			$defineProperty(obj, property, {
				configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
				enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
				value: value,
				writable: nonWritable === null && desc ? desc.writable : !nonWritable
			});
		} else if (loose || (!nonEnumerable && !nonWritable && !nonConfigurable)) {
			// must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
			obj[property] = value; // eslint-disable-line no-param-reassign
		} else {
			throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
		}
	};
	return defineDataProperty;
}

var hasPropertyDescriptors_1;
var hasRequiredHasPropertyDescriptors;

function requireHasPropertyDescriptors () {
	if (hasRequiredHasPropertyDescriptors) return hasPropertyDescriptors_1;
	hasRequiredHasPropertyDescriptors = 1;

	var $defineProperty = /*@__PURE__*/ requireEsDefineProperty();

	var hasPropertyDescriptors = function hasPropertyDescriptors() {
		return !!$defineProperty;
	};

	hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
		// node v0.6 has a bug where array lengths can be Set but not Defined
		if (!$defineProperty) {
			return null;
		}
		try {
			return $defineProperty([], 'length', { value: 1 }).length !== 1;
		} catch (e) {
			// In Firefox 4-22, defining length on an array throws an exception.
			return true;
		}
	};

	hasPropertyDescriptors_1 = hasPropertyDescriptors;
	return hasPropertyDescriptors_1;
}

var setFunctionLength;
var hasRequiredSetFunctionLength;

function requireSetFunctionLength () {
	if (hasRequiredSetFunctionLength) return setFunctionLength;
	hasRequiredSetFunctionLength = 1;

	var GetIntrinsic = /*@__PURE__*/ requireGetIntrinsic();
	var define = /*@__PURE__*/ requireDefineDataProperty();
	var hasDescriptors = /*@__PURE__*/ requireHasPropertyDescriptors()();
	var gOPD = /*@__PURE__*/ requireGopd();

	var $TypeError = /*@__PURE__*/ requireType();
	var $floor = GetIntrinsic('%Math.floor%');

	/** @type {import('.')} */
	setFunctionLength = function setFunctionLength(fn, length) {
		if (typeof fn !== 'function') {
			throw new $TypeError('`fn` is not a function');
		}
		if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
			throw new $TypeError('`length` must be a positive 32-bit integer');
		}

		var loose = arguments.length > 2 && !!arguments[2];

		var functionLengthIsConfigurable = true;
		var functionLengthIsWritable = true;
		if ('length' in fn && gOPD) {
			var desc = gOPD(fn, 'length');
			if (desc && !desc.configurable) {
				functionLengthIsConfigurable = false;
			}
			if (desc && !desc.writable) {
				functionLengthIsWritable = false;
			}
		}

		if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
			if (hasDescriptors) {
				define(/** @type {Parameters<define>[0]} */ (fn), 'length', length, true, true);
			} else {
				define(/** @type {Parameters<define>[0]} */ (fn), 'length', length);
			}
		}
		return fn;
	};
	return setFunctionLength;
}

var applyBind;
var hasRequiredApplyBind;

function requireApplyBind () {
	if (hasRequiredApplyBind) return applyBind;
	hasRequiredApplyBind = 1;

	var bind = requireFunctionBind();
	var $apply = requireFunctionApply();
	var actualApply = requireActualApply();

	/** @type {import('./applyBind')} */
	applyBind = function applyBind() {
		return actualApply(bind, $apply, arguments);
	};
	return applyBind;
}

var hasRequiredCallBind;

function requireCallBind () {
	if (hasRequiredCallBind) return callBind.exports;
	hasRequiredCallBind = 1;
	(function (module) {

		var setFunctionLength = /*@__PURE__*/ requireSetFunctionLength();

		var $defineProperty = /*@__PURE__*/ requireEsDefineProperty();

		var callBindBasic = requireCallBindApplyHelpers();
		var applyBind = requireApplyBind();

		module.exports = function callBind(originalFunction) {
			var func = callBindBasic(arguments);
			var adjustedLength = originalFunction.length - (arguments.length - 1);
			return setFunctionLength(
				func,
				1 + (adjustedLength > 0 ? adjustedLength : 0),
				true
			);
		};

		if ($defineProperty) {
			$defineProperty(module.exports, 'apply', { value: applyBind });
		} else {
			module.exports.apply = applyBind;
		} 
	} (callBind));
	return callBind.exports;
}

var whichTypedArray;
var hasRequiredWhichTypedArray;

function requireWhichTypedArray () {
	if (hasRequiredWhichTypedArray) return whichTypedArray;
	hasRequiredWhichTypedArray = 1;
	var forEach = requireForEach();
	var availableTypedArrays = /*@__PURE__*/ requireAvailableTypedArrays();
	var callBind = requireCallBind();
	var callBound = /*@__PURE__*/ requireCallBound();
	var gOPD = /*@__PURE__*/ requireGopd();
	var getProto = requireGetProto();
	var $toString = callBound("Object.prototype.toString");
	var hasToStringTag = requireShams()();
	var g = typeof globalThis === "undefined" ? globalThis : globalThis;
	var typedArrays = availableTypedArrays();
	var $slice = callBound("String.prototype.slice");
	var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
	  for (var i = 0; i < array.length; i += 1) {
	    if (array[i] === value) {
	      return i;
	    }
	  }
	  return -1;
	};
	var cache = { __proto__: null };
	if (hasToStringTag && gOPD && getProto) {
	  forEach(typedArrays, function(typedArray) {
	    var arr = new g[typedArray]();
	    if (Symbol.toStringTag in arr && getProto) {
	      var proto = getProto(arr);
	      var descriptor = gOPD(proto, Symbol.toStringTag);
	      if (!descriptor && proto) {
	        var superProto = getProto(proto);
	        descriptor = gOPD(superProto, Symbol.toStringTag);
	      }
	      if (descriptor && descriptor.get) {
	        var bound = callBind(descriptor.get);
	        cache[
	          /** @type {`$${import('.').TypedArrayName}`} */
	          "$" + typedArray
	        ] = bound;
	      }
	    }
	  });
	} else {
	  forEach(typedArrays, function(typedArray) {
	    var arr = new g[typedArray]();
	    var fn = arr.slice || arr.set;
	    if (fn) {
	      var bound = (
	        /** @type {import('./types').BoundSlice | import('./types').BoundSet} */
	        // @ts-expect-error TODO FIXME
	        callBind(fn)
	      );
	      cache[
	        /** @type {`$${import('.').TypedArrayName}`} */
	        "$" + typedArray
	      ] = bound;
	    }
	  });
	}
	var tryTypedArrays = function tryAllTypedArrays(value) {
	  var found = false;
	  forEach(
	    /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
	    cache,
	    /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
	    function(getter, typedArray) {
	      if (!found) {
	        try {
	          if ("$" + getter(value) === typedArray) {
	            found = /** @type {import('.').TypedArrayName} */
	            $slice(typedArray, 1);
	          }
	        } catch (e) {
	        }
	      }
	    }
	  );
	  return found;
	};
	var trySlices = function tryAllSlices(value) {
	  var found = false;
	  forEach(
	    /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
	    cache,
	    /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
	    function(getter, name) {
	      if (!found) {
	        try {
	          getter(value);
	          found = /** @type {import('.').TypedArrayName} */
	          $slice(name, 1);
	        } catch (e) {
	        }
	      }
	    }
	  );
	  return found;
	};
	whichTypedArray = function whichTypedArray(value) {
	  if (!value || typeof value !== "object") {
	    return false;
	  }
	  if (!hasToStringTag) {
	    var tag = $slice($toString(value), 8, -1);
	    if ($indexOf(typedArrays, tag) > -1) {
	      return tag;
	    }
	    if (tag !== "Object") {
	      return false;
	    }
	    return trySlices(value);
	  }
	  if (!gOPD) {
	    return null;
	  }
	  return tryTypedArrays(value);
	};
	return whichTypedArray;
}

var isTypedArray;
var hasRequiredIsTypedArray;

function requireIsTypedArray () {
	if (hasRequiredIsTypedArray) return isTypedArray;
	hasRequiredIsTypedArray = 1;

	var whichTypedArray = /*@__PURE__*/ requireWhichTypedArray();

	/** @type {import('.')} */
	isTypedArray = function isTypedArray(value) {
		return !!whichTypedArray(value);
	};
	return isTypedArray;
}

var hasRequiredTypes;

function requireTypes () {
	if (hasRequiredTypes) return types;
	hasRequiredTypes = 1;
	(function (exports$1) {

		var isArgumentsObject = /*@__PURE__*/ requireIsArguments();
		var isGeneratorFunction = requireIsGeneratorFunction();
		var whichTypedArray = /*@__PURE__*/ requireWhichTypedArray();
		var isTypedArray = /*@__PURE__*/ requireIsTypedArray();

		function uncurryThis(f) {
		  return f.call.bind(f);
		}

		var BigIntSupported = typeof BigInt !== 'undefined';
		var SymbolSupported = typeof Symbol !== 'undefined';

		var ObjectToString = uncurryThis(Object.prototype.toString);

		var numberValue = uncurryThis(Number.prototype.valueOf);
		var stringValue = uncurryThis(String.prototype.valueOf);
		var booleanValue = uncurryThis(Boolean.prototype.valueOf);

		if (BigIntSupported) {
		  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
		}

		if (SymbolSupported) {
		  var symbolValue = uncurryThis(Symbol.prototype.valueOf);
		}

		function checkBoxedPrimitive(value, prototypeValueOf) {
		  if (typeof value !== 'object') {
		    return false;
		  }
		  try {
		    prototypeValueOf(value);
		    return true;
		  } catch(e) {
		    return false;
		  }
		}

		exports$1.isArgumentsObject = isArgumentsObject;
		exports$1.isGeneratorFunction = isGeneratorFunction;
		exports$1.isTypedArray = isTypedArray;

		// Taken from here and modified for better browser support
		// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
		function isPromise(input) {
			return (
				(
					typeof Promise !== 'undefined' &&
					input instanceof Promise
				) ||
				(
					input !== null &&
					typeof input === 'object' &&
					typeof input.then === 'function' &&
					typeof input.catch === 'function'
				)
			);
		}
		exports$1.isPromise = isPromise;

		function isArrayBufferView(value) {
		  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
		    return ArrayBuffer.isView(value);
		  }

		  return (
		    isTypedArray(value) ||
		    isDataView(value)
		  );
		}
		exports$1.isArrayBufferView = isArrayBufferView;


		function isUint8Array(value) {
		  return whichTypedArray(value) === 'Uint8Array';
		}
		exports$1.isUint8Array = isUint8Array;

		function isUint8ClampedArray(value) {
		  return whichTypedArray(value) === 'Uint8ClampedArray';
		}
		exports$1.isUint8ClampedArray = isUint8ClampedArray;

		function isUint16Array(value) {
		  return whichTypedArray(value) === 'Uint16Array';
		}
		exports$1.isUint16Array = isUint16Array;

		function isUint32Array(value) {
		  return whichTypedArray(value) === 'Uint32Array';
		}
		exports$1.isUint32Array = isUint32Array;

		function isInt8Array(value) {
		  return whichTypedArray(value) === 'Int8Array';
		}
		exports$1.isInt8Array = isInt8Array;

		function isInt16Array(value) {
		  return whichTypedArray(value) === 'Int16Array';
		}
		exports$1.isInt16Array = isInt16Array;

		function isInt32Array(value) {
		  return whichTypedArray(value) === 'Int32Array';
		}
		exports$1.isInt32Array = isInt32Array;

		function isFloat32Array(value) {
		  return whichTypedArray(value) === 'Float32Array';
		}
		exports$1.isFloat32Array = isFloat32Array;

		function isFloat64Array(value) {
		  return whichTypedArray(value) === 'Float64Array';
		}
		exports$1.isFloat64Array = isFloat64Array;

		function isBigInt64Array(value) {
		  return whichTypedArray(value) === 'BigInt64Array';
		}
		exports$1.isBigInt64Array = isBigInt64Array;

		function isBigUint64Array(value) {
		  return whichTypedArray(value) === 'BigUint64Array';
		}
		exports$1.isBigUint64Array = isBigUint64Array;

		function isMapToString(value) {
		  return ObjectToString(value) === '[object Map]';
		}
		isMapToString.working = (
		  typeof Map !== 'undefined' &&
		  isMapToString(new Map())
		);

		function isMap(value) {
		  if (typeof Map === 'undefined') {
		    return false;
		  }

		  return isMapToString.working
		    ? isMapToString(value)
		    : value instanceof Map;
		}
		exports$1.isMap = isMap;

		function isSetToString(value) {
		  return ObjectToString(value) === '[object Set]';
		}
		isSetToString.working = (
		  typeof Set !== 'undefined' &&
		  isSetToString(new Set())
		);
		function isSet(value) {
		  if (typeof Set === 'undefined') {
		    return false;
		  }

		  return isSetToString.working
		    ? isSetToString(value)
		    : value instanceof Set;
		}
		exports$1.isSet = isSet;

		function isWeakMapToString(value) {
		  return ObjectToString(value) === '[object WeakMap]';
		}
		isWeakMapToString.working = (
		  typeof WeakMap !== 'undefined' &&
		  isWeakMapToString(new WeakMap())
		);
		function isWeakMap(value) {
		  if (typeof WeakMap === 'undefined') {
		    return false;
		  }

		  return isWeakMapToString.working
		    ? isWeakMapToString(value)
		    : value instanceof WeakMap;
		}
		exports$1.isWeakMap = isWeakMap;

		function isWeakSetToString(value) {
		  return ObjectToString(value) === '[object WeakSet]';
		}
		isWeakSetToString.working = (
		  typeof WeakSet !== 'undefined' &&
		  isWeakSetToString(new WeakSet())
		);
		function isWeakSet(value) {
		  return isWeakSetToString(value);
		}
		exports$1.isWeakSet = isWeakSet;

		function isArrayBufferToString(value) {
		  return ObjectToString(value) === '[object ArrayBuffer]';
		}
		isArrayBufferToString.working = (
		  typeof ArrayBuffer !== 'undefined' &&
		  isArrayBufferToString(new ArrayBuffer())
		);
		function isArrayBuffer(value) {
		  if (typeof ArrayBuffer === 'undefined') {
		    return false;
		  }

		  return isArrayBufferToString.working
		    ? isArrayBufferToString(value)
		    : value instanceof ArrayBuffer;
		}
		exports$1.isArrayBuffer = isArrayBuffer;

		function isDataViewToString(value) {
		  return ObjectToString(value) === '[object DataView]';
		}
		isDataViewToString.working = (
		  typeof ArrayBuffer !== 'undefined' &&
		  typeof DataView !== 'undefined' &&
		  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))
		);
		function isDataView(value) {
		  if (typeof DataView === 'undefined') {
		    return false;
		  }

		  return isDataViewToString.working
		    ? isDataViewToString(value)
		    : value instanceof DataView;
		}
		exports$1.isDataView = isDataView;

		// Store a copy of SharedArrayBuffer in case it's deleted elsewhere
		var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
		function isSharedArrayBufferToString(value) {
		  return ObjectToString(value) === '[object SharedArrayBuffer]';
		}
		function isSharedArrayBuffer(value) {
		  if (typeof SharedArrayBufferCopy === 'undefined') {
		    return false;
		  }

		  if (typeof isSharedArrayBufferToString.working === 'undefined') {
		    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
		  }

		  return isSharedArrayBufferToString.working
		    ? isSharedArrayBufferToString(value)
		    : value instanceof SharedArrayBufferCopy;
		}
		exports$1.isSharedArrayBuffer = isSharedArrayBuffer;

		function isAsyncFunction(value) {
		  return ObjectToString(value) === '[object AsyncFunction]';
		}
		exports$1.isAsyncFunction = isAsyncFunction;

		function isMapIterator(value) {
		  return ObjectToString(value) === '[object Map Iterator]';
		}
		exports$1.isMapIterator = isMapIterator;

		function isSetIterator(value) {
		  return ObjectToString(value) === '[object Set Iterator]';
		}
		exports$1.isSetIterator = isSetIterator;

		function isGeneratorObject(value) {
		  return ObjectToString(value) === '[object Generator]';
		}
		exports$1.isGeneratorObject = isGeneratorObject;

		function isWebAssemblyCompiledModule(value) {
		  return ObjectToString(value) === '[object WebAssembly.Module]';
		}
		exports$1.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

		function isNumberObject(value) {
		  return checkBoxedPrimitive(value, numberValue);
		}
		exports$1.isNumberObject = isNumberObject;

		function isStringObject(value) {
		  return checkBoxedPrimitive(value, stringValue);
		}
		exports$1.isStringObject = isStringObject;

		function isBooleanObject(value) {
		  return checkBoxedPrimitive(value, booleanValue);
		}
		exports$1.isBooleanObject = isBooleanObject;

		function isBigIntObject(value) {
		  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
		}
		exports$1.isBigIntObject = isBigIntObject;

		function isSymbolObject(value) {
		  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
		}
		exports$1.isSymbolObject = isSymbolObject;

		function isBoxedPrimitive(value) {
		  return (
		    isNumberObject(value) ||
		    isStringObject(value) ||
		    isBooleanObject(value) ||
		    isBigIntObject(value) ||
		    isSymbolObject(value)
		  );
		}
		exports$1.isBoxedPrimitive = isBoxedPrimitive;

		function isAnyArrayBuffer(value) {
		  return typeof Uint8Array !== 'undefined' && (
		    isArrayBuffer(value) ||
		    isSharedArrayBuffer(value)
		  );
		}
		exports$1.isAnyArrayBuffer = isAnyArrayBuffer;

		['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {
		  Object.defineProperty(exports$1, method, {
		    enumerable: false,
		    value: function() {
		      throw new Error(method + ' is not supported in userland');
		    }
		  });
		}); 
	} (types));
	return types;
}

var isBuffer;
var hasRequiredIsBuffer;

function requireIsBuffer () {
	if (hasRequiredIsBuffer) return isBuffer;
	hasRequiredIsBuffer = 1;
	isBuffer = function isBuffer(arg) {
	  return arg instanceof Buffer$1;
	};
	return isBuffer;
}

var hasRequiredUtil;

function requireUtil () {
	if (hasRequiredUtil) return util;
	hasRequiredUtil = 1;
	(function (exports$1) {
		// Copyright Joyent, Inc. and other Node contributors.
		//
		// Permission is hereby granted, free of charge, to any person obtaining a
		// copy of this software and associated documentation files (the
		// "Software"), to deal in the Software without restriction, including
		// without limitation the rights to use, copy, modify, merge, publish,
		// distribute, sublicense, and/or sell copies of the Software, and to permit
		// persons to whom the Software is furnished to do so, subject to the
		// following conditions:
		//
		// The above copyright notice and this permission notice shall be included
		// in all copies or substantial portions of the Software.
		//
		// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
		// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
		// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
		// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
		// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
		// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
		// USE OR OTHER DEALINGS IN THE SOFTWARE.

		var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
		  function getOwnPropertyDescriptors(obj) {
		    var keys = Object.keys(obj);
		    var descriptors = {};
		    for (var i = 0; i < keys.length; i++) {
		      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
		    }
		    return descriptors;
		  };

		var formatRegExp = /%[sdj%]/g;
		exports$1.format = function(f) {
		  if (!isString(f)) {
		    var objects = [];
		    for (var i = 0; i < arguments.length; i++) {
		      objects.push(inspect(arguments[i]));
		    }
		    return objects.join(' ');
		  }

		  var i = 1;
		  var args = arguments;
		  var len = args.length;
		  var str = String(f).replace(formatRegExp, function(x) {
		    if (x === '%%') return '%';
		    if (i >= len) return x;
		    switch (x) {
		      case '%s': return String(args[i++]);
		      case '%d': return Number(args[i++]);
		      case '%j':
		        try {
		          return JSON.stringify(args[i++]);
		        } catch (_) {
		          return '[Circular]';
		        }
		      default:
		        return x;
		    }
		  });
		  for (var x = args[i]; i < len; x = args[++i]) {
		    if (isNull(x) || !isObject(x)) {
		      str += ' ' + x;
		    } else {
		      str += ' ' + inspect(x);
		    }
		  }
		  return str;
		};


		// Mark that a method should not be used.
		// Returns a modified function which warns once by default.
		// If --no-deprecation is set, then it is a no-op.
		exports$1.deprecate = function(fn, msg) {
		  if (typeof process$1 !== 'undefined' && process$1.noDeprecation === true) {
		    return fn;
		  }

		  // Allow for deprecating things in the process of starting up.
		  if (typeof process$1 === 'undefined') {
		    return function() {
		      return exports$1.deprecate(fn, msg).apply(this, arguments);
		    };
		  }

		  var warned = false;
		  function deprecated() {
		    if (!warned) {
		      if (process$1.throwDeprecation) {
		        throw new Error(msg);
		      } else if (process$1.traceDeprecation) {
		        console.trace(msg);
		      } else {
		        console.error(msg);
		      }
		      warned = true;
		    }
		    return fn.apply(this, arguments);
		  }

		  return deprecated;
		};


		var debugs = {};
		var debugEnvRegex = /^$/;

		if (process$1.env.NODE_DEBUG) {
		  var debugEnv = process$1.env.NODE_DEBUG;
		  debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&')
		    .replace(/\*/g, '.*')
		    .replace(/,/g, '$|^')
		    .toUpperCase();
		  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
		}
		exports$1.debuglog = function(set) {
		  set = set.toUpperCase();
		  if (!debugs[set]) {
		    if (debugEnvRegex.test(set)) {
		      var pid = process$1.pid;
		      debugs[set] = function() {
		        var msg = exports$1.format.apply(exports$1, arguments);
		        console.error('%s %d: %s', set, pid, msg);
		      };
		    } else {
		      debugs[set] = function() {};
		    }
		  }
		  return debugs[set];
		};


		/**
		 * Echos the value of a value. Trys to print the value out
		 * in the best way possible given the different types.
		 *
		 * @param {Object} obj The object to print out.
		 * @param {Object} opts Optional options object that alters the output.
		 */
		/* legacy: obj, showHidden, depth, colors*/
		function inspect(obj, opts) {
		  // default options
		  var ctx = {
		    seen: [],
		    stylize: stylizeNoColor
		  };
		  // legacy...
		  if (arguments.length >= 3) ctx.depth = arguments[2];
		  if (arguments.length >= 4) ctx.colors = arguments[3];
		  if (isBoolean(opts)) {
		    // legacy...
		    ctx.showHidden = opts;
		  } else if (opts) {
		    // got an "options" object
		    exports$1._extend(ctx, opts);
		  }
		  // set default options
		  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
		  if (isUndefined(ctx.depth)) ctx.depth = 2;
		  if (isUndefined(ctx.colors)) ctx.colors = false;
		  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
		  if (ctx.colors) ctx.stylize = stylizeWithColor;
		  return formatValue(ctx, obj, ctx.depth);
		}
		exports$1.inspect = inspect;


		// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
		inspect.colors = {
		  'bold' : [1, 22],
		  'italic' : [3, 23],
		  'underline' : [4, 24],
		  'inverse' : [7, 27],
		  'white' : [37, 39],
		  'grey' : [90, 39],
		  'black' : [30, 39],
		  'blue' : [34, 39],
		  'cyan' : [36, 39],
		  'green' : [32, 39],
		  'magenta' : [35, 39],
		  'red' : [31, 39],
		  'yellow' : [33, 39]
		};

		// Don't use 'blue' not visible on cmd.exe
		inspect.styles = {
		  'special': 'cyan',
		  'number': 'yellow',
		  'boolean': 'yellow',
		  'undefined': 'grey',
		  'null': 'bold',
		  'string': 'green',
		  'date': 'magenta',
		  // "name": intentionally not styling
		  'regexp': 'red'
		};


		function stylizeWithColor(str, styleType) {
		  var style = inspect.styles[styleType];

		  if (style) {
		    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
		           '\u001b[' + inspect.colors[style][1] + 'm';
		  } else {
		    return str;
		  }
		}


		function stylizeNoColor(str, styleType) {
		  return str;
		}


		function arrayToHash(array) {
		  var hash = {};

		  array.forEach(function(val, idx) {
		    hash[val] = true;
		  });

		  return hash;
		}


		function formatValue(ctx, value, recurseTimes) {
		  // Provide a hook for user-specified inspect functions.
		  // Check that value is an object with an inspect function on it
		  if (ctx.customInspect &&
		      value &&
		      isFunction(value.inspect) &&
		      // Filter out the util module, it's inspect function is special
		      value.inspect !== exports$1.inspect &&
		      // Also filter out any prototype objects using the circular check.
		      !(value.constructor && value.constructor.prototype === value)) {
		    var ret = value.inspect(recurseTimes, ctx);
		    if (!isString(ret)) {
		      ret = formatValue(ctx, ret, recurseTimes);
		    }
		    return ret;
		  }

		  // Primitive types cannot have properties
		  var primitive = formatPrimitive(ctx, value);
		  if (primitive) {
		    return primitive;
		  }

		  // Look up the keys of the object.
		  var keys = Object.keys(value);
		  var visibleKeys = arrayToHash(keys);

		  if (ctx.showHidden) {
		    keys = Object.getOwnPropertyNames(value);
		  }

		  // IE doesn't make error fields non-enumerable
		  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
		  if (isError(value)
		      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
		    return formatError(value);
		  }

		  // Some type of object without properties can be shortcutted.
		  if (keys.length === 0) {
		    if (isFunction(value)) {
		      var name = value.name ? ': ' + value.name : '';
		      return ctx.stylize('[Function' + name + ']', 'special');
		    }
		    if (isRegExp(value)) {
		      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
		    }
		    if (isDate(value)) {
		      return ctx.stylize(Date.prototype.toString.call(value), 'date');
		    }
		    if (isError(value)) {
		      return formatError(value);
		    }
		  }

		  var base = '', array = false, braces = ['{', '}'];

		  // Make Array say that they are Array
		  if (isArray(value)) {
		    array = true;
		    braces = ['[', ']'];
		  }

		  // Make functions say that they are functions
		  if (isFunction(value)) {
		    var n = value.name ? ': ' + value.name : '';
		    base = ' [Function' + n + ']';
		  }

		  // Make RegExps say that they are RegExps
		  if (isRegExp(value)) {
		    base = ' ' + RegExp.prototype.toString.call(value);
		  }

		  // Make dates with properties first say the date
		  if (isDate(value)) {
		    base = ' ' + Date.prototype.toUTCString.call(value);
		  }

		  // Make error with message first say the error
		  if (isError(value)) {
		    base = ' ' + formatError(value);
		  }

		  if (keys.length === 0 && (!array || value.length == 0)) {
		    return braces[0] + base + braces[1];
		  }

		  if (recurseTimes < 0) {
		    if (isRegExp(value)) {
		      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
		    } else {
		      return ctx.stylize('[Object]', 'special');
		    }
		  }

		  ctx.seen.push(value);

		  var output;
		  if (array) {
		    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
		  } else {
		    output = keys.map(function(key) {
		      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
		    });
		  }

		  ctx.seen.pop();

		  return reduceToSingleString(output, base, braces);
		}


		function formatPrimitive(ctx, value) {
		  if (isUndefined(value))
		    return ctx.stylize('undefined', 'undefined');
		  if (isString(value)) {
		    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
		                                             .replace(/'/g, "\\'")
		                                             .replace(/\\"/g, '"') + '\'';
		    return ctx.stylize(simple, 'string');
		  }
		  if (isNumber(value))
		    return ctx.stylize('' + value, 'number');
		  if (isBoolean(value))
		    return ctx.stylize('' + value, 'boolean');
		  // For some reason typeof null is "object", so special case here.
		  if (isNull(value))
		    return ctx.stylize('null', 'null');
		}


		function formatError(value) {
		  return '[' + Error.prototype.toString.call(value) + ']';
		}


		function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
		  var output = [];
		  for (var i = 0, l = value.length; i < l; ++i) {
		    if (hasOwnProperty(value, String(i))) {
		      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
		          String(i), true));
		    } else {
		      output.push('');
		    }
		  }
		  keys.forEach(function(key) {
		    if (!key.match(/^\d+$/)) {
		      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
		          key, true));
		    }
		  });
		  return output;
		}


		function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
		  var name, str, desc;
		  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
		  if (desc.get) {
		    if (desc.set) {
		      str = ctx.stylize('[Getter/Setter]', 'special');
		    } else {
		      str = ctx.stylize('[Getter]', 'special');
		    }
		  } else {
		    if (desc.set) {
		      str = ctx.stylize('[Setter]', 'special');
		    }
		  }
		  if (!hasOwnProperty(visibleKeys, key)) {
		    name = '[' + key + ']';
		  }
		  if (!str) {
		    if (ctx.seen.indexOf(desc.value) < 0) {
		      if (isNull(recurseTimes)) {
		        str = formatValue(ctx, desc.value, null);
		      } else {
		        str = formatValue(ctx, desc.value, recurseTimes - 1);
		      }
		      if (str.indexOf('\n') > -1) {
		        if (array) {
		          str = str.split('\n').map(function(line) {
		            return '  ' + line;
		          }).join('\n').slice(2);
		        } else {
		          str = '\n' + str.split('\n').map(function(line) {
		            return '   ' + line;
		          }).join('\n');
		        }
		      }
		    } else {
		      str = ctx.stylize('[Circular]', 'special');
		    }
		  }
		  if (isUndefined(name)) {
		    if (array && key.match(/^\d+$/)) {
		      return str;
		    }
		    name = JSON.stringify('' + key);
		    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
		      name = name.slice(1, -1);
		      name = ctx.stylize(name, 'name');
		    } else {
		      name = name.replace(/'/g, "\\'")
		                 .replace(/\\"/g, '"')
		                 .replace(/(^"|"$)/g, "'");
		      name = ctx.stylize(name, 'string');
		    }
		  }

		  return name + ': ' + str;
		}


		function reduceToSingleString(output, base, braces) {
		  var length = output.reduce(function(prev, cur) {
		    if (cur.indexOf('\n') >= 0) ;
		    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
		  }, 0);

		  if (length > 60) {
		    return braces[0] +
		           (base === '' ? '' : base + '\n ') +
		           ' ' +
		           output.join(',\n  ') +
		           ' ' +
		           braces[1];
		  }

		  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
		}


		// NOTE: These type checking functions intentionally don't use `instanceof`
		// because it is fragile and can be easily faked with `Object.create()`.
		exports$1.types = requireTypes();

		function isArray(ar) {
		  return Array.isArray(ar);
		}
		exports$1.isArray = isArray;

		function isBoolean(arg) {
		  return typeof arg === 'boolean';
		}
		exports$1.isBoolean = isBoolean;

		function isNull(arg) {
		  return arg === null;
		}
		exports$1.isNull = isNull;

		function isNullOrUndefined(arg) {
		  return arg == null;
		}
		exports$1.isNullOrUndefined = isNullOrUndefined;

		function isNumber(arg) {
		  return typeof arg === 'number';
		}
		exports$1.isNumber = isNumber;

		function isString(arg) {
		  return typeof arg === 'string';
		}
		exports$1.isString = isString;

		function isSymbol(arg) {
		  return typeof arg === 'symbol';
		}
		exports$1.isSymbol = isSymbol;

		function isUndefined(arg) {
		  return arg === void 0;
		}
		exports$1.isUndefined = isUndefined;

		function isRegExp(re) {
		  return isObject(re) && objectToString(re) === '[object RegExp]';
		}
		exports$1.isRegExp = isRegExp;
		exports$1.types.isRegExp = isRegExp;

		function isObject(arg) {
		  return typeof arg === 'object' && arg !== null;
		}
		exports$1.isObject = isObject;

		function isDate(d) {
		  return isObject(d) && objectToString(d) === '[object Date]';
		}
		exports$1.isDate = isDate;
		exports$1.types.isDate = isDate;

		function isError(e) {
		  return isObject(e) &&
		      (objectToString(e) === '[object Error]' || e instanceof Error);
		}
		exports$1.isError = isError;
		exports$1.types.isNativeError = isError;

		function isFunction(arg) {
		  return typeof arg === 'function';
		}
		exports$1.isFunction = isFunction;

		function isPrimitive(arg) {
		  return arg === null ||
		         typeof arg === 'boolean' ||
		         typeof arg === 'number' ||
		         typeof arg === 'string' ||
		         typeof arg === 'symbol' ||  // ES6 symbol
		         typeof arg === 'undefined';
		}
		exports$1.isPrimitive = isPrimitive;

		exports$1.isBuffer = requireIsBuffer();

		function objectToString(o) {
		  return Object.prototype.toString.call(o);
		}


		function pad(n) {
		  return n < 10 ? '0' + n.toString(10) : n.toString(10);
		}


		var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
		              'Oct', 'Nov', 'Dec'];

		// 26 Feb 16:19:34
		function timestamp() {
		  var d = new Date();
		  var time = [pad(d.getHours()),
		              pad(d.getMinutes()),
		              pad(d.getSeconds())].join(':');
		  return [d.getDate(), months[d.getMonth()], time].join(' ');
		}


		// log is just a thin wrapper to console.log that prepends a timestamp
		exports$1.log = function() {
		  console.log('%s - %s', timestamp(), exports$1.format.apply(exports$1, arguments));
		};


		/**
		 * Inherit the prototype methods from one constructor into another.
		 *
		 * The Function.prototype.inherits from lang.js rewritten as a standalone
		 * function (not on Function.prototype). NOTE: If this file is to be loaded
		 * during bootstrapping this function needs to be rewritten using some native
		 * functions as prototype setup using normal JavaScript does not work as
		 * expected during bootstrapping (see mirror.js in r114903).
		 *
		 * @param {function} ctor Constructor function which needs to inherit the
		 *     prototype.
		 * @param {function} superCtor Constructor function to inherit prototype from.
		 */
		exports$1.inherits = requireInherits();

		exports$1._extend = function(origin, add) {
		  // Don't do anything if add isn't an object
		  if (!add || !isObject(add)) return origin;

		  var keys = Object.keys(add);
		  var i = keys.length;
		  while (i--) {
		    origin[keys[i]] = add[keys[i]];
		  }
		  return origin;
		};

		function hasOwnProperty(obj, prop) {
		  return Object.prototype.hasOwnProperty.call(obj, prop);
		}

		var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

		exports$1.promisify = function promisify(original) {
		  if (typeof original !== 'function')
		    throw new TypeError('The "original" argument must be of type Function');

		  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
		    var fn = original[kCustomPromisifiedSymbol];
		    if (typeof fn !== 'function') {
		      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
		    }
		    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
		      value: fn, enumerable: false, writable: false, configurable: true
		    });
		    return fn;
		  }

		  function fn() {
		    var promiseResolve, promiseReject;
		    var promise = new Promise(function (resolve, reject) {
		      promiseResolve = resolve;
		      promiseReject = reject;
		    });

		    var args = [];
		    for (var i = 0; i < arguments.length; i++) {
		      args.push(arguments[i]);
		    }
		    args.push(function (err, value) {
		      if (err) {
		        promiseReject(err);
		      } else {
		        promiseResolve(value);
		      }
		    });

		    try {
		      original.apply(this, args);
		    } catch (err) {
		      promiseReject(err);
		    }

		    return promise;
		  }

		  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

		  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
		    value: fn, enumerable: false, writable: false, configurable: true
		  });
		  return Object.defineProperties(
		    fn,
		    getOwnPropertyDescriptors(original)
		  );
		};

		exports$1.promisify.custom = kCustomPromisifiedSymbol;

		function callbackifyOnRejected(reason, cb) {
		  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
		  // Because `null` is a special error value in callbacks which means "no error
		  // occurred", we error-wrap so the callback consumer can distinguish between
		  // "the promise rejected with null" or "the promise fulfilled with undefined".
		  if (!reason) {
		    var newReason = new Error('Promise was rejected with a falsy value');
		    newReason.reason = reason;
		    reason = newReason;
		  }
		  return cb(reason);
		}

		function callbackify(original) {
		  if (typeof original !== 'function') {
		    throw new TypeError('The "original" argument must be of type Function');
		  }

		  // We DO NOT return the promise as it gives the user a false sense that
		  // the promise is actually somehow related to the callback's execution
		  // and that the callback throwing will reject the promise.
		  function callbackified() {
		    var args = [];
		    for (var i = 0; i < arguments.length; i++) {
		      args.push(arguments[i]);
		    }

		    var maybeCb = args.pop();
		    if (typeof maybeCb !== 'function') {
		      throw new TypeError('The last argument must be of type Function');
		    }
		    var self = this;
		    var cb = function() {
		      return maybeCb.apply(self, arguments);
		    };
		    // In true node style we process the callback on `nextTick` with all the
		    // implications (stack, `uncaughtException`, `async_hooks`)
		    original.apply(this, args)
		      .then(function(ret) { process$1.nextTick(cb.bind(null, null, ret)); },
		            function(rej) { process$1.nextTick(callbackifyOnRejected.bind(null, rej, cb)); });
		  }

		  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
		  Object.defineProperties(callbackified,
		                          getOwnPropertyDescriptors(original));
		  return callbackified;
		}
		exports$1.callbackify = callbackify; 
	} (util));
	return util;
}

var inherits_browser = {exports: {}};

var hasRequiredInherits_browser;

function requireInherits_browser () {
	if (hasRequiredInherits_browser) return inherits_browser.exports;
	hasRequiredInherits_browser = 1;
	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  inherits_browser.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor;
	      ctor.prototype = Object.create(superCtor.prototype, {
	        constructor: {
	          value: ctor,
	          enumerable: false,
	          writable: true,
	          configurable: true
	        }
	      });
	    }
	  };
	} else {
	  // old school shim for old browsers
	  inherits_browser.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor;
	      var TempCtor = function () {};
	      TempCtor.prototype = superCtor.prototype;
	      ctor.prototype = new TempCtor();
	      ctor.prototype.constructor = ctor;
	    }
	  };
	}
	return inherits_browser.exports;
}

var hasRequiredInherits;

function requireInherits () {
	if (hasRequiredInherits) return inherits.exports;
	hasRequiredInherits = 1;
	try {
	  var util = requireUtil();
	  /* istanbul ignore next */
	  if (typeof util.inherits !== 'function') throw '';
	  inherits.exports = util.inherits;
	} catch (e) {
	  /* istanbul ignore next */
	  inherits.exports = requireInherits_browser();
	}
	return inherits.exports;
}

var isarray;
var hasRequiredIsarray;

function requireIsarray () {
	if (hasRequiredIsarray) return isarray;
	hasRequiredIsarray = 1;
	var toString = {}.toString;

	isarray = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};
	return isarray;
}

var typedArrayBuffer;
var hasRequiredTypedArrayBuffer;

function requireTypedArrayBuffer () {
	if (hasRequiredTypedArrayBuffer) return typedArrayBuffer;
	hasRequiredTypedArrayBuffer = 1;

	var $TypeError = /*@__PURE__*/ requireType();

	var callBound = /*@__PURE__*/ requireCallBound();

	/** @type {undefined | ((thisArg: import('.').TypedArray) => Buffer<ArrayBufferLike>)} */
	var $typedArrayBuffer = callBound('TypedArray.prototype.buffer', true);

	var isTypedArray = /*@__PURE__*/ requireIsTypedArray();

	/** @type {import('.')} */
	// node <= 0.10, < 0.11.4 has a nonconfigurable own property instead of a prototype getter
	typedArrayBuffer = $typedArrayBuffer || function typedArrayBuffer(x) {
		if (!isTypedArray(x)) {
			throw new $TypeError('Not a Typed Array');
		}
		return x.buffer;
	};
	return typedArrayBuffer;
}

var toBuffer;
var hasRequiredToBuffer;

function requireToBuffer () {
	if (hasRequiredToBuffer) return toBuffer;
	hasRequiredToBuffer = 1;

	var Buffer = requireSafeBuffer().Buffer;
	var isArray = requireIsarray();
	var typedArrayBuffer = /*@__PURE__*/ requireTypedArrayBuffer();

	var isView = ArrayBuffer.isView || function isView(obj) {
		try {
			typedArrayBuffer(obj);
			return true;
		} catch (e) {
			return false;
		}
	};

	var useUint8Array = typeof Uint8Array !== 'undefined';
	var useArrayBuffer = typeof ArrayBuffer !== 'undefined'
		&& typeof Uint8Array !== 'undefined';
	var useFromArrayBuffer = useArrayBuffer && (Buffer.prototype instanceof Uint8Array || Buffer.TYPED_ARRAY_SUPPORT);

	toBuffer = function toBuffer(data, encoding) {
		if (Buffer.isBuffer(data)) {
			if (data.constructor && !('isBuffer' in data)) {
				// probably a SlowBuffer
				return Buffer.from(data);
			}
			return data;
		}

		if (typeof data === 'string') {
			return Buffer.from(data, encoding);
		}

		/*
		 * Wrap any TypedArray instances and DataViews
		 * Makes sense only on engines with full TypedArray support -- let Buffer detect that
		 */
		if (useArrayBuffer && isView(data)) {
			// Bug in Node.js <6.3.1, which treats this as out-of-bounds
			if (data.byteLength === 0) {
				return Buffer.alloc(0);
			}

			// When Buffer is based on Uint8Array, we can just construct it from ArrayBuffer
			if (useFromArrayBuffer) {
				var res = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
				/*
				 * Recheck result size, as offset/length doesn't work on Node.js <5.10
				 * We just go to Uint8Array case if this fails
				 */
				if (res.byteLength === data.byteLength) {
					return res;
				}
			}

			// Convert to Uint8Array bytes and then to Buffer
			var uint8 = data instanceof Uint8Array ? data : new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
			var result = Buffer.from(uint8);

			/*
			 * Let's recheck that conversion succeeded
			 * We have .length but not .byteLength when useFromArrayBuffer is false
			 */
			if (result.length === data.byteLength) {
				return result;
			}
		}

		/*
		 * Uint8Array in engines where Buffer.from might not work with ArrayBuffer, just copy over
		 * Doesn't make sense with other TypedArray instances
		 */
		if (useUint8Array && data instanceof Uint8Array) {
			return Buffer.from(data);
		}

		var isArr = isArray(data);
		if (isArr) {
			for (var i = 0; i < data.length; i += 1) {
				var x = data[i];
				if (
					typeof x !== 'number'
					|| x < 0
					|| x > 255
					|| ~~x !== x // NaN and integer check
				) {
					throw new RangeError('Array items must be numbers in the range 0-255.');
				}
			}
		}

		/*
		 * Old Buffer polyfill on an engine that doesn't have TypedArray support
		 * Also, this is from a different Buffer polyfill implementation then we have, as instanceof check failed
		 * Convert to our current Buffer implementation
		 */
		if (
			isArr || (
				Buffer.isBuffer(data)
				&& data.constructor
				&& typeof data.constructor.isBuffer === 'function'
				&& data.constructor.isBuffer(data)
			)
		) {
			return Buffer.from(data);
		}

		throw new TypeError('The "data" argument must be a string, an Array, a Buffer, a Uint8Array, or a DataView.');
	};
	return toBuffer;
}

var hash;
var hasRequiredHash;

function requireHash () {
	if (hasRequiredHash) return hash;
	hasRequiredHash = 1;

	var Buffer = requireSafeBuffer().Buffer;
	var toBuffer = /*@__PURE__*/ requireToBuffer();

	// prototype class for hash functions
	function Hash(blockSize, finalSize) {
		this._block = Buffer.alloc(blockSize);
		this._finalSize = finalSize;
		this._blockSize = blockSize;
		this._len = 0;
	}

	Hash.prototype.update = function (data, enc) {
		/* eslint no-param-reassign: 0 */
		data = toBuffer(data, enc || 'utf8');

		var block = this._block;
		var blockSize = this._blockSize;
		var length = data.length;
		var accum = this._len;

		for (var offset = 0; offset < length;) {
			var assigned = accum % blockSize;
			var remainder = Math.min(length - offset, blockSize - assigned);

			for (var i = 0; i < remainder; i++) {
				block[assigned + i] = data[offset + i];
			}

			accum += remainder;
			offset += remainder;

			if ((accum % blockSize) === 0) {
				this._update(block);
			}
		}

		this._len += length;
		return this;
	};

	Hash.prototype.digest = function (enc) {
		var rem = this._len % this._blockSize;

		this._block[rem] = 0x80;

		/*
		 * zero (rem + 1) trailing bits, where (rem + 1) is the smallest
		 * non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
		 */
		this._block.fill(0, rem + 1);

		if (rem >= this._finalSize) {
			this._update(this._block);
			this._block.fill(0);
		}

		var bits = this._len * 8;

		// uint32
		if (bits <= 0xffffffff) {
			this._block.writeUInt32BE(bits, this._blockSize - 4);

			// uint64
		} else {
			var lowBits = (bits & 0xffffffff) >>> 0;
			var highBits = (bits - lowBits) / 0x100000000;

			this._block.writeUInt32BE(highBits, this._blockSize - 8);
			this._block.writeUInt32BE(lowBits, this._blockSize - 4);
		}

		this._update(this._block);
		var hash = this._hash();

		return enc ? hash.toString(enc) : hash;
	};

	Hash.prototype._update = function () {
		throw new Error('_update must be implemented by subclass');
	};

	hash = Hash;
	return hash;
}

var sha;
var hasRequiredSha;

function requireSha () {
	if (hasRequiredSha) return sha;
	hasRequiredSha = 1;

	/*
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
	 * in FIPS PUB 180-1
	 * This source code is derived from sha1.js of the same repository.
	 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
	 * operation was added.
	 */

	var inherits = requireInherits();
	var Hash = requireHash();
	var Buffer = requireSafeBuffer().Buffer;

	var K = [
		0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
	];

	var W = new Array(80);

	function Sha() {
		this.init();
		this._w = W;

		Hash.call(this, 64, 56);
	}

	inherits(Sha, Hash);

	Sha.prototype.init = function () {
		this._a = 0x67452301;
		this._b = 0xefcdab89;
		this._c = 0x98badcfe;
		this._d = 0x10325476;
		this._e = 0xc3d2e1f0;

		return this;
	};

	function rotl5(num) {
		return (num << 5) | (num >>> 27);
	}

	function rotl30(num) {
		return (num << 30) | (num >>> 2);
	}

	function ft(s, b, c, d) {
		if (s === 0) {
			return (b & c) | (~b & d);
		}
		if (s === 2) {
			return (b & c) | (b & d) | (c & d);
		}
		return b ^ c ^ d;
	}

	Sha.prototype._update = function (M) {
		var w = this._w;

		var a = this._a | 0;
		var b = this._b | 0;
		var c = this._c | 0;
		var d = this._d | 0;
		var e = this._e | 0;

		for (var i = 0; i < 16; ++i) {
			w[i] = M.readInt32BE(i * 4);
		}
		for (; i < 80; ++i) {
			w[i] = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
		}

		for (var j = 0; j < 80; ++j) {
			var s = ~~(j / 20);
			var t = (rotl5(a) + ft(s, b, c, d) + e + w[j] + K[s]) | 0;

			e = d;
			d = c;
			c = rotl30(b);
			b = a;
			a = t;
		}

		this._a = (a + this._a) | 0;
		this._b = (b + this._b) | 0;
		this._c = (c + this._c) | 0;
		this._d = (d + this._d) | 0;
		this._e = (e + this._e) | 0;
	};

	Sha.prototype._hash = function () {
		var H = Buffer.allocUnsafe(20);

		H.writeInt32BE(this._a | 0, 0);
		H.writeInt32BE(this._b | 0, 4);
		H.writeInt32BE(this._c | 0, 8);
		H.writeInt32BE(this._d | 0, 12);
		H.writeInt32BE(this._e | 0, 16);

		return H;
	};

	sha = Sha;
	return sha;
}

var sha1;
var hasRequiredSha1;

function requireSha1 () {
	if (hasRequiredSha1) return sha1;
	hasRequiredSha1 = 1;

	/*
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
	 * in FIPS PUB 180-1
	 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for details.
	 */

	var inherits = requireInherits();
	var Hash = requireHash();
	var Buffer = requireSafeBuffer().Buffer;

	var K = [
		0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
	];

	var W = new Array(80);

	function Sha1() {
		this.init();
		this._w = W;

		Hash.call(this, 64, 56);
	}

	inherits(Sha1, Hash);

	Sha1.prototype.init = function () {
		this._a = 0x67452301;
		this._b = 0xefcdab89;
		this._c = 0x98badcfe;
		this._d = 0x10325476;
		this._e = 0xc3d2e1f0;

		return this;
	};

	function rotl1(num) {
		return (num << 1) | (num >>> 31);
	}

	function rotl5(num) {
		return (num << 5) | (num >>> 27);
	}

	function rotl30(num) {
		return (num << 30) | (num >>> 2);
	}

	function ft(s, b, c, d) {
		if (s === 0) {
			return (b & c) | (~b & d);
		}
		if (s === 2) {
			return (b & c) | (b & d) | (c & d);
		}
		return b ^ c ^ d;
	}

	Sha1.prototype._update = function (M) {
		var w = this._w;

		var a = this._a | 0;
		var b = this._b | 0;
		var c = this._c | 0;
		var d = this._d | 0;
		var e = this._e | 0;

		for (var i = 0; i < 16; ++i) {
			w[i] = M.readInt32BE(i * 4);
		}
		for (; i < 80; ++i) {
			w[i] = rotl1(w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]);
		}

		for (var j = 0; j < 80; ++j) {
			var s = ~~(j / 20);
			var t = (rotl5(a) + ft(s, b, c, d) + e + w[j] + K[s]) | 0;

			e = d;
			d = c;
			c = rotl30(b);
			b = a;
			a = t;
		}

		this._a = (a + this._a) | 0;
		this._b = (b + this._b) | 0;
		this._c = (c + this._c) | 0;
		this._d = (d + this._d) | 0;
		this._e = (e + this._e) | 0;
	};

	Sha1.prototype._hash = function () {
		var H = Buffer.allocUnsafe(20);

		H.writeInt32BE(this._a | 0, 0);
		H.writeInt32BE(this._b | 0, 4);
		H.writeInt32BE(this._c | 0, 8);
		H.writeInt32BE(this._d | 0, 12);
		H.writeInt32BE(this._e | 0, 16);

		return H;
	};

	sha1 = Sha1;
	return sha1;
}

var sha256;
var hasRequiredSha256;

function requireSha256 () {
	if (hasRequiredSha256) return sha256;
	hasRequiredSha256 = 1;

	/**
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
	 * in FIPS 180-2
	 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 *
	 */

	var inherits = requireInherits();
	var Hash = requireHash();
	var Buffer = requireSafeBuffer().Buffer;

	var K = [
		0x428A2F98,
		0x71374491,
		0xB5C0FBCF,
		0xE9B5DBA5,
		0x3956C25B,
		0x59F111F1,
		0x923F82A4,
		0xAB1C5ED5,
		0xD807AA98,
		0x12835B01,
		0x243185BE,
		0x550C7DC3,
		0x72BE5D74,
		0x80DEB1FE,
		0x9BDC06A7,
		0xC19BF174,
		0xE49B69C1,
		0xEFBE4786,
		0x0FC19DC6,
		0x240CA1CC,
		0x2DE92C6F,
		0x4A7484AA,
		0x5CB0A9DC,
		0x76F988DA,
		0x983E5152,
		0xA831C66D,
		0xB00327C8,
		0xBF597FC7,
		0xC6E00BF3,
		0xD5A79147,
		0x06CA6351,
		0x14292967,
		0x27B70A85,
		0x2E1B2138,
		0x4D2C6DFC,
		0x53380D13,
		0x650A7354,
		0x766A0ABB,
		0x81C2C92E,
		0x92722C85,
		0xA2BFE8A1,
		0xA81A664B,
		0xC24B8B70,
		0xC76C51A3,
		0xD192E819,
		0xD6990624,
		0xF40E3585,
		0x106AA070,
		0x19A4C116,
		0x1E376C08,
		0x2748774C,
		0x34B0BCB5,
		0x391C0CB3,
		0x4ED8AA4A,
		0x5B9CCA4F,
		0x682E6FF3,
		0x748F82EE,
		0x78A5636F,
		0x84C87814,
		0x8CC70208,
		0x90BEFFFA,
		0xA4506CEB,
		0xBEF9A3F7,
		0xC67178F2
	];

	var W = new Array(64);

	function Sha256() {
		this.init();

		this._w = W; // new Array(64)

		Hash.call(this, 64, 56);
	}

	inherits(Sha256, Hash);

	Sha256.prototype.init = function () {
		this._a = 0x6a09e667;
		this._b = 0xbb67ae85;
		this._c = 0x3c6ef372;
		this._d = 0xa54ff53a;
		this._e = 0x510e527f;
		this._f = 0x9b05688c;
		this._g = 0x1f83d9ab;
		this._h = 0x5be0cd19;

		return this;
	};

	function ch(x, y, z) {
		return z ^ (x & (y ^ z));
	}

	function maj(x, y, z) {
		return (x & y) | (z & (x | y));
	}

	function sigma0(x) {
		return ((x >>> 2) | (x << 30)) ^ ((x >>> 13) | (x << 19)) ^ ((x >>> 22) | (x << 10));
	}

	function sigma1(x) {
		return ((x >>> 6) | (x << 26)) ^ ((x >>> 11) | (x << 21)) ^ ((x >>> 25) | (x << 7));
	}

	function gamma0(x) {
		return ((x >>> 7) | (x << 25)) ^ ((x >>> 18) | (x << 14)) ^ (x >>> 3);
	}

	function gamma1(x) {
		return ((x >>> 17) | (x << 15)) ^ ((x >>> 19) | (x << 13)) ^ (x >>> 10);
	}

	Sha256.prototype._update = function (M) {
		var w = this._w;

		var a = this._a | 0;
		var b = this._b | 0;
		var c = this._c | 0;
		var d = this._d | 0;
		var e = this._e | 0;
		var f = this._f | 0;
		var g = this._g | 0;
		var h = this._h | 0;

		for (var i = 0; i < 16; ++i) {
			w[i] = M.readInt32BE(i * 4);
		}
		for (; i < 64; ++i) {
			w[i] = (gamma1(w[i - 2]) + w[i - 7] + gamma0(w[i - 15]) + w[i - 16]) | 0;
		}

		for (var j = 0; j < 64; ++j) {
			var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + w[j]) | 0;
			var T2 = (sigma0(a) + maj(a, b, c)) | 0;

			h = g;
			g = f;
			f = e;
			e = (d + T1) | 0;
			d = c;
			c = b;
			b = a;
			a = (T1 + T2) | 0;
		}

		this._a = (a + this._a) | 0;
		this._b = (b + this._b) | 0;
		this._c = (c + this._c) | 0;
		this._d = (d + this._d) | 0;
		this._e = (e + this._e) | 0;
		this._f = (f + this._f) | 0;
		this._g = (g + this._g) | 0;
		this._h = (h + this._h) | 0;
	};

	Sha256.prototype._hash = function () {
		var H = Buffer.allocUnsafe(32);

		H.writeInt32BE(this._a, 0);
		H.writeInt32BE(this._b, 4);
		H.writeInt32BE(this._c, 8);
		H.writeInt32BE(this._d, 12);
		H.writeInt32BE(this._e, 16);
		H.writeInt32BE(this._f, 20);
		H.writeInt32BE(this._g, 24);
		H.writeInt32BE(this._h, 28);

		return H;
	};

	sha256 = Sha256;
	return sha256;
}

var sha224;
var hasRequiredSha224;

function requireSha224 () {
	if (hasRequiredSha224) return sha224;
	hasRequiredSha224 = 1;

	/**
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
	 * in FIPS 180-2
	 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 *
	 */

	var inherits = requireInherits();
	var Sha256 = requireSha256();
	var Hash = requireHash();
	var Buffer = requireSafeBuffer().Buffer;

	var W = new Array(64);

	function Sha224() {
		this.init();

		this._w = W; // new Array(64)

		Hash.call(this, 64, 56);
	}

	inherits(Sha224, Sha256);

	Sha224.prototype.init = function () {
		this._a = 0xc1059ed8;
		this._b = 0x367cd507;
		this._c = 0x3070dd17;
		this._d = 0xf70e5939;
		this._e = 0xffc00b31;
		this._f = 0x68581511;
		this._g = 0x64f98fa7;
		this._h = 0xbefa4fa4;

		return this;
	};

	Sha224.prototype._hash = function () {
		var H = Buffer.allocUnsafe(28);

		H.writeInt32BE(this._a, 0);
		H.writeInt32BE(this._b, 4);
		H.writeInt32BE(this._c, 8);
		H.writeInt32BE(this._d, 12);
		H.writeInt32BE(this._e, 16);
		H.writeInt32BE(this._f, 20);
		H.writeInt32BE(this._g, 24);

		return H;
	};

	sha224 = Sha224;
	return sha224;
}

var sha512;
var hasRequiredSha512;

function requireSha512 () {
	if (hasRequiredSha512) return sha512;
	hasRequiredSha512 = 1;

	var inherits = requireInherits();
	var Hash = requireHash();
	var Buffer = requireSafeBuffer().Buffer;

	var K = [
		0x428a2f98,
		0xd728ae22,
		0x71374491,
		0x23ef65cd,
		0xb5c0fbcf,
		0xec4d3b2f,
		0xe9b5dba5,
		0x8189dbbc,
		0x3956c25b,
		0xf348b538,
		0x59f111f1,
		0xb605d019,
		0x923f82a4,
		0xaf194f9b,
		0xab1c5ed5,
		0xda6d8118,
		0xd807aa98,
		0xa3030242,
		0x12835b01,
		0x45706fbe,
		0x243185be,
		0x4ee4b28c,
		0x550c7dc3,
		0xd5ffb4e2,
		0x72be5d74,
		0xf27b896f,
		0x80deb1fe,
		0x3b1696b1,
		0x9bdc06a7,
		0x25c71235,
		0xc19bf174,
		0xcf692694,
		0xe49b69c1,
		0x9ef14ad2,
		0xefbe4786,
		0x384f25e3,
		0x0fc19dc6,
		0x8b8cd5b5,
		0x240ca1cc,
		0x77ac9c65,
		0x2de92c6f,
		0x592b0275,
		0x4a7484aa,
		0x6ea6e483,
		0x5cb0a9dc,
		0xbd41fbd4,
		0x76f988da,
		0x831153b5,
		0x983e5152,
		0xee66dfab,
		0xa831c66d,
		0x2db43210,
		0xb00327c8,
		0x98fb213f,
		0xbf597fc7,
		0xbeef0ee4,
		0xc6e00bf3,
		0x3da88fc2,
		0xd5a79147,
		0x930aa725,
		0x06ca6351,
		0xe003826f,
		0x14292967,
		0x0a0e6e70,
		0x27b70a85,
		0x46d22ffc,
		0x2e1b2138,
		0x5c26c926,
		0x4d2c6dfc,
		0x5ac42aed,
		0x53380d13,
		0x9d95b3df,
		0x650a7354,
		0x8baf63de,
		0x766a0abb,
		0x3c77b2a8,
		0x81c2c92e,
		0x47edaee6,
		0x92722c85,
		0x1482353b,
		0xa2bfe8a1,
		0x4cf10364,
		0xa81a664b,
		0xbc423001,
		0xc24b8b70,
		0xd0f89791,
		0xc76c51a3,
		0x0654be30,
		0xd192e819,
		0xd6ef5218,
		0xd6990624,
		0x5565a910,
		0xf40e3585,
		0x5771202a,
		0x106aa070,
		0x32bbd1b8,
		0x19a4c116,
		0xb8d2d0c8,
		0x1e376c08,
		0x5141ab53,
		0x2748774c,
		0xdf8eeb99,
		0x34b0bcb5,
		0xe19b48a8,
		0x391c0cb3,
		0xc5c95a63,
		0x4ed8aa4a,
		0xe3418acb,
		0x5b9cca4f,
		0x7763e373,
		0x682e6ff3,
		0xd6b2b8a3,
		0x748f82ee,
		0x5defb2fc,
		0x78a5636f,
		0x43172f60,
		0x84c87814,
		0xa1f0ab72,
		0x8cc70208,
		0x1a6439ec,
		0x90befffa,
		0x23631e28,
		0xa4506ceb,
		0xde82bde9,
		0xbef9a3f7,
		0xb2c67915,
		0xc67178f2,
		0xe372532b,
		0xca273ece,
		0xea26619c,
		0xd186b8c7,
		0x21c0c207,
		0xeada7dd6,
		0xcde0eb1e,
		0xf57d4f7f,
		0xee6ed178,
		0x06f067aa,
		0x72176fba,
		0x0a637dc5,
		0xa2c898a6,
		0x113f9804,
		0xbef90dae,
		0x1b710b35,
		0x131c471b,
		0x28db77f5,
		0x23047d84,
		0x32caab7b,
		0x40c72493,
		0x3c9ebe0a,
		0x15c9bebc,
		0x431d67c4,
		0x9c100d4c,
		0x4cc5d4be,
		0xcb3e42b6,
		0x597f299c,
		0xfc657e2a,
		0x5fcb6fab,
		0x3ad6faec,
		0x6c44198c,
		0x4a475817
	];

	var W = new Array(160);

	function Sha512() {
		this.init();
		this._w = W;

		Hash.call(this, 128, 112);
	}

	inherits(Sha512, Hash);

	Sha512.prototype.init = function () {
		this._ah = 0x6a09e667;
		this._bh = 0xbb67ae85;
		this._ch = 0x3c6ef372;
		this._dh = 0xa54ff53a;
		this._eh = 0x510e527f;
		this._fh = 0x9b05688c;
		this._gh = 0x1f83d9ab;
		this._hh = 0x5be0cd19;

		this._al = 0xf3bcc908;
		this._bl = 0x84caa73b;
		this._cl = 0xfe94f82b;
		this._dl = 0x5f1d36f1;
		this._el = 0xade682d1;
		this._fl = 0x2b3e6c1f;
		this._gl = 0xfb41bd6b;
		this._hl = 0x137e2179;

		return this;
	};

	function Ch(x, y, z) {
		return z ^ (x & (y ^ z));
	}

	function maj(x, y, z) {
		return (x & y) | (z & (x | y));
	}

	function sigma0(x, xl) {
		return ((x >>> 28) | (xl << 4)) ^ ((xl >>> 2) | (x << 30)) ^ ((xl >>> 7) | (x << 25));
	}

	function sigma1(x, xl) {
		return ((x >>> 14) | (xl << 18)) ^ ((x >>> 18) | (xl << 14)) ^ ((xl >>> 9) | (x << 23));
	}

	function Gamma0(x, xl) {
		return ((x >>> 1) | (xl << 31)) ^ ((x >>> 8) | (xl << 24)) ^ (x >>> 7);
	}

	function Gamma0l(x, xl) {
		return ((x >>> 1) | (xl << 31)) ^ ((x >>> 8) | (xl << 24)) ^ ((x >>> 7) | (xl << 25));
	}

	function Gamma1(x, xl) {
		return ((x >>> 19) | (xl << 13)) ^ ((xl >>> 29) | (x << 3)) ^ (x >>> 6);
	}

	function Gamma1l(x, xl) {
		return ((x >>> 19) | (xl << 13)) ^ ((xl >>> 29) | (x << 3)) ^ ((x >>> 6) | (xl << 26));
	}

	function getCarry(a, b) {
		return (a >>> 0) < (b >>> 0) ? 1 : 0;
	}

	Sha512.prototype._update = function (M) {
		var w = this._w;

		var ah = this._ah | 0;
		var bh = this._bh | 0;
		var ch = this._ch | 0;
		var dh = this._dh | 0;
		var eh = this._eh | 0;
		var fh = this._fh | 0;
		var gh = this._gh | 0;
		var hh = this._hh | 0;

		var al = this._al | 0;
		var bl = this._bl | 0;
		var cl = this._cl | 0;
		var dl = this._dl | 0;
		var el = this._el | 0;
		var fl = this._fl | 0;
		var gl = this._gl | 0;
		var hl = this._hl | 0;

		for (var i = 0; i < 32; i += 2) {
			w[i] = M.readInt32BE(i * 4);
			w[i + 1] = M.readInt32BE((i * 4) + 4);
		}
		for (; i < 160; i += 2) {
			var xh = w[i - (15 * 2)];
			var xl = w[i - (15 * 2) + 1];
			var gamma0 = Gamma0(xh, xl);
			var gamma0l = Gamma0l(xl, xh);

			xh = w[i - (2 * 2)];
			xl = w[i - (2 * 2) + 1];
			var gamma1 = Gamma1(xh, xl);
			var gamma1l = Gamma1l(xl, xh);

			// w[i] = gamma0 + w[i - 7] + gamma1 + w[i - 16]
			var Wi7h = w[i - (7 * 2)];
			var Wi7l = w[i - (7 * 2) + 1];

			var Wi16h = w[i - (16 * 2)];
			var Wi16l = w[i - (16 * 2) + 1];

			var Wil = (gamma0l + Wi7l) | 0;
			var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0;
			Wil = (Wil + gamma1l) | 0;
			Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0;
			Wil = (Wil + Wi16l) | 0;
			Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0;

			w[i] = Wih;
			w[i + 1] = Wil;
		}

		for (var j = 0; j < 160; j += 2) {
			Wih = w[j];
			Wil = w[j + 1];

			var majh = maj(ah, bh, ch);
			var majl = maj(al, bl, cl);

			var sigma0h = sigma0(ah, al);
			var sigma0l = sigma0(al, ah);
			var sigma1h = sigma1(eh, el);
			var sigma1l = sigma1(el, eh);

			// t1 = h + sigma1 + ch + K[j] + w[j]
			var Kih = K[j];
			var Kil = K[j + 1];

			var chh = Ch(eh, fh, gh);
			var chl = Ch(el, fl, gl);

			var t1l = (hl + sigma1l) | 0;
			var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0;
			t1l = (t1l + chl) | 0;
			t1h = (t1h + chh + getCarry(t1l, chl)) | 0;
			t1l = (t1l + Kil) | 0;
			t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0;
			t1l = (t1l + Wil) | 0;
			t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0;

			// t2 = sigma0 + maj
			var t2l = (sigma0l + majl) | 0;
			var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0;

			hh = gh;
			hl = gl;
			gh = fh;
			gl = fl;
			fh = eh;
			fl = el;
			el = (dl + t1l) | 0;
			eh = (dh + t1h + getCarry(el, dl)) | 0;
			dh = ch;
			dl = cl;
			ch = bh;
			cl = bl;
			bh = ah;
			bl = al;
			al = (t1l + t2l) | 0;
			ah = (t1h + t2h + getCarry(al, t1l)) | 0;
		}

		this._al = (this._al + al) | 0;
		this._bl = (this._bl + bl) | 0;
		this._cl = (this._cl + cl) | 0;
		this._dl = (this._dl + dl) | 0;
		this._el = (this._el + el) | 0;
		this._fl = (this._fl + fl) | 0;
		this._gl = (this._gl + gl) | 0;
		this._hl = (this._hl + hl) | 0;

		this._ah = (this._ah + ah + getCarry(this._al, al)) | 0;
		this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0;
		this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0;
		this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0;
		this._eh = (this._eh + eh + getCarry(this._el, el)) | 0;
		this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0;
		this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0;
		this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0;
	};

	Sha512.prototype._hash = function () {
		var H = Buffer.allocUnsafe(64);

		function writeInt64BE(h, l, offset) {
			H.writeInt32BE(h, offset);
			H.writeInt32BE(l, offset + 4);
		}

		writeInt64BE(this._ah, this._al, 0);
		writeInt64BE(this._bh, this._bl, 8);
		writeInt64BE(this._ch, this._cl, 16);
		writeInt64BE(this._dh, this._dl, 24);
		writeInt64BE(this._eh, this._el, 32);
		writeInt64BE(this._fh, this._fl, 40);
		writeInt64BE(this._gh, this._gl, 48);
		writeInt64BE(this._hh, this._hl, 56);

		return H;
	};

	sha512 = Sha512;
	return sha512;
}

var sha384;
var hasRequiredSha384;

function requireSha384 () {
	if (hasRequiredSha384) return sha384;
	hasRequiredSha384 = 1;

	var inherits = requireInherits();
	var SHA512 = requireSha512();
	var Hash = requireHash();
	var Buffer = requireSafeBuffer().Buffer;

	var W = new Array(160);

	function Sha384() {
		this.init();
		this._w = W;

		Hash.call(this, 128, 112);
	}

	inherits(Sha384, SHA512);

	Sha384.prototype.init = function () {
		this._ah = 0xcbbb9d5d;
		this._bh = 0x629a292a;
		this._ch = 0x9159015a;
		this._dh = 0x152fecd8;
		this._eh = 0x67332667;
		this._fh = 0x8eb44a87;
		this._gh = 0xdb0c2e0d;
		this._hh = 0x47b5481d;

		this._al = 0xc1059ed8;
		this._bl = 0x367cd507;
		this._cl = 0x3070dd17;
		this._dl = 0xf70e5939;
		this._el = 0xffc00b31;
		this._fl = 0x68581511;
		this._gl = 0x64f98fa7;
		this._hl = 0xbefa4fa4;

		return this;
	};

	Sha384.prototype._hash = function () {
		var H = Buffer.allocUnsafe(48);

		function writeInt64BE(h, l, offset) {
			H.writeInt32BE(h, offset);
			H.writeInt32BE(l, offset + 4);
		}

		writeInt64BE(this._ah, this._al, 0);
		writeInt64BE(this._bh, this._bl, 8);
		writeInt64BE(this._ch, this._cl, 16);
		writeInt64BE(this._dh, this._dl, 24);
		writeInt64BE(this._eh, this._el, 32);
		writeInt64BE(this._fh, this._fl, 40);

		return H;
	};

	sha384 = Sha384;
	return sha384;
}

var hasRequiredSha_js;

function requireSha_js () {
	if (hasRequiredSha_js) return sha_js.exports;
	hasRequiredSha_js = 1;
	(function (module) {

		module.exports = function SHA(algorithm) {
			var alg = algorithm.toLowerCase();

			var Algorithm = module.exports[alg];
			if (!Algorithm) {
				throw new Error(alg + ' is not supported (we accept pull requests)');
			}

			return new Algorithm();
		};

		module.exports.sha = requireSha();
		module.exports.sha1 = requireSha1();
		module.exports.sha224 = requireSha224();
		module.exports.sha256 = requireSha256();
		module.exports.sha384 = requireSha384();
		module.exports.sha512 = requireSha512(); 
	} (sha_js));
	return sha_js.exports;
}

var sha_jsExports = requireSha_js();
const shajs = /*@__PURE__*/getDefaultExportFromCjs$1(sha_jsExports);

var ABIDataTypes;
(function (ABIDataTypes) {
    ABIDataTypes["UINT8"] = "UINT8";
    ABIDataTypes["UINT16"] = "UINT16";
    ABIDataTypes["UINT32"] = "UINT32";
    ABIDataTypes["UINT64"] = "UINT64";
    ABIDataTypes["UINT128"] = "UINT128";
    ABIDataTypes["UINT256"] = "UINT256";
    ABIDataTypes["INT128"] = "INT128";
    ABIDataTypes["BOOL"] = "BOOL";
    ABIDataTypes["ADDRESS"] = "ADDRESS";
    ABIDataTypes["STRING"] = "STRING";
    ABIDataTypes["BYTES4"] = "BYTES4";
    ABIDataTypes["BYTES32"] = "BYTES32";
    ABIDataTypes["BYTES"] = "BYTES";
    ABIDataTypes["ADDRESS_UINT256_TUPLE"] = "ADDRESS_UINT256_TUPLE";
    ABIDataTypes["ARRAY_OF_ADDRESSES"] = "ARRAY_OF_ADDRESSES";
    ABIDataTypes["ARRAY_OF_UINT256"] = "ARRAY_OF_UINT256";
    ABIDataTypes["ARRAY_OF_UINT128"] = "ARRAY_OF_UINT128";
    ABIDataTypes["ARRAY_OF_UINT64"] = "ARRAY_OF_UINT64";
    ABIDataTypes["ARRAY_OF_UINT32"] = "ARRAY_OF_UINT32";
    ABIDataTypes["ARRAY_OF_UINT16"] = "ARRAY_OF_UINT16";
    ABIDataTypes["ARRAY_OF_UINT8"] = "ARRAY_OF_UINT8";
    ABIDataTypes["ARRAY_OF_STRING"] = "ARRAY_OF_STRING";
    ABIDataTypes["ARRAY_OF_BYTES"] = "ARRAY_OF_BYTES";
    ABIDataTypes["ARRAY_OF_BUFFERS"] = "ARRAY_OF_BUFFERS";
})(ABIDataTypes || (ABIDataTypes = {}));
class ABICoder {
    decodeData(data, types) {
        const byteReader = new BinaryReader(data);
        const result = [];
        for (let i = 0; i < types.length; i++) {
            const type = types[i];
            switch (type) {
                case ABIDataTypes.UINT8:
                    result.push(byteReader.readU8());
                    break;
                case ABIDataTypes.UINT16:
                    result.push(byteReader.readU16());
                    break;
                case ABIDataTypes.UINT32:
                    result.push(byteReader.readU32());
                    break;
                case ABIDataTypes.BYTES4:
                    result.push(byteReader.readBytes(4));
                    break;
                case ABIDataTypes.BYTES32:
                    result.push(byteReader.readBytes(32));
                    break;
                case ABIDataTypes.BOOL:
                    result.push(byteReader.readBoolean());
                    break;
                case ABIDataTypes.ADDRESS:
                    result.push(byteReader.readAddress());
                    break;
                case ABIDataTypes.STRING:
                    result.push(byteReader.readStringWithLength());
                    break;
                case ABIDataTypes.UINT128:
                    result.push(byteReader.readU128());
                    break;
                case ABIDataTypes.UINT256:
                    result.push(byteReader.readU256());
                    break;
                case ABIDataTypes.INT128:
                    result.push(byteReader.readI128());
                    break;
                case ABIDataTypes.ADDRESS_UINT256_TUPLE:
                    result.push(byteReader.readAddressValueTuple());
                    break;
                case ABIDataTypes.BYTES:
                    result.push(byteReader.readBytesWithLength());
                    break;
                case ABIDataTypes.UINT64:
                    result.push(byteReader.readU64());
                    break;
                case ABIDataTypes.ARRAY_OF_ADDRESSES:
                    result.push(byteReader.readAddressArray());
                    break;
                case ABIDataTypes.ARRAY_OF_UINT256:
                    result.push(byteReader.readU256Array());
                    break;
                case ABIDataTypes.ARRAY_OF_UINT128:
                    result.push(byteReader.readU128Array());
                    break;
                case ABIDataTypes.ARRAY_OF_UINT64:
                    result.push(byteReader.readU64Array());
                    break;
                case ABIDataTypes.ARRAY_OF_UINT32:
                    result.push(byteReader.readU32Array());
                    break;
                case ABIDataTypes.ARRAY_OF_UINT16:
                    result.push(byteReader.readU16Array());
                    break;
                case ABIDataTypes.ARRAY_OF_UINT8:
                    result.push(byteReader.readU8Array());
                    break;
                case ABIDataTypes.ARRAY_OF_STRING:
                    result.push(byteReader.readStringArray());
                    break;
                case ABIDataTypes.ARRAY_OF_BYTES:
                    result.push(byteReader.readBytesArray());
                    break;
                case ABIDataTypes.ARRAY_OF_BUFFERS:
                    result.push(byteReader.readArrayOfBuffer());
                    break;
            }
        }
        return result;
    }
    encodeSelector(selectorIdentifier) {
        const hash = this.sha256(selectorIdentifier);
        const selector = Buffer$1.from(hash.subarray(0, 4));
        return selector.toString('hex');
    }
    numericSelectorToHex(selector) {
        return selector.toString(16);
    }
    bigIntToUint8Array(bigIntValue, length) {
        const byteArray = new Uint8Array(length);
        const buf = BufferHelper.valueToUint8Array(bigIntValue);
        for (let i = 0; i < length; i++) {
            byteArray[i] = buf[i] || 0;
        }
        return byteArray;
    }
    sha256(buffer) {
        return new shajs.sha256().update(buffer).digest();
    }
}

(undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
(undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};

class NetEvent {
    constructor(type, data) {
        this.type = type;
        this.data = data;
    }
}

var WalletNetworks;
(function (WalletNetworks) {
    WalletNetworks["testnet"] = "testnet";
    WalletNetworks["mainnet"] = "mainnet";
    WalletNetworks["regtest"] = "regtest";
})(WalletNetworks || (WalletNetworks = {}));
var UnisatChainType;
(function (UnisatChainType) {
    UnisatChainType["BITCOIN_MAINNET"] = "BITCOIN_MAINNET";
    UnisatChainType["BITCOIN_TESTNET"] = "BITCOIN_TESTNET";
    UnisatChainType["BITCOIN_TESTNET4"] = "BITCOIN_TESTNET4";
    UnisatChainType["BITCOIN_REGTEST"] = "BITCOIN_REGTEST";
    UnisatChainType["BITCOIN_SIGNET"] = "BITCOIN_SIGNET";
    UnisatChainType["FRACTAL_BITCOIN_MAINNET"] = "FRACTAL_BITCOIN_MAINNET";
    UnisatChainType["FRACTAL_BITCOIN_TESTNET"] = "FRACTAL_BITCOIN_TESTNET";
})(UnisatChainType || (UnisatChainType = {}));

var MessageType;
(function (MessageType) {
    MessageType["ecdsa"] = "ecdsa";
    MessageType["bip322"] = "bip322-simple";
})(MessageType || (MessageType = {}));
var SignatureType;
(function (SignatureType) {
    SignatureType["ecdsa"] = "ecdsa";
    SignatureType["schnorr"] = "schnorr";
})(SignatureType || (SignatureType = {}));

var XverseNetwork;
(function (XverseNetwork) {
    XverseNetwork["mainnet"] = "mainnet";
    XverseNetwork["testnet"] = "testnet";
    XverseNetwork["signet"] = "Signet";
})(XverseNetwork || (XverseNetwork = {}));
var SigningProtocol;
(function (SigningProtocol) {
    SigningProtocol["ECDSA"] = "ECDSA";
    SigningProtocol["BIP322"] = "BIP322";
})(SigningProtocol || (SigningProtocol = {}));

(undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
(undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};

/*
How it works:
`this.#head` is an instance of `Node` which keeps track of its current value and nests another instance of `Node` that keeps the value that comes after it. When a value is provided to `.enqueue()`, the code needs to iterate through `this.#head`, going deeper and deeper to find the last value. However, iterating through every single item is slow. This problem is solved by saving a reference to the last value as `this.#tail` so that it can reference it to add a new value.
*/

class Node {
	value;
	next;

	constructor(value) {
		this.value = value;
	}
}

class Queue {
	#head;
	#tail;
	#size;

	constructor() {
		this.clear();
	}

	enqueue(value) {
		const node = new Node(value);

		if (this.#head) {
			this.#tail.next = node;
			this.#tail = node;
		} else {
			this.#head = node;
			this.#tail = node;
		}

		this.#size++;
	}

	dequeue() {
		const current = this.#head;
		if (!current) {
			return;
		}

		this.#head = this.#head.next;
		this.#size--;

		// Clean up tail reference when queue becomes empty
		if (!this.#head) {
			this.#tail = undefined;
		}

		return current.value;
	}

	peek() {
		if (!this.#head) {
			return;
		}

		return this.#head.value;

		// TODO: Node.js 18.
		// return this.#head?.value;
	}

	clear() {
		this.#head = undefined;
		this.#tail = undefined;
		this.#size = 0;
	}

	get size() {
		return this.#size;
	}

	* [Symbol.iterator]() {
		let current = this.#head;

		while (current) {
			yield current.value;
			current = current.next;
		}
	}

	* drain() {
		while (this.#head) {
			yield this.dequeue();
		}
	}
}

function pLimit(concurrency) {
	validateConcurrency(concurrency);

	const queue = new Queue();
	let activeCount = 0;

	const resumeNext = () => {
		// Process the next queued function if we're under the concurrency limit
		if (activeCount < concurrency && queue.size > 0) {
			activeCount++;
			queue.dequeue()();
		}
	};

	const next = () => {
		activeCount--;
		resumeNext();
	};

	const run = async (function_, resolve, arguments_) => {
		// Execute the function and capture the result promise
		const result = (async () => function_(...arguments_))();

		// Resolve immediately with the promise (don't wait for completion)
		resolve(result);

		// Wait for the function to complete (success or failure)
		// We catch errors here to prevent unhandled rejections,
		// but the original promise rejection is preserved for the caller
		try {
			await result;
		} catch {}

		// Decrement active count and process next queued function
		next();
	};

	const enqueue = (function_, resolve, arguments_) => {
		// Queue the internal resolve function instead of the run function
		// to preserve the asynchronous execution context.
		new Promise(internalResolve => { // eslint-disable-line promise/param-names
			queue.enqueue(internalResolve);
		}).then(run.bind(undefined, function_, resolve, arguments_)); // eslint-disable-line promise/prefer-await-to-then

		// Start processing immediately if we haven't reached the concurrency limit
		if (activeCount < concurrency) {
			resumeNext();
		}
	};

	const generator = (function_, ...arguments_) => new Promise(resolve => {
		enqueue(function_, resolve, arguments_);
	});

	Object.defineProperties(generator, {
		activeCount: {
			get: () => activeCount,
		},
		pendingCount: {
			get: () => queue.size,
		},
		clearQueue: {
			value() {
				queue.clear();
			},
		},
		concurrency: {
			get: () => concurrency,

			set(newConcurrency) {
				validateConcurrency(newConcurrency);
				concurrency = newConcurrency;

				queueMicrotask(() => {
					// eslint-disable-next-line no-unmodified-loop-condition
					while (activeCount < concurrency && queue.size > 0) {
						resumeNext();
					}
				});
			},
		},
		map: {
			async value(iterable, function_) {
				const promises = Array.from(iterable, (value, index) => this(function_, value, index));
				return Promise.all(promises);
			},
		},
	});

	return generator;
}

function validateConcurrency(concurrency) {
	if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {
		throw new TypeError('Expected `concurrency` to be a number from 1 and up');
	}
}

/**
 * @license
 * Copyright 2009 The Closure Library Authors
 * Copyright 2020 Daniel Wirtz / The long.js Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
var wasm = null;
try {
  wasm = new WebAssembly.Instance(
    new WebAssembly.Module(
      new Uint8Array([
        // \0asm
        0,
        97,
        115,
        109,
        // version 1
        1,
        0,
        0,
        0,
        // section "type"
        1,
        13,
        2,
        // 0, () => i32
        96,
        0,
        1,
        127,
        // 1, (i32, i32, i32, i32) => i32
        96,
        4,
        127,
        127,
        127,
        127,
        1,
        127,
        // section "function"
        3,
        7,
        6,
        // 0, type 0
        0,
        // 1, type 1
        1,
        // 2, type 1
        1,
        // 3, type 1
        1,
        // 4, type 1
        1,
        // 5, type 1
        1,
        // section "global"
        6,
        6,
        1,
        // 0, "high", mutable i32
        127,
        1,
        65,
        0,
        11,
        // section "export"
        7,
        50,
        6,
        // 0, "mul"
        3,
        109,
        117,
        108,
        0,
        1,
        // 1, "div_s"
        5,
        100,
        105,
        118,
        95,
        115,
        0,
        2,
        // 2, "div_u"
        5,
        100,
        105,
        118,
        95,
        117,
        0,
        3,
        // 3, "rem_s"
        5,
        114,
        101,
        109,
        95,
        115,
        0,
        4,
        // 4, "rem_u"
        5,
        114,
        101,
        109,
        95,
        117,
        0,
        5,
        // 5, "get_high"
        8,
        103,
        101,
        116,
        95,
        104,
        105,
        103,
        104,
        0,
        0,
        // section "code"
        10,
        191,
        1,
        6,
        // 0, "get_high"
        4,
        0,
        35,
        0,
        11,
        // 1, "mul"
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        126,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        // 2, "div_s"
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        127,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        // 3, "div_u"
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        128,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        // 4, "rem_s"
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        129,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        // 5, "rem_u"
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        130,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11
      ])
    ),
    {}
  ).exports;
} catch {
}
function Long(low, high, unsigned) {
  this.low = low | 0;
  this.high = high | 0;
  this.unsigned = !!unsigned;
}
Long.prototype.__isLong__;
Object.defineProperty(Long.prototype, "__isLong__", { value: true });
function isLong(obj) {
  return (obj && obj["__isLong__"]) === true;
}
function ctz32(value) {
  var c = Math.clz32(value & -value);
  return value ? 31 - c : c;
}
Long.isLong = isLong;
var INT_CACHE = {};
var UINT_CACHE = {};
function fromInt(value, unsigned) {
  var obj, cachedObj, cache;
  if (unsigned) {
    value >>>= 0;
    if (cache = 0 <= value && value < 256) {
      cachedObj = UINT_CACHE[value];
      if (cachedObj) return cachedObj;
    }
    obj = fromBits(value, 0, true);
    if (cache) UINT_CACHE[value] = obj;
    return obj;
  } else {
    value |= 0;
    if (cache = -128 <= value && value < 128) {
      cachedObj = INT_CACHE[value];
      if (cachedObj) return cachedObj;
    }
    obj = fromBits(value, value < 0 ? -1 : 0, false);
    if (cache) INT_CACHE[value] = obj;
    return obj;
  }
}
Long.fromInt = fromInt;
function fromNumber(value, unsigned) {
  if (isNaN(value)) return unsigned ? UZERO : ZERO;
  if (unsigned) {
    if (value < 0) return UZERO;
    if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
  } else {
    if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;
    if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
  }
  if (value < 0) return fromNumber(-value, unsigned).neg();
  return fromBits(
    value % TWO_PWR_32_DBL | 0,
    value / TWO_PWR_32_DBL | 0,
    unsigned
  );
}
Long.fromNumber = fromNumber;
function fromBits(lowBits, highBits, unsigned) {
  return new Long(lowBits, highBits, unsigned);
}
Long.fromBits = fromBits;
var pow_dbl = Math.pow;
function fromString(str, unsigned, radix) {
  if (str.length === 0) throw Error("empty string");
  if (typeof unsigned === "number") {
    radix = unsigned;
    unsigned = false;
  } else {
    unsigned = !!unsigned;
  }
  if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
    return unsigned ? UZERO : ZERO;
  radix = radix || 10;
  if (radix < 2 || 36 < radix) throw RangeError("radix");
  var p;
  if ((p = str.indexOf("-")) > 0) throw Error("interior hyphen");
  else if (p === 0) {
    return fromString(str.substring(1), unsigned, radix).neg();
  }
  var radixToPower = fromNumber(pow_dbl(radix, 8));
  var result = ZERO;
  for (var i = 0; i < str.length; i += 8) {
    var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
    if (size < 8) {
      var power = fromNumber(pow_dbl(radix, size));
      result = result.mul(power).add(fromNumber(value));
    } else {
      result = result.mul(radixToPower);
      result = result.add(fromNumber(value));
    }
  }
  result.unsigned = unsigned;
  return result;
}
Long.fromString = fromString;
function fromValue(val, unsigned) {
  if (typeof val === "number") return fromNumber(val, unsigned);
  if (typeof val === "string") return fromString(val, unsigned);
  return fromBits(
    val.low,
    val.high,
    typeof unsigned === "boolean" ? unsigned : val.unsigned
  );
}
Long.fromValue = fromValue;
var TWO_PWR_16_DBL = 1 << 16;
var TWO_PWR_24_DBL = 1 << 24;
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
var ZERO = fromInt(0);
Long.ZERO = ZERO;
var UZERO = fromInt(0, true);
Long.UZERO = UZERO;
var ONE = fromInt(1);
Long.ONE = ONE;
var UONE = fromInt(1, true);
Long.UONE = UONE;
var NEG_ONE = fromInt(-1);
Long.NEG_ONE = NEG_ONE;
var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
Long.MAX_VALUE = MAX_VALUE;
var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
Long.MIN_VALUE = MIN_VALUE;
var LongPrototype = Long.prototype;
LongPrototype.toInt = function toInt() {
  return this.unsigned ? this.low >>> 0 : this.low;
};
LongPrototype.toNumber = function toNumber() {
  if (this.unsigned)
    return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
  return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};
LongPrototype.toString = function toString(radix) {
  radix = radix || 10;
  if (radix < 2 || 36 < radix) throw RangeError("radix");
  if (this.isZero()) return "0";
  if (this.isNegative()) {
    if (this.eq(MIN_VALUE)) {
      var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
      return div.toString(radix) + rem1.toInt().toString(radix);
    } else return "-" + this.neg().toString(radix);
  }
  var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
  var result = "";
  while (true) {
    var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
    rem = remDiv;
    if (rem.isZero()) return digits + result;
    else {
      while (digits.length < 6) digits = "0" + digits;
      result = "" + digits + result;
    }
  }
};
LongPrototype.getHighBits = function getHighBits() {
  return this.high;
};
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
  return this.high >>> 0;
};
LongPrototype.getLowBits = function getLowBits() {
  return this.low;
};
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
  return this.low >>> 0;
};
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
  if (this.isNegative())
    return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
  var val = this.high != 0 ? this.high : this.low;
  for (var bit = 31; bit > 0; bit--) if ((val & 1 << bit) != 0) break;
  return this.high != 0 ? bit + 33 : bit + 1;
};
LongPrototype.isSafeInteger = function isSafeInteger() {
  var top11Bits = this.high >> 21;
  if (!top11Bits) return true;
  if (this.unsigned) return false;
  return top11Bits === -1 && !(this.low === 0 && this.high === -2097152);
};
LongPrototype.isZero = function isZero() {
  return this.high === 0 && this.low === 0;
};
LongPrototype.eqz = LongPrototype.isZero;
LongPrototype.isNegative = function isNegative() {
  return !this.unsigned && this.high < 0;
};
LongPrototype.isPositive = function isPositive() {
  return this.unsigned || this.high >= 0;
};
LongPrototype.isOdd = function isOdd() {
  return (this.low & 1) === 1;
};
LongPrototype.isEven = function isEven() {
  return (this.low & 1) === 0;
};
LongPrototype.equals = function equals(other) {
  if (!isLong(other)) other = fromValue(other);
  if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
    return false;
  return this.high === other.high && this.low === other.low;
};
LongPrototype.eq = LongPrototype.equals;
LongPrototype.notEquals = function notEquals(other) {
  return !this.eq(
    /* validates */
    other
  );
};
LongPrototype.neq = LongPrototype.notEquals;
LongPrototype.ne = LongPrototype.notEquals;
LongPrototype.lessThan = function lessThan(other) {
  return this.comp(
    /* validates */
    other
  ) < 0;
};
LongPrototype.lt = LongPrototype.lessThan;
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
  return this.comp(
    /* validates */
    other
  ) <= 0;
};
LongPrototype.lte = LongPrototype.lessThanOrEqual;
LongPrototype.le = LongPrototype.lessThanOrEqual;
LongPrototype.greaterThan = function greaterThan(other) {
  return this.comp(
    /* validates */
    other
  ) > 0;
};
LongPrototype.gt = LongPrototype.greaterThan;
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
  return this.comp(
    /* validates */
    other
  ) >= 0;
};
LongPrototype.gte = LongPrototype.greaterThanOrEqual;
LongPrototype.ge = LongPrototype.greaterThanOrEqual;
LongPrototype.compare = function compare(other) {
  if (!isLong(other)) other = fromValue(other);
  if (this.eq(other)) return 0;
  var thisNeg = this.isNegative(), otherNeg = other.isNegative();
  if (thisNeg && !otherNeg) return -1;
  if (!thisNeg && otherNeg) return 1;
  if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;
  return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
};
LongPrototype.comp = LongPrototype.compare;
LongPrototype.negate = function negate() {
  if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
  return this.not().add(ONE);
};
LongPrototype.neg = LongPrototype.negate;
LongPrototype.add = function add(addend) {
  if (!isLong(addend)) addend = fromValue(addend);
  var a48 = this.high >>> 16;
  var a32 = this.high & 65535;
  var a16 = this.low >>> 16;
  var a00 = this.low & 65535;
  var b48 = addend.high >>> 16;
  var b32 = addend.high & 65535;
  var b16 = addend.low >>> 16;
  var b00 = addend.low & 65535;
  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 + b00;
  c16 += c00 >>> 16;
  c00 &= 65535;
  c16 += a16 + b16;
  c32 += c16 >>> 16;
  c16 &= 65535;
  c32 += a32 + b32;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c48 += a48 + b48;
  c48 &= 65535;
  return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
};
LongPrototype.subtract = function subtract(subtrahend) {
  if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
  return this.add(subtrahend.neg());
};
LongPrototype.sub = LongPrototype.subtract;
LongPrototype.multiply = function multiply(multiplier) {
  if (this.isZero()) return this;
  if (!isLong(multiplier)) multiplier = fromValue(multiplier);
  if (wasm) {
    var low = wasm["mul"](this.low, this.high, multiplier.low, multiplier.high);
    return fromBits(low, wasm["get_high"](), this.unsigned);
  }
  if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;
  if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
  if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;
  if (this.isNegative()) {
    if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());
    else return this.neg().mul(multiplier).neg();
  } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();
  if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
    return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
  var a48 = this.high >>> 16;
  var a32 = this.high & 65535;
  var a16 = this.low >>> 16;
  var a00 = this.low & 65535;
  var b48 = multiplier.high >>> 16;
  var b32 = multiplier.high & 65535;
  var b16 = multiplier.low >>> 16;
  var b00 = multiplier.low & 65535;
  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 * b00;
  c16 += c00 >>> 16;
  c00 &= 65535;
  c16 += a16 * b00;
  c32 += c16 >>> 16;
  c16 &= 65535;
  c16 += a00 * b16;
  c32 += c16 >>> 16;
  c16 &= 65535;
  c32 += a32 * b00;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c32 += a16 * b16;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c32 += a00 * b32;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
  c48 &= 65535;
  return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
};
LongPrototype.mul = LongPrototype.multiply;
LongPrototype.divide = function divide(divisor) {
  if (!isLong(divisor)) divisor = fromValue(divisor);
  if (divisor.isZero()) throw Error("division by zero");
  if (wasm) {
    if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
      return this;
    }
    var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(
      this.low,
      this.high,
      divisor.low,
      divisor.high
    );
    return fromBits(low, wasm["get_high"](), this.unsigned);
  }
  if (this.isZero()) return this.unsigned ? UZERO : ZERO;
  var approx, rem, res;
  if (!this.unsigned) {
    if (this.eq(MIN_VALUE)) {
      if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
        return MIN_VALUE;
      else if (divisor.eq(MIN_VALUE)) return ONE;
      else {
        var halfThis = this.shr(1);
        approx = halfThis.div(divisor).shl(1);
        if (approx.eq(ZERO)) {
          return divisor.isNegative() ? ONE : NEG_ONE;
        } else {
          rem = this.sub(divisor.mul(approx));
          res = approx.add(rem.div(divisor));
          return res;
        }
      }
    } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
    if (this.isNegative()) {
      if (divisor.isNegative()) return this.neg().div(divisor.neg());
      return this.neg().div(divisor).neg();
    } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
    res = ZERO;
  } else {
    if (!divisor.unsigned) divisor = divisor.toUnsigned();
    if (divisor.gt(this)) return UZERO;
    if (divisor.gt(this.shru(1)))
      return UONE;
    res = UZERO;
  }
  rem = this;
  while (rem.gte(divisor)) {
    approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
    var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
    while (approxRem.isNegative() || approxRem.gt(rem)) {
      approx -= delta;
      approxRes = fromNumber(approx, this.unsigned);
      approxRem = approxRes.mul(divisor);
    }
    if (approxRes.isZero()) approxRes = ONE;
    res = res.add(approxRes);
    rem = rem.sub(approxRem);
  }
  return res;
};
LongPrototype.div = LongPrototype.divide;
LongPrototype.modulo = function modulo(divisor) {
  if (!isLong(divisor)) divisor = fromValue(divisor);
  if (wasm) {
    var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(
      this.low,
      this.high,
      divisor.low,
      divisor.high
    );
    return fromBits(low, wasm["get_high"](), this.unsigned);
  }
  return this.sub(this.div(divisor).mul(divisor));
};
LongPrototype.mod = LongPrototype.modulo;
LongPrototype.rem = LongPrototype.modulo;
LongPrototype.not = function not() {
  return fromBits(~this.low, ~this.high, this.unsigned);
};
LongPrototype.countLeadingZeros = function countLeadingZeros() {
  return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
};
LongPrototype.clz = LongPrototype.countLeadingZeros;
LongPrototype.countTrailingZeros = function countTrailingZeros() {
  return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
};
LongPrototype.ctz = LongPrototype.countTrailingZeros;
LongPrototype.and = function and(other) {
  if (!isLong(other)) other = fromValue(other);
  return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};
LongPrototype.or = function or(other) {
  if (!isLong(other)) other = fromValue(other);
  return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};
LongPrototype.xor = function xor(other) {
  if (!isLong(other)) other = fromValue(other);
  return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};
LongPrototype.shiftLeft = function shiftLeft(numBits) {
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  else if (numBits < 32)
    return fromBits(
      this.low << numBits,
      this.high << numBits | this.low >>> 32 - numBits,
      this.unsigned
    );
  else return fromBits(0, this.low << numBits - 32, this.unsigned);
};
LongPrototype.shl = LongPrototype.shiftLeft;
LongPrototype.shiftRight = function shiftRight(numBits) {
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  else if (numBits < 32)
    return fromBits(
      this.low >>> numBits | this.high << 32 - numBits,
      this.high >> numBits,
      this.unsigned
    );
  else
    return fromBits(
      this.high >> numBits - 32,
      this.high >= 0 ? 0 : -1,
      this.unsigned
    );
};
LongPrototype.shr = LongPrototype.shiftRight;
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  if (numBits < 32)
    return fromBits(
      this.low >>> numBits | this.high << 32 - numBits,
      this.high >>> numBits,
      this.unsigned
    );
  if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
  return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
};
LongPrototype.shru = LongPrototype.shiftRightUnsigned;
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
LongPrototype.rotateLeft = function rotateLeft(numBits) {
  var b;
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
  if (numBits < 32) {
    b = 32 - numBits;
    return fromBits(
      this.low << numBits | this.high >>> b,
      this.high << numBits | this.low >>> b,
      this.unsigned
    );
  }
  numBits -= 32;
  b = 32 - numBits;
  return fromBits(
    this.high << numBits | this.low >>> b,
    this.low << numBits | this.high >>> b,
    this.unsigned
  );
};
LongPrototype.rotl = LongPrototype.rotateLeft;
LongPrototype.rotateRight = function rotateRight(numBits) {
  var b;
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
  if (numBits < 32) {
    b = 32 - numBits;
    return fromBits(
      this.high << b | this.low >>> numBits,
      this.low << b | this.high >>> numBits,
      this.unsigned
    );
  }
  numBits -= 32;
  b = 32 - numBits;
  return fromBits(
    this.low << b | this.high >>> numBits,
    this.high << b | this.low >>> numBits,
    this.unsigned
  );
};
LongPrototype.rotr = LongPrototype.rotateRight;
LongPrototype.toSigned = function toSigned() {
  if (!this.unsigned) return this;
  return fromBits(this.low, this.high, false);
};
LongPrototype.toUnsigned = function toUnsigned() {
  if (this.unsigned) return this;
  return fromBits(this.low, this.high, true);
};
LongPrototype.toBytes = function toBytes(le) {
  return le ? this.toBytesLE() : this.toBytesBE();
};
LongPrototype.toBytesLE = function toBytesLE() {
  var hi = this.high, lo = this.low;
  return [
    lo & 255,
    lo >>> 8 & 255,
    lo >>> 16 & 255,
    lo >>> 24,
    hi & 255,
    hi >>> 8 & 255,
    hi >>> 16 & 255,
    hi >>> 24
  ];
};
LongPrototype.toBytesBE = function toBytesBE() {
  var hi = this.high, lo = this.low;
  return [
    hi >>> 24,
    hi >>> 16 & 255,
    hi >>> 8 & 255,
    hi & 255,
    lo >>> 24,
    lo >>> 16 & 255,
    lo >>> 8 & 255,
    lo & 255
  ];
};
Long.fromBytes = function fromBytes(bytes, unsigned, le) {
  return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
  return new Long(
    bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
    bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,
    unsigned
  );
};
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
  return new Long(
    bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],
    bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],
    unsigned
  );
};
if (typeof BigInt === "function") {
  Long.fromBigInt = function fromBigInt(value, unsigned) {
    var lowBits = Number(BigInt.asIntN(32, value));
    var highBits = Number(BigInt.asIntN(32, value >> BigInt(32)));
    return fromBits(lowBits, highBits, unsigned);
  };
  Long.fromValue = function fromValueWithBigInt(value, unsigned) {
    if (typeof value === "bigint") return Long.fromBigInt(value, unsigned);
    return fromValue(value, unsigned);
  };
  LongPrototype.toBigInt = function toBigInt() {
    var lowBigInt = BigInt(this.low >>> 0);
    var highBigInt = BigInt(this.unsigned ? this.high >>> 0 : this.high);
    return highBigInt << BigInt(32) | lowBigInt;
  };
}

/*
 *      bignumber.js v9.3.1
 *      A JavaScript library for arbitrary-precision arithmetic.
 *      https://github.com/MikeMcl/bignumber.js
 *      Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
 *      MIT Licensed.
 *
 *      BigNumber.prototype methods     |  BigNumber methods
 *                                      |
 *      absoluteValue            abs    |  clone
 *      comparedTo                      |  config               set
 *      decimalPlaces            dp     |      DECIMAL_PLACES
 *      dividedBy                div    |      ROUNDING_MODE
 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
 *      exponentiatedBy          pow    |      RANGE
 *      integerValue                    |      CRYPTO
 *      isEqualTo                eq     |      MODULO_MODE
 *      isFinite                        |      POW_PRECISION
 *      isGreaterThan            gt     |      FORMAT
 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
 *      isInteger                       |  isBigNumber
 *      isLessThan               lt     |  maximum              max
 *      isLessThanOrEqualTo      lte    |  minimum              min
 *      isNaN                           |  random
 *      isNegative                      |  sum
 *      isPositive                      |
 *      isZero                          |
 *      minus                           |
 *      modulo                   mod    |
 *      multipliedBy             times  |
 *      negated                         |
 *      plus                            |
 *      precision                sd     |
 *      shiftedBy                       |
 *      squareRoot               sqrt   |
 *      toExponential                   |
 *      toFixed                         |
 *      toFormat                        |
 *      toFraction                      |
 *      toJSON                          |
 *      toNumber                        |
 *      toPrecision                     |
 *      toString                        |
 *      valueOf                         |
 *
 */


var
  isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
  mathceil = Math.ceil,
  mathfloor = Math.floor,

  bignumberError = '[BigNumber Error] ',
  tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',

  BASE = 1e14,
  LOG_BASE = 14,
  MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
  // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
  POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
  SQRT_BASE = 1e7,

  // EDITABLE
  // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
  // the arguments to toExponential, toFixed, toFormat, and toPrecision.
  MAX = 1E9;                                   // 0 to MAX_INT32


/*
 * Create and return a BigNumber constructor.
 */
function clone(configObject) {
  var div, convertBase, parseNumeric,
    P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },
    ONE = new BigNumber(1),


    //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------


    // The default values below must be integers within the inclusive ranges stated.
    // The values can also be changed at run-time using BigNumber.set.

    // The maximum number of decimal places for operations involving division.
    DECIMAL_PLACES = 20,                     // 0 to MAX

    // The rounding mode used when rounding to the above decimal places, and when using
    // toExponential, toFixed, toFormat and toPrecision, and round (default value).
    // UP         0 Away from zero.
    // DOWN       1 Towards zero.
    // CEIL       2 Towards +Infinity.
    // FLOOR      3 Towards -Infinity.
    // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
    // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
    // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
    // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
    // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
    ROUNDING_MODE = 4,                       // 0 to 8

    // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

    // The exponent value at and beneath which toString returns exponential notation.
    // Number type: -7
    TO_EXP_NEG = -7,                         // 0 to -MAX

    // The exponent value at and above which toString returns exponential notation.
    // Number type: 21
    TO_EXP_POS = 21,                         // 0 to MAX

    // RANGE : [MIN_EXP, MAX_EXP]

    // The minimum exponent value, beneath which underflow to zero occurs.
    // Number type: -324  (5e-324)
    MIN_EXP = -1e7,                          // -1 to -MAX

    // The maximum exponent value, above which overflow to Infinity occurs.
    // Number type:  308  (1.7976931348623157e+308)
    // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
    MAX_EXP = 1e7,                           // 1 to MAX

    // Whether to use cryptographically-secure random number generation, if available.
    CRYPTO = false,                          // true or false

    // The modulo mode used when calculating the modulus: a mod n.
    // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
    // The remainder (r) is calculated as: r = a - n * q.
    //
    // UP        0 The remainder is positive if the dividend is negative, else is negative.
    // DOWN      1 The remainder has the same sign as the dividend.
    //             This modulo mode is commonly known as 'truncated division' and is
    //             equivalent to (a % n) in JavaScript.
    // FLOOR     3 The remainder has the same sign as the divisor (Python %).
    // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
    // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
    //             The remainder is always positive.
    //
    // The truncated division, floored division, Euclidian division and IEEE 754 remainder
    // modes are commonly used for the modulus operation.
    // Although the other rounding modes can also be used, they may not give useful results.
    MODULO_MODE = 1,                         // 0 to 9

    // The maximum number of significant digits of the result of the exponentiatedBy operation.
    // If POW_PRECISION is 0, there will be unlimited significant digits.
    POW_PRECISION = 0,                       // 0 to MAX

    // The format specification used by the BigNumber.prototype.toFormat method.
    FORMAT = {
      prefix: '',
      groupSize: 3,
      secondaryGroupSize: 0,
      groupSeparator: ',',
      decimalSeparator: '.',
      fractionGroupSize: 0,
      fractionGroupSeparator: '\xA0',        // non-breaking space
      suffix: ''
    },

    // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
    // '-', '.', whitespace, or repeated character.
    // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
    ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz',
    alphabetHasNormalDecimalDigits = true;


  //------------------------------------------------------------------------------------------


  // CONSTRUCTOR


  /*
   * The BigNumber constructor and exported function.
   * Create and return a new instance of a BigNumber object.
   *
   * v {number|string|BigNumber} A numeric value.
   * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
   */
  function BigNumber(v, b) {
    var alphabet, c, caseChanged, e, i, isNum, len, str,
      x = this;

    // Enable constructor call without `new`.
    if (!(x instanceof BigNumber)) return new BigNumber(v, b);

    if (b == null) {

      if (v && v._isBigNumber === true) {
        x.s = v.s;

        if (!v.c || v.e > MAX_EXP) {
          x.c = x.e = null;
        } else if (v.e < MIN_EXP) {
          x.c = [x.e = 0];
        } else {
          x.e = v.e;
          x.c = v.c.slice();
        }

        return;
      }

      if ((isNum = typeof v == 'number') && v * 0 == 0) {

        // Use `1 / n` to handle minus zero also.
        x.s = 1 / v < 0 ? (v = -v, -1) : 1;

        // Fast path for integers, where n < 2147483648 (2**31).
        if (v === ~~v) {
          for (e = 0, i = v; i >= 10; i /= 10, e++);

          if (e > MAX_EXP) {
            x.c = x.e = null;
          } else {
            x.e = e;
            x.c = [v];
          }

          return;
        }

        str = String(v);
      } else {

        if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);

        x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
      }

      // Decimal point?
      if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

      // Exponential form?
      if ((i = str.search(/e/i)) > 0) {

        // Determine exponent.
        if (e < 0) e = i;
        e += +str.slice(i + 1);
        str = str.substring(0, i);
      } else if (e < 0) {

        // Integer.
        e = str.length;
      }

    } else {

      // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
      intCheck(b, 2, ALPHABET.length, 'Base');

      // Allow exponential notation to be used with base 10 argument, while
      // also rounding to DECIMAL_PLACES as with other bases.
      if (b == 10 && alphabetHasNormalDecimalDigits) {
        x = new BigNumber(v);
        return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
      }

      str = String(v);

      if (isNum = typeof v == 'number') {

        // Avoid potential interpretation of Infinity and NaN as base 44+ values.
        if (v * 0 != 0) return parseNumeric(x, str, isNum, b);

        x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;

        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
        if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
          throw Error
           (tooManyDigits + v);
        }
      } else {
        x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
      }

      alphabet = ALPHABET.slice(0, b);
      e = i = 0;

      // Check that str is a valid base b number.
      // Don't use RegExp, so alphabet can contain special characters.
      for (len = str.length; i < len; i++) {
        if (alphabet.indexOf(c = str.charAt(i)) < 0) {
          if (c == '.') {

            // If '.' is not the first character and it has not be found before.
            if (i > e) {
              e = len;
              continue;
            }
          } else if (!caseChanged) {

            // Allow e.g. hexadecimal 'FF' as well as 'ff'.
            if (str == str.toUpperCase() && (str = str.toLowerCase()) ||
                str == str.toLowerCase() && (str = str.toUpperCase())) {
              caseChanged = true;
              i = -1;
              e = 0;
              continue;
            }
          }

          return parseNumeric(x, String(v), isNum, b);
        }
      }

      // Prevent later check for length on converted number.
      isNum = false;
      str = convertBase(str, b, 10, x.s);

      // Decimal point?
      if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
      else e = str.length;
    }

    // Determine leading zeros.
    for (i = 0; str.charCodeAt(i) === 48; i++);

    // Determine trailing zeros.
    for (len = str.length; str.charCodeAt(--len) === 48;);

    if (str = str.slice(i, ++len)) {
      len -= i;

      // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
      if (isNum && BigNumber.DEBUG &&
        len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
          throw Error
           (tooManyDigits + (x.s * v));
      }

       // Overflow?
      if ((e = e - i - 1) > MAX_EXP) {

        // Infinity.
        x.c = x.e = null;

      // Underflow?
      } else if (e < MIN_EXP) {

        // Zero.
        x.c = [x.e = 0];
      } else {
        x.e = e;
        x.c = [];

        // Transform base

        // e is the base 10 exponent.
        // i is where to slice str to get the first element of the coefficient array.
        i = (e + 1) % LOG_BASE;
        if (e < 0) i += LOG_BASE;  // i < 1

        if (i < len) {
          if (i) x.c.push(+str.slice(0, i));

          for (len -= LOG_BASE; i < len;) {
            x.c.push(+str.slice(i, i += LOG_BASE));
          }

          i = LOG_BASE - (str = str.slice(i)).length;
        } else {
          i -= len;
        }

        for (; i--; str += '0');
        x.c.push(+str);
      }
    } else {

      // Zero.
      x.c = [x.e = 0];
    }
  }


  // CONSTRUCTOR PROPERTIES


  BigNumber.clone = clone;

  BigNumber.ROUND_UP = 0;
  BigNumber.ROUND_DOWN = 1;
  BigNumber.ROUND_CEIL = 2;
  BigNumber.ROUND_FLOOR = 3;
  BigNumber.ROUND_HALF_UP = 4;
  BigNumber.ROUND_HALF_DOWN = 5;
  BigNumber.ROUND_HALF_EVEN = 6;
  BigNumber.ROUND_HALF_CEIL = 7;
  BigNumber.ROUND_HALF_FLOOR = 8;
  BigNumber.EUCLID = 9;


  /*
   * Configure infrequently-changing library-wide settings.
   *
   * Accept an object with the following optional properties (if the value of a property is
   * a number, it must be an integer within the inclusive range stated):
   *
   *   DECIMAL_PLACES   {number}           0 to MAX
   *   ROUNDING_MODE    {number}           0 to 8
   *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
   *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
   *   CRYPTO           {boolean}          true or false
   *   MODULO_MODE      {number}           0 to 9
   *   POW_PRECISION       {number}           0 to MAX
   *   ALPHABET         {string}           A string of two or more unique characters which does
   *                                       not contain '.'.
   *   FORMAT           {object}           An object with some of the following properties:
   *     prefix                 {string}
   *     groupSize              {number}
   *     secondaryGroupSize     {number}
   *     groupSeparator         {string}
   *     decimalSeparator       {string}
   *     fractionGroupSize      {number}
   *     fractionGroupSeparator {string}
   *     suffix                 {string}
   *
   * (The values assigned to the above FORMAT object properties are not checked for validity.)
   *
   * E.g.
   * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
   *
   * Ignore properties/parameters set to null or undefined, except for ALPHABET.
   *
   * Return an object with the properties current values.
   */
  BigNumber.config = BigNumber.set = function (obj) {
    var p, v;

    if (obj != null) {

      if (typeof obj == 'object') {

        // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
        // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
        if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          DECIMAL_PLACES = v;
        }

        // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
        // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
        if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
          v = obj[p];
          intCheck(v, 0, 8, p);
          ROUNDING_MODE = v;
        }

        // EXPONENTIAL_AT {number|number[]}
        // Integer, -MAX to MAX inclusive or
        // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
        // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
        if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
          v = obj[p];
          if (v && v.pop) {
            intCheck(v[0], -MAX, 0, p);
            intCheck(v[1], 0, MAX, p);
            TO_EXP_NEG = v[0];
            TO_EXP_POS = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
          }
        }

        // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
        // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
        // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
        if (obj.hasOwnProperty(p = 'RANGE')) {
          v = obj[p];
          if (v && v.pop) {
            intCheck(v[0], -MAX, -1, p);
            intCheck(v[1], 1, MAX, p);
            MIN_EXP = v[0];
            MAX_EXP = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            if (v) {
              MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
            } else {
              throw Error
               (bignumberError + p + ' cannot be zero: ' + v);
            }
          }
        }

        // CRYPTO {boolean} true or false.
        // '[BigNumber Error] CRYPTO not true or false: {v}'
        // '[BigNumber Error] crypto unavailable'
        if (obj.hasOwnProperty(p = 'CRYPTO')) {
          v = obj[p];
          if (v === !!v) {
            if (v) {
              if (typeof crypto != 'undefined' && crypto &&
               (crypto.getRandomValues || crypto.randomBytes)) {
                CRYPTO = v;
              } else {
                CRYPTO = !v;
                throw Error
                 (bignumberError + 'crypto unavailable');
              }
            } else {
              CRYPTO = v;
            }
          } else {
            throw Error
             (bignumberError + p + ' not true or false: ' + v);
          }
        }

        // MODULO_MODE {number} Integer, 0 to 9 inclusive.
        // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
        if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
          v = obj[p];
          intCheck(v, 0, 9, p);
          MODULO_MODE = v;
        }

        // POW_PRECISION {number} Integer, 0 to MAX inclusive.
        // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
        if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          POW_PRECISION = v;
        }

        // FORMAT {object}
        // '[BigNumber Error] FORMAT not an object: {v}'
        if (obj.hasOwnProperty(p = 'FORMAT')) {
          v = obj[p];
          if (typeof v == 'object') FORMAT = v;
          else throw Error
           (bignumberError + p + ' not an object: ' + v);
        }

        // ALPHABET {string}
        // '[BigNumber Error] ALPHABET invalid: {v}'
        if (obj.hasOwnProperty(p = 'ALPHABET')) {
          v = obj[p];

          // Disallow if less than two characters,
          // or if it contains '+', '-', '.', whitespace, or a repeated character.
          if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
            alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';
            ALPHABET = v;
          } else {
            throw Error
             (bignumberError + p + ' invalid: ' + v);
          }
        }

      } else {

        // '[BigNumber Error] Object expected: {v}'
        throw Error
         (bignumberError + 'Object expected: ' + obj);
      }
    }

    return {
      DECIMAL_PLACES: DECIMAL_PLACES,
      ROUNDING_MODE: ROUNDING_MODE,
      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
      RANGE: [MIN_EXP, MAX_EXP],
      CRYPTO: CRYPTO,
      MODULO_MODE: MODULO_MODE,
      POW_PRECISION: POW_PRECISION,
      FORMAT: FORMAT,
      ALPHABET: ALPHABET
    };
  };


  /*
   * Return true if v is a BigNumber instance, otherwise return false.
   *
   * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
   *
   * v {any}
   *
   * '[BigNumber Error] Invalid BigNumber: {v}'
   */
  BigNumber.isBigNumber = function (v) {
    if (!v || v._isBigNumber !== true) return false;
    if (!BigNumber.DEBUG) return true;

    var i, n,
      c = v.c,
      e = v.e,
      s = v.s;

    out: if ({}.toString.call(c) == '[object Array]') {

      if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {

        // If the first element is zero, the BigNumber value must be zero.
        if (c[0] === 0) {
          if (e === 0 && c.length === 1) return true;
          break out;
        }

        // Calculate number of digits that c[0] should have, based on the exponent.
        i = (e + 1) % LOG_BASE;
        if (i < 1) i += LOG_BASE;

        // Calculate number of digits of c[0].
        //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
        if (String(c[0]).length == i) {

          for (i = 0; i < c.length; i++) {
            n = c[i];
            if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
          }

          // Last element cannot be zero, unless it is the only element.
          if (n !== 0) return true;
        }
      }

    // Infinity/NaN
    } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
      return true;
    }

    throw Error
      (bignumberError + 'Invalid BigNumber: ' + v);
  };


  /*
   * Return a new BigNumber whose value is the maximum of the arguments.
   *
   * arguments {number|string|BigNumber}
   */
  BigNumber.maximum = BigNumber.max = function () {
    return maxOrMin(arguments, -1);
  };


  /*
   * Return a new BigNumber whose value is the minimum of the arguments.
   *
   * arguments {number|string|BigNumber}
   */
  BigNumber.minimum = BigNumber.min = function () {
    return maxOrMin(arguments, 1);
  };


  /*
   * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
   * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
   * zeros are produced).
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
   * '[BigNumber Error] crypto unavailable'
   */
  BigNumber.random = (function () {
    var pow2_53 = 0x20000000000000;

    // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
    // Check if Math.random() produces more than 32 bits of randomness.
    // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
    // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
    var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
     ? function () { return mathfloor(Math.random() * pow2_53); }
     : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
       (Math.random() * 0x800000 | 0); };

    return function (dp) {
      var a, b, e, k, v,
        i = 0,
        c = [],
        rand = new BigNumber(ONE);

      if (dp == null) dp = DECIMAL_PLACES;
      else intCheck(dp, 0, MAX);

      k = mathceil(dp / LOG_BASE);

      if (CRYPTO) {

        // Browsers supporting crypto.getRandomValues.
        if (crypto.getRandomValues) {

          a = crypto.getRandomValues(new Uint32Array(k *= 2));

          for (; i < k;) {

            // 53 bits:
            // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
            // 11111 11111111 11111111 11111111 11100000 00000000 00000000
            // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
            //                                     11111 11111111 11111111
            // 0x20000 is 2^21.
            v = a[i] * 0x20000 + (a[i + 1] >>> 11);

            // Rejection sampling:
            // 0 <= v < 9007199254740992
            // Probability that v >= 9e15, is
            // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
            if (v >= 9e15) {
              b = crypto.getRandomValues(new Uint32Array(2));
              a[i] = b[0];
              a[i + 1] = b[1];
            } else {

              // 0 <= v <= 8999999999999999
              // 0 <= (v % 1e14) <= 99999999999999
              c.push(v % 1e14);
              i += 2;
            }
          }
          i = k / 2;

        // Node.js supporting crypto.randomBytes.
        } else if (crypto.randomBytes) {

          // buffer
          a = crypto.randomBytes(k *= 7);

          for (; i < k;) {

            // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
            // 0x100000000 is 2^32, 0x1000000 is 2^24
            // 11111 11111111 11111111 11111111 11111111 11111111 11111111
            // 0 <= v < 9007199254740992
            v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
               (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
               (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

            if (v >= 9e15) {
              crypto.randomBytes(7).copy(a, i);
            } else {

              // 0 <= (v % 1e14) <= 99999999999999
              c.push(v % 1e14);
              i += 7;
            }
          }
          i = k / 7;
        } else {
          CRYPTO = false;
          throw Error
           (bignumberError + 'crypto unavailable');
        }
      }

      // Use Math.random.
      if (!CRYPTO) {

        for (; i < k;) {
          v = random53bitInt();
          if (v < 9e15) c[i++] = v % 1e14;
        }
      }

      k = c[--i];
      dp %= LOG_BASE;

      // Convert trailing digits to zeros according to dp.
      if (k && dp) {
        v = POWS_TEN[LOG_BASE - dp];
        c[i] = mathfloor(k / v) * v;
      }

      // Remove trailing elements which are zero.
      for (; c[i] === 0; c.pop(), i--);

      // Zero?
      if (i < 0) {
        c = [e = 0];
      } else {

        // Remove leading elements which are zero and adjust exponent accordingly.
        for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

        // Count the digits of the first element of c to determine leading zeros, and...
        for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

        // adjust the exponent accordingly.
        if (i < LOG_BASE) e -= LOG_BASE - i;
      }

      rand.e = e;
      rand.c = c;
      return rand;
    };
  })();


   /*
   * Return a BigNumber whose value is the sum of the arguments.
   *
   * arguments {number|string|BigNumber}
   */
  BigNumber.sum = function () {
    var i = 1,
      args = arguments,
      sum = new BigNumber(args[0]);
    for (; i < args.length;) sum = sum.plus(args[i++]);
    return sum;
  };


  // PRIVATE FUNCTIONS


  // Called by BigNumber and BigNumber.prototype.toString.
  convertBase = (function () {
    var decimal = '0123456789';

    /*
     * Convert string of baseIn to an array of numbers of baseOut.
     * Eg. toBaseOut('255', 10, 16) returns [15, 15].
     * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
     */
    function toBaseOut(str, baseIn, baseOut, alphabet) {
      var j,
        arr = [0],
        arrL,
        i = 0,
        len = str.length;

      for (; i < len;) {
        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

        arr[0] += alphabet.indexOf(str.charAt(i++));

        for (j = 0; j < arr.length; j++) {

          if (arr[j] > baseOut - 1) {
            if (arr[j + 1] == null) arr[j + 1] = 0;
            arr[j + 1] += arr[j] / baseOut | 0;
            arr[j] %= baseOut;
          }
        }
      }

      return arr.reverse();
    }

    // Convert a numeric string of baseIn to a numeric string of baseOut.
    // If the caller is toString, we are converting from base 10 to baseOut.
    // If the caller is BigNumber, we are converting from baseIn to base 10.
    return function (str, baseIn, baseOut, sign, callerIsToString) {
      var alphabet, d, e, k, r, x, xc, y,
        i = str.indexOf('.'),
        dp = DECIMAL_PLACES,
        rm = ROUNDING_MODE;

      // Non-integer.
      if (i >= 0) {
        k = POW_PRECISION;

        // Unlimited precision.
        POW_PRECISION = 0;
        str = str.replace('.', '');
        y = new BigNumber(baseIn);
        x = y.pow(str.length - i);
        POW_PRECISION = k;

        // Convert str as if an integer, then restore the fraction part by dividing the
        // result by its base raised to a power.

        y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),
         10, baseOut, decimal);
        y.e = y.c.length;
      }

      // Convert the number as integer.

      xc = toBaseOut(str, baseIn, baseOut, callerIsToString
       ? (alphabet = ALPHABET, decimal)
       : (alphabet = decimal, ALPHABET));

      // xc now represents str as an integer and converted to baseOut. e is the exponent.
      e = k = xc.length;

      // Remove trailing zeros.
      for (; xc[--k] == 0; xc.pop());

      // Zero?
      if (!xc[0]) return alphabet.charAt(0);

      // Does str represent an integer? If so, no need for the division.
      if (i < 0) {
        --e;
      } else {
        x.c = xc;
        x.e = e;

        // The sign is needed for correct rounding.
        x.s = sign;
        x = div(x, y, dp, rm, baseOut);
        xc = x.c;
        r = x.r;
        e = x.e;
      }

      // xc now represents str converted to baseOut.

      // The index of the rounding digit.
      d = e + dp + 1;

      // The rounding digit: the digit to the right of the digit that may be rounded up.
      i = xc[d];

      // Look at the rounding digits and mode to determine whether to round up.

      k = baseOut / 2;
      r = r || d < 0 || xc[d + 1] != null;

      r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
            : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
             rm == (x.s < 0 ? 8 : 7));

      // If the index of the rounding digit is not greater than zero, or xc represents
      // zero, then the result of the base conversion is zero or, if rounding up, a value
      // such as 0.00001.
      if (d < 1 || !xc[0]) {

        // 1^-dp or 0
        str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
      } else {

        // Truncate xc to the required number of decimal places.
        xc.length = d;

        // Round up?
        if (r) {

          // Rounding up may mean the previous digit has to be rounded up and so on.
          for (--baseOut; ++xc[--d] > baseOut;) {
            xc[d] = 0;

            if (!d) {
              ++e;
              xc = [1].concat(xc);
            }
          }
        }

        // Determine trailing zeros.
        for (k = xc.length; !xc[--k];);

        // E.g. [4, 11, 15] becomes 4bf.
        for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

        // Add leading zeros, decimal point and trailing zeros as required.
        str = toFixedPoint(str, e, alphabet.charAt(0));
      }

      // The caller will add the sign.
      return str;
    };
  })();


  // Perform division in the specified base. Called by div and convertBase.
  div = (function () {

    // Assume non-zero x and k.
    function multiply(x, k, base) {
      var m, temp, xlo, xhi,
        carry = 0,
        i = x.length,
        klo = k % SQRT_BASE,
        khi = k / SQRT_BASE | 0;

      for (x = x.slice(); i--;) {
        xlo = x[i] % SQRT_BASE;
        xhi = x[i] / SQRT_BASE | 0;
        m = khi * xlo + xhi * klo;
        temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
        carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
        x[i] = temp % base;
      }

      if (carry) x = [carry].concat(x);

      return x;
    }

    function compare(a, b, aL, bL) {
      var i, cmp;

      if (aL != bL) {
        cmp = aL > bL ? 1 : -1;
      } else {

        for (i = cmp = 0; i < aL; i++) {

          if (a[i] != b[i]) {
            cmp = a[i] > b[i] ? 1 : -1;
            break;
          }
        }
      }

      return cmp;
    }

    function subtract(a, b, aL, base) {
      var i = 0;

      // Subtract b from a.
      for (; aL--;) {
        a[aL] -= i;
        i = a[aL] < b[aL] ? 1 : 0;
        a[aL] = i * base + a[aL] - b[aL];
      }

      // Remove leading zeros.
      for (; !a[0] && a.length > 1; a.splice(0, 1));
    }

    // x: dividend, y: divisor.
    return function (x, y, dp, rm, base) {
      var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
        yL, yz,
        s = x.s == y.s ? 1 : -1,
        xc = x.c,
        yc = y.c;

      // Either NaN, Infinity or 0?
      if (!xc || !xc[0] || !yc || !yc[0]) {

        return new BigNumber(

         // Return NaN if either NaN, or both Infinity or 0.
         !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :

          // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
          xc && xc[0] == 0 || !yc ? s * 0 : s / 0
       );
      }

      q = new BigNumber(s);
      qc = q.c = [];
      e = x.e - y.e;
      s = dp + e + 1;

      if (!base) {
        base = BASE;
        e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
        s = s / LOG_BASE | 0;
      }

      // Result exponent may be one less then the current value of e.
      // The coefficients of the BigNumbers from convertBase may have trailing zeros.
      for (i = 0; yc[i] == (xc[i] || 0); i++);

      if (yc[i] > (xc[i] || 0)) e--;

      if (s < 0) {
        qc.push(1);
        more = true;
      } else {
        xL = xc.length;
        yL = yc.length;
        i = 0;
        s += 2;

        // Normalise xc and yc so highest order digit of yc is >= base / 2.

        n = mathfloor(base / (yc[0] + 1));

        // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
        // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
        if (n > 1) {
          yc = multiply(yc, n, base);
          xc = multiply(xc, n, base);
          yL = yc.length;
          xL = xc.length;
        }

        xi = yL;
        rem = xc.slice(0, yL);
        remL = rem.length;

        // Add zeros to make remainder as long as divisor.
        for (; remL < yL; rem[remL++] = 0);
        yz = yc.slice();
        yz = [0].concat(yz);
        yc0 = yc[0];
        if (yc[1] >= base / 2) yc0++;
        // Not necessary, but to prevent trial digit n > base, when using base 3.
        // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

        do {
          n = 0;

          // Compare divisor and remainder.
          cmp = compare(yc, rem, yL, remL);

          // If divisor < remainder.
          if (cmp < 0) {

            // Calculate trial digit, n.

            rem0 = rem[0];
            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

            // n is how many times the divisor goes into the current remainder.
            n = mathfloor(rem0 / yc0);

            //  Algorithm:
            //  product = divisor multiplied by trial digit (n).
            //  Compare product and remainder.
            //  If product is greater than remainder:
            //    Subtract divisor from product, decrement trial digit.
            //  Subtract product from remainder.
            //  If product was less than remainder at the last compare:
            //    Compare new remainder and divisor.
            //    If remainder is greater than divisor:
            //      Subtract divisor from remainder, increment trial digit.

            if (n > 1) {

              // n may be > base only when base is 3.
              if (n >= base) n = base - 1;

              // product = divisor * trial digit.
              prod = multiply(yc, n, base);
              prodL = prod.length;
              remL = rem.length;

              // Compare product and remainder.
              // If product > remainder then trial digit n too high.
              // n is 1 too high about 5% of the time, and is not known to have
              // ever been more than 1 too high.
              while (compare(prod, rem, prodL, remL) == 1) {
                n--;

                // Subtract divisor from product.
                subtract(prod, yL < prodL ? yz : yc, prodL, base);
                prodL = prod.length;
                cmp = 1;
              }
            } else {

              // n is 0 or 1, cmp is -1.
              // If n is 0, there is no need to compare yc and rem again below,
              // so change cmp to 1 to avoid it.
              // If n is 1, leave cmp as -1, so yc and rem are compared again.
              if (n == 0) {

                // divisor < remainder, so n must be at least 1.
                cmp = n = 1;
              }

              // product = divisor
              prod = yc.slice();
              prodL = prod.length;
            }

            if (prodL < remL) prod = [0].concat(prod);

            // Subtract product from remainder.
            subtract(rem, prod, remL, base);
            remL = rem.length;

             // If product was < remainder.
            if (cmp == -1) {

              // Compare divisor and new remainder.
              // If divisor < new remainder, subtract divisor from remainder.
              // Trial digit n too low.
              // n is 1 too low about 5% of the time, and very rarely 2 too low.
              while (compare(yc, rem, yL, remL) < 1) {
                n++;

                // Subtract divisor from remainder.
                subtract(rem, yL < remL ? yz : yc, remL, base);
                remL = rem.length;
              }
            }
          } else if (cmp === 0) {
            n++;
            rem = [0];
          } // else cmp === 1 and n will be 0

          // Add the next digit, n, to the result array.
          qc[i++] = n;

          // Update the remainder.
          if (rem[0]) {
            rem[remL++] = xc[xi] || 0;
          } else {
            rem = [xc[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] != null) && s--);

        more = rem[0] != null;

        // Leading zero?
        if (!qc[0]) qc.splice(0, 1);
      }

      if (base == BASE) {

        // To calculate q.e, first get the number of digits of qc[0].
        for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

        round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

      // Caller is convertBase.
      } else {
        q.e = e;
        q.r = +more;
      }

      return q;
    };
  })();


  /*
   * Return a string representing the value of BigNumber n in fixed-point or exponential
   * notation rounded to the specified decimal places or significant digits.
   *
   * n: a BigNumber.
   * i: the index of the last digit required (i.e. the digit that may be rounded up).
   * rm: the rounding mode.
   * id: 1 (toExponential) or 2 (toPrecision).
   */
  function format(n, i, rm, id) {
    var c0, e, ne, len, str;

    if (rm == null) rm = ROUNDING_MODE;
    else intCheck(rm, 0, 8);

    if (!n.c) return n.toString();

    c0 = n.c[0];
    ne = n.e;

    if (i == null) {
      str = coeffToString(n.c);
      str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)
       ? toExponential(str, ne)
       : toFixedPoint(str, ne, '0');
    } else {
      n = round(new BigNumber(n), i, rm);

      // n.e may have changed if the value was rounded up.
      e = n.e;

      str = coeffToString(n.c);
      len = str.length;

      // toPrecision returns exponential notation if the number of significant digits
      // specified is less than the number of digits necessary to represent the integer
      // part of the value in fixed-point notation.

      // Exponential notation.
      if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {

        // Append zeros?
        for (; len < i; str += '0', len++);
        str = toExponential(str, e);

      // Fixed-point notation.
      } else {
        i -= ne + (id === 2 && e > ne);
        str = toFixedPoint(str, e, '0');

        // Append zeros?
        if (e + 1 > len) {
          if (--i > 0) for (str += '.'; i--; str += '0');
        } else {
          i += e - len;
          if (i > 0) {
            if (e + 1 == len) str += '.';
            for (; i--; str += '0');
          }
        }
      }
    }

    return n.s < 0 && c0 ? '-' + str : str;
  }


  // Handle BigNumber.max and BigNumber.min.
  // If any number is NaN, return NaN.
  function maxOrMin(args, n) {
    var k, y,
      i = 1,
      x = new BigNumber(args[0]);

    for (; i < args.length; i++) {
      y = new BigNumber(args[i]);
      if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
        x = y;
      }
    }

    return x;
  }


  /*
   * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
   * Called by minus, plus and times.
   */
  function normalise(n, c, e) {
    var i = 1,
      j = c.length;

     // Remove trailing zeros.
    for (; !c[--j]; c.pop());

    // Calculate the base 10 exponent. First get the number of digits of c[0].
    for (j = c[0]; j >= 10; j /= 10, i++);

    // Overflow?
    if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {

      // Infinity.
      n.c = n.e = null;

    // Underflow?
    } else if (e < MIN_EXP) {

      // Zero.
      n.c = [n.e = 0];
    } else {
      n.e = e;
      n.c = c;
    }

    return n;
  }


  // Handle values that fail the validity test in BigNumber.
  parseNumeric = (function () {
    var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
      dotAfter = /^([^.]+)\.$/,
      dotBefore = /^\.([^.]+)$/,
      isInfinityOrNaN = /^-?(Infinity|NaN)$/,
      whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

    return function (x, str, isNum, b) {
      var base,
        s = isNum ? str : str.replace(whitespaceOrPlus, '');

      // No exception on Infinity or NaN.
      if (isInfinityOrNaN.test(s)) {
        x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
      } else {
        if (!isNum) {

          // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
          s = s.replace(basePrefix, function (m, p1, p2) {
            base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
            return !b || b == base ? p1 : m;
          });

          if (b) {
            base = b;

            // E.g. '1.' to '1', '.1' to '0.1'
            s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
          }

          if (str != s) return new BigNumber(s, base);
        }

        // '[BigNumber Error] Not a number: {n}'
        // '[BigNumber Error] Not a base {b} number: {n}'
        if (BigNumber.DEBUG) {
          throw Error
            (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
        }

        // NaN
        x.s = null;
      }

      x.c = x.e = null;
    }
  })();


  /*
   * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
   * If r is truthy, it is known that there are more digits after the rounding digit.
   */
  function round(x, sd, rm, r) {
    var d, i, j, k, n, ni, rd,
      xc = x.c,
      pows10 = POWS_TEN;

    // if x is not Infinity or NaN...
    if (xc) {

      // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
      // n is a base 1e14 number, the value of the element of array x.c containing rd.
      // ni is the index of n within x.c.
      // d is the number of digits of n.
      // i is the index of rd within n including leading zeros.
      // j is the actual index of rd within n (if < 0, rd is a leading zero).
      out: {

        // Get the number of digits of the first element of xc.
        for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
        i = sd - d;

        // If the rounding digit is in the first element of xc...
        if (i < 0) {
          i += LOG_BASE;
          j = sd;
          n = xc[ni = 0];

          // Get the rounding digit at index j of n.
          rd = mathfloor(n / pows10[d - j - 1] % 10);
        } else {
          ni = mathceil((i + 1) / LOG_BASE);

          if (ni >= xc.length) {

            if (r) {

              // Needed by sqrt.
              for (; xc.length <= ni; xc.push(0));
              n = rd = 0;
              d = 1;
              i %= LOG_BASE;
              j = i - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            n = k = xc[ni];

            // Get the number of digits of n.
            for (d = 1; k >= 10; k /= 10, d++);

            // Get the index of rd within n.
            i %= LOG_BASE;

            // Get the index of rd within n, adjusted for leading zeros.
            // The number of leading zeros of n is given by LOG_BASE - d.
            j = i - LOG_BASE + d;

            // Get the rounding digit at index j of n.
            rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
          }
        }

        r = r || sd < 0 ||

        // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
         xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);

        r = rm < 4
         ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
         : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&

          // Check whether the digit to the left of the rounding digit is odd.
          ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
           rm == (x.s < 0 ? 8 : 7));

        if (sd < 1 || !xc[0]) {
          xc.length = 0;

          if (r) {

            // Convert sd to decimal places.
            sd -= x.e + 1;

            // 1, 0.1, 0.01, 0.001, 0.0001 etc.
            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
            x.e = -sd || 0;
          } else {

            // Zero.
            xc[0] = x.e = 0;
          }

          return x;
        }

        // Remove excess digits.
        if (i == 0) {
          xc.length = ni;
          k = 1;
          ni--;
        } else {
          xc.length = ni + 1;
          k = pows10[LOG_BASE - i];

          // E.g. 56700 becomes 56000 if 7 is the rounding digit.
          // j > 0 means i > number of leading zeros of n.
          xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
        }

        // Round up?
        if (r) {

          for (; ;) {

            // If the digit to be rounded up is in the first element of xc...
            if (ni == 0) {

              // i will be the length of xc[0] before k is added.
              for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
              j = xc[0] += k;
              for (k = 1; j >= 10; j /= 10, k++);

              // if i != k the length has increased.
              if (i != k) {
                x.e++;
                if (xc[0] == BASE) xc[0] = 1;
              }

              break;
            } else {
              xc[ni] += k;
              if (xc[ni] != BASE) break;
              xc[ni--] = 0;
              k = 1;
            }
          }
        }

        // Remove trailing zeros.
        for (i = xc.length; xc[--i] === 0; xc.pop());
      }

      // Overflow? Infinity.
      if (x.e > MAX_EXP) {
        x.c = x.e = null;

      // Underflow? Zero.
      } else if (x.e < MIN_EXP) {
        x.c = [x.e = 0];
      }
    }

    return x;
  }


  function valueOf(n) {
    var str,
      e = n.e;

    if (e === null) return n.toString();

    str = coeffToString(n.c);

    str = e <= TO_EXP_NEG || e >= TO_EXP_POS
      ? toExponential(str, e)
      : toFixedPoint(str, e, '0');

    return n.s < 0 ? '-' + str : str;
  }


  // PROTOTYPE/INSTANCE METHODS


  /*
   * Return a new BigNumber whose value is the absolute value of this BigNumber.
   */
  P.absoluteValue = P.abs = function () {
    var x = new BigNumber(this);
    if (x.s < 0) x.s = 1;
    return x;
  };


  /*
   * Return
   *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
   *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
   *   0 if they have the same value,
   *   or null if the value of either is NaN.
   */
  P.comparedTo = function (y, b) {
    return compare(this, new BigNumber(y, b));
  };


  /*
   * If dp is undefined or null or true or false, return the number of decimal places of the
   * value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
   *
   * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
   * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
   * ROUNDING_MODE if rm is omitted.
   *
   * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
   */
  P.decimalPlaces = P.dp = function (dp, rm) {
    var c, n, v,
      x = this;

    if (dp != null) {
      intCheck(dp, 0, MAX);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);

      return round(new BigNumber(x), dp + x.e + 1, rm);
    }

    if (!(c = x.c)) return null;
    n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

    // Subtract the number of trailing zeros of the last number.
    if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
    if (n < 0) n = 0;

    return n;
  };


  /*
   *  n / 0 = I
   *  n / N = N
   *  n / I = 0
   *  0 / n = 0
   *  0 / 0 = N
   *  0 / N = N
   *  0 / I = 0
   *  N / n = N
   *  N / 0 = N
   *  N / N = N
   *  N / I = N
   *  I / n = I
   *  I / 0 = I
   *  I / N = N
   *  I / I = N
   *
   * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
   * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
   */
  P.dividedBy = P.div = function (y, b) {
    return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
  };


  /*
   * Return a new BigNumber whose value is the integer part of dividing the value of this
   * BigNumber by the value of BigNumber(y, b).
   */
  P.dividedToIntegerBy = P.idiv = function (y, b) {
    return div(this, new BigNumber(y, b), 0, 1);
  };


  /*
   * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
   *
   * If m is present, return the result modulo m.
   * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
   * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
   *
   * The modular power operation works efficiently when x, n, and m are integers, otherwise it
   * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
   *
   * n {number|string|BigNumber} The exponent. An integer.
   * [m] {number|string|BigNumber} The modulus.
   *
   * '[BigNumber Error] Exponent not an integer: {n}'
   */
  P.exponentiatedBy = P.pow = function (n, m) {
    var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,
      x = this;

    n = new BigNumber(n);

    // Allow NaN and Infinity, but not other non-integers.
    if (n.c && !n.isInteger()) {
      throw Error
        (bignumberError + 'Exponent not an integer: ' + valueOf(n));
    }

    if (m != null) m = new BigNumber(m);

    // Exponent of MAX_SAFE_INTEGER is 15.
    nIsBig = n.e > 14;

    // If x is NaN, Infinity, 0 or 1, or n is Infinity, NaN or 0.
    if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {

      // The sign of the result of pow when x is negative depends on the evenness of n.
      // If +n overflows to Infinity, the evenness of n would be not be known.
      y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
      return m ? y.mod(m) : y;
    }

    nIsNeg = n.s < 0;

    if (m) {

      // x % m returns NaN if abs(m) is zero, or m is NaN.
      if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);

      isModExp = !nIsNeg && x.isInteger() && m.isInteger();

      if (isModExp) x = x.mod(m);

    // Overflow to Infinity: >=2**1e10 or >=1.0000024**1e15.
    // Underflow to 0: <=0.79**1e10 or <=0.9999975**1e15.
    } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
      // [1, 240000000]
      ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
      // [80000000000000]  [99999750000000]
      : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {

      // If x is negative and n is odd, k = -0, else k = 0.
      k = x.s < 0 && isOdd(n) ? -0 : 0;

      // If x >= 1, k = Infinity.
      if (x.e > -1) k = 1 / k;

      // If n is negative return 0, else return Infinity.
      return new BigNumber(nIsNeg ? 1 / k : k);

    } else if (POW_PRECISION) {

      // Truncating each coefficient array to a length of k after each multiplication
      // equates to truncating significant digits to POW_PRECISION + [28, 41],
      // i.e. there will be a minimum of 28 guard digits retained.
      k = mathceil(POW_PRECISION / LOG_BASE + 2);
    }

    if (nIsBig) {
      half = new BigNumber(0.5);
      if (nIsNeg) n.s = 1;
      nIsOdd = isOdd(n);
    } else {
      i = Math.abs(+valueOf(n));
      nIsOdd = i % 2;
    }

    y = new BigNumber(ONE);

    // Performs 54 loop iterations for n of 9007199254740991.
    for (; ;) {

      if (nIsOdd) {
        y = y.times(x);
        if (!y.c) break;

        if (k) {
          if (y.c.length > k) y.c.length = k;
        } else if (isModExp) {
          y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
        }
      }

      if (i) {
        i = mathfloor(i / 2);
        if (i === 0) break;
        nIsOdd = i % 2;
      } else {
        n = n.times(half);
        round(n, n.e + 1, 1);

        if (n.e > 14) {
          nIsOdd = isOdd(n);
        } else {
          i = +valueOf(n);
          if (i === 0) break;
          nIsOdd = i % 2;
        }
      }

      x = x.times(x);

      if (k) {
        if (x.c && x.c.length > k) x.c.length = k;
      } else if (isModExp) {
        x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
      }
    }

    if (isModExp) return y;
    if (nIsNeg) y = ONE.div(y);

    return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
  };


  /*
   * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
   * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
   *
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
   */
  P.integerValue = function (rm) {
    var n = new BigNumber(this);
    if (rm == null) rm = ROUNDING_MODE;
    else intCheck(rm, 0, 8);
    return round(n, n.e + 1, rm);
  };


  /*
   * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
   * otherwise return false.
   */
  P.isEqualTo = P.eq = function (y, b) {
    return compare(this, new BigNumber(y, b)) === 0;
  };


  /*
   * Return true if the value of this BigNumber is a finite number, otherwise return false.
   */
  P.isFinite = function () {
    return !!this.c;
  };


  /*
   * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
   * otherwise return false.
   */
  P.isGreaterThan = P.gt = function (y, b) {
    return compare(this, new BigNumber(y, b)) > 0;
  };


  /*
   * Return true if the value of this BigNumber is greater than or equal to the value of
   * BigNumber(y, b), otherwise return false.
   */
  P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
    return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;

  };


  /*
   * Return true if the value of this BigNumber is an integer, otherwise return false.
   */
  P.isInteger = function () {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  };


  /*
   * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
   * otherwise return false.
   */
  P.isLessThan = P.lt = function (y, b) {
    return compare(this, new BigNumber(y, b)) < 0;
  };


  /*
   * Return true if the value of this BigNumber is less than or equal to the value of
   * BigNumber(y, b), otherwise return false.
   */
  P.isLessThanOrEqualTo = P.lte = function (y, b) {
    return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
  };


  /*
   * Return true if the value of this BigNumber is NaN, otherwise return false.
   */
  P.isNaN = function () {
    return !this.s;
  };


  /*
   * Return true if the value of this BigNumber is negative, otherwise return false.
   */
  P.isNegative = function () {
    return this.s < 0;
  };


  /*
   * Return true if the value of this BigNumber is positive, otherwise return false.
   */
  P.isPositive = function () {
    return this.s > 0;
  };


  /*
   * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
   */
  P.isZero = function () {
    return !!this.c && this.c[0] == 0;
  };


  /*
   *  n - 0 = n
   *  n - N = N
   *  n - I = -I
   *  0 - n = -n
   *  0 - 0 = 0
   *  0 - N = N
   *  0 - I = -I
   *  N - n = N
   *  N - 0 = N
   *  N - N = N
   *  N - I = N
   *  I - n = I
   *  I - 0 = I
   *  I - N = N
   *  I - I = N
   *
   * Return a new BigNumber whose value is the value of this BigNumber minus the value of
   * BigNumber(y, b).
   */
  P.minus = function (y, b) {
    var i, j, t, xLTy,
      x = this,
      a = x.s;

    y = new BigNumber(y, b);
    b = y.s;

    // Either NaN?
    if (!a || !b) return new BigNumber(NaN);

    // Signs differ?
    if (a != b) {
      y.s = -b;
      return x.plus(y);
    }

    var xe = x.e / LOG_BASE,
      ye = y.e / LOG_BASE,
      xc = x.c,
      yc = y.c;

    if (!xe || !ye) {

      // Either Infinity?
      if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

      // Either zero?
      if (!xc[0] || !yc[0]) {

        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
        return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :

         // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
         ROUNDING_MODE == 3 ? -0 : 0);
      }
    }

    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();

    // Determine which is the bigger number.
    if (a = xe - ye) {

      if (xLTy = a < 0) {
        a = -a;
        t = xc;
      } else {
        ye = xe;
        t = yc;
      }

      t.reverse();

      // Prepend zeros to equalise exponents.
      for (b = a; b--; t.push(0));
      t.reverse();
    } else {

      // Exponents equal. Check digit by digit.
      j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

      for (a = b = 0; b < j; b++) {

        if (xc[b] != yc[b]) {
          xLTy = xc[b] < yc[b];
          break;
        }
      }
    }

    // x < y? Point xc to the array of the bigger number.
    if (xLTy) {
      t = xc;
      xc = yc;
      yc = t;
      y.s = -y.s;
    }

    b = (j = yc.length) - (i = xc.length);

    // Append zeros to xc if shorter.
    // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
    if (b > 0) for (; b--; xc[i++] = 0);
    b = BASE - 1;

    // Subtract yc from xc.
    for (; j > a;) {

      if (xc[--j] < yc[j]) {
        for (i = j; i && !xc[--i]; xc[i] = b);
        --xc[i];
        xc[j] += BASE;
      }

      xc[j] -= yc[j];
    }

    // Remove leading zeros and adjust exponent accordingly.
    for (; xc[0] == 0; xc.splice(0, 1), --ye);

    // Zero?
    if (!xc[0]) {

      // Following IEEE 754 (2008) 6.3,
      // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
      y.s = ROUNDING_MODE == 3 ? -1 : 1;
      y.c = [y.e = 0];
      return y;
    }

    // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
    // for finite x and y.
    return normalise(y, xc, ye);
  };


  /*
   *   n % 0 =  N
   *   n % N =  N
   *   n % I =  n
   *   0 % n =  0
   *  -0 % n = -0
   *   0 % 0 =  N
   *   0 % N =  N
   *   0 % I =  0
   *   N % n =  N
   *   N % 0 =  N
   *   N % N =  N
   *   N % I =  N
   *   I % n =  N
   *   I % 0 =  N
   *   I % N =  N
   *   I % I =  N
   *
   * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
   * BigNumber(y, b). The result depends on the value of MODULO_MODE.
   */
  P.modulo = P.mod = function (y, b) {
    var q, s,
      x = this;

    y = new BigNumber(y, b);

    // Return NaN if x is Infinity or NaN, or y is NaN or zero.
    if (!x.c || !y.s || y.c && !y.c[0]) {
      return new BigNumber(NaN);

    // Return x if y is Infinity or x is zero.
    } else if (!y.c || x.c && !x.c[0]) {
      return new BigNumber(x);
    }

    if (MODULO_MODE == 9) {

      // Euclidian division: q = sign(y) * floor(x / abs(y))
      // r = x - qy    where  0 <= r < abs(y)
      s = y.s;
      y.s = 1;
      q = div(x, y, 0, 3);
      y.s = s;
      q.s *= s;
    } else {
      q = div(x, y, 0, MODULO_MODE);
    }

    y = x.minus(q.times(y));

    // To match JavaScript %, ensure sign of zero is sign of dividend.
    if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;

    return y;
  };


  /*
   *  n * 0 = 0
   *  n * N = N
   *  n * I = I
   *  0 * n = 0
   *  0 * 0 = 0
   *  0 * N = N
   *  0 * I = N
   *  N * n = N
   *  N * 0 = N
   *  N * N = N
   *  N * I = N
   *  I * n = I
   *  I * 0 = N
   *  I * N = N
   *  I * I = I
   *
   * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
   * of BigNumber(y, b).
   */
  P.multipliedBy = P.times = function (y, b) {
    var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
      base, sqrtBase,
      x = this,
      xc = x.c,
      yc = (y = new BigNumber(y, b)).c;

    // Either NaN, Infinity or 0?
    if (!xc || !yc || !xc[0] || !yc[0]) {

      // Return NaN if either is NaN, or one is 0 and the other is Infinity.
      if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
        y.c = y.e = y.s = null;
      } else {
        y.s *= x.s;

        // Return Infinity if either is Infinity.
        if (!xc || !yc) {
          y.c = y.e = null;

        // Return 0 if either is 0.
        } else {
          y.c = [0];
          y.e = 0;
        }
      }

      return y;
    }

    e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
    y.s *= x.s;
    xcL = xc.length;
    ycL = yc.length;

    // Ensure xc points to longer array and xcL to its length.
    if (xcL < ycL) {
      zc = xc;
      xc = yc;
      yc = zc;
      i = xcL;
      xcL = ycL;
      ycL = i;
    }

    // Initialise the result array with zeros.
    for (i = xcL + ycL, zc = []; i--; zc.push(0));

    base = BASE;
    sqrtBase = SQRT_BASE;

    for (i = ycL; --i >= 0;) {
      c = 0;
      ylo = yc[i] % sqrtBase;
      yhi = yc[i] / sqrtBase | 0;

      for (k = xcL, j = i + k; j > i;) {
        xlo = xc[--k] % sqrtBase;
        xhi = xc[k] / sqrtBase | 0;
        m = yhi * xlo + xhi * ylo;
        xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
        c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
        zc[j--] = xlo % base;
      }

      zc[j] = c;
    }

    if (c) {
      ++e;
    } else {
      zc.splice(0, 1);
    }

    return normalise(y, zc, e);
  };


  /*
   * Return a new BigNumber whose value is the value of this BigNumber negated,
   * i.e. multiplied by -1.
   */
  P.negated = function () {
    var x = new BigNumber(this);
    x.s = -x.s || null;
    return x;
  };


  /*
   *  n + 0 = n
   *  n + N = N
   *  n + I = I
   *  0 + n = n
   *  0 + 0 = 0
   *  0 + N = N
   *  0 + I = I
   *  N + n = N
   *  N + 0 = N
   *  N + N = N
   *  N + I = N
   *  I + n = I
   *  I + 0 = I
   *  I + N = N
   *  I + I = I
   *
   * Return a new BigNumber whose value is the value of this BigNumber plus the value of
   * BigNumber(y, b).
   */
  P.plus = function (y, b) {
    var t,
      x = this,
      a = x.s;

    y = new BigNumber(y, b);
    b = y.s;

    // Either NaN?
    if (!a || !b) return new BigNumber(NaN);

    // Signs differ?
     if (a != b) {
      y.s = -b;
      return x.minus(y);
    }

    var xe = x.e / LOG_BASE,
      ye = y.e / LOG_BASE,
      xc = x.c,
      yc = y.c;

    if (!xe || !ye) {

      // Return Infinity if either Infinity.
      if (!xc || !yc) return new BigNumber(a / 0);

      // Either zero?
      // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
      if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
    }

    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();

    // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
    if (a = xe - ye) {
      if (a > 0) {
        ye = xe;
        t = yc;
      } else {
        a = -a;
        t = xc;
      }

      t.reverse();
      for (; a--; t.push(0));
      t.reverse();
    }

    a = xc.length;
    b = yc.length;

    // Point xc to the longer array, and b to the shorter length.
    if (a - b < 0) {
      t = yc;
      yc = xc;
      xc = t;
      b = a;
    }

    // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
    for (a = 0; b;) {
      a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
      xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
    }

    if (a) {
      xc = [a].concat(xc);
      ++ye;
    }

    // No need to check for zero, as +x + +y != 0 && -x + -y != 0
    // ye = MAX_EXP + 1 possible
    return normalise(y, xc, ye);
  };


  /*
   * If sd is undefined or null or true or false, return the number of significant digits of
   * the value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
   * If sd is true include integer-part trailing zeros in the count.
   *
   * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
   * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
   * ROUNDING_MODE if rm is omitted.
   *
   * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
   *                     boolean: whether to count integer-part trailing zeros: true or false.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
   */
  P.precision = P.sd = function (sd, rm) {
    var c, n, v,
      x = this;

    if (sd != null && sd !== !!sd) {
      intCheck(sd, 1, MAX);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);

      return round(new BigNumber(x), sd, rm);
    }

    if (!(c = x.c)) return null;
    v = c.length - 1;
    n = v * LOG_BASE + 1;

    if (v = c[v]) {

      // Subtract the number of trailing zeros of the last element.
      for (; v % 10 == 0; v /= 10, n--);

      // Add the number of digits of the first element.
      for (v = c[0]; v >= 10; v /= 10, n++);
    }

    if (sd && x.e + 1 > n) n = x.e + 1;

    return n;
  };


  /*
   * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
   * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
   *
   * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
   */
  P.shiftedBy = function (k) {
    intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
    return this.times('1e' + k);
  };


  /*
   *  sqrt(-n) =  N
   *  sqrt(N) =  N
   *  sqrt(-I) =  N
   *  sqrt(I) =  I
   *  sqrt(0) =  0
   *  sqrt(-0) = -0
   *
   * Return a new BigNumber whose value is the square root of the value of this BigNumber,
   * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
   */
  P.squareRoot = P.sqrt = function () {
    var m, n, r, rep, t,
      x = this,
      c = x.c,
      s = x.s,
      e = x.e,
      dp = DECIMAL_PLACES + 4,
      half = new BigNumber('0.5');

    // Negative/NaN/Infinity/zero?
    if (s !== 1 || !c || !c[0]) {
      return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
    }

    // Initial estimate.
    s = Math.sqrt(+valueOf(x));

    // Math.sqrt underflow/overflow?
    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
    if (s == 0 || s == 1 / 0) {
      n = coeffToString(c);
      if ((n.length + e) % 2 == 0) n += '0';
      s = Math.sqrt(+n);
      e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

      if (s == 1 / 0) {
        n = '5e' + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf('e') + 1) + e;
      }

      r = new BigNumber(n);
    } else {
      r = new BigNumber(s + '');
    }

    // Check for zero.
    // r could be zero if MIN_EXP is changed after the this value was created.
    // This would cause a division by zero (x/t) and hence Infinity below, which would cause
    // coeffToString to throw.
    if (r.c[0]) {
      e = r.e;
      s = e + dp;
      if (s < 3) s = 0;

      // Newton-Raphson iteration.
      for (; ;) {
        t = r;
        r = half.times(t.plus(div(x, t, dp, 1)));

        if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {

          // The exponent of r may here be one less than the final result exponent,
          // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
          // are indexed correctly.
          if (r.e < e) --s;
          n = n.slice(s - 3, s + 1);

          // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
          // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
          // iteration.
          if (n == '9999' || !rep && n == '4999') {

            // On the first iteration only, check to see if rounding up gives the
            // exact result as the nines may infinitely repeat.
            if (!rep) {
              round(t, t.e + DECIMAL_PLACES + 2, 0);

              if (t.times(t).eq(x)) {
                r = t;
                break;
              }
            }

            dp += 4;
            s += 4;
            rep = 1;
          } else {

            // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
            // result. If not, then there are further digits and m will be truthy.
            if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

              // Truncate to the first rounding digit.
              round(r, r.e + DECIMAL_PLACES + 2, 1);
              m = !r.times(r).eq(x);
            }

            break;
          }
        }
      }
    }

    return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
  };


  /*
   * Return a string representing the value of this BigNumber in exponential notation and
   * rounded using ROUNDING_MODE to dp fixed decimal places.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
   */
  P.toExponential = function (dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp++;
    }
    return format(this, dp, rm, 1);
  };


  /*
   * Return a string representing the value of this BigNumber in fixed-point notation rounding
   * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
   *
   * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
   * but e.g. (-0.00001).toFixed(0) is '-0'.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
   */
  P.toFixed = function (dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp = dp + this.e + 1;
    }
    return format(this, dp, rm);
  };


  /*
   * Return a string representing the value of this BigNumber in fixed-point notation rounded
   * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
   * of the format or FORMAT object (see BigNumber.set).
   *
   * The formatting object may contain some or all of the properties shown below.
   *
   * FORMAT = {
   *   prefix: '',
   *   groupSize: 3,
   *   secondaryGroupSize: 0,
   *   groupSeparator: ',',
   *   decimalSeparator: '.',
   *   fractionGroupSize: 0,
   *   fractionGroupSeparator: '\xA0',      // non-breaking space
   *   suffix: ''
   * };
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   * [format] {object} Formatting options. See FORMAT pbject above.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
   * '[BigNumber Error] Argument not an object: {format}'
   */
  P.toFormat = function (dp, rm, format) {
    var str,
      x = this;

    if (format == null) {
      if (dp != null && rm && typeof rm == 'object') {
        format = rm;
        rm = null;
      } else if (dp && typeof dp == 'object') {
        format = dp;
        dp = rm = null;
      } else {
        format = FORMAT;
      }
    } else if (typeof format != 'object') {
      throw Error
        (bignumberError + 'Argument not an object: ' + format);
    }

    str = x.toFixed(dp, rm);

    if (x.c) {
      var i,
        arr = str.split('.'),
        g1 = +format.groupSize,
        g2 = +format.secondaryGroupSize,
        groupSeparator = format.groupSeparator || '',
        intPart = arr[0],
        fractionPart = arr[1],
        isNeg = x.s < 0,
        intDigits = isNeg ? intPart.slice(1) : intPart,
        len = intDigits.length;

      if (g2) {
        i = g1;
        g1 = g2;
        g2 = i;
        len -= i;
      }

      if (g1 > 0 && len > 0) {
        i = len % g1 || g1;
        intPart = intDigits.substr(0, i);
        for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
        if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
        if (isNeg) intPart = '-' + intPart;
      }

      str = fractionPart
       ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)
        ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'),
         '$&' + (format.fractionGroupSeparator || ''))
        : fractionPart)
       : intPart;
    }

    return (format.prefix || '') + str + (format.suffix || '');
  };


  /*
   * Return an array of two BigNumbers representing the value of this BigNumber as a simple
   * fraction with an integer numerator and an integer denominator.
   * The denominator will be a positive non-zero value less than or equal to the specified
   * maximum denominator. If a maximum denominator is not specified, the denominator will be
   * the lowest value necessary to represent the number exactly.
   *
   * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
   *
   * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
   */
  P.toFraction = function (md) {
    var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,
      x = this,
      xc = x.c;

    if (md != null) {
      n = new BigNumber(md);

      // Throw if md is less than one or is not an integer, unless it is Infinity.
      if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
        throw Error
          (bignumberError + 'Argument ' +
            (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
      }
    }

    if (!xc) return new BigNumber(x);

    d = new BigNumber(ONE);
    n1 = d0 = new BigNumber(ONE);
    d1 = n0 = new BigNumber(ONE);
    s = coeffToString(xc);

    // Determine initial denominator.
    // d is a power of 10 and the minimum max denominator that specifies the value exactly.
    e = d.e = s.length - x.e - 1;
    d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
    md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;

    exp = MAX_EXP;
    MAX_EXP = 1 / 0;
    n = new BigNumber(s);

    // n0 = d1 = 0
    n0.c[0] = 0;

    for (; ;)  {
      q = div(n, d, 0, 1);
      d2 = d0.plus(q.times(d1));
      if (d2.comparedTo(md) == 1) break;
      d0 = d1;
      d1 = d2;
      n1 = n0.plus(q.times(d2 = n1));
      n0 = d2;
      d = n.minus(q.times(d2 = d));
      n = d2;
    }

    d2 = div(md.minus(d0), d1, 0, 1);
    n0 = n0.plus(d2.times(n1));
    d0 = d0.plus(d2.times(d1));
    n0.s = n1.s = x.s;
    e = e * 2;

    // Determine which fraction is closer to x, n0/d0 or n1/d1
    r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
        div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];

    MAX_EXP = exp;

    return r;
  };


  /*
   * Return the value of this BigNumber converted to a number primitive.
   */
  P.toNumber = function () {
    return +valueOf(this);
  };


  /*
   * Return a string representing the value of this BigNumber rounded to sd significant digits
   * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
   * necessary to represent the integer part of the value in fixed-point notation, then use
   * exponential notation.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
   */
  P.toPrecision = function (sd, rm) {
    if (sd != null) intCheck(sd, 1, MAX);
    return format(this, sd, rm, 2);
  };


  /*
   * Return a string representing the value of this BigNumber in base b, or base 10 if b is
   * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
   * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
   * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
   * TO_EXP_NEG, return exponential notation.
   *
   * [b] {number} Integer, 2 to ALPHABET.length inclusive.
   *
   * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
   */
  P.toString = function (b) {
    var str,
      n = this,
      s = n.s,
      e = n.e;

    // Infinity or NaN?
    if (e === null) {
      if (s) {
        str = 'Infinity';
        if (s < 0) str = '-' + str;
      } else {
        str = 'NaN';
      }
    } else {
      if (b == null) {
        str = e <= TO_EXP_NEG || e >= TO_EXP_POS
         ? toExponential(coeffToString(n.c), e)
         : toFixedPoint(coeffToString(n.c), e, '0');
      } else if (b === 10 && alphabetHasNormalDecimalDigits) {
        n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
        str = toFixedPoint(coeffToString(n.c), n.e, '0');
      } else {
        intCheck(b, 2, ALPHABET.length, 'Base');
        str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
      }

      if (s < 0 && n.c[0]) str = '-' + str;
    }

    return str;
  };


  /*
   * Return as toString, but do not accept a base argument, and include the minus sign for
   * negative zero.
   */
  P.valueOf = P.toJSON = function () {
    return valueOf(this);
  };


  P._isBigNumber = true;

  P[Symbol.toStringTag] = 'BigNumber';

  // Node.js v10.12.0+
  P[Symbol.for('nodejs.util.inspect.custom')] = P.valueOf;

  if (configObject != null) BigNumber.set(configObject);

  return BigNumber;
}


// PRIVATE HELPER FUNCTIONS

// These functions don't need access to variables,
// e.g. DECIMAL_PLACES, in the scope of the `clone` function above.


function bitFloor(n) {
  var i = n | 0;
  return n > 0 || n === i ? i : i - 1;
}


// Return a coefficient array as a string of base 10 digits.
function coeffToString(a) {
  var s, z,
    i = 1,
    j = a.length,
    r = a[0] + '';

  for (; i < j;) {
    s = a[i++] + '';
    z = LOG_BASE - s.length;
    for (; z--; s = '0' + s);
    r += s;
  }

  // Determine trailing zeros.
  for (j = r.length; r.charCodeAt(--j) === 48;);

  return r.slice(0, j + 1 || 1);
}


// Compare the value of BigNumbers x and y.
function compare(x, y) {
  var a, b,
    xc = x.c,
    yc = y.c,
    i = x.s,
    j = y.s,
    k = x.e,
    l = y.e;

  // Either NaN?
  if (!i || !j) return null;

  a = xc && !xc[0];
  b = yc && !yc[0];

  // Either zero?
  if (a || b) return a ? b ? 0 : -j : i;

  // Signs differ?
  if (i != j) return i;

  a = i < 0;
  b = k == l;

  // Either Infinity?
  if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

  // Compare exponents.
  if (!b) return k > l ^ a ? 1 : -1;

  j = (k = xc.length) < (l = yc.length) ? k : l;

  // Compare digit by digit.
  for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

  // Compare lengths.
  return k == l ? 0 : k > l ^ a ? 1 : -1;
}


/*
 * Check that n is a primitive number, an integer, and in range, otherwise throw.
 */
function intCheck(n, min, max, name) {
  if (n < min || n > max || n !== mathfloor(n)) {
    throw Error
     (bignumberError + (name || 'Argument') + (typeof n == 'number'
       ? n < min || n > max ? ' out of range: ' : ' not an integer: '
       : ' not a primitive number: ') + String(n));
  }
}


// Assumes finite n.
function isOdd(n) {
  var k = n.c.length - 1;
  return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
}


function toExponential(str, e) {
  return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
   (e < 0 ? 'e' : 'e+') + e;
}


function toFixedPoint(str, e, z) {
  var len, zs;

  // Negative exponent?
  if (e < 0) {

    // Prepend zeros.
    for (zs = z + '.'; ++e; zs += z);
    str = zs + str;

  // Positive exponent
  } else {
    len = str.length;

    // Append zeros.
    if (++e > len) {
      for (zs = z, e -= len; --e; zs += z);
      str += zs;
    } else if (e < len) {
      str = str.slice(0, e) + '.' + str.slice(e);
    }
  }

  return str;
}


// EXPORT


var BigNumber = clone();

export { Address as A, Buffer$1 as B, ChallengeSolution as C, Logger as L, NetEvent as N, TransactionFactory as T, Buffer$1$1 as a, BinaryWriter as b, BinaryReader as c, decompile as d, AddressTypes as e, AddressVerificator as f, bitcoin$1 as g, BufferHelper as h, AddressMap as i, process$1 as j, Long as k, ABIDataTypes as l, ABICoder as m, BigNumber as n, pLimit as p, regtest as r, testnet as t };
