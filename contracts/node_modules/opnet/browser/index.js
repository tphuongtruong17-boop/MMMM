import { d as decompile, B as Buffer, A as Address, N as NetEvent, a as Buffer$1, b as BinaryWriter, c as BinaryReader, e as AddressTypes, f as AddressVerificator, T as TransactionFactory, C as ChallengeSolution, r as regtest, t as testnet, g as bitcoin, h as BufferHelper, i as AddressMap, p as pLimit, j as process$1, L as Logger, k as Long, l as ABIDataTypes, m as ABICoder, n as BigNumber } from './vendors.js';
import { p as protobuf } from './protobuf.js';

const version = "1.8.0";

var OPNetTransactionTypes = /* @__PURE__ */ ((OPNetTransactionTypes2) => {
  OPNetTransactionTypes2["Generic"] = "Generic";
  OPNetTransactionTypes2["Deployment"] = "Deployment";
  OPNetTransactionTypes2["Interaction"] = "Interaction";
  return OPNetTransactionTypes2;
})(OPNetTransactionTypes || {});

class TransactionInput {
  originalTransactionId;
  outputTransactionIndex;
  scriptSignature;
  sequenceId;
  transactionInWitness = [];
  constructor(data) {
    this.originalTransactionId = data.originalTransactionId;
    this.outputTransactionIndex = data.outputTransactionIndex;
    this.scriptSignature = data.scriptSignature;
    this.sequenceId = data.sequenceId;
    this.transactionInWitness = data.transactionInWitness || [];
  }
}

class TransactionOutput {
  value;
  index;
  scriptPubKey;
  script;
  constructor(data) {
    this.value = this.convertValue(data.value);
    this.index = data.index;
    this.scriptPubKey = data.scriptPubKey;
    this.script = decompile(Buffer.from(this.scriptPubKey.hex, "hex"));
  }
  convertValue(value) {
    return BigInt(value);
  }
}

class LRUCache {
  cache;
  maxSize;
  constructor(maxSize) {
    this.cache = /* @__PURE__ */ new Map();
    this.maxSize = maxSize;
  }
  get(key) {
    const value = this.cache.get(key);
    if (value !== void 0) {
      this.cache.delete(key);
      this.cache.set(key, value);
    }
    return value;
  }
  set(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      if (firstKey !== void 0) {
        this.cache.delete(firstKey);
      }
    }
    this.cache.set(key, value);
  }
}

const P2OP_CACHE_MAX_SIZE = 5e3;
const p2opCache = new LRUCache(P2OP_CACHE_MAX_SIZE);
const addressCache = new LRUCache(P2OP_CACHE_MAX_SIZE);
const getP2op = (rawAddress, network) => {
  const cacheKey = `${network.bip32}:${network.pubKeyHash}:${network.bech32}:${rawAddress}`;
  let cached = p2opCache.get(cacheKey);
  if (cached === void 0) {
    let addr = addressCache.get(rawAddress);
    if (addr === void 0) {
      addr = Address.fromString(rawAddress);
      addressCache.set(rawAddress, addr);
    }
    cached = addr.p2op(network);
    p2opCache.set(cacheKey, cached);
  }
  return cached;
};

const ERROR_SELECTOR_BYTES = Uint8Array.from([99, 115, 157, 92]);
function areBytesEqual(a, b) {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
function startsWithErrorSelector(revertDataBytes) {
  return revertDataBytes.length >= 4 && areBytesEqual(Buffer.from(revertDataBytes.subarray(0, 4)), ERROR_SELECTOR_BYTES);
}
function bytesToHexString(byteArray) {
  return Array.from(byteArray, function(byte) {
    return ("0" + (byte & 255).toString(16)).slice(-2);
  }).join("");
}
function decodeRevertData(revertDataBytes) {
  if (startsWithErrorSelector(revertDataBytes)) {
    const decoder = new TextDecoder();
    const buf = Buffer.from(revertDataBytes.subarray(8));
    return decoder.decode(buf);
  } else {
    return `Unknown Revert: 0x${bytesToHexString(revertDataBytes)}`;
  }
}

class TransactionReceipt {
  /**
   * @description The receipt of the transaction.
   */
  receipt;
  /**
   * @description The receipt proofs of the transaction.
   */
  receiptProofs;
  /**
   * @description The events of the transaction.
   */
  events;
  rawEvents = {};
  /**
   * @description If the transaction was reverted, this field will contain the revert message.
   */
  rawRevert;
  revert;
  gasUsed;
  specialGasUsed;
  constructor(receipt, network) {
    this.receipt = receipt.receipt ? Buffer.from(receipt.receipt, "base64") : void 0;
    this.receiptProofs = receipt.receiptProofs || [];
    this.events = receipt.events ? this.parseEvents(receipt.events, network) : {};
    this.rawRevert = receipt.revert ? Buffer.from(receipt.revert, "base64") : void 0;
    this.revert = this.rawRevert ? decodeRevertData(this.rawRevert) : void 0;
    this.gasUsed = BigInt(receipt.gasUsed || "0x00") || 0n;
    this.specialGasUsed = BigInt(receipt.specialGasUsed || "0x00") || 0n;
  }
  /**
   * @description Parse transaction events.
   * @param events - The events to parse.
   * @param network - The network to use.
   * @private
   */
  parseEvents(events, network) {
    const parsedEvents = {};
    if (!Array.isArray(events)) {
      for (const [key, value] of Object.entries(events)) {
        const caP2op = getP2op(key, network);
        const v = value.map((event) => {
          return this.decodeEvent(event);
        });
        parsedEvents[caP2op] = v;
        this.rawEvents[key] = v;
      }
    } else {
      for (const event of events) {
        const parsedEvent = this.decodeEvent(event);
        const contractAddress = event.contractAddress;
        const caP2op = getP2op(contractAddress, network);
        if (!parsedEvents[caP2op]) {
          parsedEvents[caP2op] = [];
        }
        parsedEvents[caP2op].push(parsedEvent);
        if (!this.rawEvents[contractAddress]) {
          this.rawEvents[contractAddress] = [];
        }
        this.rawEvents[contractAddress].push(parsedEvent);
      }
    }
    return parsedEvents;
  }
  decodeEvent(event) {
    let eventData;
    if (typeof event.data === "string") {
      const buf = Buffer.from(event.data, "base64");
      eventData = new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
    } else {
      eventData = event.data;
    }
    return new NetEvent(event.type, eventData);
  }
}

class TransactionBase extends TransactionReceipt {
  /**
   * @description The transaction ID (hash).
   */
  id;
  /**
   * @description The transaction "hash".
   */
  hash;
  /**
   * @description The index of the transaction in the block.
   */
  index;
  /**
   * @description Returns the amount of satoshi that were burned in the transaction.
   */
  burnedBitcoin;
  /**
   * @description The priority fee of the transaction.
   */
  priorityFee;
  /**
   * @description The maximum amount of gas that can be spent by the transaction.
   */
  maxGasSat;
  /**
   * @description The inputs of the transaction.
   */
  inputs;
  /**
   * @description The outputs of the transaction.
   */
  outputs;
  /**
   * @description The type of the transaction.
   */
  OPNetType;
  /**
   * @description The amount of gas used by the transaction.
   */
  gasUsed;
  /**
   * @description Special gas used by the transaction.
   */
  specialGasUsed;
  /**
   * @description The proof of work challenge.
   */
  pow;
  /**
   * @description The block number in which the transaction was included.
   */
  blockNumber;
  constructor(transaction, network) {
    super(
      {
        receipt: transaction.receipt,
        receiptProofs: transaction.receiptProofs,
        events: transaction.events,
        revert: transaction.revert,
        gasUsed: transaction.gasUsed,
        specialGasUsed: transaction.specialGasUsed
      },
      network
    );
    this.id = transaction.id;
    this.hash = transaction.hash;
    this.index = transaction.index;
    if (transaction.blockNumber) this.blockNumber = BigInt(transaction.blockNumber);
    this.burnedBitcoin = BigInt(transaction.burnedBitcoin) || 0n;
    this.priorityFee = BigInt(transaction.priorityFee) || 0n;
    this.inputs = transaction.inputs.map((input) => new TransactionInput(input));
    this.outputs = transaction.outputs.map(
      (output) => new TransactionOutput(output)
    );
    this.OPNetType = transaction.OPNetType;
    this.gasUsed = BigInt(transaction.gasUsed || "0x00") || 0n;
    this.specialGasUsed = BigInt(transaction.specialGasUsed || "0x00") || 0n;
    if (transaction.pow) {
      this.pow = this.decodeProofOfWorkChallenge(transaction.pow);
    }
    this.maxGasSat = this.burnedBitcoin + (this.pow?.reward || 0n) - this.priorityFee;
  }
  decodeProofOfWorkChallenge(challenge) {
    return {
      preimage: Buffer.from(challenge.preimage, "base64"),
      reward: BigInt(challenge.reward) || 0n,
      difficulty: BigInt(challenge.difficulty || "0"),
      version: challenge.version || 0
    };
  }
}

class DeploymentTransaction extends TransactionBase {
  contractAddress;
  contractPublicKey;
  bytecode;
  wasCompressed;
  deployerPubKey;
  deployerHashedPublicKey;
  deployerAddress;
  contractSeed;
  contractSaltHash;
  from;
  constructor(transaction, network) {
    super(transaction, network);
    if (!transaction.deployerAddress && !transaction.revert) {
      throw new Error("Deployer address is missing");
    }
    try {
      this.from = new Address(
        Buffer.from(transaction.from, "base64"),
        Buffer.from(transaction.fromLegacy, "base64")
      );
      this.contractAddress = transaction.contractAddress;
      this.contractPublicKey = new Address(
        Buffer.from(transaction.contractPublicKey, "base64")
      );
      this.bytecode = Buffer.from(transaction.bytecode, "base64");
      this.wasCompressed = transaction.wasCompressed;
      if (transaction.deployerPubKey) {
        this.deployerPubKey = Buffer.from(transaction.deployerPubKey, "base64");
      }
      if (transaction.deployerAddress) {
        this.deployerHashedPublicKey = Buffer.from(
          transaction.deployerAddress.replace("0x", ""),
          "hex"
        );
      }
      if (this.deployerHashedPublicKey && this.deployerPubKey) {
        this.deployerAddress = new Address(
          this.deployerHashedPublicKey,
          this.deployerPubKey
        );
      }
      this.contractSeed = Buffer.from(transaction.contractSeed, "base64");
      this.contractSaltHash = Buffer.from(transaction.contractSaltHash, "base64");
    } catch {
    }
  }
}

class GenericTransaction extends TransactionBase {
  constructor(transaction, network) {
    super(transaction, network);
  }
}

class InteractionTransaction extends TransactionBase {
  /**
   * @description The calldata of the transaction.
   */
  calldata;
  /**
   * @description The sender's public key hash.
   */
  senderPubKeyHash;
  /**
   * @description The contract secret.
   */
  contractSecret;
  /**
   * @description The interaction public key.
   */
  interactionPubKey;
  /**
   * @description Whether the transaction data was compressed.
   */
  wasCompressed;
  /**
   * @description The from address of the transaction. (ALWAYS TAPROOT. *This address is generated from the P2TR of the pubkey of the deployer.*)
   */
  from;
  /**
   * @description The contract address where the transaction was sent. (AKA "to").
   */
  contractAddress;
  /**
   * @description The contract tweaked public key.
   */
  contractPublicKey;
  constructor(transaction, network) {
    super(transaction, network);
    this.contractPublicKey = new Address(
      Buffer$1.from(transaction.contractPublicKey, "base64")
    );
    if (transaction.calldata) {
      this.calldata = Buffer$1.from(transaction.calldata, "base64");
    }
    this.senderPubKeyHash = Buffer$1.from(transaction.senderPubKeyHash, "base64");
    this.contractSecret = Buffer$1.from(transaction.contractSecret, "base64");
    this.interactionPubKey = Buffer$1.from(transaction.interactionPubKey, "base64");
    this.wasCompressed = transaction.wasCompressed || false;
    this.contractAddress = transaction.contractAddress;
    try {
      if (transaction.from) {
        this.from = new Address(
          Buffer$1.from(transaction.from, "base64"),
          Buffer$1.from(transaction.fromLegacy, "base64")
        );
      }
    } catch {
    }
  }
}

BigInt.prototype.toJSON = function() {
  return this.toString();
};

class TransactionParser {
  static parseTransactions(transactions, network) {
    if (!transactions) {
      return [];
    }
    const transactionArray = [];
    for (const transaction of transactions) {
      if (!transaction) throw new Error(`Something went wrong while parsing transactions`);
      transactionArray.push(this.parseTransaction(transaction, network));
    }
    return transactionArray;
  }
  static parseTransaction(transaction, network) {
    if (!transaction) throw new Error("Transaction is required");
    const opnetType = transaction.OPNetType;
    switch (opnetType) {
      case OPNetTransactionTypes.Generic:
        return new GenericTransaction(transaction, network);
      case OPNetTransactionTypes.Interaction:
        return new InteractionTransaction(transaction, network);
      case OPNetTransactionTypes.Deployment:
        return new DeploymentTransaction(transaction, network);
      default:
        throw new Error("Unknown transaction type");
    }
  }
}

class Block {
  height;
  hash;
  previousBlockHash;
  previousBlockChecksum;
  bits;
  nonce;
  version;
  size;
  txCount;
  weight;
  strippedSize;
  time;
  medianTime;
  checksumRoot;
  merkleRoot;
  storageRoot;
  receiptRoot;
  ema;
  baseGas;
  gasUsed;
  checksumProofs;
  _rawBlock;
  _network;
  constructor(block, network) {
    if (!block) throw new Error("Invalid block.");
    this._rawBlock = block;
    this._network = network;
    this.height = BigInt(block.height.toString());
    this.hash = block.hash;
    this.previousBlockHash = block.previousBlockHash;
    this.previousBlockChecksum = block.previousBlockChecksum;
    this.bits = block.bits;
    this.nonce = block.nonce;
    this.version = block.version;
    this.size = block.size;
    this.txCount = block.txCount;
    this.ema = BigInt(block.ema);
    this.baseGas = BigInt(block.baseGas);
    this.gasUsed = BigInt(block.gasUsed);
    this.weight = block.weight;
    this.strippedSize = block.strippedSize;
    this.time = block.time;
    this.medianTime = block.medianTime;
    this.checksumRoot = block.checksumRoot;
    this.merkleRoot = block.merkleRoot;
    this.storageRoot = block.storageRoot;
    this.receiptRoot = block.receiptRoot;
    this.checksumProofs = block.checksumProofs;
  }
  _transactions;
  get transactions() {
    if (!this._transactions) {
      this._transactions = TransactionParser.parseTransactions(
        this._rawBlock.transactions,
        this._network
      );
    }
    return this._transactions;
  }
  _deployments;
  get deployments() {
    if (!this._deployments) {
      this._deployments = this._rawBlock.deployments ? this._rawBlock.deployments.map((address) => Address.fromString(address)) : [];
    }
    return this._deployments;
  }
  // For cases where you need raw without parsing
  get rawTransactions() {
    return this._rawBlock.transactions;
  }
}

class BlockGasParameters {
  blockNumber;
  gasUsed;
  targetGasLimit;
  ema;
  baseGas;
  gasPerSat;
  bitcoin;
  constructor(data) {
    this.blockNumber = BigInt(data.blockNumber);
    this.gasUsed = BigInt(data.gasUsed);
    this.targetGasLimit = BigInt(data.targetGasLimit);
    this.ema = BigInt(data.ema);
    this.baseGas = BigInt(data.baseGas);
    this.gasPerSat = BigInt(data.gasPerSat);
    this.bitcoin = {
      conservative: Number(data.bitcoin.conservative),
      recommended: {
        low: Number(data.bitcoin.recommended.low),
        medium: Number(data.bitcoin.recommended.medium),
        high: Number(data.bitcoin.recommended.high)
      }
    };
  }
}

function stringToBuffer(str) {
  return Buffer.from(str.replace("0x", ""), "hex");
}
function stringBase64ToBuffer(str) {
  return Buffer.from(str, "base64");
}

class BlockWitnessAPI {
  trusted;
  signature;
  timestamp;
  proofs;
  identity;
  publicKey;
  constructor(data) {
    this.trusted = data.trusted;
    this.signature = stringBase64ToBuffer(data.signature);
    this.timestamp = data.timestamp;
    this.proofs = Object.freeze(data.proofs.map((proof) => stringBase64ToBuffer(proof)));
    this.identity = data.identity ? stringBase64ToBuffer(data.identity) : void 0;
    this.publicKey = data.publicKey ? Address.fromString(data.publicKey) : void 0;
  }
}
class BlockWitness {
  blockNumber;
  witnesses;
  constructor(data) {
    this.blockNumber = typeof data.blockNumber === "string" ? BigInt(data.blockNumber) : data.blockNumber;
    this.witnesses = Object.freeze(
      data.witnesses.map((witness) => new BlockWitnessAPI(witness))
    );
  }
}
function parseBlockWitnesses(rawWitnesses) {
  return Object.freeze(rawWitnesses.map((rawWitness) => new BlockWitness(rawWitness)));
}

var NetworkName = /* @__PURE__ */ ((NetworkName2) => {
  NetworkName2["Mainnet"] = "mainnet";
  NetworkName2["Testnet"] = "testnet";
  NetworkName2["Regtest"] = "regtest";
  return NetworkName2;
})(NetworkName || {});
const SERIALIZATION_VERSION = 1;
class CallResultSerializer {
  /**
   * Serializes offline data to a Buffer.
   * @param {OfflineCallResultData} data - The data to serialize.
   * @returns {Buffer} The serialized binary data.
   */
  static serialize(data) {
    const writer = new BinaryWriter();
    writer.writeU8(SERIALIZATION_VERSION);
    writer.writeU8(this.networkNameToU8(data.network));
    writer.writeBytesWithLength(data.calldata);
    writer.writeStringWithLength(data.to);
    writer.writeStringWithLength(data.contractAddress);
    writer.writeU256(data.estimatedSatGas);
    writer.writeU256(data.estimatedRefundedGasInSat);
    writer.writeU256(data.estimatedGas ?? 0n);
    writer.writeU256(data.refundedGas ?? 0n);
    if (data.revert !== void 0) {
      writer.writeBoolean(true);
      writer.writeStringWithLength(data.revert);
    } else {
      writer.writeBoolean(false);
    }
    writer.writeBytesWithLength(data.result);
    this.writeAccessList(writer, data.accessList);
    if (data.bitcoinFees) {
      writer.writeBoolean(true);
      this.writeBitcoinFees(writer, data.bitcoinFees);
    } else {
      writer.writeBoolean(false);
    }
    this.writeChallenge(writer, data.challenge);
    writer.writeBytesWithLength(data.challengeOriginalPublicKey);
    this.writeUTXOs(writer, data.utxos);
    if (data.csvAddress) {
      writer.writeBoolean(true);
      writer.writeStringWithLength(data.csvAddress.address);
      writer.writeBytesWithLength(data.csvAddress.witnessScript);
    } else {
      writer.writeBoolean(false);
    }
    return Buffer.from(writer.getBuffer());
  }
  /**
   * Deserializes a Buffer to offline data.
   * @param {Buffer} buffer - The serialized data.
   * @returns {OfflineCallResultData} The deserialized data.
   */
  static deserialize(buffer) {
    const reader = new BinaryReader(buffer);
    const version = reader.readU8();
    if (version !== SERIALIZATION_VERSION) {
      throw new Error(
        `Unsupported serialization version: ${version}. Expected: ${SERIALIZATION_VERSION}`
      );
    }
    const network = this.u8ToNetworkName(reader.readU8());
    const calldata = Buffer.from(reader.readBytesWithLength());
    const to = reader.readStringWithLength();
    const contractAddress = reader.readStringWithLength();
    const estimatedSatGas = reader.readU256();
    const estimatedRefundedGasInSat = reader.readU256();
    const estimatedGasRaw = reader.readU256();
    const refundedGasRaw = reader.readU256();
    const estimatedGas = estimatedGasRaw > 0n ? estimatedGasRaw : void 0;
    const refundedGas = refundedGasRaw > 0n ? refundedGasRaw : void 0;
    const hasRevert = reader.readBoolean();
    const revert = hasRevert ? reader.readStringWithLength() : void 0;
    const result = Buffer.from(reader.readBytesWithLength());
    const accessList = this.readAccessList(reader);
    const hasBitcoinFees = reader.readBoolean();
    const bitcoinFees = hasBitcoinFees ? this.readBitcoinFees(reader) : void 0;
    const challenge = this.readChallenge(reader);
    const challengeOriginalPublicKey = Buffer.from(reader.readBytesWithLength());
    const utxos = this.readUTXOs(reader);
    const hasCsvAddress = reader.readBoolean();
    const csvAddress = hasCsvAddress ? {
      address: reader.readStringWithLength(),
      witnessScript: Buffer.from(reader.readBytesWithLength())
    } : void 0;
    return {
      calldata,
      to,
      contractAddress,
      estimatedSatGas,
      estimatedRefundedGasInSat,
      estimatedGas,
      refundedGas,
      revert,
      result,
      accessList,
      bitcoinFees,
      network,
      challenge,
      challengeOriginalPublicKey,
      utxos,
      csvAddress
    };
  }
  static networkNameToU8(network) {
    switch (network) {
      case "mainnet" /* Mainnet */:
        return 0;
      case "testnet" /* Testnet */:
        return 1;
      case "regtest" /* Regtest */:
        return 2;
      default:
        return 2;
    }
  }
  static u8ToNetworkName(value) {
    switch (value) {
      case 0:
        return "mainnet" /* Mainnet */;
      case 1:
        return "testnet" /* Testnet */;
      case 2:
        return "regtest" /* Regtest */;
      default:
        return "regtest" /* Regtest */;
    }
  }
  static writeAccessList(writer, accessList) {
    const contracts = Object.keys(accessList);
    writer.writeU16(contracts.length);
    for (const contract of contracts) {
      writer.writeStringWithLength(contract);
      const slots = accessList[contract];
      const slotKeys = Object.keys(slots);
      writer.writeU16(slotKeys.length);
      for (const key of slotKeys) {
        writer.writeStringWithLength(key);
        writer.writeStringWithLength(slots[key]);
      }
    }
  }
  static readAccessList(reader) {
    const accessList = {};
    const contractCount = reader.readU16();
    for (let i = 0; i < contractCount; i++) {
      const contract = reader.readStringWithLength();
      const slotCount = reader.readU16();
      accessList[contract] = {};
      for (let j = 0; j < slotCount; j++) {
        const key = reader.readStringWithLength();
        const value = reader.readStringWithLength();
        accessList[contract][key] = value;
      }
    }
    return accessList;
  }
  static FEE_PRECISION = 1e6;
  static writeBitcoinFees(writer, fees) {
    writer.writeU64(BigInt(Math.round(fees.conservative * this.FEE_PRECISION)));
    writer.writeU64(BigInt(Math.round(fees.recommended.low * this.FEE_PRECISION)));
    writer.writeU64(BigInt(Math.round(fees.recommended.medium * this.FEE_PRECISION)));
    writer.writeU64(BigInt(Math.round(fees.recommended.high * this.FEE_PRECISION)));
  }
  static readBitcoinFees(reader) {
    return {
      conservative: Number(reader.readU64()) / this.FEE_PRECISION,
      recommended: {
        low: Number(reader.readU64()) / this.FEE_PRECISION,
        medium: Number(reader.readU64()) / this.FEE_PRECISION,
        high: Number(reader.readU64()) / this.FEE_PRECISION
      }
    };
  }
  static writeChallenge(writer, challenge) {
    writer.writeStringWithLength(challenge.epochNumber);
    writer.writeStringWithLength(challenge.mldsaPublicKey);
    writer.writeStringWithLength(challenge.legacyPublicKey);
    writer.writeStringWithLength(challenge.solution);
    writer.writeStringWithLength(challenge.salt);
    writer.writeStringWithLength(challenge.graffiti);
    writer.writeU256(BigInt(challenge.difficulty));
    writer.writeStringWithLength(challenge.verification.epochHash);
    writer.writeStringWithLength(challenge.verification.epochRoot);
    writer.writeStringWithLength(challenge.verification.targetHash);
    writer.writeStringWithLength(challenge.verification.targetChecksum);
    writer.writeStringWithLength(challenge.verification.startBlock);
    writer.writeStringWithLength(challenge.verification.endBlock);
    writer.writeU16(challenge.verification.proofs.length);
    for (const proof of challenge.verification.proofs) {
      writer.writeStringWithLength(proof);
    }
    if (challenge.submission) {
      writer.writeBoolean(true);
      writer.writeStringWithLength(challenge.submission.mldsaPublicKey);
      writer.writeStringWithLength(challenge.submission.legacyPublicKey);
      writer.writeStringWithLength(challenge.submission.solution);
      writer.writeStringWithLength(challenge.submission.graffiti || "");
      writer.writeStringWithLength(challenge.submission.signature);
    } else {
      writer.writeBoolean(false);
    }
  }
  static readChallenge(reader) {
    const epochNumber = reader.readStringWithLength();
    const mldsaPublicKey = reader.readStringWithLength();
    const legacyPublicKey = reader.readStringWithLength();
    const solution = reader.readStringWithLength();
    const salt = reader.readStringWithLength();
    const graffiti = reader.readStringWithLength();
    const difficulty = Number(reader.readU256());
    const epochHash = reader.readStringWithLength();
    const epochRoot = reader.readStringWithLength();
    const targetHash = reader.readStringWithLength();
    const targetChecksum = reader.readStringWithLength();
    const startBlock = reader.readStringWithLength();
    const endBlock = reader.readStringWithLength();
    const proofCount = reader.readU16();
    const proofs = [];
    for (let i = 0; i < proofCount; i++) {
      proofs.push(reader.readStringWithLength());
    }
    const hasSubmission = reader.readBoolean();
    const submission = hasSubmission ? {
      mldsaPublicKey: reader.readStringWithLength(),
      legacyPublicKey: reader.readStringWithLength(),
      solution: reader.readStringWithLength(),
      graffiti: reader.readStringWithLength() || void 0,
      signature: reader.readStringWithLength()
    } : void 0;
    return {
      epochNumber,
      mldsaPublicKey,
      legacyPublicKey,
      solution,
      salt,
      graffiti,
      difficulty,
      verification: {
        epochHash,
        epochRoot,
        targetHash,
        targetChecksum,
        startBlock,
        endBlock,
        proofs
      },
      submission
    };
  }
  static writeUTXOs(writer, utxos) {
    writer.writeU16(utxos.length);
    for (const utxo of utxos) {
      writer.writeStringWithLength(utxo.transactionId);
      writer.writeU32(utxo.outputIndex);
      writer.writeU64(utxo.value);
      writer.writeStringWithLength(utxo.scriptPubKey.hex);
      writer.writeStringWithLength(utxo.scriptPubKey.address || "");
      writer.writeBoolean(!!utxo.isCSV);
      if (utxo.witnessScript) {
        writer.writeBoolean(true);
        const witnessScriptBuffer = typeof utxo.witnessScript === "string" ? Buffer.from(utxo.witnessScript, "hex") : utxo.witnessScript;
        writer.writeBytesWithLength(witnessScriptBuffer);
      } else {
        writer.writeBoolean(false);
      }
      if (utxo.redeemScript) {
        writer.writeBoolean(true);
        const redeemScriptBuffer = typeof utxo.redeemScript === "string" ? Buffer.from(utxo.redeemScript, "hex") : utxo.redeemScript;
        writer.writeBytesWithLength(redeemScriptBuffer);
      } else {
        writer.writeBoolean(false);
      }
    }
  }
  static readUTXOs(reader) {
    const count = reader.readU16();
    const utxos = [];
    for (let i = 0; i < count; i++) {
      const transactionId = reader.readStringWithLength();
      const outputIndex = reader.readU32();
      const value = reader.readU64();
      const hex = reader.readStringWithLength();
      const addressStr = reader.readStringWithLength();
      const isCSV = reader.readBoolean();
      const hasWitnessScript = reader.readBoolean();
      const witnessScript = hasWitnessScript ? Buffer.from(reader.readBytesWithLength()) : void 0;
      const hasRedeemScript = reader.readBoolean();
      const redeemScript = hasRedeemScript ? Buffer.from(reader.readBytesWithLength()) : void 0;
      utxos.push({
        transactionId,
        outputIndex,
        value,
        scriptPubKey: {
          hex,
          address: addressStr || void 0
        },
        isCSV,
        witnessScript,
        redeemScript
      });
    }
    return utxos;
  }
}

class TransactionHelper {
  static estimateMiningCost(utxos, extraOutputs, opReturnLen, network, feeRate) {
    const vBytes = this.estimateVBytes(utxos, extraOutputs, opReturnLen, network);
    return BigInt(Math.ceil(vBytes * feeRate));
  }
  static varIntLen(n) {
    return n < 253 ? 1 : n <= 65535 ? 3 : n <= 4294967295 ? 5 : 9;
  }
  static estimateVBytes(utxos, extraOutputs, scriptLength, network) {
    const INPUT_WU = {
      [AddressTypes.P2PKH]: 148 * 4,
      [AddressTypes.P2SH_OR_P2SH_P2WPKH]: 91 * 4 + 107,
      [AddressTypes.P2WPKH]: 41 * 4 + 107,
      [AddressTypes.P2TR]: 41 * 4 + 65,
      [AddressTypes.P2PK]: 148 * 4,
      [AddressTypes.P2WSH]: 41 * 4 + (1 + 73 + 1 + 33),
      [AddressTypes.P2OP]: 41 * 4 + 107,
      [AddressTypes.P2WDA]: 41 * 4 + 253
    };
    const OUTPUT_BYTES = {
      [AddressTypes.P2PKH]: 34,
      [AddressTypes.P2SH_OR_P2SH_P2WPKH]: 32,
      [AddressTypes.P2WPKH]: 31,
      [AddressTypes.P2TR]: 43,
      [AddressTypes.P2PK]: 34,
      [AddressTypes.P2OP]: 32,
      [AddressTypes.P2WSH]: 43,
      [AddressTypes.P2WDA]: 43
    };
    const ins = utxos.length ? utxos : new Array(3).fill(null);
    let weight = 0;
    weight += 8 * 4;
    const usesWitness = utxos.length === 0 || utxos.some((u) => {
      const t = AddressVerificator.detectAddressType(
        u?.scriptPubKey?.address ?? "",
        network
      );
      return t === AddressTypes.P2WPKH || t === AddressTypes.P2SH_OR_P2SH_P2WPKH || t === AddressTypes.P2TR || t === AddressTypes.P2OP || t === AddressTypes.P2WSH;
    });
    if (usesWitness) weight += 2 * 4;
    weight += this.varIntLen(ins.length) * 4;
    weight += this.varIntLen(extraOutputs.length) * 4;
    for (const u of ins) {
      const t = utxos.length === 0 ? AddressTypes.P2TR : AddressVerificator.detectAddressType(
        u?.scriptPubKey?.address ?? "",
        network
      ) ?? AddressTypes.P2PKH;
      weight += INPUT_WU[t] ?? 110 * 4;
    }
    for (const o of extraOutputs) {
      if ("address" in o) {
        const t = AddressVerificator.detectAddressType(o.address, network) ?? AddressTypes.P2PKH;
        weight += (OUTPUT_BYTES[t] ?? 40) * 4;
      } else if ("script" in o) {
        const scriptLen = o.script.length;
        const bytes = 8 + this.varIntLen(scriptLen) + scriptLen;
        weight += bytes * 4;
      } else {
        weight += 34 * 4;
      }
    }
    const witnessBytes = 1 + 3 * (this.varIntLen(32) + 32);
    weight += witnessBytes;
    const stackItemScript = this.varIntLen(scriptLength) + scriptLength;
    const controlBlock = 1 + 33;
    weight += stackItemScript + controlBlock;
    return Math.ceil(weight / 4);
  }
}

const factory = new TransactionFactory();
class CallResult {
  result;
  accessList;
  revert;
  calldata;
  loadedStorage;
  estimatedGas;
  refundedGas;
  properties = {};
  estimatedSatGas = 0n;
  estimatedRefundedGasInSat = 0n;
  events = [];
  to;
  address;
  fromAddress;
  csvAddress;
  #bitcoinFees;
  #rawEvents;
  #provider;
  #resultBase64;
  constructor(callResult, provider) {
    this.#provider = provider;
    this.#rawEvents = this.parseEvents(callResult.events);
    this.accessList = callResult.accessList;
    this.loadedStorage = callResult.loadedStorage;
    if (callResult.estimatedGas) {
      this.estimatedGas = BigInt(callResult.estimatedGas);
    }
    if (callResult.specialGas) {
      this.refundedGas = BigInt(callResult.specialGas);
    }
    const revert = typeof callResult.revert === "string" ? this.base64ToUint8Array(callResult.revert) : callResult.revert;
    if (revert) {
      this.revert = CallResult.decodeRevertData(revert);
    }
    if (typeof callResult.result === "string") {
      this.#resultBase64 = callResult.result;
      this.result = new BinaryReader(this.base64ToUint8Array(callResult.result));
    } else {
      this.#resultBase64 = "";
      this.result = callResult.result;
    }
  }
  get rawEvents() {
    return this.#rawEvents;
  }
  static decodeRevertData(revertDataBytes) {
    return decodeRevertData(revertDataBytes);
  }
  /**
   * Reconstructs a CallResult from offline serialized buffer.
   * Use this on a device to sign transactions offline.
   * @param {Buffer | string} input - The serialized offline data as Buffer or hex string.
   * @returns {CallResult} A CallResult instance ready for offline signing.
   *
   * @example
   * ```typescript
   * // Offline device: reconstruct from buffer
   * const buffer = fs.readFileSync('offline-tx.bin');
   * const simulation = CallResult.fromOfflineBuffer(buffer);
   *
   * // Now sign offline
   * const signedTx = await simulation.signTransaction({
   *     signer: wallet.keypair,
   *     // ... other params
   * });
   * ```
   */
  static fromOfflineBuffer(input) {
    const buffer = typeof input === "string" ? Buffer.from(input, "hex") : input;
    const data = CallResultSerializer.deserialize(buffer);
    const network = CallResult.resolveNetwork(data.network);
    const challengeWithOriginalKey = {
      ...data.challenge,
      legacyPublicKey: "0x" + data.challengeOriginalPublicKey.toString("hex")
    };
    const challengeSolution = new ChallengeSolution(challengeWithOriginalKey);
    const offlineProvider = {
      network,
      utxoManager: {
        getUTXOsForAmount: () => Promise.resolve(data.utxos),
        spentUTXO: () => {
        },
        clean: () => {
        }
      },
      getChallenge: () => Promise.resolve(challengeSolution),
      sendRawTransaction: () => {
        return Promise.reject(
          new Error(
            "Cannot broadcast from offline CallResult. Export signed transaction and broadcast online."
          )
        );
      },
      getCSV1ForAddress: () => {
        if (!data.csvAddress) {
          throw new Error("CSV address not available in offline data");
        }
        return data.csvAddress;
      }
    };
    const callResultData = {
      result: data.result.toString("base64"),
      accessList: data.accessList,
      events: {},
      revert: void 0,
      estimatedGas: data.estimatedGas?.toString(),
      specialGas: data.refundedGas?.toString()
    };
    const callResult = new CallResult(callResultData, offlineProvider);
    callResult.revert = data.revert;
    callResult.calldata = data.calldata;
    callResult.to = data.to;
    callResult.address = Address.fromString(data.contractAddress);
    callResult.estimatedSatGas = data.estimatedSatGas;
    callResult.estimatedRefundedGasInSat = data.estimatedRefundedGasInSat;
    callResult.csvAddress = data.csvAddress;
    if (data.bitcoinFees) {
      callResult.setBitcoinFee(data.bitcoinFees);
    }
    return callResult;
  }
  /**
   * Resolves a NetworkName enum to a Network object.
   */
  static resolveNetwork(networkName) {
    switch (networkName) {
      case NetworkName.Mainnet:
        return bitcoin;
      case NetworkName.Testnet:
        return testnet;
      case NetworkName.Regtest:
        return regtest;
      default:
        return regtest;
    }
  }
  setTo(to, address) {
    this.to = to;
    this.address = address;
  }
  setFromAddress(from) {
    this.fromAddress = from;
    this.csvAddress = this.fromAddress && this.fromAddress.originalPublicKey ? this.#provider.getCSV1ForAddress(this.fromAddress) : void 0;
  }
  /**
   * Signs a bitcoin interaction transaction from a simulated contract call without broadcasting.
   * @param {TransactionParameters} interactionParams - The parameters for the transaction.
   * @param {bigint} amountAddition - Additional satoshis to request when acquiring UTXOs.
   * @returns {Promise<SignedInteractionTransactionReceipt>} The signed transaction data and UTXO tracking info.
   */
  async signTransaction(interactionParams, amountAddition = 0n) {
    if (!this.address) {
      throw new Error("Contract address not set");
    }
    if (!this.calldata) {
      throw new Error("Calldata not set");
    }
    if (!this.to) {
      throw new Error("To address not set");
    }
    if (this.revert) {
      throw new Error(`Can not send transaction! Simulation reverted: ${this.revert}`);
    }
    let UTXOs = interactionParams.utxos || await this.acquire(interactionParams, amountAddition);
    if (interactionParams.extraInputs) {
      UTXOs = UTXOs.filter((utxo) => {
        return interactionParams.extraInputs?.find((input) => {
          return input.outputIndex === utxo.outputIndex && input.transactionId === utxo.transactionId;
        }) === void 0;
      });
    }
    if (!UTXOs || UTXOs.length === 0) {
      throw new Error("No UTXOs found");
    }
    const priorityFee = interactionParams.priorityFee || 0n;
    const challenge = interactionParams.challenge || await this.#provider.getChallenge();
    const params = {
      contract: this.address.toHex(),
      calldata: this.calldata,
      priorityFee,
      gasSatFee: this.bigintMax(this.estimatedSatGas, interactionParams.minGas || 0n),
      feeRate: interactionParams.feeRate || this.#bitcoinFees?.conservative || 10,
      from: interactionParams.refundTo,
      utxos: UTXOs,
      to: this.to,
      network: interactionParams.network,
      optionalInputs: interactionParams.extraInputs || [],
      optionalOutputs: interactionParams.extraOutputs || [],
      signer: interactionParams.signer,
      challenge,
      note: interactionParams.note,
      anchor: interactionParams.anchor || false,
      txVersion: interactionParams.txVersion || 2,
      mldsaSigner: interactionParams.mldsaSigner,
      linkMLDSAPublicKeyToAddress: interactionParams.linkMLDSAPublicKeyToAddress ?? true,
      revealMLDSAPublicKey: interactionParams.revealMLDSAPublicKey ?? false
    };
    const transaction = await factory.signInteraction(params);
    const csvUTXOs = UTXOs.filter((u) => u.isCSV === true);
    const p2wdaUTXOs = UTXOs.filter((u) => u.witnessScript && u.isCSV !== true);
    const regularUTXOs = UTXOs.filter((u) => !u.witnessScript && u.isCSV !== true);
    const refundAddress = interactionParams.sender || interactionParams.refundTo;
    const p2wdaAddress = interactionParams.from?.p2wda(this.#provider.network);
    let refundToAddress;
    if (this.csvAddress && refundAddress === this.csvAddress.address) {
      refundToAddress = this.csvAddress.address;
    } else if (p2wdaAddress && refundAddress === p2wdaAddress.address) {
      refundToAddress = p2wdaAddress.address;
    } else {
      refundToAddress = refundAddress;
    }
    const utxoTracking = {
      csvUTXOs,
      p2wdaUTXOs,
      regularUTXOs,
      refundAddress,
      refundToAddress,
      csvAddress: this.csvAddress,
      p2wdaAddress: p2wdaAddress ? { address: p2wdaAddress.address, witnessScript: p2wdaAddress.witnessScript } : void 0,
      isP2WDA: interactionParams.p2wda || false
    };
    return {
      fundingTransactionRaw: transaction.fundingTransaction,
      interactionTransactionRaw: transaction.interactionTransaction,
      nextUTXOs: transaction.nextUTXOs,
      estimatedFees: transaction.estimatedFees,
      challengeSolution: transaction.challenge,
      interactionAddress: transaction.interactionAddress,
      fundingUTXOs: transaction.fundingUTXOs,
      fundingInputUtxos: transaction.fundingInputUtxos,
      compiledTargetScript: transaction.compiledTargetScript,
      utxoTracking
    };
  }
  /**
   * Broadcasts a pre-signed interaction transaction.
   * @param {SignedInteractionTransactionReceipt} signedTx - The signed transaction data.
   * @returns {Promise<InteractionTransactionReceipt>} The transaction receipt with broadcast results.
   */
  async sendPresignedTransaction(signedTx) {
    if (!signedTx.utxoTracking.isP2WDA) {
      if (!signedTx.fundingTransactionRaw) {
        throw new Error("Funding transaction not created");
      }
      const tx1 = await this.#provider.sendRawTransaction(
        signedTx.fundingTransactionRaw,
        false
      );
      if (!tx1 || tx1.error) {
        throw new Error(`Error sending transaction: ${tx1?.error || "Unknown error"}`);
      }
      if (!tx1.success) {
        throw new Error(`Error sending transaction: ${tx1.result || "Unknown error"}`);
      }
    }
    const tx2 = await this.#provider.sendRawTransaction(
      signedTx.interactionTransactionRaw,
      false
    );
    if (!tx2 || tx2.error) {
      throw new Error(`Error sending transaction: ${tx2?.error || "Unknown error"}`);
    }
    if (!tx2.result) {
      throw new Error("No transaction ID returned");
    }
    if (!tx2.success) {
      throw new Error(`Error sending transaction: ${tx2.result || "Unknown error"}`);
    }
    this.#processUTXOTracking(signedTx);
    return {
      interactionAddress: signedTx.interactionAddress,
      transactionId: tx2.result,
      peerAcknowledgements: tx2.peers || 0,
      newUTXOs: signedTx.nextUTXOs,
      estimatedFees: signedTx.estimatedFees,
      challengeSolution: signedTx.challengeSolution,
      rawTransaction: signedTx.interactionTransactionRaw,
      fundingUTXOs: signedTx.fundingUTXOs,
      fundingInputUtxos: signedTx.fundingInputUtxos,
      compiledTargetScript: signedTx.compiledTargetScript
    };
  }
  /**
   * Signs and broadcasts a bitcoin interaction transaction from a simulated contract call.
   * @param {TransactionParameters} interactionParams - The parameters for the transaction.
   * @param {bigint} amountAddition - Additional satoshis to request when acquiring UTXOs.
   * @returns {Promise<InteractionTransactionReceipt>} The transaction receipt with broadcast results.
   */
  async sendTransaction(interactionParams, amountAddition = 0n) {
    try {
      const signedTx = await this.signTransaction(interactionParams, amountAddition);
      return await this.sendPresignedTransaction(signedTx);
    } catch (e) {
      const msgStr = e.message;
      if (msgStr.includes("Insufficient funds to pay the fees") && amountAddition === 0n) {
        return await this.sendTransaction(interactionParams, 200000n);
      }
      this.#provider.utxoManager.clean();
      throw e;
    }
  }
  /**
   * Set the gas estimation values.
   * @param {bigint} estimatedGas - The estimated gas in satoshis.
   * @param {bigint} refundedGas - The refunded gas in satoshis.
   */
  setGasEstimation(estimatedGas, refundedGas) {
    this.estimatedSatGas = estimatedGas;
    this.estimatedRefundedGasInSat = refundedGas;
  }
  /**
   * Set the Bitcoin fee rates.
   * @param {BitcoinFees} fees - The Bitcoin fee rates.
   */
  setBitcoinFee(fees) {
    this.#bitcoinFees = fees;
  }
  /**
   * Set the decoded contract output properties.
   * @param {DecodedOutput} decoded - The decoded output.
   */
  setDecoded(decoded) {
    this.properties = Object.freeze(decoded.obj);
  }
  /**
   * Set the contract events.
   * @param {U} events - The contract events.
   */
  setEvents(events) {
    this.events = events;
  }
  /**
   * Set the calldata for the transaction.
   * @param {Buffer} calldata - The calldata buffer.
   */
  setCalldata(calldata) {
    this.calldata = calldata;
  }
  /**
   * Serializes this CallResult to a Buffer.
   * Call this on an online device after simulation, then transfer the result
   * to an offline device for signing.
   *
   * @param {string} refundAddress - The address to fetch UTXOs from (your p2tr address).
   * @param {bigint} amount - The amount of satoshis needed for the transaction.
   * @returns {Promise<Buffer>} Serialized buffer ready for offline signing.
   *
   * @example
   * ```typescript
   * // Online device: prepare for offline signing
   * const simulation = await contract.transfer(recipient, amount);
   * const offlineBuffer = await simulation.toOfflineBuffer(wallet.p2tr, 50000n);
   *
   * // Save to file or encode as base64 for QR code
   * fs.writeFileSync('offline-tx.bin', offlineBuffer);
   * // Or: const qrData = offlineBuffer.toString('base64');
   * ```
   */
  async toOfflineBuffer(refundAddress, amount) {
    if (!this.calldata) {
      throw new Error("Calldata not set");
    }
    if (!this.to) {
      throw new Error("Contract address not set");
    }
    if (!this.address) {
      throw new Error("Contract Address object not set");
    }
    if (this.revert) {
      throw new Error(`Cannot serialize reverted simulation: ${this.revert}`);
    }
    const utxos = await this.#provider.utxoManager.getUTXOsForAmount({
      address: refundAddress,
      amount: amount + this.estimatedSatGas + 10000n,
      // Add buffer for fees
      throwErrors: true
    });
    const challengeSolution = await this.#provider.getChallenge();
    const networkName = this.#getNetworkName();
    return CallResultSerializer.serialize({
      calldata: this.calldata,
      to: this.to,
      contractAddress: this.address.toHex(),
      estimatedSatGas: this.estimatedSatGas,
      estimatedRefundedGasInSat: this.estimatedRefundedGasInSat,
      revert: this.revert,
      result: Buffer.from(this.#resultBase64, "base64"),
      accessList: this.accessList,
      bitcoinFees: this.#bitcoinFees,
      network: networkName,
      estimatedGas: this.estimatedGas,
      refundedGas: this.refundedGas,
      challenge: challengeSolution.toRaw(),
      challengeOriginalPublicKey: challengeSolution.publicKey.originalPublicKeyBuffer(),
      utxos,
      csvAddress: this.csvAddress
    });
  }
  /**
   * Gets the NetworkName enum from the provider's network.
   * @returns {NetworkName} The network name enum value.
   */
  #getNetworkName() {
    const network = this.#provider.network;
    if (network === bitcoin) return NetworkName.Mainnet;
    if (network === testnet) return NetworkName.Testnet;
    if (network === regtest) return NetworkName.Regtest;
    return NetworkName.Regtest;
  }
  /**
   * Clone a UTXO and attach a witness script.
   * @param {UTXO} utxo - The UTXO to clone.
   * @param {Buffer} witnessScript - The witness script to attach.
   * @returns {UTXO} The cloned UTXO with witness script.
   */
  #cloneUTXOWithWitnessScript(utxo, witnessScript) {
    const clone = Object.assign(
      Object.create(Object.getPrototypeOf(utxo)),
      utxo
    );
    clone.witnessScript = witnessScript;
    return clone;
  }
  /**
   * Process UTXO tracking after transaction broadcast.
   * @param {SignedInteractionTransactionReceipt} signedTx - The signed transaction receipt.
   */
  #processUTXOTracking(signedTx) {
    const {
      csvUTXOs,
      p2wdaUTXOs,
      regularUTXOs,
      refundAddress,
      refundToAddress,
      csvAddress,
      p2wdaAddress
    } = signedTx.utxoTracking;
    if (csvAddress && csvUTXOs.length) {
      const finalUTXOs = signedTx.nextUTXOs.map(
        (u) => this.#cloneUTXOWithWitnessScript(u, csvAddress.witnessScript)
      );
      this.#provider.utxoManager.spentUTXO(
        csvAddress.address,
        csvUTXOs,
        refundToAddress === csvAddress.address ? finalUTXOs : []
      );
    }
    if (p2wdaAddress && p2wdaUTXOs.length) {
      const finalUTXOs = signedTx.nextUTXOs.map(
        (u) => this.#cloneUTXOWithWitnessScript(u, p2wdaAddress.witnessScript)
      );
      this.#provider.utxoManager.spentUTXO(
        p2wdaAddress.address,
        p2wdaUTXOs,
        refundToAddress === p2wdaAddress.address ? finalUTXOs : []
      );
    }
    if (regularUTXOs.length) {
      this.#provider.utxoManager.spentUTXO(
        refundAddress,
        regularUTXOs,
        refundToAddress === refundAddress ? signedTx.nextUTXOs : []
      );
    }
    if (csvAddress && refundToAddress === csvAddress.address && !csvUTXOs.length) {
      const finalUTXOs = signedTx.nextUTXOs.map(
        (u) => this.#cloneUTXOWithWitnessScript(u, csvAddress.witnessScript)
      );
      this.#provider.utxoManager.spentUTXO(csvAddress.address, [], finalUTXOs);
    } else if (p2wdaAddress && refundToAddress === p2wdaAddress.address && !p2wdaUTXOs.length) {
      const finalUTXOs = signedTx.nextUTXOs.map(
        (u) => this.#cloneUTXOWithWitnessScript(u, p2wdaAddress.witnessScript)
      );
      this.#provider.utxoManager.spentUTXO(p2wdaAddress.address, [], finalUTXOs);
    } else if (refundToAddress === refundAddress && !regularUTXOs.length) {
      const isSpecialAddress = csvAddress && refundToAddress === csvAddress.address || p2wdaAddress && refundToAddress === p2wdaAddress.address;
      if (!isSpecialAddress) {
        this.#provider.utxoManager.spentUTXO(refundAddress, [], signedTx.nextUTXOs);
      }
    }
  }
  /**
   * Acquire UTXOs for the transaction.
   * @param {TransactionParameters} interactionParams - The transaction parameters.
   * @param {bigint} amountAddition - Additional amount to request.
   * @returns {Promise<UTXO[]>} The acquired UTXOs.
   */
  async acquire(interactionParams, amountAddition = 0n) {
    if (!this.calldata) {
      throw new Error("Calldata not set");
    }
    if (!interactionParams.feeRate) {
      interactionParams.feeRate = 1.5;
    }
    const feeRate = interactionParams.feeRate;
    const priority = interactionParams.priorityFee ?? 0n;
    const addedOuts = interactionParams.extraOutputs ?? [];
    const totalOuts = BigInt(addedOuts.reduce((s, o) => s + o.value, 0));
    const gasFee = this.bigintMax(this.estimatedSatGas, interactionParams.minGas ?? 0n);
    const preWant = gasFee + priority + amountAddition + totalOuts + interactionParams.maximumAllowedSatToSpend;
    let utxos = interactionParams.utxos ?? await this.#fetchUTXOs(preWant, interactionParams);
    let refetched = false;
    while (true) {
      const miningCost = TransactionHelper.estimateMiningCost(
        utxos,
        addedOuts,
        this.calldata.length + 200,
        interactionParams.network,
        feeRate
      );
      const want = gasFee + priority + amountAddition + totalOuts + miningCost + interactionParams.maximumAllowedSatToSpend;
      const have = utxos.reduce((s, u) => s + u.value, 0n);
      if (have >= want) break;
      if (refetched) {
        throw new Error("Not enough sat to complete transaction");
      }
      utxos = await this.#fetchUTXOs(want, interactionParams);
      refetched = true;
      const haveAfter = utxos.reduce((s, u) => s + u.value, 0n);
      if (haveAfter === have) {
        throw new Error("Not enough sat to complete transaction");
      }
    }
    return utxos;
  }
  /**
   * Return the maximum of two bigints.
   * @param {bigint} a - First value.
   * @param {bigint} b - Second value.
   * @returns {bigint} The maximum value.
   */
  bigintMax(a, b) {
    return a > b ? a : b;
  }
  /**
   * Fetch UTXOs from the provider.
   * @param {bigint} amount - The amount needed.
   * @param {TransactionParameters} interactionParams - The transaction parameters.
   * @returns {Promise<UTXO[]>} The fetched UTXOs.
   */
  async #fetchUTXOs(amount, interactionParams) {
    if (!interactionParams.sender && !interactionParams.refundTo) {
      throw new Error("Refund address not set");
    }
    const utxoSetting = {
      address: interactionParams.sender || interactionParams.refundTo,
      amount,
      throwErrors: true,
      maxUTXOs: interactionParams.maxUTXOs,
      throwIfUTXOsLimitReached: interactionParams.throwIfUTXOsLimitReached,
      csvAddress: !interactionParams.p2wda && !interactionParams.dontUseCSVUtxos ? this.csvAddress?.address : void 0
    };
    const utxos = await this.#provider.utxoManager.getUTXOsForAmount(utxoSetting);
    if (!utxos) {
      throw new Error("No UTXOs found");
    }
    if (this.csvAddress) {
      const csvUtxos = utxos.filter((u) => u.isCSV === true);
      if (csvUtxos.length > 0) {
        for (const utxo of csvUtxos) {
          utxo.witnessScript = this.csvAddress.witnessScript;
        }
      }
    }
    if (interactionParams.p2wda) {
      if (!interactionParams.from) {
        throw new Error("From address not set in interaction parameters");
      }
      const p2wda = interactionParams.from.p2wda(this.#provider.network);
      if (interactionParams.sender ? p2wda.address === interactionParams.sender : p2wda.address === interactionParams.refundTo) {
        utxos.forEach((utxo) => {
          utxo.witnessScript = p2wda.witnessScript;
        });
      }
    }
    return utxos;
  }
  /**
   * Get storage keys from access list.
   * @returns {LoadedStorage} The loaded storage map.
   */
  getValuesFromAccessList() {
    const storage = {};
    for (const contract in this.accessList) {
      const contractData = this.accessList[contract];
      storage[contract] = Object.keys(contractData);
    }
    return storage;
  }
  /**
   * Convert contract address to p2op string.
   * @param {string} contract - The contract address hex.
   * @returns {string} The p2op address string.
   */
  contractToString(contract) {
    const addressCa = Address.fromString(contract);
    return addressCa.p2op(this.#provider.network);
  }
  /**
   * Parse raw events into EventList format.
   * @param {RawEventList} events - The raw events.
   * @returns {EventList} The parsed events.
   */
  parseEvents(events) {
    const eventsList = {};
    for (const [contract, value] of Object.entries(events)) {
      const events2 = [];
      for (const event of value) {
        const eventData = new NetEvent(event.type, Buffer.from(event.data, "base64"));
        events2.push(eventData);
      }
      eventsList[this.contractToString(contract)] = events2;
    }
    return eventsList;
  }
  /**
   * Convert base64 string to Uint8Array.
   * @param {string} base64 - The base64 encoded string.
   * @returns {Uint8Array} The decoded bytes.
   */
  base64ToUint8Array(base64) {
    return BufferHelper.bufferToUint8Array(Buffer.from(base64, "base64"));
  }
}

class ContractData {
  contractAddress;
  contractPublicKey;
  bytecode;
  wasCompressed;
  deployedTransactionId;
  deployedTransactionHash;
  deployerPubKey;
  deployerHashedPublicKey;
  contractSeed;
  contractSaltHash;
  deployerAddress;
  constructor(raw) {
    this.contractAddress = raw.contractAddress;
    this.contractPublicKey = Buffer.isBuffer(raw.contractPublicKey) ? new Address(raw.contractPublicKey) : new Address(Buffer.from(raw.contractPublicKey, "base64"));
    this.bytecode = Buffer.isBuffer(raw.bytecode) ? raw.bytecode : Buffer.from(raw.bytecode, "base64");
    this.wasCompressed = raw.wasCompressed;
    this.deployedTransactionId = raw.deployedTransactionId;
    this.deployedTransactionHash = raw.deployedTransactionHash;
    this.deployerPubKey = Buffer.isBuffer(raw.deployerPubKey) ? raw.deployerPubKey : Buffer.from(raw.deployerPubKey, "base64");
    this.deployerHashedPublicKey = Buffer.isBuffer(raw.deployerAddress) ? raw.deployerAddress : Buffer.from(raw.deployerAddress.replace("0x", ""), "base64");
    this.contractSeed = Buffer.isBuffer(raw.contractSeed) ? raw.contractSeed : Buffer.from(raw.contractSeed, "base64");
    this.contractSaltHash = Buffer.isBuffer(raw.contractSaltHash) ? raw.contractSaltHash : Buffer.from(raw.contractSaltHash, "base64");
    if (this.deployerHashedPublicKey && this.deployerPubKey) {
      this.deployerAddress = new Address(this.deployerHashedPublicKey, this.deployerPubKey);
    } else {
      throw new Error("Deployer address or public key is missing");
    }
  }
}

var TransactionInputFlags = /* @__PURE__ */ ((TransactionInputFlags2) => {
  TransactionInputFlags2[TransactionInputFlags2["hasCoinbase"] = 1] = "hasCoinbase";
  TransactionInputFlags2[TransactionInputFlags2["hasWitness"] = 2] = "hasWitness";
  return TransactionInputFlags2;
})(TransactionInputFlags || {});
var TransactionOutputFlags = /* @__PURE__ */ ((TransactionOutputFlags2) => {
  TransactionOutputFlags2[TransactionOutputFlags2["hasTo"] = 1] = "hasTo";
  TransactionOutputFlags2[TransactionOutputFlags2["hasScriptPubKey"] = 2] = "hasScriptPubKey";
  TransactionOutputFlags2[TransactionOutputFlags2["OP_RETURN"] = 4] = "OP_RETURN";
  return TransactionOutputFlags2;
})(TransactionOutputFlags || {});

class EpochMiner {
  solution;
  publicKey;
  salt;
  graffiti;
  constructor(data) {
    this.solution = stringToBuffer(data.solution);
    this.publicKey = Address.fromString(data.mldsaPublicKey, data.legacyPublicKey);
    this.salt = stringToBuffer(data.salt);
    this.graffiti = data.graffiti ? stringToBuffer(data.graffiti) : void 0;
  }
}
class Epoch {
  epochNumber;
  epochHash;
  epochRoot;
  startBlock;
  endBlock;
  difficultyScaled;
  minDifficulty;
  targetHash;
  proposer;
  proofs;
  constructor(data) {
    this.epochNumber = BigInt(data.epochNumber);
    this.epochHash = stringToBuffer(data.epochHash);
    this.epochRoot = stringToBuffer(data.epochRoot);
    this.startBlock = BigInt(data.startBlock);
    this.endBlock = BigInt(data.endBlock);
    this.difficultyScaled = BigInt(data.difficultyScaled);
    this.minDifficulty = data.minDifficulty;
    this.targetHash = stringToBuffer(data.targetHash);
    this.proposer = new EpochMiner(data.proposer);
    this.proofs = Object.freeze(data.proofs.map((proof) => stringToBuffer(proof)));
  }
}

class EpochSubmission {
  submissionTxId;
  submissionTxHash;
  submissionHash;
  confirmedAt;
  epochProposed;
  constructor(data) {
    this.submissionTxId = stringToBuffer(data.submissionTxId);
    this.submissionTxHash = stringToBuffer(data.submissionTxHash);
    this.submissionHash = stringToBuffer(data.submissionHash);
    this.confirmedAt = data.confirmedAt;
    this.epochProposed = new EpochMiner(data.epochProposed);
  }
}
class EpochWithSubmissions extends Epoch {
  submissions;
  constructor(data) {
    super(data);
    if (data.submissions) {
      this.submissions = Object.freeze(
        data.submissions.map((sub) => new EpochSubmission(sub))
      );
    }
  }
}

class EpochTemplate {
  epochNumber;
  epochTarget;
  constructor(data) {
    this.epochNumber = BigInt(data.epochNumber);
    this.epochTarget = stringToBuffer(data.epochTarget);
  }
}

class SubmittedEpoch {
  epochNumber;
  submissionHash;
  difficulty;
  timestamp;
  status;
  message;
  constructor(data) {
    this.epochNumber = BigInt(data.epochNumber);
    this.submissionHash = stringToBuffer(data.submissionHash);
    this.difficulty = data.difficulty;
    this.timestamp = typeof data.timestamp === "number" ? new Date(data.timestamp) : data.timestamp;
    this.status = data.status;
    this.message = data.message;
  }
}

class StoredValue {
  pointer;
  value;
  height;
  proofs;
  constructor(iStoredValue) {
    this.pointer = typeof iStoredValue.pointer === "string" ? this.base64ToBigInt(iStoredValue.pointer) : iStoredValue.pointer;
    if (typeof iStoredValue.value !== "string") {
      this.value = iStoredValue.value;
    } else {
      this.value = Buffer.from(
        iStoredValue.value,
        iStoredValue.value.startsWith("0x") ? "hex" : "base64"
      );
    }
    this.height = BigInt(iStoredValue.height);
    this.proofs = iStoredValue.proofs || [];
  }
  base64ToBigInt(base64) {
    return BufferHelper.uint8ArrayToPointer(Buffer.from(base64, "base64"));
  }
}

class UTXO {
  transactionId;
  outputIndex;
  value;
  scriptPubKey;
  nonWitnessUtxo;
  witnessScript;
  redeemScript;
  isCSV;
  /**
   * Create a UTXO from raw interface data
   * @param iUTXO - The raw UTXO data from the API
   * @param isCSV - Whether this is a CSV UTXO
   */
  constructor(iUTXO, isCSV) {
    this.transactionId = iUTXO.transactionId;
    this.outputIndex = iUTXO.outputIndex;
    this.isCSV = isCSV || false;
    this.value = BigInt(iUTXO.value);
    this.scriptPubKey = iUTXO.scriptPubKey;
    this.nonWitnessUtxo = Buffer.from(iUTXO.raw, "base64");
  }
}

var JSONRpcMethods = /* @__PURE__ */ ((JSONRpcMethods2) => {
  JSONRpcMethods2["BLOCK_BY_NUMBER"] = "btc_blockNumber";
  JSONRpcMethods2["CHAIN_ID"] = "btc_chainId";
  JSONRpcMethods2["REORG"] = "btc_reorg";
  JSONRpcMethods2["GET_BLOCK_BY_HASH"] = "btc_getBlockByHash";
  JSONRpcMethods2["GET_BLOCK_BY_CHECKSUM"] = "btc_getBlockByChecksum";
  JSONRpcMethods2["GET_BLOCK_BY_NUMBER"] = "btc_getBlockByNumber";
  JSONRpcMethods2["GAS"] = "btc_gas";
  JSONRpcMethods2["GET_TRANSACTION_BY_HASH"] = "btc_getTransactionByHash";
  JSONRpcMethods2["BROADCAST_TRANSACTION"] = "btc_sendRawTransaction";
  JSONRpcMethods2["TRANSACTION_PREIMAGE"] = "btc_preimage";
  JSONRpcMethods2["PUBLIC_KEY_INFO"] = "btc_publicKeyInfo";
  JSONRpcMethods2["GET_UTXOS"] = "btc_getUTXOs";
  JSONRpcMethods2["GET_BALANCE"] = "btc_getBalance";
  JSONRpcMethods2["BLOCK_WITNESS"] = "btc_blockWitness";
  JSONRpcMethods2["GET_TRANSACTION_RECEIPT"] = "btc_getTransactionReceipt";
  JSONRpcMethods2["GET_CODE"] = "btc_getCode";
  JSONRpcMethods2["GET_STORAGE_AT"] = "btc_getStorageAt";
  JSONRpcMethods2["LATEST_EPOCH"] = "btc_latestEpoch";
  JSONRpcMethods2["GET_EPOCH_BY_NUMBER"] = "btc_getEpochByNumber";
  JSONRpcMethods2["GET_EPOCH_BY_HASH"] = "btc_getEpochByHash";
  JSONRpcMethods2["GET_EPOCH_TEMPLATE"] = "btc_getEpochTemplate";
  JSONRpcMethods2["SUBMIT_EPOCH"] = "btc_submitEpoch";
  JSONRpcMethods2["CALL"] = "btc_call";
  return JSONRpcMethods2;
})(JSONRpcMethods || {});

const AUTO_PURGE_AFTER = 1e3 * 60;
const FETCH_COOLDOWN = 1e4;
const MEMPOOL_CHAIN_LIMIT = 25;
class UTXOsManager {
  constructor(provider) {
    this.provider = provider;
  }
  /**
   * Holds all address-specific data so we dont mix up UTXOs between addresses/wallets.
   */
  dataByAddress = {};
  /**
   * Mark UTXOs as spent and track new UTXOs created by the transaction, _per address_.
   *
   * Enforces a mempool chain limit of 25 unconfirmed transaction descendants.
   *
   * @param address - The address these spent/new UTXOs belong to
   * @param {UTXOs} spent - The UTXOs that were spent.
   * @param {UTXOs} newUTXOs - The new UTXOs created by the transaction.
   * @throws {Error} If adding the new unconfirmed outputs would exceed the mempool chain limit.
   */
  spentUTXO(address, spent, newUTXOs) {
    const addressData = this.getAddressData(address);
    const utxoKey = (u) => `${u.transactionId}:${u.outputIndex}`;
    addressData.pendingUTXOs = addressData.pendingUTXOs.filter((utxo) => {
      return !spent.some(
        (spentUtxo) => spentUtxo.transactionId === utxo.transactionId && spentUtxo.outputIndex === utxo.outputIndex
      );
    });
    let maxParentDepth = 0;
    for (const spentUtxo of spent) {
      const key = utxoKey(spentUtxo);
      const parentDepth = addressData.pendingUtxoDepth[key] ?? 0;
      if (parentDepth > maxParentDepth) {
        maxParentDepth = parentDepth;
      }
    }
    for (const spentUtxo of spent) {
      const key = utxoKey(spentUtxo);
      delete addressData.pendingUtxoDepth[key];
    }
    addressData.spentUTXOs.push(...spent);
    const newDepth = maxParentDepth + 1;
    if (newDepth > MEMPOOL_CHAIN_LIMIT) {
      throw new Error(
        `too-long-mempool-chain, too many descendants for tx ... [limit: ${MEMPOOL_CHAIN_LIMIT}]`
      );
    }
    for (const nu of newUTXOs) {
      addressData.pendingUTXOs.push(nu);
      addressData.pendingUtxoDepth[utxoKey(nu)] = newDepth;
    }
  }
  /**
   * Get the pending UTXOs for a specific address.
   * @param address
   */
  getPendingUTXOs(address) {
    const addressData = this.getAddressData(address);
    return addressData.pendingUTXOs;
  }
  /**
   * Clean (reset) the data for a particular address or for all addresses if none is passed.
   */
  clean(address) {
    if (address) {
      const addressData = this.getAddressData(address);
      addressData.spentUTXOs = [];
      addressData.pendingUTXOs = [];
      addressData.pendingUtxoDepth = {};
      addressData.lastCleanup = Date.now();
      addressData.lastFetchTimestamp = 0;
      addressData.lastFetchedData = null;
    } else {
      this.dataByAddress = {};
    }
  }
  /**
   * Get UTXOs with configurable options, specifically for an address.
   *
   * If the last UTXO fetch for that address was <10s ago, returns cached data.
   * Otherwise, fetches fresh data from the provider.
   *
   * @param {object} options - The UTXO fetch options
   * @param {string} options.address - The address to get the UTXOs for
   * @param {boolean} [options.optimize=true] - Whether to optimize the UTXOs
   * @param {boolean} [options.mergePendingUTXOs=true] - Merge locally pending UTXOs
   * @param {boolean} [options.filterSpentUTXOs=true] - Filter out known-spent UTXOs
   * @param {boolean} [options.isCSV=false] - Whether to this UTXO as a CSV UTXO
   * @param {bigint} [options.olderThan] - Only fetch UTXOs older than this value
   * @returns {Promise<UTXOs>} The UTXOs
   * @throws {Error} If something goes wrong
   */
  async getUTXOs({
    address,
    isCSV = false,
    optimize = true,
    mergePendingUTXOs = true,
    filterSpentUTXOs = true,
    olderThan
  }) {
    const addressData = this.getAddressData(address);
    const fetchedData = await this.maybeFetchUTXOs(address, optimize, olderThan, isCSV);
    const utxoKey = (utxo) => `${utxo.transactionId}:${utxo.outputIndex}`;
    const spentRefKey = (ref) => `${ref.transactionId}:${ref.outputIndex}`;
    const pendingUTXOKeys = new Set(addressData.pendingUTXOs.map(utxoKey));
    const spentUTXOKeys = new Set(addressData.spentUTXOs.map(utxoKey));
    const fetchedSpentKeys = new Set(fetchedData.spentTransactions.map(spentRefKey));
    const combinedUTXOs = [];
    const combinedKeysSet = /* @__PURE__ */ new Set();
    for (const utxo of fetchedData.confirmed) {
      const key = utxoKey(utxo);
      if (!combinedKeysSet.has(key)) {
        combinedUTXOs.push(utxo);
        combinedKeysSet.add(key);
      }
    }
    if (mergePendingUTXOs) {
      for (const utxo of addressData.pendingUTXOs) {
        const key = utxoKey(utxo);
        if (!combinedKeysSet.has(key)) {
          combinedUTXOs.push(utxo);
          combinedKeysSet.add(key);
        }
      }
      for (const utxo of fetchedData.pending) {
        const key = utxoKey(utxo);
        if (!pendingUTXOKeys.has(key) && !combinedKeysSet.has(key)) {
          combinedUTXOs.push(utxo);
          combinedKeysSet.add(key);
        }
      }
    }
    let finalUTXOs = combinedUTXOs.filter((utxo) => !spentUTXOKeys.has(utxoKey(utxo)));
    if (filterSpentUTXOs && fetchedSpentKeys.size > 0) {
      finalUTXOs = finalUTXOs.filter((utxo) => !fetchedSpentKeys.has(utxoKey(utxo)));
    }
    return finalUTXOs;
  }
  /**
   * Fetch UTXOs for a specific amount needed, from a single address,
   * merging from pending and confirmed UTXOs.
   *
   * @param {object} options
   * @param {string} options.address The address to fetch UTXOs for
   * @param {bigint} options.amount The needed amount
   * @param {boolean} [options.optimize=true] Optimize the UTXOs
   * @param {boolean} [options.csvAddress] Use CSV UTXOs in priority
   * @param {boolean} [options.mergePendingUTXOs=true] Merge pending
   * @param {boolean} [options.filterSpentUTXOs=true] Filter out spent
   * @param {boolean} [options.throwErrors=false] Throw error if insufficient
   * @param {bigint} [options.olderThan] Only fetch UTXOs older than this value
   * @returns {Promise<UTXOs>}
   */
  async getUTXOsForAmount({
    address,
    amount,
    csvAddress,
    optimize = true,
    mergePendingUTXOs = true,
    filterSpentUTXOs = true,
    throwErrors = false,
    olderThan,
    maxUTXOs = 5e3,
    throwIfUTXOsLimitReached = false
  }) {
    const utxosPromises = [];
    if (csvAddress) {
      utxosPromises.push(
        this.getUTXOs({
          address: csvAddress,
          optimize: true,
          mergePendingUTXOs: false,
          filterSpentUTXOs: true,
          olderThan: 1n,
          isCSV: true
        })
      );
    }
    utxosPromises.push(
      this.getUTXOs({
        address,
        optimize,
        mergePendingUTXOs,
        filterSpentUTXOs,
        olderThan
      })
    );
    const combinedUTXOs = (await Promise.all(utxosPromises)).flat();
    const utxoUntilAmount = [];
    let currentValue = 0n;
    for (const utxo of combinedUTXOs) {
      if (maxUTXOs && utxoUntilAmount.length >= maxUTXOs) {
        if (throwIfUTXOsLimitReached) {
          throw new Error(
            `Woah. You must consolidate your UTXOs (${combinedUTXOs.length})! This transaction is too large.`
          );
        }
        break;
      }
      utxoUntilAmount.push(utxo);
      currentValue += utxo.value;
      if (currentValue >= amount) {
        break;
      }
    }
    if (currentValue < amount && throwErrors) {
      throw new Error(
        `Insufficient UTXOs to cover amount. Available: ${currentValue}, Needed: ${amount}`
      );
    }
    return utxoUntilAmount;
  }
  /**
   * Fetch UTXOs for multiple addresses in a single batch request.
   *
   * This method bypasses caching and directly fetches from the provider
   * for all requested addresses in parallel using batch RPC calls.
   *
   * @param {RequestMultipleUTXOsParams} options - The batch UTXO fetch options
   * @param {BatchUTXORequest[]} options.requests - Array of address-specific fetch parameters
   * @param {boolean} [options.mergePendingUTXOs=true] - Merge locally pending UTXOs
   * @param {boolean} [options.filterSpentUTXOs=true] - Filter out known-spent UTXOs
   * @returns {Promise<Record<string, UTXOs>>} Map of address to UTXOs
   * @throws {Error} If something goes wrong during the batch fetch
   */
  async getMultipleUTXOs({
    requests,
    mergePendingUTXOs = true,
    filterSpentUTXOs = true
  }) {
    if (requests.length === 0) {
      return {};
    }
    const fetchedDataMap = await this.fetchMultipleUTXOs(requests);
    const result = {};
    for (const request of requests) {
      const { address, isCSV = false } = request;
      const addressData = this.getAddressData(address);
      const fetchedData = fetchedDataMap[address];
      if (!fetchedData) {
        result[address] = [];
        continue;
      }
      addressData.lastFetchedData = fetchedData;
      addressData.lastFetchTimestamp = Date.now();
      this.syncPendingDepthWithFetched(address);
      const utxoKey = (utxo) => `${utxo.transactionId}:${utxo.outputIndex}`;
      const spentRefKey = (ref) => `${ref.transactionId}:${ref.outputIndex}`;
      const pendingUTXOKeys = new Set(addressData.pendingUTXOs.map(utxoKey));
      const spentUTXOKeys = new Set(addressData.spentUTXOs.map(utxoKey));
      const fetchedSpentKeys = new Set(fetchedData.spentTransactions.map(spentRefKey));
      const combinedUTXOs = [];
      const combinedKeysSet = /* @__PURE__ */ new Set();
      for (const utxo of fetchedData.confirmed) {
        const key = utxoKey(utxo);
        if (!combinedKeysSet.has(key)) {
          combinedUTXOs.push(utxo);
          combinedKeysSet.add(key);
        }
      }
      if (mergePendingUTXOs) {
        for (const utxo of addressData.pendingUTXOs) {
          const key = utxoKey(utxo);
          if (!combinedKeysSet.has(key)) {
            combinedUTXOs.push(utxo);
            combinedKeysSet.add(key);
          }
        }
        for (const utxo of fetchedData.pending) {
          const key = utxoKey(utxo);
          if (!pendingUTXOKeys.has(key) && !combinedKeysSet.has(key)) {
            combinedUTXOs.push(utxo);
            combinedKeysSet.add(key);
          }
        }
      }
      let finalUTXOs = combinedUTXOs.filter((utxo) => !spentUTXOKeys.has(utxoKey(utxo)));
      if (filterSpentUTXOs && fetchedSpentKeys.size > 0) {
        finalUTXOs = finalUTXOs.filter((utxo) => !fetchedSpentKeys.has(utxoKey(utxo)));
      }
      result[address] = finalUTXOs;
    }
    return result;
  }
  /**
   * Fetch UTXOs for multiple addresses in a single batch RPC call.
   * @private
   */
  async fetchMultipleUTXOs(requests) {
    const payloads = requests.map((request) => {
      const data = [request.address, request.optimize ?? true];
      if (request.olderThan !== void 0) {
        data.push(request.olderThan.toString());
      }
      return this.provider.buildJsonRpcPayload(JSONRpcMethods.GET_UTXOS, data);
    });
    const rawResults = await this.provider.callMultiplePayloads(payloads);
    if ("error" in rawResults) {
      throw new Error(`Error fetching UTXOs: ${rawResults.error}`);
    }
    const result = {};
    for (let i = 0; i < rawResults.length; i++) {
      const rawUTXOs = rawResults[i];
      const request = requests[i];
      if (!request) {
        throw new Error("Impossible index mismatch");
      }
      if ("error" in rawUTXOs) {
        throw new Error(`Error fetching UTXOs for ${request.address}: ${rawUTXOs.error}`);
      }
      const rawData = rawUTXOs.result || {
        confirmed: [],
        pending: [],
        spentTransactions: [],
        raw: []
      };
      const rawTransactions = rawData.raw || [];
      const isCSV = request.isCSV ?? false;
      result[request.address] = {
        confirmed: rawData.confirmed.map((utxo) => {
          return this.parseUTXO(utxo, isCSV, rawTransactions);
        }),
        pending: rawData.pending.map((utxo) => {
          return this.parseUTXO(utxo, isCSV, rawTransactions);
        }),
        spentTransactions: rawData.spentTransactions.map(
          (spent) => ({
            transactionId: spent.transactionId,
            outputIndex: spent.outputIndex
          })
        )
      };
    }
    return result;
  }
  /**
   * Return the AddressData object for a given address. Initializes it if nonexistent.
   */
  getAddressData(address) {
    if (!this.dataByAddress[address]) {
      this.dataByAddress[address] = {
        spentUTXOs: [],
        pendingUTXOs: [],
        pendingUtxoDepth: {},
        lastCleanup: Date.now(),
        lastFetchTimestamp: 0,
        lastFetchedData: null
      };
    }
    return this.dataByAddress[address];
  }
  /**
   * Checks if we need to fetch fresh UTXOs or can return the cached data (per address).
   */
  async maybeFetchUTXOs(address, optimize, olderThan, isCSV = false) {
    const addressData = this.getAddressData(address);
    const now = Date.now();
    const age = now - addressData.lastFetchTimestamp;
    if (now - addressData.lastCleanup > AUTO_PURGE_AFTER) {
      this.clean(address);
    }
    if (addressData.lastFetchedData && age < FETCH_COOLDOWN) {
      return addressData.lastFetchedData;
    }
    addressData.lastFetchedData = await this.fetchUTXOs(address, optimize, olderThan, isCSV);
    addressData.lastFetchTimestamp = now;
    this.syncPendingDepthWithFetched(address);
    return addressData.lastFetchedData;
  }
  /**
   * Generic method to fetch all UTXOs in one call (confirmed, pending, spent) for a given address.
   */
  async fetchUTXOs(address, optimize = false, olderThan, isCSV = false) {
    const data = [address, optimize];
    if (olderThan !== void 0) {
      data.push(olderThan.toString());
    }
    const payload = this.provider.buildJsonRpcPayload(
      JSONRpcMethods.GET_UTXOS,
      data
    );
    const rawUTXOs = await this.provider.callPayloadSingle(payload);
    if ("error" in rawUTXOs) {
      throw new Error(`Error fetching UTXOs: ${rawUTXOs.error}`);
    }
    const rawResult = rawUTXOs.result;
    const result = rawResult && typeof rawResult === "object" && Array.isArray(rawResult.confirmed) ? rawResult : {
      confirmed: [],
      pending: [],
      spentTransactions: [],
      raw: []
    };
    const rawTransactions = result.raw || [];
    return {
      confirmed: (result.confirmed || []).map((utxo) => {
        return this.parseUTXO(utxo, isCSV, rawTransactions);
      }),
      pending: (result.pending || []).map((utxo) => {
        return this.parseUTXO(utxo, isCSV, rawTransactions);
      }),
      // spentTransactions only contain transactionId and outputIndex (no raw data needed)
      spentTransactions: (result.spentTransactions || []).map(
        (spent) => ({
          transactionId: spent.transactionId,
          outputIndex: spent.outputIndex
        })
      )
    };
  }
  parseUTXO(utxo, isCSV, rawTransactions) {
    if (utxo.raw === void 0 || utxo.raw === null) {
      throw new Error("Missing raw index field in UTXO");
    }
    const rawHex = rawTransactions[utxo.raw];
    if (!rawHex) {
      throw new Error(`Invalid raw index ${utxo.raw} - not found in rawTransactions array`);
    }
    const raw = {
      ...utxo,
      raw: rawTransactions[utxo.raw]
    };
    return new UTXO(raw, isCSV);
  }
  /**
   * After fetching new data for a single address, some pending UTXOs may have confirmed
   * or become known-spent. Remove them from pending state/depth map.
   */
  syncPendingDepthWithFetched(address) {
    const addressData = this.getAddressData(address);
    const fetched = addressData.lastFetchedData;
    if (!fetched) return;
    const confirmedKeys = new Set(
      fetched.confirmed.map((u) => `${u.transactionId}:${u.outputIndex}`)
    );
    const spentKeys = new Set(
      fetched.spentTransactions.map(
        (s) => `${s.transactionId}:${s.outputIndex}`
      )
    );
    addressData.pendingUTXOs = addressData.pendingUTXOs.filter((u) => {
      const key = `${u.transactionId}:${u.outputIndex}`;
      if (confirmedKeys.has(key) || spentKeys.has(key)) {
        delete addressData.pendingUtxoDepth[key];
        return false;
      }
      return true;
    });
  }
}

class AbstractRpcProvider {
  constructor(network) {
    this.network = network;
  }
  nextId = 0;
  chainId;
  gasCache;
  lastFetchedGas = 0;
  challengeCache;
  csvCache = new AddressMap();
  _utxoManager = new UTXOsManager(this);
  /**
   * Get the UTXO manager.
   */
  get utxoManager() {
    return this._utxoManager;
  }
  /**
   * Get the CSV1 address for a given address.
   * @description This method is used to get the CSV1 address for a given address.
   * @param {Address} address The address to get the CSV1 address for
   * @returns {IP2WSHAddress} The CSV1 address
   * @example const csv1Address = provider.getCSV1ForAddress(Address.fromString('bcrt1q...'));
   */
  getCSV1ForAddress(address) {
    const cached = this.csvCache.get(address);
    if (cached) return cached;
    const csv = address.toCSV(1, this.network);
    this.csvCache.set(address, csv);
    return csv;
  }
  /**
   * Get the public key information.
   * @description This method is used to get the public key information.
   * @param {string | Address} addressRaw The address or addresses to get the public key information of
   * @param isContract
   * @returns {Promise<Address>} The public keys information
   * @example await getPublicKeyInfo('bcrt1qfqsr3m7vjxheghcvw4ks0fryqxfq8qzjf8fxes');
   * @throws {Error} If the address is invalid
   */
  async getPublicKeyInfo(addressRaw, isContract) {
    const address = addressRaw.toString();
    try {
      const pubKeyInfo = await this.getPublicKeysInfo(address, isContract);
      return pubKeyInfo[address] || pubKeyInfo[address.replace("0x", "")];
    } catch (e) {
      if (AddressVerificator.isValidPublicKey(address, this.network)) {
        return Address.fromString(address);
      }
      throw e;
    }
  }
  /**
   * Verify an address.
   * @param {string | Address} addr The address to verify
   * @param {Network} network The network to verify the address against
   * @returns {AddressTypes} The address type, return null if the address is invalid
   */
  validateAddress(addr, network) {
    let validationResult = null;
    if (addr instanceof Address) {
      validationResult = AddressVerificator.detectAddressType(addr.toHex(), network);
    } else if (typeof addr === "string") {
      validationResult = AddressVerificator.detectAddressType(addr, network);
    } else {
      throw new Error(`Invalid type: ${typeof addr} for address: ${addr}`);
    }
    return validationResult;
  }
  /**
   * Get the latest block number.
   * @description This method is used to get the latest block number.
   * @returns {Promise<number>} The latest block number
   * @example await getBlockNumber();
   */
  async getBlockNumber() {
    const payload = this.buildJsonRpcPayload(
      JSONRpcMethods.BLOCK_BY_NUMBER,
      []
    );
    const rawBlockNumber = await this.callPayloadSingle(payload);
    const result = rawBlockNumber.result;
    return BigInt(result);
  }
  /**
   * Get block by checksum.
   * @param {string} checksum The block checksum
   * @param {boolean} prefetchTxs Whether to prefetch transactions
   * @description This method is used to get a block by its checksum.
   * @returns {Promise<Block>} The requested block
   * @throws {Error} If the block is not found
   * @example await getBlockByChecksum('0xabcdef123456...');
   */
  async getBlockByChecksum(checksum, prefetchTxs = false) {
    const payload = this.buildJsonRpcPayload(
      JSONRpcMethods.GET_BLOCK_BY_CHECKSUM,
      [checksum, prefetchTxs]
    );
    const block = await this.callPayloadSingle(payload);
    if ("error" in block) {
      throw new Error(
        `Error fetching block by checksum: ${block.error?.message || "Unknown error"}`
      );
    }
    const result = block.result;
    return new Block(result, this.network);
  }
  /**
   * Get the latest challenge to use in a transaction.
   * @description This method is used to get the latest challenge along with epoch winner and verification data.
   * @returns {Promise<ChallengeSolution>} The challenge and epoch data
   * @example const challenge = await getChallenge();
   * @throws {Error} If no challenge found or OPNet is not active
   */
  async getChallenge() {
    if (this.challengeCache && Date.now() < this.challengeCache.expireAt) {
      return this.challengeCache.challenge;
    }
    const payload = this.buildJsonRpcPayload(
      JSONRpcMethods.TRANSACTION_PREIMAGE,
      []
    );
    const rawChallenge = await this.callPayloadSingle(payload);
    if ("error" in rawChallenge) {
      throw new Error(
        `Error fetching preimage: ${rawChallenge.error?.message || "Unknown error"}`
      );
    }
    const result = rawChallenge.result;
    if (!result || !result.solution) {
      throw new Error(
        "No challenge found. OPNet is probably not active yet on this blockchain."
      );
    }
    const solutionHex = result.solution.replace("0x", "");
    if (solutionHex === "0".repeat(64)) {
      throw new Error(
        "No valid challenge found. OPNet is probably not active yet on this blockchain."
      );
    }
    const challengeSolution = new ChallengeSolution(result);
    this.challengeCache = {
      challenge: challengeSolution,
      expireAt: Date.now() + 1e4
    };
    return challengeSolution;
  }
  /**
   * Get block by number or hash.
   * @param {BlockTag} blockNumberOrHash The block number or hash
   * @param {boolean} prefetchTxs Whether to prefetch transactions
   * @description This method is used to get a block by its number or hash.
   * @returns {Promise<Block>} The requested block
   * @throws {Error} If the block is not found
   * @example await getBlock(123456);
   */
  async getBlock(blockNumberOrHash, prefetchTxs = false) {
    const method = typeof blockNumberOrHash === "string" ? JSONRpcMethods.GET_BLOCK_BY_HASH : JSONRpcMethods.GET_BLOCK_BY_NUMBER;
    const payload = this.buildJsonRpcPayload(method, [
      blockNumberOrHash,
      prefetchTxs
    ]);
    const block = await this.callPayloadSingle(payload);
    if ("error" in block) {
      throw new Error(`Error fetching block: ${block.error?.message || "Unknown error"}`);
    }
    const result = block.result;
    return new Block(result, this.network);
  }
  /**
   * Get multiple blocks by number or hash.
   * @param {BlockTag[]} blockNumbers The block numbers or hashes
   * @param {boolean} prefetchTxs Whether to prefetch transactions
   * @description This method is used to get multiple blocks by their numbers or hashes.
   * @returns {Promise<Block[]>} The requested blocks
   */
  async getBlocks(blockNumbers, prefetchTxs = false) {
    const payloads = blockNumbers.map((blockNumber) => {
      return this.buildJsonRpcPayload(JSONRpcMethods.GET_BLOCK_BY_NUMBER, [
        blockNumber,
        prefetchTxs
      ]);
    });
    const blocks = await this.callMultiplePayloads(payloads);
    if ("error" in blocks) {
      const error = blocks.error;
      throw new Error(`Error fetching block: ${error.message}`);
    }
    return blocks.map((block) => {
      if ("error" in block) {
        throw new Error(`Error fetching block: ${block.error}`);
      }
      const result = block.result;
      return new Block(result, this.network);
    });
  }
  /**
   * Get block by hash. This is the same method as getBlock.
   * @param {string} blockHash The block hash
   * @description This method is used to get a block by its hash. Note that this method is the same as getBlock.
   * @returns {Promise<Block>} The requested block
   * @throws {Error} If the block is not found
   */
  async getBlockByHash(blockHash) {
    return await this.getBlock(blockHash);
  }
  /**
   * Get the bitcoin balance of an address.
   * @param {string} address The address to get the balance of
   * @param {boolean} filterOrdinals Whether to filter ordinals or not
   * @description This method is used to get the balance of a bitcoin address.
   * @returns {Promise<bigint>} The balance of the address
   * @example await getBalance('bc1qar0srrr7xfkvy5l643lydnw9re59gtzzwf5mdq');
   */
  async getBalance(address, filterOrdinals = true) {
    const payload = this.buildJsonRpcPayload(JSONRpcMethods.GET_BALANCE, [
      address,
      filterOrdinals
    ]);
    const rawBalance = await this.callPayloadSingle(payload);
    const result = rawBalance.result;
    if (!result || result && !result.startsWith("0x")) {
      throw new Error(`Invalid balance returned from provider: ${result}`);
    }
    return BigInt(result);
  }
  /**
   * Get the bitcoin balances of multiple addresses.
   * @param {string[]} addressesLike The addresses to get the balances of
   * @param {boolean} filterOrdinals Whether to filter ordinals or not
   * @description This method is used to get the balance of a bitcoin address.
   * @returns {Record<string, bigint>} The balance of the address
   * @example await getBalances(['bc1qar0srrr7xfkvy5l643lydnw9re59gtzzwf5mdq']);
   */
  async getBalances(addressesLike, filterOrdinals = true) {
    const payloads = addressesLike.map((address) => {
      return this.buildJsonRpcPayload(JSONRpcMethods.GET_BALANCE, [address, filterOrdinals]);
    });
    const balances = await this.callMultiplePayloads(payloads);
    if ("error" in balances) {
      const error = balances.error;
      throw new Error(`Error fetching block: ${error.message}`);
    }
    const resultBalance = {};
    for (let i = 0; i < balances.length; i++) {
      const balance = balances[i];
      const address = addressesLike[i];
      if (!address) throw new Error("Impossible index.");
      if ("error" in balance) {
        throw new Error(`Error fetching block: ${balance.error}`);
      }
      const result = balance.result;
      if (!result || result && !result.startsWith("0x")) {
        throw new Error(`Invalid balance returned from provider: ${result}`);
      }
      resultBalance[address] = BigInt(result);
    }
    return resultBalance;
  }
  /**
   * Get a transaction by its hash or hash id.
   * @description This method is used to get a transaction by its hash or hash id.
   * @param {string} txHash The transaction hash
   * @returns {Promise<TransactionBase<OPNetTransactionTypes>>} The requested transaction
   * @example await getTransaction('63e77ba9fa4262b3d4d0d9d97fa8a7359534606c3f3af096284662e3f619f374');
   * @throws {Error} If something went wrong while fetching the transaction
   */
  async getTransaction(txHash) {
    const payload = this.buildJsonRpcPayload(
      JSONRpcMethods.GET_TRANSACTION_BY_HASH,
      [txHash]
    );
    const rawTransaction = await this.callPayloadSingle(payload);
    const result = rawTransaction.result;
    if ("error" in rawTransaction) {
      throw new Error(
        `Error fetching transaction: ${rawTransaction.error?.message || "Unknown error"}`
      );
    }
    return TransactionParser.parseTransaction(result, this.network);
  }
  /**
   * Get a transaction receipt by its hash.
   * @description This method is used to get a transaction receipt by its hash.
   * @param {string} txHash The transaction hash
   * @returns {Promise<TransactionReceipt>} The requested transaction receipt
   * @example await getTransactionReceipt('63e77ba9fa4262b3d4d0d9d97fa8a7359534606c3f3af096284662e3f619f374');
   * @throws {Error} Something went wrong while fetching the transaction receipt
   */
  async getTransactionReceipt(txHash) {
    const payload = this.buildJsonRpcPayload(
      JSONRpcMethods.GET_TRANSACTION_RECEIPT,
      [txHash]
    );
    const rawTransaction = await this.callPayloadSingle(payload);
    return new TransactionReceipt(rawTransaction.result, this.network);
  }
  /**
   * Get the current connected network type.
   * @description This method is used to get the current connected network type.
   * @returns {Network} The current connected network type
   * @throws {Error} If the chain id is invalid
   */
  getNetwork() {
    return this.network;
  }
  /**
   * Get the chain id.
   * @description This method is used to get the chain id.
   * @returns {Promise<bigint>} The chain id
   * @throws {Error} If something went wrong while fetching the chain id
   */
  async getChainId() {
    if (this.chainId !== void 0) return this.chainId;
    const payload = this.buildJsonRpcPayload(JSONRpcMethods.CHAIN_ID, []);
    const rawChainId = await this.callPayloadSingle(payload);
    if ("error" in rawChainId) {
      throw new Error(`Something went wrong while fetching: ${rawChainId.error}`);
    }
    const chainId = rawChainId.result;
    this.chainId = BigInt(chainId);
    return this.chainId;
  }
  /**
   * Get the contract code of an address.
   * @description This method is used to get the contract code of an address.
   * @param {string | Address} address The address of the contract
   * @param {boolean} [onlyBytecode] Whether to return only the bytecode
   * @returns {Promise<ContractData | Buffer>} The contract data or bytecode
   * @example await getCode('tb1pth90usc4f528aqphpjrfkkdm4vy8hxnt5gps6aau2nva6pxeshtqqzlt3a');
   * @throws {Error} If something went wrong while fetching the contract code
   */
  async getCode(address, onlyBytecode = false) {
    const addressStr = address.toString();
    const payload = this.buildJsonRpcPayload(JSONRpcMethods.GET_CODE, [
      addressStr,
      onlyBytecode
    ]);
    const rawCode = await this.callPayloadSingle(payload);
    if (rawCode.error) {
      throw new Error(
        `${rawCode.error.code}: Something went wrong while fetching: ${rawCode.error.message}`
      );
    }
    const result = rawCode.result;
    if ("contractAddress" in result) {
      return new ContractData(result);
    } else {
      return Buffer.from(result.bytecode, "base64");
    }
  }
  /**
   * Get the storage at a specific address and pointer.
   * @description This method is used to get the storage at a specific address and pointer.
   * @param {string | Address} address The address to get the storage from
   * @param {BigNumberish} rawPointer The pointer to get the storage from as base64 or bigint
   * @param {boolean} proofs Whether to send proofs or not
   * @param {BigNumberish} [height] The height to get the storage from
   * @returns {Promise<StoredValue>} The storage value
   * @example await getStorageAt('tb1pth90usc4f528aqphpjrfkkdm4vy8hxnt5gps6aau2nva6pxeshtqqzlt3a', 'EXLK/QhEQMI5d9DrthLvozT+UcDQ7WuSPaz7g8GV3AQ=');
   * @throws {Error} If something went wrong while fetching the storage
   */
  async getStorageAt(address, rawPointer, proofs = true, height) {
    const addressStr = address.toString();
    const pointer = typeof rawPointer === "string" ? rawPointer : this.bigintToBase64(rawPointer);
    const params = [addressStr, pointer, proofs];
    if (height) {
      params.push(height.toString());
    }
    const payload = this.buildJsonRpcPayload(
      JSONRpcMethods.GET_STORAGE_AT,
      params
    );
    const rawStorage = await this.callPayloadSingle(payload);
    const result = rawStorage.result;
    return new StoredValue(result);
  }
  /**
   * Call a contract function with a given calldata.
   * @description This method is used to call a contract function with a given calldata.
   * @param {string | Address} to The address of the contract
   * @param {Buffer} data The calldata of the contract function
   * @param {string | Address} [from] The address to call the contract from
   * @param {BigNumberish} [height] The height to call the contract from
   * @param {ParsedSimulatedTransaction} [simulatedTransaction] UTXOs to simulate the transaction
   * @param {IAccessList} [accessList] The access list of previous simulation to use for this call
   * @returns {Promise<CallResult>} The result of the contract function call
   * @example await call('tb1pth90usc4f528aqphpjrfkkdm4vy8hxnt5gps6aau2nva6pxeshtqqzlt3a', Buffer.from('0x12345678'));
   * @throws {Error} If something went wrong while calling the contract
   */
  async call(to, data, from, height, simulatedTransaction, accessList) {
    const toStr = to.toString();
    const fromStr = from ? from.toHex() : void 0;
    const fromLegacyStr = from ? from.tweakedToHex() : void 0;
    let dataStr = Buffer.isBuffer(data) ? this.bufferToHex(data) : data;
    if (dataStr.startsWith("0x")) {
      dataStr = dataStr.slice(2);
    }
    const params = [toStr, dataStr, fromStr, fromLegacyStr];
    if (height) {
      if (typeof height === "object") {
        throw new Error("Height must be a number or bigint");
      }
      params.push(height.toString());
    } else {
      params.push(void 0);
    }
    if (simulatedTransaction) {
      params.push(this.parseSimulatedTransaction(simulatedTransaction));
    } else {
      params.push(void 0);
    }
    if (accessList) {
      params.push(accessList);
    } else {
      params.push(void 0);
    }
    const payload = this.buildJsonRpcPayload(JSONRpcMethods.CALL, params);
    const rawCall = await this.callPayloadSingle(payload);
    const result = rawCall.result || rawCall;
    if (!rawCall.result) {
      return {
        error: result.error.message
      };
    }
    if ("error" in result) {
      return result;
    }
    if (result.revert) {
      let decodedError;
      try {
        decodedError = decodeRevertData(
          BufferHelper.bufferToUint8Array(Buffer.from(result.revert, "base64"))
        );
      } catch {
        decodedError = result.revert;
      }
      return {
        error: decodedError
      };
    }
    return new CallResult(result, this);
  }
  /**
   * Get the next block gas parameters.
   * @description This method is used to get the next block gas parameters. Such as base gas, gas limit, and gas price.
   * @returns {Promise<BlockGasParameters>} The gas parameters of the next block
   * @example await provider.gasParameters();
   * @throws {Error} If something went wrong while calling the contract
   */
  async gasParameters() {
    if (!this.gasCache || Date.now() - this.lastFetchedGas > 1e4) {
      this.lastFetchedGas = Date.now();
      this.gasCache = await this._gasParameters();
    }
    return this.gasCache;
  }
  /**
   * Send a raw transaction.
   * @description This method is used to send a raw transaction.
   * @param {string} tx The raw transaction to send as hex string
   * @param {boolean} [psbt] Whether the transaction is a PSBT or not
   * @returns {Promise<BroadcastedTransaction>} The result of the transaction
   * @example await sendRawTransaction('02000000000101ad897689f66c98daae5fdc3606235c1ad7a17b9e0a6aaa0ea9e58ecc1198ad2a0100000000ffffffff01a154c39400000000160014482038efcc91af945f0c756d07a46401920380520247304402201c1f8718dec637ddb41b42abc44dcbf35a94c6be6a9de8c1db48c9fa6e456b7e022032a4b3286808372a7ac2c5094d6341b4d61b17663f4ccd1c1d92efa85c7dada80121020373626d317ae8788ce3280b491068610d840c23ecb64c14075bbb9f670af52c00000000', false);
   * @throws {Error} If something went wrong while sending the transaction
   */
  async sendRawTransaction(tx, psbt) {
    if (!/^[0-9A-Fa-f]+$/.test(tx)) {
      throw new Error("sendRawTransaction: Invalid hex string");
    }
    const payload = this.buildJsonRpcPayload(
      JSONRpcMethods.BROADCAST_TRANSACTION,
      [tx, psbt]
    );
    const rawTx = await this.callPayloadSingle(payload);
    return rawTx.result;
  }
  /**
   * Bulk send transactions.
   * @description This method is used to send multiple transactions at the same time.
   * @param {string[]} txs The raw transactions to send as hex string
   * @returns {Promise<BroadcastedTransaction[]>} The result of the transaction
   * @throws {Error} If something went wrong while sending the transaction
   */
  async sendRawTransactions(txs) {
    const payloads = txs.map((tx) => {
      return this.buildJsonRpcPayload(JSONRpcMethods.BROADCAST_TRANSACTION, [tx, false]);
    });
    const rawTxs = await this.callMultiplePayloads(payloads);
    if ("error" in rawTxs) {
      throw new Error(`Error sending transactions: ${rawTxs.error}`);
    }
    return rawTxs.map((rawTx) => {
      return rawTx.result;
    });
  }
  /**
   * Get block witnesses.
   * @description This method is used to get the witnesses of a block. This proves that the actions executed inside a block are valid and confirmed by the network. If the minimum number of witnesses are not met, the block is considered as potentially invalid.
   * @param {BlockTag} height The block number or hash, use -1 for latest block
   * @param {boolean} [trusted] Whether to trust the witnesses or not
   * @param {number} [limit] The maximum number of witnesses to return
   * @param {number} [page] The page number of the witnesses
   * @returns {Promise<BlockWitnesses>} The witnesses of the block
   * @example await getBlockWitness(123456n);
   * @throws {Error} If something went wrong while fetching the witnesses
   */
  async getBlockWitness(height = -1, trusted, limit, page) {
    const params = [height.toString()];
    if (trusted !== void 0 && trusted !== null) params.push(trusted);
    if (limit !== void 0 && limit !== null) params.push(limit);
    if (page !== void 0 && page !== null) params.push(page);
    const payload = this.buildJsonRpcPayload(
      JSONRpcMethods.BLOCK_WITNESS,
      params
    );
    const rawWitnesses = await this.callPayloadSingle(payload);
    if ("error" in rawWitnesses) {
      throw new Error(
        `Error fetching block witnesses: ${rawWitnesses.error?.message || "Unknown error"}`
      );
    }
    const result = rawWitnesses.result;
    return parseBlockWitnesses(result);
  }
  /**
   * Get reorgs that happened between two blocks.
   * @description This method is used to get the reorgs that happened between two blocks.
   * @param {BigNumberish} [fromBlock] The block number to start from
   * @param {BigNumberish} [toBlock] The block number to end at
   * @returns {Promise<ReorgInformation>} The reorg information
   * @example await getReorg(123456n, 123457n);
   * @throws {Error} If something went wrong while fetching the reorg information
   */
  async getReorg(fromBlock, toBlock) {
    const params = [];
    if (fromBlock !== void 0 && fromBlock !== null) params.push(fromBlock.toString());
    if (toBlock !== void 0 && toBlock !== null) params.push(toBlock.toString());
    const payload = this.buildJsonRpcPayload(JSONRpcMethods.REORG, params);
    const rawReorg = await this.callPayloadSingle(payload);
    const result = rawReorg.result;
    if (result.length > 0) {
      for (let i = 0; i < result.length; i++) {
        const res = result[i];
        res.fromBlock = BigInt("0x" + res.fromBlock.toString());
        res.toBlock = BigInt("0x" + res.toBlock.toString());
      }
    }
    return result;
  }
  /**
   * Send a single payload. This method is used to send a single payload.
   * @param {JsonRpcPayload} payload The payload to send
   * @returns {Promise<JsonRpcResult>} The result of the payload
   * @throws {Error} If no data is returned
   * @private
   */
  async callPayloadSingle(payload) {
    const rawData = await this._send(payload);
    if (!rawData.length) {
      throw new Error("No data returned");
    }
    const data = rawData.shift();
    if (!data) {
      throw new Error("Block not found");
    }
    return data;
  }
  /**
   * Send multiple payloads. This method is used to send multiple payloads.
   * @param {JsonRpcPayload[]} payloads The payloads to send
   * @returns {Promise<JsonRpcResult>} The result of the payloads
   */
  async callMultiplePayloads(payloads) {
    const rawData = await this._send(
      payloads
    );
    if ("error" in rawData) {
      throw new Error(`Error fetching block: ${rawData.error}`);
    }
    const data = rawData.shift();
    if (!data) {
      throw new Error("Block not found");
    }
    return data;
  }
  /**
   * Build a JSON RPC payload. This method is used to build a JSON RPC payload.
   * @param {JSONRpcMethods} method The method to call
   * @param {unknown[]} params The parameters to send
   * @returns {JsonRpcPayload} The JSON RPC payload
   */
  buildJsonRpcPayload(method, params) {
    return {
      method,
      params,
      id: this.nextId++,
      jsonrpc: "2.0"
    };
  }
  /**
   * Get the raw public key information from the API.
   * @description Returns the raw API response without transforming to Address objects.
   * @param {string | string[] | Address | Address[]} addresses The address or addresses to get the public key information of
   * @returns {Promise<IPublicKeyInfoResult>} The raw public keys information from the API
   * @example await getPublicKeysInfoRaw(['addressA', 'addressB']);
   * @throws {Error} If the address is invalid or API call fails
   */
  async getPublicKeysInfoRaw(addresses) {
    const addressArray = Array.isArray(addresses) ? addresses : [addresses];
    for (const addr of addressArray) {
      if (this.validateAddress(addr, this.network) === null) {
        throw new Error(`Invalid address: ${addr}`);
      }
    }
    const method = JSONRpcMethods.PUBLIC_KEY_INFO;
    const payload = this.buildJsonRpcPayload(method, [addressArray]);
    const data = await this.callPayloadSingle(payload);
    if (data.error) {
      const errorData = data.error;
      const errorMessage = typeof errorData === "string" ? errorData : errorData.message;
      throw new Error(errorMessage);
    }
    return data.result;
  }
  /**
   * Get the public key information and transform to Address objects.
   * @description Fetches public key information from the API and converts results to Address instances
   * containing both ML-DSA (quantum-resistant) and classical key data when available.
   *
   * The method resolves various address formats (p2tr, p2pkh, p2wpkh, p2op, raw public keys) to their
   * corresponding public key information and constructs Address objects with the appropriate key hierarchy.
   *
   * For addresses with ML-DSA keys registered, the returned Address will have:
   * - Primary content: SHA256 hash of the ML-DSA public key (mldsaHashedPublicKey)
   * - Legacy key: The classical tweaked/original public key for Bitcoin address derivation
   * - Original ML-DSA public key and security level attached to the Address instance
   *
   * For addresses without ML-DSA keys, the Address will use the tweaked x-only public key as primary content.
   *
   * @param {string | string[] | Address | Address[]} addresses The address(es) to look up. Accepts p2tr addresses,
   * p2op addresses, raw public keys (32-byte x-only, 33-byte compressed, or 65-byte uncompressed), or existing Address instances.
   * @param {boolean} [isContract=false] When true, uses tweakedPubkey as the legacy key since contracts
   * don't have original untweaked keys. When false, prefers originalPubKey when available.
   * @param {boolean} [logErrors=false] When true, logs errors to console for addresses that fail lookup
   * instead of silently skipping them.
   * @returns {Promise<AddressesInfo>} Map of input keys to Address instances. Keys that failed lookup are omitted.
   * @example
   * // Single address lookup
   * const info = await provider.getPublicKeysInfo('bc1p...');
   *
   * @example
   * // Multiple addresses with error logging
   * const info = await provider.getPublicKeysInfo(['bc1p...', 'bc1q...'], false, true);
   *
   * @example
   * // Contract address lookup
   * const info = await provider.getPublicKeysInfo(contractAddress, true);
   *
   * @throws {Error} If any provided address fails validation before the API call
   */
  async getPublicKeysInfo(addresses, isContract = false, logErrors = false) {
    const result = await this.getPublicKeysInfoRaw(addresses);
    const response = {};
    for (const pubKey of Object.keys(result)) {
      const info = result[pubKey];
      if ("error" in info) {
        if (logErrors) {
          console.error(`Error fetching public key info for ${pubKey}: ${info.error}`);
        }
        continue;
      }
      const addressContent = isContract ? info.mldsaHashedPublicKey ?? info.tweakedPubkey : info.mldsaHashedPublicKey;
      const legacyKey = isContract ? info.tweakedPubkey : info.originalPubKey ?? info.tweakedPubkey;
      if (!addressContent) {
        throw new Error(
          `No valid address content found for ${pubKey}. Use getPublicKeysInfoRaw instead.`
        );
      }
      const address = Address.fromString(addressContent, legacyKey);
      if (info.mldsaPublicKey) {
        address.originalMDLSAPublicKey = Buffer.from(info.mldsaPublicKey, "hex");
        address.mldsaLevel = info.mldsaLevel;
      }
      response[pubKey] = address;
    }
    return response;
  }
  /**
   * Get the latest epoch.
   * @description This method is used to get the latest epoch in the OPNet protocol.
   * @returns {Promise<Epoch>} The latest epoch
   * @example await getLatestEpoch();
   * @throws {Error} If something went wrong while fetching the epoch
   */
  async getLatestEpoch(includeSubmissions) {
    const payload = this.buildJsonRpcPayload(JSONRpcMethods.LATEST_EPOCH, []);
    const rawEpoch = await this.callPayloadSingle(payload);
    const result = rawEpoch.result;
    return new Epoch(result);
  }
  /**
   * Get an epoch by its number.
   * @description This method is used to get an epoch by its number.
   * @param {BigNumberish} epochNumber The epoch number (-1 for latest)
   * @param {boolean} [includeSubmissions] Whether to include submissions in the response
   * @returns {Promise<Epoch | EpochWithSubmissions>} The requested epoch
   * @example await getEpochByNumber(123n);
   * @throws {Error} If something went wrong while fetching the epoch
   */
  async getEpochByNumber(epochNumber, includeSubmissions = false) {
    const payload = this.buildJsonRpcPayload(
      JSONRpcMethods.GET_EPOCH_BY_NUMBER,
      [epochNumber.toString(), includeSubmissions]
    );
    const rawEpoch = await this.callPayloadSingle(payload);
    if ("error" in rawEpoch) {
      throw new Error(`Error fetching epoch: ${rawEpoch.error?.message || "Unknown error"}`);
    }
    const result = rawEpoch.result;
    return includeSubmissions || result.submissions ? new EpochWithSubmissions(result) : new Epoch(result);
  }
  /**
   * Get an epoch by its hash.
   * @description This method is used to get an epoch by its hash.
   * @param {string} epochHash The epoch hash
   * @param {boolean} [includeSubmissions] Whether to include submissions in the response
   * @returns {Promise<Epoch | EpochWithSubmissions>} The requested epoch
   * @example await getEpochByHash('0x1234567890abcdef...');
   * @throws {Error} If something went wrong while fetching the epoch
   */
  async getEpochByHash(epochHash, includeSubmissions = false) {
    const payload = this.buildJsonRpcPayload(JSONRpcMethods.GET_EPOCH_BY_HASH, [
      epochHash,
      includeSubmissions
    ]);
    const rawEpoch = await this.callPayloadSingle(payload);
    if ("error" in rawEpoch) {
      throw new Error(`Error fetching epoch: ${rawEpoch.error?.message || "Unknown error"}`);
    }
    const result = rawEpoch.result;
    return includeSubmissions || result.submissions ? new EpochWithSubmissions(result) : new Epoch(result);
  }
  /**
   * Get the current epoch mining template.
   * @description This method is used to get the current epoch mining template with target hash and requirements.
   * @returns {Promise<EpochTemplate>} The epoch template
   * @example await getEpochTemplate();
   * @throws {Error} If something went wrong while fetching the template
   */
  async getEpochTemplate() {
    const payload = this.buildJsonRpcPayload(
      JSONRpcMethods.GET_EPOCH_TEMPLATE,
      []
    );
    const rawTemplate = await this.callPayloadSingle(payload);
    if ("error" in rawTemplate) {
      throw new Error(
        `Error fetching epoch template: ${rawTemplate.error?.message || "Unknown error"}`
      );
    }
    const result = rawTemplate.result;
    return new EpochTemplate(result);
  }
  /**
   * Submit a new epoch solution.
   * @description This method is used to submit a SHA-1 collision solution for epoch mining.
   * @param {EpochSubmissionParams} params The parameters for the epoch submission
   * @returns {Promise<SubmittedEpoch>} The submission result
   * @example await submitEpoch({
   *     epochNumber: 123n,
   *     targetHash: Buffer.from('00000000000000000000000000000000', 'hex'),
   *     salt: Buffer.from('0a0a0a0a0a0a00a', 'hex'),
   *     mldsaPublicKey: Address.dead(),
   *     graffiti: Buffer.from('Hello, world!'),
   *     signature: Buffer.from('1234567890abcdef', 'hex'),
   * });
   * @throws {Error} If something went wrong while submitting the epoch
   */
  async submitEpoch(params) {
    const payload = this.buildJsonRpcPayload(JSONRpcMethods.SUBMIT_EPOCH, [
      {
        epochNumber: params.epochNumber.toString(),
        targetHash: this.bufferToHex(params.targetHash),
        salt: this.bufferToHex(params.salt),
        mldsaPublicKey: this.bufferToHex(params.mldsaPublicKey),
        signature: this.bufferToHex(params.signature),
        graffiti: params.graffiti ? this.bufferToHex(params.graffiti) : void 0
      }
    ]);
    const rawSubmission = await this.callPayloadSingle(payload);
    if ("error" in rawSubmission) {
      throw new Error(
        `Error submitting epoch: ${rawSubmission.error?.message || "Unknown error"}`
      );
    }
    const result = rawSubmission.result;
    return new SubmittedEpoch(result);
  }
  async _gasParameters() {
    const payload = this.buildJsonRpcPayload(JSONRpcMethods.GAS, []);
    const rawCall = await this.callPayloadSingle(payload);
    if ("error" in rawCall) {
      throw new Error(`Error fetching gas parameters: ${rawCall.error}`);
    }
    const result = rawCall.result;
    return new BlockGasParameters(result);
  }
  parseSimulatedTransaction(transaction) {
    return {
      inputs: transaction.inputs.map((input) => {
        return {
          txId: input.txId.toString("base64"),
          outputIndex: input.outputIndex,
          scriptSig: input.scriptSig.toString("base64"),
          witnesses: input.witnesses.map((w) => w.toString("base64")),
          coinbase: input.coinbase ? input.coinbase.toString("base64") : void 0,
          flags: input.flags
        };
      }),
      outputs: transaction.outputs.map((output) => {
        return {
          index: output.index,
          to: output.to,
          value: output.value.toString(),
          scriptPubKey: output.scriptPubKey?.toString("base64") || void 0,
          flags: output.flags || TransactionOutputFlags.hasTo
        };
      })
    };
  }
  bufferToHex(buffer) {
    return buffer.toString("hex");
  }
  bigintToBase64(bigint) {
    return Buffer.from(BufferHelper.pointerToUint8Array(bigint)).toString("base64");
  }
}

class Agent {
  async close() {
  }
}
function fetch$1(input, init) {
  const nativeFetch = globalThis.fetch || window.fetch || self.fetch;
  if (!nativeFetch) {
    throw new Error("Fetch API is not available.");
  }
  return nativeFetch(input, init);
}

function getFetcher(configs) {
  const agent = new Agent(configs);
  const limit = pLimit(500);
  async function limitedFetch(input, init) {
    return limit(() => fetch$1(input, { ...init, dispatcher: agent }));
  }
  return {
    fetch: limitedFetch,
    close: async () => {
      await agent.close();
    }
  };
}

const isNode = typeof process$1 !== "undefined" && process$1.versions != null && process$1.versions.node != null;
async function createWorker(workerScript) {
  if (isNode) {
    const { Worker: Worker2 } = await import('./worker_threads-browser.js');
    const worker = new Worker2(workerScript, { eval: true });
    worker.on("error", (err) => {
      console.error("[WorkerCreator] Worker error:", err);
    });
    let messageCallback = null;
    worker.on("message", (msg) => {
      if (messageCallback) messageCallback(msg);
    });
    worker.unref();
    return {
      postMessage: (msg, transferables) => {
        if (transferables && transferables.length > 0) {
          worker.postMessage(msg, transferables);
        } else {
          worker.postMessage(msg);
        }
      },
      onMessage: (callback) => {
        messageCallback = callback;
      },
      terminate: async () => {
        await worker.terminate();
      }
    };
  } else {
    const blob = new Blob([workerScript], { type: "application/javascript" });
    const url = URL.createObjectURL(blob);
    const worker = new Worker(url);
    worker.onerror = (err) => {
      console.error("[WorkerCreator] Worker error:", err);
    };
    return {
      postMessage: (msg, transferables) => {
        if (transferables && transferables.length > 0) {
          worker.postMessage(msg, transferables);
        } else {
          worker.postMessage(msg);
        }
      },
      onMessage: (callback) => {
        worker.onmessage = (e) => callback(e.data);
      },
      terminate: () => {
        worker.terminate();
        URL.revokeObjectURL(url);
      }
    };
  }
}

class BaseThreader extends Logger {
  logColor = "#FF5733";
  workers = [];
  available = [];
  pending = /* @__PURE__ */ new Map();
  queue = [];
  idCounter = 0;
  poolSize;
  initialized = false;
  initializing = null;
  tasksProcessed = 0;
  tasksFailed = 0;
  lastStatsLog = 0;
  statsInterval = 3e4;
  cleanupBound = false;
  constructor(options = {}) {
    super();
    this.poolSize = options.poolSize ?? (isNode ? 6 : Math.max(Math.max(1, Math.ceil((navigator?.hardwareConcurrency ?? 8) / 2)), 6));
  }
  get stats() {
    return {
      pending: this.pending.size,
      queued: this.queue.length,
      available: this.available.length,
      total: this.workers.length,
      processed: this.tasksProcessed,
      failed: this.tasksFailed
    };
  }
  async terminate() {
    if (!this.initialized && !this.initializing) return;
    const queuedCount = this.queue.length;
    const pendingCount = this.pending.size;
    for (const task of this.queue) {
      task.reject(new Error("Threader terminated"));
    }
    for (const [, handler] of this.pending) {
      handler.reject(new Error("Threader terminated"));
    }
    for (const worker of this.workers) {
      await worker.terminate();
    }
    this.queue = [];
    this.pending.clear();
    this.workers = [];
    this.available = [];
    this.initialized = false;
    this.initializing = null;
    if (queuedCount > 0 || pendingCount > 0) {
      this.info(
        `Terminated. Rejected ${queuedCount} queued and ${pendingCount} pending tasks. Total processed: ${this.tasksProcessed}, failed: ${this.tasksFailed}`
      );
    }
  }
  async drain() {
    if (!this.initialized) return;
    const queuedCount = this.queue.length;
    const pendingCount = this.pending.size;
    this.info(
      `Draining. Rejecting ${queuedCount} queued, waiting for ${pendingCount} pending...`
    );
    for (const task of this.queue) {
      task.reject(new Error("Threader draining"));
    }
    this.queue = [];
    if (this.pending.size > 0) {
      await new Promise((resolve) => {
        const checkDone = () => {
          if (this.pending.size === 0) {
            resolve();
          }
        };
        const originalPending = new Map(this.pending);
        for (const [id, handler] of originalPending) {
          const origResolve = handler.resolve;
          const origReject = handler.reject;
          handler.resolve = (v) => {
            origResolve(v);
            checkDone();
          };
          handler.reject = (e) => {
            origReject(e);
            checkDone();
          };
          this.pending.set(id, handler);
        }
        checkDone();
      });
    }
    await this.terminate();
  }
  runWithTransfer(op, data, transferables) {
    return new Promise(async (resolve, reject) => {
      await this.init();
      this.queue.push({ resolve, reject, op, data, transferables });
      this.processQueue();
    });
  }
  run(op, data) {
    return new Promise(async (resolve, reject) => {
      await this.init();
      this.queue.push({ resolve, reject, op, data });
      this.processQueue();
    });
  }
  bindCleanupHandlers() {
    if (this.cleanupBound) return;
    this.cleanupBound = true;
    const cleanup = () => {
      this.terminate().catch(() => {
      });
    };
    if (isNode) {
      process$1.once("beforeExit", cleanup);
      process$1.once("SIGINT", cleanup);
      process$1.once("SIGTERM", cleanup);
    } else if (typeof window !== "undefined") {
      window.addEventListener("beforeunload", cleanup);
      window.addEventListener("unload", cleanup);
    } else if (typeof self !== "undefined") {
      self.addEventListener("beforeunload", cleanup);
    }
  }
  async init() {
    if (this.initialized) return;
    if (this.initializing) return this.initializing;
    this.bindCleanupHandlers();
    this.initializing = (async () => {
      const workers = await Promise.all(
        Array.from(
          { length: this.poolSize },
          () => createWorker(this.workerScript)
        )
      );
      for (const worker of workers) {
        worker.onMessage((msg) => {
          const handler = this.pending.get(msg.id);
          if (handler) {
            this.pending.delete(msg.id);
            if (msg.error) {
              this.tasksFailed++;
              handler.reject(new Error(msg.error));
            } else {
              this.tasksProcessed++;
              handler.resolve(msg.result);
            }
          }
          this.available.push(worker);
          this.logStatsIfNeeded();
          this.processQueue();
        });
        this.workers.push(worker);
        this.available.push(worker);
      }
      this.initialized = true;
    })();
    return this.initializing;
  }
  logStatsIfNeeded() {
    const now = Date.now();
    if (now - this.lastStatsLog < this.statsInterval) return;
    this.lastStatsLog = now;
  }
  processQueue() {
    if (this.queue.length > 100 && this.available.length === 0) {
      this.warn(`Queue backing up: ${this.queue.length} tasks waiting, no workers available`);
    }
    while (this.queue.length > 0 && this.available.length > 0) {
      const task = this.queue.shift();
      if (!task) break;
      const worker = this.available.pop();
      if (!worker) break;
      const id = this.idCounter++;
      this.pending.set(id, task);
      worker.postMessage({ id, op: task.op, data: task.data }, task.transferables);
    }
  }
}

const jsonWorkerScript = `
    (async () => {
        let parentPort = null;
        let isBrowser = typeof self !== 'undefined' && typeof self.onmessage !== 'undefined';
        
        if (!isBrowser) {
            const wt = await import('node:worker_threads');
            parentPort = wt.parentPort;
        }
        
        const send = (msg) => {
            if (isBrowser) {
                postMessage(msg);
            } else if (parentPort) {
                parentPort.postMessage(msg);
            } else {
                console.error('[JsonWorker] No way to send message:', msg);
            }
        };
        
        const handler = (e) => {
            // Node: e is the message directly
            // Browser: e is MessageEvent, e.data is the message
            const msg = isBrowser ? e.data : e;
                        
            // Handle raw ArrayBuffer (shouldn't happen but defensive)
            if (msg instanceof ArrayBuffer) {
                console.error('[JsonWorker] Received raw ArrayBuffer instead of message object. Length:', msg.byteLength);
                return;
            }
            
            const { id, op, data } = msg ?? {};
            
            if (typeof id !== 'number') {
                console.error('[JsonWorker] Invalid message, missing id. Got:', msg);
                return;
            }
            
            try {
                let result;
                if (op === 'parse') {
                    if (data === undefined || data === null) {
                        throw new Error('No data provided for parse operation');
                    }
                    const text = data instanceof ArrayBuffer 
                        ? new TextDecoder().decode(data) 
                        : data;
                    result = JSON.parse(text);
                } else if (op === 'stringify') {
                    result = JSON.stringify(data);
                } else {
                    throw new Error('Unknown operation: ' + op);
                }
                send({ id, result });
            } catch (err) {
                const error = err instanceof Error ? err.message : String(err);
                console.error('[JsonWorker] Error processing task ' + id + ':', error);
                send({ id, error });
            }
        };
        
        if (isBrowser) {
            self.onmessage = handler;
            self.onerror = (err) => {
                console.error('[JsonWorker] Uncaught error:', err);
            };
        } else if (parentPort) {
            parentPort.on('message', handler);
            parentPort.on('error', (err) => {
                console.error('[JsonWorker] Uncaught error:', err);
            });
        } else {
            console.error('[JsonWorker] No parentPort and not browser - worker cannot receive messages');
        }
    })();
`;

let _isServiceWorker = null;
function checkIsServiceWorker() {
  if (_isServiceWorker !== null) return _isServiceWorker;
  if (typeof __IS_SERVICE_WORKER__ !== "undefined" && __IS_SERVICE_WORKER__) {
    _isServiceWorker = true;
    return true;
  }
  if (typeof ServiceWorkerGlobalScope !== "undefined" && self instanceof ServiceWorkerGlobalScope) {
    _isServiceWorker = true;
    return true;
  }
  _isServiceWorker = false;
  return false;
}
const isServiceWorker = checkIsServiceWorker();
class JsonThreader extends BaseThreader {
  workerScript = jsonWorkerScript;
  threadingThreshold;
  constructor(options = {}) {
    super(options);
    this.threadingThreshold = options.threadingThreshold ?? 16384;
  }
  async parse(json) {
    if (isServiceWorker || json.length < this.threadingThreshold) {
      return JSON.parse(json);
    }
    const result = await this.run("parse", json);
    return result;
  }
  async parseBuffer(buffer) {
    if (isServiceWorker || buffer.byteLength <= this.threadingThreshold) {
      const text = new TextDecoder().decode(buffer);
      return JSON.parse(text);
    }
    const result = await this.runWithTransfer("parse", buffer, [buffer]);
    return result;
  }
  async stringify(data) {
    const result = JSON.stringify(data);
    if (isServiceWorker || result.length < this.threadingThreshold) {
      return result;
    }
    return await this.run("stringify", data);
  }
}
const GLOBAL_KEY = /* @__PURE__ */ Symbol.for("opnet.jsonThreader");
const globalObj = typeof globalThis !== "undefined" ? globalThis : globalThis;
if (!globalObj[GLOBAL_KEY]) {
  globalObj[GLOBAL_KEY] = new JsonThreader();
}
const jsonThreader = globalObj[GLOBAL_KEY];

class JSONRpcProvider extends AbstractRpcProvider {
  constructor(url, network, timeout = 2e4, fetcherConfigurations = {
    keepAliveTimeout: 3e4,
    // how long sockets stay open
    keepAliveTimeoutThreshold: 3e4,
    // threshold before closing keep-alive sockets
    connections: 128,
    // max connections per server
    pipelining: 2
    // max pipelining per server
  }, useRESTAPI = true, useThreadedParsing = true) {
    super(network);
    this.timeout = timeout;
    this.fetcherConfigurations = fetcherConfigurations;
    this.useRESTAPI = useRESTAPI;
    this.useThreadedParsing = useThreadedParsing;
    this.url = this.providerUrl(url);
  }
  url;
  _fetcherWithCleanup;
  get fetcher() {
    if (!this._fetcherWithCleanup) {
      this._fetcherWithCleanup = getFetcher(this.fetcherConfigurations);
    }
    return this._fetcherWithCleanup.fetch;
  }
  async close() {
    if (this._fetcherWithCleanup) {
      await this._fetcherWithCleanup.close();
      this._fetcherWithCleanup = void 0;
    }
  }
  /**
   * @description Sets the fetch mode to use REST API or not.
   * @param {boolean} useRESTAPI - Whether to use REST API or not
   * @returns {void}
   */
  setFetchMode(useRESTAPI) {
    this.useRESTAPI = useRESTAPI;
  }
  /**
   * @description Sends a JSON RPC payload to the provider.
   * @param {JsonRpcPayload | JsonRpcPayload[]} payload - The payload to send
   * @returns {Promise<JsonRpcCallResult>} - The result of the call
   */
  async _send(payload) {
    const controller = new AbortController();
    const { signal } = controller;
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);
    const params = {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "User-Agent": "OPNET/1.0",
        Accept: "application/json",
        "Accept-Charset": "utf-8",
        "Accept-Language": "en-US",
        Connection: "Keep-Alive"
      },
      body: JSON.stringify(payload),
      timeout: this.timeout,
      signal
    };
    try {
      const resp = await this.fetcher(this.url, params);
      if (!resp.ok) {
        throw new Error(`Failed to fetch: ${resp.statusText}`);
      }
      const fetchedData = await this.parseResponse(resp);
      if (!fetchedData) {
        throw new Error("No data fetched");
      }
      return [fetchedData];
    } catch (e) {
      const error = e;
      if (error.name === "AbortError") {
        throw new Error(`Request timed out after ${this.timeout}ms`);
      }
      throw e;
    } finally {
      clearTimeout(timeoutId);
    }
  }
  providerUrl(url) {
    url = url.trim();
    if (url.endsWith("/")) {
      return url.slice(0, -1);
    }
    if (url.includes("api/v1/json-rpc")) {
      return url;
    } else {
      return `${url}/api/v1/json-rpc`;
    }
  }
  async parseResponse(resp) {
    if (this.useThreadedParsing) {
      const buffer = await resp.arrayBuffer();
      return jsonThreader.parseBuffer(buffer);
    }
    return await resp.json();
  }
}

var ProtocolError = /* @__PURE__ */ ((ProtocolError2) => {
  ProtocolError2[ProtocolError2["MALFORMED_MESSAGE"] = 1] = "MALFORMED_MESSAGE";
  ProtocolError2[ProtocolError2["UNKNOWN_OPCODE"] = 2] = "UNKNOWN_OPCODE";
  ProtocolError2[ProtocolError2["HANDSHAKE_REQUIRED"] = 3] = "HANDSHAKE_REQUIRED";
  ProtocolError2[ProtocolError2["HANDSHAKE_ALREADY_COMPLETED"] = 4] = "HANDSHAKE_ALREADY_COMPLETED";
  ProtocolError2[ProtocolError2["UNSUPPORTED_PROTOCOL_VERSION"] = 5] = "UNSUPPORTED_PROTOCOL_VERSION";
  ProtocolError2[ProtocolError2["PAYLOAD_TOO_LARGE"] = 6] = "PAYLOAD_TOO_LARGE";
  ProtocolError2[ProtocolError2["INVALID_REQUEST_ID"] = 7] = "INVALID_REQUEST_ID";
  ProtocolError2[ProtocolError2["CONNECTION_CLOSING"] = 8] = "CONNECTION_CLOSING";
  ProtocolError2[ProtocolError2["RATE_LIMIT_EXCEEDED"] = 9] = "RATE_LIMIT_EXCEEDED";
  ProtocolError2[ProtocolError2["TOO_MANY_PENDING_REQUESTS"] = 10] = "TOO_MANY_PENDING_REQUESTS";
  ProtocolError2[ProtocolError2["REQUEST_TIMEOUT"] = 11] = "REQUEST_TIMEOUT";
  ProtocolError2[ProtocolError2["INVALID_MESSAGE_FORMAT"] = 12] = "INVALID_MESSAGE_FORMAT";
  return ProtocolError2;
})(ProtocolError || {});
var AuthError = /* @__PURE__ */ ((AuthError2) => {
  AuthError2[AuthError2["AUTHENTICATION_REQUIRED"] = 1e3] = "AUTHENTICATION_REQUIRED";
  AuthError2[AuthError2["INVALID_CREDENTIALS"] = 1001] = "INVALID_CREDENTIALS";
  AuthError2[AuthError2["SESSION_EXPIRED"] = 1002] = "SESSION_EXPIRED";
  AuthError2[AuthError2["PERMISSION_DENIED"] = 1003] = "PERMISSION_DENIED";
  AuthError2[AuthError2["INVALID_CLIENT_INFO"] = 1004] = "INVALID_CLIENT_INFO";
  return AuthError2;
})(AuthError || {});
var ResourceError = /* @__PURE__ */ ((ResourceError2) => {
  ResourceError2[ResourceError2["NOT_FOUND"] = 2e3] = "NOT_FOUND";
  ResourceError2[ResourceError2["BLOCK_NOT_FOUND"] = 2001] = "BLOCK_NOT_FOUND";
  ResourceError2[ResourceError2["TRANSACTION_NOT_FOUND"] = 2002] = "TRANSACTION_NOT_FOUND";
  ResourceError2[ResourceError2["ADDRESS_NOT_FOUND"] = 2003] = "ADDRESS_NOT_FOUND";
  ResourceError2[ResourceError2["CONTRACT_NOT_FOUND"] = 2004] = "CONTRACT_NOT_FOUND";
  ResourceError2[ResourceError2["EPOCH_NOT_FOUND"] = 2005] = "EPOCH_NOT_FOUND";
  ResourceError2[ResourceError2["SUBSCRIPTION_NOT_FOUND"] = 2006] = "SUBSCRIPTION_NOT_FOUND";
  ResourceError2[ResourceError2["ALREADY_EXISTS"] = 2100] = "ALREADY_EXISTS";
  ResourceError2[ResourceError2["SUBSCRIPTION_ALREADY_EXISTS"] = 2101] = "SUBSCRIPTION_ALREADY_EXISTS";
  ResourceError2[ResourceError2["MAX_SUBSCRIPTIONS_REACHED"] = 2102] = "MAX_SUBSCRIPTIONS_REACHED";
  return ResourceError2;
})(ResourceError || {});
var ValidationError = /* @__PURE__ */ ((ValidationError2) => {
  ValidationError2[ValidationError2["INVALID_PARAMS"] = 3e3] = "INVALID_PARAMS";
  ValidationError2[ValidationError2["MISSING_REQUIRED_FIELD"] = 3001] = "MISSING_REQUIRED_FIELD";
  ValidationError2[ValidationError2["VALUE_OUT_OF_RANGE"] = 3002] = "VALUE_OUT_OF_RANGE";
  ValidationError2[ValidationError2["INVALID_ADDRESS"] = 3003] = "INVALID_ADDRESS";
  ValidationError2[ValidationError2["INVALID_HASH"] = 3004] = "INVALID_HASH";
  ValidationError2[ValidationError2["INVALID_BLOCK_IDENTIFIER"] = 3005] = "INVALID_BLOCK_IDENTIFIER";
  ValidationError2[ValidationError2["INVALID_TRANSACTION_DATA"] = 3006] = "INVALID_TRANSACTION_DATA";
  ValidationError2[ValidationError2["INVALID_SIGNATURE"] = 3007] = "INVALID_SIGNATURE";
  ValidationError2[ValidationError2["INVALID_CALLDATA"] = 3008] = "INVALID_CALLDATA";
  ValidationError2[ValidationError2["INVALID_BLOCK_HEIGHT"] = 3009] = "INVALID_BLOCK_HEIGHT";
  ValidationError2[ValidationError2["INVALID_EPOCH_NUMBER"] = 3010] = "INVALID_EPOCH_NUMBER";
  ValidationError2[ValidationError2["INVALID_POINTER"] = 3011] = "INVALID_POINTER";
  ValidationError2[ValidationError2["INVALID_PUBLIC_KEY"] = 3012] = "INVALID_PUBLIC_KEY";
  return ValidationError2;
})(ValidationError || {});
var InternalError = /* @__PURE__ */ ((InternalError2) => {
  InternalError2[InternalError2["INTERNAL_ERROR"] = 4e3] = "INTERNAL_ERROR";
  InternalError2[InternalError2["DATABASE_ERROR"] = 4001] = "DATABASE_ERROR";
  InternalError2[InternalError2["STORAGE_ERROR"] = 4002] = "STORAGE_ERROR";
  InternalError2[InternalError2["SERIALIZATION_ERROR"] = 4003] = "SERIALIZATION_ERROR";
  InternalError2[InternalError2["DESERIALIZATION_ERROR"] = 4004] = "DESERIALIZATION_ERROR";
  InternalError2[InternalError2["VM_ERROR"] = 4005] = "VM_ERROR";
  InternalError2[InternalError2["NETWORK_ERROR"] = 4006] = "NETWORK_ERROR";
  InternalError2[InternalError2["SERVICE_UNAVAILABLE"] = 4007] = "SERVICE_UNAVAILABLE";
  InternalError2[InternalError2["NOT_IMPLEMENTED"] = 4008] = "NOT_IMPLEMENTED";
  InternalError2[InternalError2["TIMEOUT"] = 4009] = "TIMEOUT";
  return InternalError2;
})(InternalError || {});
const ErrorMessages = {
  // Protocol errors
  [1 /* MALFORMED_MESSAGE */]: "Malformed message",
  [2 /* UNKNOWN_OPCODE */]: "Unknown opcode",
  [3 /* HANDSHAKE_REQUIRED */]: "Handshake required before making requests",
  [4 /* HANDSHAKE_ALREADY_COMPLETED */]: "Handshake has already been completed",
  [5 /* UNSUPPORTED_PROTOCOL_VERSION */]: "Unsupported protocol version",
  [6 /* PAYLOAD_TOO_LARGE */]: "Message payload too large",
  [7 /* INVALID_REQUEST_ID */]: "Invalid or missing request ID",
  [8 /* CONNECTION_CLOSING */]: "Connection is closing",
  [9 /* RATE_LIMIT_EXCEEDED */]: "Rate limit exceeded",
  [10 /* TOO_MANY_PENDING_REQUESTS */]: "Too many pending requests",
  [11 /* REQUEST_TIMEOUT */]: "Request timed out",
  [12 /* INVALID_MESSAGE_FORMAT */]: "Invalid message format",
  // Auth errors
  [1e3 /* AUTHENTICATION_REQUIRED */]: "Authentication required",
  [1001 /* INVALID_CREDENTIALS */]: "Invalid credentials",
  [1002 /* SESSION_EXPIRED */]: "Session has expired",
  [1003 /* PERMISSION_DENIED */]: "Permission denied",
  [1004 /* INVALID_CLIENT_INFO */]: "Invalid client information",
  // Resource errors
  [2e3 /* NOT_FOUND */]: "Resource not found",
  [2001 /* BLOCK_NOT_FOUND */]: "Block not found",
  [2002 /* TRANSACTION_NOT_FOUND */]: "Transaction not found",
  [2003 /* ADDRESS_NOT_FOUND */]: "Address not found",
  [2004 /* CONTRACT_NOT_FOUND */]: "Contract not found",
  [2005 /* EPOCH_NOT_FOUND */]: "Epoch not found",
  [2006 /* SUBSCRIPTION_NOT_FOUND */]: "Subscription not found",
  [2100 /* ALREADY_EXISTS */]: "Resource already exists",
  [2101 /* SUBSCRIPTION_ALREADY_EXISTS */]: "Subscription already exists",
  [2102 /* MAX_SUBSCRIPTIONS_REACHED */]: "Maximum subscriptions reached",
  // Validation errors
  [3e3 /* INVALID_PARAMS */]: "Invalid parameters",
  [3001 /* MISSING_REQUIRED_FIELD */]: "Missing required field",
  [3002 /* VALUE_OUT_OF_RANGE */]: "Value out of valid range",
  [3003 /* INVALID_ADDRESS */]: "Invalid address format",
  [3004 /* INVALID_HASH */]: "Invalid hash format",
  [3005 /* INVALID_BLOCK_IDENTIFIER */]: "Invalid block identifier",
  [3006 /* INVALID_TRANSACTION_DATA */]: "Invalid transaction data",
  [3007 /* INVALID_SIGNATURE */]: "Invalid signature",
  [3008 /* INVALID_CALLDATA */]: "Invalid calldata",
  [3009 /* INVALID_BLOCK_HEIGHT */]: "Invalid block height",
  [3010 /* INVALID_EPOCH_NUMBER */]: "Invalid epoch number",
  [3011 /* INVALID_POINTER */]: "Invalid pointer format",
  [3012 /* INVALID_PUBLIC_KEY */]: "Invalid public key",
  // Internal errors
  [4e3 /* INTERNAL_ERROR */]: "Internal server error",
  [4001 /* DATABASE_ERROR */]: "Database error",
  [4002 /* STORAGE_ERROR */]: "Storage error",
  [4003 /* SERIALIZATION_ERROR */]: "Serialization error",
  [4004 /* DESERIALIZATION_ERROR */]: "Deserialization error",
  [4005 /* VM_ERROR */]: "VM execution error",
  [4006 /* NETWORK_ERROR */]: "Network error",
  [4007 /* SERVICE_UNAVAILABLE */]: "Service temporarily unavailable",
  [4008 /* NOT_IMPLEMENTED */]: "Method not implemented",
  [4009 /* TIMEOUT */]: "Operation timed out"
};
function getErrorMessage(code) {
  return ErrorMessages[code] ?? "Unknown error";
}

class OPNetError extends Error {
  code;
  data;
  constructor(code, message, data) {
    super(message ?? getErrorMessage(code));
    this.name = "OPNetError";
    this.code = code;
    this.data = data;
  }
}

let cachedRoot = null;
async function loadProtobufSchema(baseUrl) {
  if (cachedRoot) {
    return cachedRoot;
  }
  let url = baseUrl.trim();
  if (url.endsWith("/")) {
    url = url.slice(0, -1);
  }
  const schemaUrl = `${url}/api/v1/protobuf/api-schema`;
  const response = await fetch(schemaUrl);
  if (!response.ok) {
    throw new Error(
      `Failed to fetch protobuf schema: ${response.status} ${response.statusText}`
    );
  }
  const protoContent = await response.text();
  cachedRoot = protobuf.parse(protoContent, { keepCase: true }).root;
  return cachedRoot;
}
function getProtobufType(root, typeName) {
  const fullPath = `OPNetAPIProtocol.${typeName}`;
  return root.lookupType(fullPath);
}
function clearProtobufCache() {
  cachedRoot = null;
}

var ConnectionState = /* @__PURE__ */ ((ConnectionState2) => {
  ConnectionState2[ConnectionState2["DISCONNECTED"] = 0] = "DISCONNECTED";
  ConnectionState2[ConnectionState2["CONNECTING"] = 1] = "CONNECTING";
  ConnectionState2[ConnectionState2["CONNECTED"] = 2] = "CONNECTED";
  ConnectionState2[ConnectionState2["HANDSHAKING"] = 3] = "HANDSHAKING";
  ConnectionState2[ConnectionState2["READY"] = 4] = "READY";
  ConnectionState2[ConnectionState2["RECONNECTING"] = 5] = "RECONNECTING";
  ConnectionState2[ConnectionState2["CLOSING"] = 6] = "CLOSING";
  return ConnectionState2;
})(ConnectionState || {});
function getConnectionStateName(state) {
  switch (state) {
    case 0 /* DISCONNECTED */:
      return "DISCONNECTED";
    case 1 /* CONNECTING */:
      return "CONNECTING";
    case 2 /* CONNECTED */:
      return "CONNECTED";
    case 3 /* HANDSHAKING */:
      return "HANDSHAKING";
    case 4 /* READY */:
      return "READY";
    case 5 /* RECONNECTING */:
      return "RECONNECTING";
    case 6 /* CLOSING */:
      return "CLOSING";
    default:
      return "UNKNOWN";
  }
}

var SubscriptionType = /* @__PURE__ */ ((SubscriptionType2) => {
  SubscriptionType2[SubscriptionType2["BLOCKS"] = 0] = "BLOCKS";
  SubscriptionType2[SubscriptionType2["EPOCHS"] = 1] = "EPOCHS";
  return SubscriptionType2;
})(SubscriptionType || {});
function getSubscriptionTypeName(type) {
  switch (type) {
    case 0 /* BLOCKS */:
      return "BLOCKS";
    case 1 /* EPOCHS */:
      return "EPOCHS";
    default:
      return "UNKNOWN";
  }
}

const DEFAULT_CONFIG = {
  connectTimeout: 1e4,
  requestTimeout: 3e4,
  handshakeTimeout: 1e4,
  pingInterval: 3e4,
  autoReconnect: true,
  maxReconnectAttempts: 10,
  reconnectBaseDelay: 1e3,
  reconnectMaxDelay: 3e4,
  maxPendingRequests: 1e3
};

var WebSocketRequestOpcode = /* @__PURE__ */ ((WebSocketRequestOpcode2) => {
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["PING"] = 0] = "PING";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["HANDSHAKE"] = 1] = "HANDSHAKE";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_BLOCK_NUMBER"] = 16] = "GET_BLOCK_NUMBER";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_BLOCK_BY_NUMBER"] = 17] = "GET_BLOCK_BY_NUMBER";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_BLOCK_BY_HASH"] = 18] = "GET_BLOCK_BY_HASH";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_BLOCK_BY_CHECKSUM"] = 19] = "GET_BLOCK_BY_CHECKSUM";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_BLOCK_WITNESS"] = 20] = "GET_BLOCK_WITNESS";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_GAS"] = 21] = "GET_GAS";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_TRANSACTION_BY_HASH"] = 32] = "GET_TRANSACTION_BY_HASH";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_TRANSACTION_RECEIPT"] = 33] = "GET_TRANSACTION_RECEIPT";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["BROADCAST_TRANSACTION"] = 34] = "BROADCAST_TRANSACTION";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_PREIMAGE"] = 35] = "GET_PREIMAGE";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_BALANCE"] = 48] = "GET_BALANCE";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_UTXOS"] = 49] = "GET_UTXOS";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_PUBLIC_KEY_INFO"] = 50] = "GET_PUBLIC_KEY_INFO";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_CHAIN_ID"] = 64] = "GET_CHAIN_ID";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_REORG"] = 65] = "GET_REORG";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_CODE"] = 80] = "GET_CODE";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_STORAGE_AT"] = 81] = "GET_STORAGE_AT";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["CALL"] = 82] = "CALL";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_LATEST_EPOCH"] = 96] = "GET_LATEST_EPOCH";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_EPOCH_BY_NUMBER"] = 97] = "GET_EPOCH_BY_NUMBER";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_EPOCH_BY_HASH"] = 98] = "GET_EPOCH_BY_HASH";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["GET_EPOCH_TEMPLATE"] = 99] = "GET_EPOCH_TEMPLATE";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["SUBMIT_EPOCH"] = 100] = "SUBMIT_EPOCH";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["SUBSCRIBE_BLOCKS"] = 112] = "SUBSCRIBE_BLOCKS";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["SUBSCRIBE_EPOCHS"] = 113] = "SUBSCRIBE_EPOCHS";
  WebSocketRequestOpcode2[WebSocketRequestOpcode2["UNSUBSCRIBE"] = 127] = "UNSUBSCRIBE";
  return WebSocketRequestOpcode2;
})(WebSocketRequestOpcode || {});
var WebSocketResponseOpcode = /* @__PURE__ */ ((WebSocketResponseOpcode2) => {
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["ERROR"] = 128] = "ERROR";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["PONG"] = 129] = "PONG";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["HANDSHAKE_ACK"] = 130] = "HANDSHAKE_ACK";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["BLOCK_NUMBER"] = 144] = "BLOCK_NUMBER";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["BLOCK"] = 145] = "BLOCK";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["BLOCK_WITNESS"] = 146] = "BLOCK_WITNESS";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["GAS"] = 147] = "GAS";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["TRANSACTION"] = 160] = "TRANSACTION";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["TRANSACTION_RECEIPT"] = 161] = "TRANSACTION_RECEIPT";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["BROADCAST_RESULT"] = 162] = "BROADCAST_RESULT";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["PREIMAGE"] = 163] = "PREIMAGE";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["BALANCE"] = 176] = "BALANCE";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["UTXOS"] = 177] = "UTXOS";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["PUBLIC_KEY_INFO"] = 178] = "PUBLIC_KEY_INFO";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["CHAIN_ID"] = 192] = "CHAIN_ID";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["REORG"] = 193] = "REORG";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["CODE"] = 208] = "CODE";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["STORAGE"] = 209] = "STORAGE";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["CALL_RESULT"] = 210] = "CALL_RESULT";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["EPOCH"] = 224] = "EPOCH";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["EPOCH_TEMPLATE"] = 225] = "EPOCH_TEMPLATE";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["EPOCH_SUBMIT_RESULT"] = 226] = "EPOCH_SUBMIT_RESULT";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["SUBSCRIPTION_CREATED"] = 240] = "SUBSCRIPTION_CREATED";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["UNSUBSCRIBE_RESULT"] = 241] = "UNSUBSCRIBE_RESULT";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["NEW_BLOCK_NOTIFICATION"] = 248] = "NEW_BLOCK_NOTIFICATION";
  WebSocketResponseOpcode2[WebSocketResponseOpcode2["NEW_EPOCH_NOTIFICATION"] = 249] = "NEW_EPOCH_NOTIFICATION";
  return WebSocketResponseOpcode2;
})(WebSocketResponseOpcode || {});

var WebSocketClientEvent = /* @__PURE__ */ ((WebSocketClientEvent2) => {
  WebSocketClientEvent2["CONNECTED"] = "connected";
  WebSocketClientEvent2["DISCONNECTED"] = "disconnected";
  WebSocketClientEvent2["ERROR"] = "error";
  WebSocketClientEvent2["BLOCK"] = "block";
  WebSocketClientEvent2["EPOCH"] = "epoch";
  return WebSocketClientEvent2;
})(WebSocketClientEvent || {});

const METHOD_MAPPINGS = {
  [JSONRpcMethods.BLOCK_BY_NUMBER]: {
    requestOpcode: WebSocketRequestOpcode.GET_BLOCK_NUMBER,
    responseOpcode: WebSocketResponseOpcode.BLOCK_NUMBER,
    requestType: "GetBlockNumberRequest",
    responseType: "GetBlockNumberResponse"
  },
  [JSONRpcMethods.GET_BLOCK_BY_NUMBER]: {
    requestOpcode: WebSocketRequestOpcode.GET_BLOCK_BY_NUMBER,
    responseOpcode: WebSocketResponseOpcode.BLOCK,
    requestType: "GetBlockByNumberRequest",
    responseType: "BlockResponse"
  },
  [JSONRpcMethods.GET_BLOCK_BY_HASH]: {
    requestOpcode: WebSocketRequestOpcode.GET_BLOCK_BY_HASH,
    responseOpcode: WebSocketResponseOpcode.BLOCK,
    requestType: "GetBlockByHashRequest",
    responseType: "BlockResponse"
  },
  [JSONRpcMethods.GET_BLOCK_BY_CHECKSUM]: {
    requestOpcode: WebSocketRequestOpcode.GET_BLOCK_BY_CHECKSUM,
    responseOpcode: WebSocketResponseOpcode.BLOCK,
    requestType: "GetBlockByChecksumRequest",
    responseType: "BlockResponse"
  },
  [JSONRpcMethods.BLOCK_WITNESS]: {
    requestOpcode: WebSocketRequestOpcode.GET_BLOCK_WITNESS,
    responseOpcode: WebSocketResponseOpcode.BLOCK_WITNESS,
    requestType: "GetBlockWitnessRequest",
    responseType: "BlockWitnessResponse"
  },
  [JSONRpcMethods.GAS]: {
    requestOpcode: WebSocketRequestOpcode.GET_GAS,
    responseOpcode: WebSocketResponseOpcode.GAS,
    requestType: "GetGasRequest",
    responseType: "GasResponse"
  },
  [JSONRpcMethods.GET_TRANSACTION_BY_HASH]: {
    requestOpcode: WebSocketRequestOpcode.GET_TRANSACTION_BY_HASH,
    responseOpcode: WebSocketResponseOpcode.TRANSACTION,
    requestType: "GetTransactionByHashRequest",
    responseType: "TransactionResponse"
  },
  [JSONRpcMethods.GET_TRANSACTION_RECEIPT]: {
    requestOpcode: WebSocketRequestOpcode.GET_TRANSACTION_RECEIPT,
    responseOpcode: WebSocketResponseOpcode.TRANSACTION_RECEIPT,
    requestType: "GetTransactionReceiptRequest",
    responseType: "TransactionReceiptResponse"
  },
  [JSONRpcMethods.BROADCAST_TRANSACTION]: {
    requestOpcode: WebSocketRequestOpcode.BROADCAST_TRANSACTION,
    responseOpcode: WebSocketResponseOpcode.BROADCAST_RESULT,
    requestType: "BroadcastTransactionRequest",
    responseType: "BroadcastTransactionResponse"
  },
  [JSONRpcMethods.TRANSACTION_PREIMAGE]: {
    requestOpcode: WebSocketRequestOpcode.GET_PREIMAGE,
    responseOpcode: WebSocketResponseOpcode.PREIMAGE,
    requestType: "GetPreimageRequest",
    responseType: "PreimageResponse"
  },
  [JSONRpcMethods.GET_BALANCE]: {
    requestOpcode: WebSocketRequestOpcode.GET_BALANCE,
    responseOpcode: WebSocketResponseOpcode.BALANCE,
    requestType: "GetBalanceRequest",
    responseType: "BalanceResponse"
  },
  [JSONRpcMethods.GET_UTXOS]: {
    requestOpcode: WebSocketRequestOpcode.GET_UTXOS,
    responseOpcode: WebSocketResponseOpcode.UTXOS,
    requestType: "GetUTXOsRequest",
    responseType: "UTXOsResponse"
  },
  [JSONRpcMethods.PUBLIC_KEY_INFO]: {
    requestOpcode: WebSocketRequestOpcode.GET_PUBLIC_KEY_INFO,
    responseOpcode: WebSocketResponseOpcode.PUBLIC_KEY_INFO,
    requestType: "GetPublicKeyInfoRequest",
    responseType: "PublicKeyInfoResponse"
  },
  [JSONRpcMethods.CHAIN_ID]: {
    requestOpcode: WebSocketRequestOpcode.GET_CHAIN_ID,
    responseOpcode: WebSocketResponseOpcode.CHAIN_ID,
    requestType: "GetChainIdRequest",
    responseType: "ChainIdResponse"
  },
  [JSONRpcMethods.REORG]: {
    requestOpcode: WebSocketRequestOpcode.GET_REORG,
    responseOpcode: WebSocketResponseOpcode.REORG,
    requestType: "GetReorgRequest",
    responseType: "ReorgResponse"
  },
  [JSONRpcMethods.GET_CODE]: {
    requestOpcode: WebSocketRequestOpcode.GET_CODE,
    responseOpcode: WebSocketResponseOpcode.CODE,
    requestType: "GetCodeRequest",
    responseType: "CodeResponse"
  },
  [JSONRpcMethods.GET_STORAGE_AT]: {
    requestOpcode: WebSocketRequestOpcode.GET_STORAGE_AT,
    responseOpcode: WebSocketResponseOpcode.STORAGE,
    requestType: "GetStorageAtRequest",
    responseType: "StorageResponse"
  },
  [JSONRpcMethods.CALL]: {
    requestOpcode: WebSocketRequestOpcode.CALL,
    responseOpcode: WebSocketResponseOpcode.CALL_RESULT,
    requestType: "CallRequest",
    responseType: "CallResponse"
  },
  [JSONRpcMethods.LATEST_EPOCH]: {
    requestOpcode: WebSocketRequestOpcode.GET_LATEST_EPOCH,
    responseOpcode: WebSocketResponseOpcode.EPOCH,
    requestType: "GetLatestEpochRequest",
    responseType: "EpochResponse"
  },
  [JSONRpcMethods.GET_EPOCH_BY_NUMBER]: {
    requestOpcode: WebSocketRequestOpcode.GET_EPOCH_BY_NUMBER,
    responseOpcode: WebSocketResponseOpcode.EPOCH,
    requestType: "GetEpochByNumberRequest",
    responseType: "EpochResponse"
  },
  [JSONRpcMethods.GET_EPOCH_BY_HASH]: {
    requestOpcode: WebSocketRequestOpcode.GET_EPOCH_BY_HASH,
    responseOpcode: WebSocketResponseOpcode.EPOCH,
    requestType: "GetEpochByHashRequest",
    responseType: "EpochResponse"
  },
  [JSONRpcMethods.GET_EPOCH_TEMPLATE]: {
    requestOpcode: WebSocketRequestOpcode.GET_EPOCH_TEMPLATE,
    responseOpcode: WebSocketResponseOpcode.EPOCH_TEMPLATE,
    requestType: "GetEpochTemplateRequest",
    responseType: "EpochTemplateResponse"
  },
  [JSONRpcMethods.SUBMIT_EPOCH]: {
    requestOpcode: WebSocketRequestOpcode.SUBMIT_EPOCH,
    responseOpcode: WebSocketResponseOpcode.EPOCH_SUBMIT_RESULT,
    requestType: "SubmitEpochRequest",
    responseType: "SubmitEpochResponse"
  }
};
class WebSocketRpcProvider extends AbstractRpcProvider {
  config;
  pendingRequests = /* @__PURE__ */ new Map();
  subscriptions = /* @__PURE__ */ new Map();
  eventHandlers = /* @__PURE__ */ new Map();
  socket = null;
  state = ConnectionState.DISCONNECTED;
  requestId = 0;
  reconnectAttempt = 0;
  pingTimeout = null;
  sessionId = null;
  userRequestedDisconnect = false;
  protoRoot = null;
  protoTypes = /* @__PURE__ */ new Map();
  constructor(url, network, config) {
    super(network);
    this.config = { ...DEFAULT_CONFIG, url, ...config };
  }
  /**
   * Get the current connection state
   */
  getState() {
    return this.state;
  }
  /**
   * Check if the provider is ready to send requests
   */
  isReady() {
    return this.state === ConnectionState.READY;
  }
  /**
   * Connect to the WebSocket server
   */
  async connect() {
    if (this.state !== ConnectionState.DISCONNECTED) {
      throw new Error(
        `Cannot connect: current state is ${getConnectionStateName(this.state)}`
      );
    }
    this.state = ConnectionState.CONNECTING;
    this.userRequestedDisconnect = false;
    try {
      const httpUrl = this.config.url.replace(/^ws/, "http");
      this.protoRoot = await loadProtobufSchema(httpUrl);
      this.protoTypes.clear();
      await this.connectWebSocket();
      await this.performHandshake();
      this.schedulePing();
      this.reconnectAttempt = 0;
      this.emit(WebSocketClientEvent.CONNECTED, void 0);
    } catch (error) {
      this.state = ConnectionState.DISCONNECTED;
      throw error;
    }
  }
  /**
   * Disconnect from the WebSocket server
   */
  disconnect() {
    if (this.state === ConnectionState.DISCONNECTED) {
      return;
    }
    this.userRequestedDisconnect = true;
    this.state = ConnectionState.CLOSING;
    this.cancelPing();
    this.cleanupPendingRequests(new Error("Connection closed"));
    if (this.socket) {
      this.socket.close(1e3, "Client disconnect");
      this.socket = null;
    }
    this.state = ConnectionState.DISCONNECTED;
    this.emit(WebSocketClientEvent.DISCONNECTED, void 0);
  }
  /**
   * Register an event handler
   */
  on(event, handler) {
    let handlers = this.eventHandlers.get(event);
    if (!handlers) {
      handlers = /* @__PURE__ */ new Set();
      this.eventHandlers.set(event, handlers);
    }
    handlers.add(handler);
  }
  /**
   * Remove an event handler
   */
  off(event, handler) {
    const handlers = this.eventHandlers.get(event);
    if (handlers) {
      handlers.delete(handler);
    }
  }
  /**
   * Subscribe to new blocks
   */
  async subscribeBlocks(handler) {
    if (this.state !== ConnectionState.READY) {
      throw new Error("Not connected");
    }
    const type = this.getType("SubscribeBlocksRequest");
    const message = type.create({});
    const encodedPayload = type.encode(message).finish();
    const requestId = this.nextRequestId();
    const fullMessage = this.buildMessage(
      WebSocketRequestOpcode.SUBSCRIBE_BLOCKS,
      requestId,
      encodedPayload
    );
    await this.sendRequest(requestId, fullMessage);
    this.subscriptions.set(SubscriptionType.BLOCKS, handler);
  }
  /**
   * Subscribe to new epochs
   */
  async subscribeEpochs(handler) {
    if (this.state !== ConnectionState.READY) {
      throw new Error("Not connected");
    }
    const type = this.getType("SubscribeEpochsRequest");
    const message = type.create({});
    const encodedPayload = type.encode(message).finish();
    const requestId = this.nextRequestId();
    const fullMessage = this.buildMessage(
      WebSocketRequestOpcode.SUBSCRIBE_EPOCHS,
      requestId,
      encodedPayload
    );
    await this.sendRequest(requestId, fullMessage);
    this.subscriptions.set(SubscriptionType.EPOCHS, handler);
  }
  /**
   * Unsubscribe from a subscription
   */
  async unsubscribe(subscriptionType) {
    if (this.state !== ConnectionState.READY) {
      throw new Error("Not connected");
    }
    const type = this.getType("UnsubscribeRequest");
    const messageData = this.buildMessageByFieldId(type, {
      2: subscriptionType
      // subscriptionId field (id=2)
    });
    const message = type.create(messageData);
    const encodedPayload = type.encode(message).finish();
    const requestId = this.nextRequestId();
    const fullMessage = this.buildMessage(
      WebSocketRequestOpcode.UNSUBSCRIBE,
      requestId,
      encodedPayload
    );
    await this.sendRequest(requestId, fullMessage);
    this.subscriptions.delete(subscriptionType);
  }
  /**
   * Clear the protobuf cache (useful when reconnecting to a different server)
   */
  clearCache() {
    clearProtobufCache();
    this.protoTypes.clear();
    this.protoRoot = null;
  }
  /**
   * Implements the abstract _send method from AbstractRpcProvider.
   * Translates JSON-RPC payloads to WebSocket binary protocol.
   *
   * Note: To match JSONRpcProvider behavior for callMultiplePayloads:
   * - Single payload returns [result]
   * - Array of payloads returns [[result1, result2, ...]] (wrapped in outer array)
   * This is because callMultiplePayloads expects the batch results to be wrapped.
   */
  async _send(payload) {
    if (this.state !== ConnectionState.READY) {
      throw new Error("WebSocket not connected. Call connect() first.");
    }
    const isArray = Array.isArray(payload);
    const payloads = isArray ? payload : [payload];
    const results = [];
    for (const p of payloads) {
      const result = await this.sendJsonRpcRequest(p);
      results.push(result);
    }
    return isArray ? [results] : results;
  }
  providerUrl(url) {
    url = url.trim();
    if (url.endsWith("/")) {
      url = url.slice(0, -1);
    }
    if (!url.startsWith("ws://") && !url.startsWith("wss://")) {
      url = url.replace(/^http/, "ws");
    }
    return url;
  }
  /**
   * Translate a JSON-RPC payload to a WebSocket request and send it
   */
  async sendJsonRpcRequest(payload) {
    const mapping = METHOD_MAPPINGS[payload.method];
    if (!mapping) {
      throw new Error(`Unsupported method: ${payload.method}`);
    }
    const requestType = this.getType(mapping.requestType);
    const params = Array.isArray(payload.params) ? payload.params : [];
    const fieldIdMap = this.translateJsonRpcParamsToFieldIds(payload.method, params);
    const protoPayload = this.buildMessageByFieldId(requestType, fieldIdMap);
    const message = requestType.create(protoPayload);
    const encodedPayload = requestType.encode(message).finish();
    const requestId = this.nextRequestId();
    const fullMessage = this.buildMessage(mapping.requestOpcode, requestId, encodedPayload);
    const responseData = await this.sendRequest(requestId, fullMessage);
    const responseType = this.getType(mapping.responseType);
    const decoded = responseType.decode(responseData);
    const responseObj = responseType.toObject(decoded, {
      longs: String,
      bytes: String,
      defaults: true
    });
    const result = this.translateProtoResponse(payload.method, responseObj, responseType);
    return {
      jsonrpc: "2.0",
      id: payload.id ?? null,
      result
    };
  }
  /**
   * Translate JSON-RPC params to protobuf field IDs.
   * Uses proto field numbers (stable) instead of field names (may change).
   * Field numbers are defined in the .proto file and are part of the wire format.
   */
  translateJsonRpcParamsToFieldIds(method, params) {
    switch (method) {
      case JSONRpcMethods.BLOCK_BY_NUMBER:
        return {};
      case JSONRpcMethods.GET_BLOCK_BY_NUMBER:
        return {
          2: { 1: Long.fromString(String(params[0])) },
          // identifier.height
          3: params[1] ?? false
        };
      case JSONRpcMethods.GET_BLOCK_BY_HASH:
        return {
          2: { 2: params[0] },
          // identifier.hash
          3: params[1] ?? false
        };
      case JSONRpcMethods.GET_BLOCK_BY_CHECKSUM:
        return {
          2: { 3: params[0] },
          // identifier.checksum
          3: params[1] ?? false
        };
      case JSONRpcMethods.BLOCK_WITNESS:
        return {
          2: Long.fromString(String(params[0] ?? -1)),
          3: params[1],
          4: params[2],
          5: params[3]
        };
      case JSONRpcMethods.GAS:
        return {};
      case JSONRpcMethods.GET_TRANSACTION_BY_HASH:
        return { 2: params[0] };
      case JSONRpcMethods.GET_TRANSACTION_RECEIPT:
        return { 2: params[0] };
      case JSONRpcMethods.BROADCAST_TRANSACTION:
        return {
          2: params[0],
          3: params[1] ?? false
        };
      case JSONRpcMethods.TRANSACTION_PREIMAGE:
        return {};
      case JSONRpcMethods.GET_BALANCE:
        return {
          2: String(params[0]),
          3: params[1] ?? true
        };
      case JSONRpcMethods.GET_UTXOS:
        return {
          2: String(params[0]),
          3: params[1] ?? true
        };
      case JSONRpcMethods.PUBLIC_KEY_INFO:
        return { 2: params[0] };
      case JSONRpcMethods.CHAIN_ID:
        return {};
      case JSONRpcMethods.REORG:
        return {
          2: params[0]
        };
      case JSONRpcMethods.GET_CODE:
        return {
          2: String(params[0]),
          3: params[1] ?? false
        };
      case JSONRpcMethods.GET_STORAGE_AT:
        return {
          2: String(params[0]),
          3: params[1],
          4: params[2] ?? true
        };
      case JSONRpcMethods.CALL:
        return {
          2: String(params[0]),
          3: params[1],
          4: params[2],
          5: params[3]
        };
      case JSONRpcMethods.LATEST_EPOCH:
        return {};
      case JSONRpcMethods.GET_EPOCH_BY_NUMBER:
        return {
          2: Long.fromString(String(params[0]))
        };
      case JSONRpcMethods.GET_EPOCH_BY_HASH:
        return {
          2: params[0]
        };
      case JSONRpcMethods.GET_EPOCH_TEMPLATE:
        return {};
      case JSONRpcMethods.SUBMIT_EPOCH: {
        const submitParams = params[0];
        return {
          2: submitParams.epochNumber,
          3: submitParams.targetHash,
          4: submitParams.salt,
          5: submitParams.mldsaPublicKey,
          6: submitParams.graffiti,
          7: submitParams.signature
        };
      }
      default:
        return {};
    }
  }
  /**
   * Convert OPNetType proto enum value to OPNetTransactionTypes string enum.
   * Proto enum: GENERIC=0, DEPLOYMENT=1, INTERACTION=2
   */
  convertOPNetTypeToString(value) {
    switch (value) {
      case 1:
        return OPNetTransactionTypes.Deployment;
      case 2:
        return OPNetTransactionTypes.Interaction;
      case 0:
      default:
        return OPNetTransactionTypes.Generic;
    }
  }
  /**
   * Convert transaction object:
   * 1. Converts OPNetType from integer to string enum
   * 2. Flattens nested type-specific data (interaction/deployment) to top level
   *
   * Proto uses oneof for type-specific data:
   * - field 20: interaction (InteractionTransactionData)
   * - field 21: deployment (DeploymentTransactionData)
   */
  convertTransaction(tx) {
    const txType = this.protoRoot?.lookupType("TransactionForAPI");
    if (!txType) {
      return tx;
    }
    const opnetTypeField = this.getFieldById(txType, 19);
    if (opnetTypeField && tx[opnetTypeField.name] !== void 0) {
      tx[opnetTypeField.name] = this.convertOPNetTypeToString(
        tx[opnetTypeField.name]
      );
    }
    const interactionField = this.getFieldById(txType, 20);
    if (interactionField && tx[interactionField.name]) {
      const interactionData = tx[interactionField.name];
      Object.assign(tx, interactionData);
      delete tx[interactionField.name];
    }
    const deploymentField = this.getFieldById(txType, 21);
    if (deploymentField && tx[deploymentField.name]) {
      const deploymentData = tx[deploymentField.name];
      Object.assign(tx, deploymentData);
      delete tx[deploymentField.name];
    }
    return tx;
  }
  /**
   * Convert block response, converting OPNetType in all transactions.
   */
  convertBlockResponse(block) {
    const blockType = this.protoRoot?.lookupType("BlockResponse");
    if (!blockType) {
      return block;
    }
    const txField = this.getFieldById(blockType, 22);
    if (txField && Array.isArray(block[txField.name])) {
      block[txField.name] = block[txField.name].map(
        (tx) => this.convertTransaction(tx)
      );
    }
    return block;
  }
  /**
   * Translate protobuf response to JSON-RPC result format.
   * Uses field IDs to extract values (not hardcoded field names).
   */
  translateProtoResponse(method, response, responseType) {
    switch (method) {
      case JSONRpcMethods.BLOCK_BY_NUMBER: {
        const fieldName = this.getFieldNameById(responseType, 1);
        return fieldName ? response[fieldName] : void 0;
      }
      case JSONRpcMethods.CHAIN_ID: {
        const fieldName = this.getFieldNameById(responseType, 1);
        return fieldName ? response[fieldName] : void 0;
      }
      case JSONRpcMethods.GET_BALANCE: {
        const fieldName = this.getFieldNameById(responseType, 1);
        return fieldName ? response[fieldName] : void 0;
      }
      case JSONRpcMethods.GET_BLOCK_BY_NUMBER:
      case JSONRpcMethods.GET_BLOCK_BY_HASH:
      case JSONRpcMethods.GET_BLOCK_BY_CHECKSUM: {
        return this.convertBlockResponse(response);
      }
      case JSONRpcMethods.GET_TRANSACTION_BY_HASH: {
        const txResponseType = this.protoRoot?.lookupType("TransactionResponse");
        if (txResponseType) {
          const txField = this.getFieldById(txResponseType, 1);
          if (txField && response[txField.name]) {
            response[txField.name] = this.convertTransaction(
              response[txField.name]
            );
          }
        }
        return response;
      }
      default:
        return response;
    }
  }
  connectWebSocket() {
    return new Promise((resolve, reject) => {
      const url = this.buildWebSocketUrl();
      const timeout = setTimeout(() => {
        reject(new Error(`Connection timeout after ${this.config.connectTimeout}ms`));
      }, this.config.connectTimeout);
      try {
        this.socket = new WebSocket(url);
        this.socket.binaryType = "arraybuffer";
        this.socket.onopen = () => {
          clearTimeout(timeout);
          this.state = ConnectionState.CONNECTED;
          resolve();
        };
        this.socket.onerror = (event) => {
          clearTimeout(timeout);
          reject(new Error(`WebSocket error: ${event}`));
        };
        this.socket.onclose = (event) => {
          this.handleClose(event);
        };
        this.socket.onmessage = (event) => {
          this.handleMessage(event.data);
        };
      } catch (error) {
        clearTimeout(timeout);
        reject(error instanceof Error ? error : new Error(String(error)));
      }
    });
  }
  buildWebSocketUrl() {
    let url = this.config.url.trim();
    if (url.endsWith("/")) {
      url = url.slice(0, -1);
    }
    if (!url.startsWith("ws://") && !url.startsWith("wss://")) {
      url = url.replace(/^http/, "ws");
    }
    if (!url.includes("/api/v1/ws")) {
      url = `${url}/api/v1/ws`;
    }
    return url;
  }
  async performHandshake() {
    this.state = ConnectionState.HANDSHAKING;
    const type = this.getType("HandshakeRequest");
    const messageData = this.buildMessageByFieldId(type, {
      1: 1,
      // protocolVersion field (id=1)
      2: "opnet-js",
      // clientName field (id=2)
      3: "1.0.0"
      // clientVersion field (id=3)
    });
    const message = type.create(messageData);
    const encodedPayload = type.encode(message).finish();
    const requestId = this.nextRequestId();
    const fullMessage = this.buildMessage(
      WebSocketRequestOpcode.HANDSHAKE,
      requestId,
      encodedPayload
    );
    const responseData = await this.sendRequest(
      requestId,
      fullMessage,
      this.config.handshakeTimeout
    );
    const responseType = this.getType("HandshakeResponse");
    const decoded = responseType.decode(responseData);
    const response = responseType.toObject(decoded, {
      longs: String,
      bytes: Uint8Array,
      defaults: true
    });
    const sessionIdFieldName = this.getFieldNameById(responseType, 2);
    if (sessionIdFieldName && response[sessionIdFieldName]) {
      this.sessionId = response[sessionIdFieldName];
    }
    this.state = ConnectionState.READY;
  }
  /**
   * Build a message object using proto field IDs instead of hardcoded field names.
   * This ensures we use whatever field names the server's proto schema defines.
   * Handles nested messages recursively.
   */
  buildMessageByFieldId(type, valuesByFieldId) {
    const result = {};
    for (const [fieldIdStr, value] of Object.entries(valuesByFieldId)) {
      const fieldId = parseInt(fieldIdStr, 10);
      const field = this.getFieldById(type, fieldId);
      if (field) {
        if (value !== null && typeof value === "object" && !Array.isArray(value) && !(value instanceof Long)) {
          const keys = Object.keys(value);
          const isFieldIdMap = keys.length > 0 && keys.every((k) => /^\d+$/.test(k));
          if (isFieldIdMap) {
            const nestedType = this.getNestedType(field.type);
            if (nestedType) {
              result[field.name] = this.buildMessageByFieldId(
                nestedType,
                value
              );
            } else {
              result[field.name] = value;
            }
          } else {
            result[field.name] = value;
          }
        } else {
          result[field.name] = value;
        }
      }
    }
    return result;
  }
  /**
   * Get field from proto Type by field ID number
   */
  getFieldById(type, fieldId) {
    for (const field of type.fieldsArray) {
      if (field.id === fieldId) {
        return { name: field.name, type: field.type };
      }
    }
    return void 0;
  }
  /**
   * Get field name from proto Type by field ID number
   */
  getFieldNameById(type, fieldId) {
    const field = this.getFieldById(type, fieldId);
    return field?.name;
  }
  /**
   * Get nested message Type by type name
   */
  getNestedType(typeName) {
    if (!this.protoRoot) return void 0;
    try {
      return getProtobufType(this.protoRoot, typeName);
    } catch {
      return void 0;
    }
  }
  getType(typeName) {
    let type = this.protoTypes.get(typeName);
    if (!type) {
      if (!this.protoRoot) {
        throw new Error("Protobuf schema not loaded");
      }
      type = getProtobufType(this.protoRoot, typeName);
      this.protoTypes.set(typeName, type);
    }
    return type;
  }
  nextRequestId() {
    this.requestId = this.requestId + 1 & 4294967295;
    return this.requestId;
  }
  buildMessage(opcode, requestId, payload) {
    const message = new Uint8Array(1 + 4 + payload.length);
    message[0] = opcode;
    message[1] = requestId & 255;
    message[2] = requestId >> 8 & 255;
    message[3] = requestId >> 16 & 255;
    message[4] = requestId >> 24 & 255;
    message.set(payload, 5);
    return message;
  }
  sendRequest(requestId, message, timeout = this.config.requestTimeout) {
    return new Promise((resolve, reject) => {
      if (this.pendingRequests.size >= this.config.maxPendingRequests) {
        reject(new Error("Too many pending requests"));
        return;
      }
      const timeoutHandle = setTimeout(() => {
        this.pendingRequests.delete(requestId);
        reject(new Error(`Request timeout after ${timeout}ms`));
      }, timeout);
      this.pendingRequests.set(requestId, {
        resolve,
        reject,
        timeout: timeoutHandle
      });
      this.send(message);
    });
  }
  send(data) {
    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {
      throw new Error("WebSocket not connected");
    }
    this.socket.send(data);
  }
  handleMessage(data) {
    const buffer = new Uint8Array(data);
    if (buffer.length < 5) {
      console.error("Invalid message: too short");
      return;
    }
    const opcode = buffer[0];
    if (opcode === WebSocketResponseOpcode.NEW_BLOCK_NOTIFICATION) {
      this.handleBlockNotification(buffer.slice(1));
      return;
    }
    if (opcode === WebSocketResponseOpcode.NEW_EPOCH_NOTIFICATION) {
      this.handleEpochNotification(buffer.slice(1));
      return;
    }
    const requestId = buffer[1] | buffer[2] << 8 | buffer[3] << 16 | buffer[4] << 24;
    const payload = buffer.slice(5);
    if (opcode === WebSocketResponseOpcode.ERROR) {
      this.handleErrorResponse(requestId, payload);
      return;
    }
    const pending = this.pendingRequests.get(requestId);
    if (pending) {
      clearTimeout(pending.timeout);
      this.pendingRequests.delete(requestId);
      pending.resolve(payload);
    }
  }
  handleErrorResponse(requestId, payload) {
    const pending = this.pendingRequests.get(requestId);
    if (!pending) return;
    clearTimeout(pending.timeout);
    this.pendingRequests.delete(requestId);
    try {
      const type = this.getType("ErrorResponse");
      const decoded = type.decode(payload);
      const error = type.toObject(decoded, {
        longs: Number,
        bytes: Uint8Array,
        defaults: true
      });
      pending.reject(
        new OPNetError(
          error.code ?? InternalError.INTERNAL_ERROR,
          error.message,
          error.data
        )
      );
    } catch (e) {
      pending.reject(new Error("Failed to parse error response"));
    }
  }
  handleBlockNotification(payload) {
    const handler = this.subscriptions.get(SubscriptionType.BLOCKS);
    if (!handler) return;
    try {
      const type = this.getType("BlockNotification");
      const decoded = type.decode(payload);
      const block = type.toObject(decoded, {
        longs: String,
        defaults: true
      });
      const notification = {
        blockNumber: BigInt(block.block_number || "0"),
        blockHash: block.block_hash || "",
        previousBlockHash: block.previous_block_hash || "",
        timestamp: BigInt(block.timestamp || "0")
      };
      handler(notification);
      this.emit(WebSocketClientEvent.BLOCK, notification);
    } catch (e) {
      console.error("Failed to parse block notification:", e);
    }
  }
  handleEpochNotification(payload) {
    const handler = this.subscriptions.get(SubscriptionType.EPOCHS);
    if (!handler) return;
    try {
      const type = this.getType("EpochNotification");
      const decoded = type.decode(payload);
      const epoch = type.toObject(decoded, {
        longs: String,
        defaults: true
      });
      const notification = {
        epochNumber: BigInt(epoch.epoch_number || "0"),
        epochHash: epoch.epoch_hash || "",
        timestamp: BigInt(epoch.timestamp || "0")
      };
      handler(notification);
      this.emit(WebSocketClientEvent.EPOCH, notification);
    } catch (e) {
      console.error("Failed to parse epoch notification:", e);
    }
  }
  handleClose(event) {
    const wasReady = this.state === ConnectionState.READY;
    this.state = ConnectionState.DISCONNECTED;
    this.cancelPing();
    if (wasReady && this.config.autoReconnect && !this.userRequestedDisconnect) {
      void this.reconnect();
    } else {
      this.cleanupPendingRequests(
        new Error(`Connection closed: ${event.code} ${event.reason}`)
      );
      this.emit(WebSocketClientEvent.DISCONNECTED, {
        code: event.code,
        reason: event.reason
      });
    }
  }
  async reconnect() {
    if (this.reconnectAttempt >= this.config.maxReconnectAttempts) {
      this.emit(WebSocketClientEvent.ERROR, new Error("Max reconnection attempts exceeded"));
      return;
    }
    this.state = ConnectionState.RECONNECTING;
    this.reconnectAttempt++;
    this.clearCache();
    const delay = Math.min(
      this.config.reconnectBaseDelay * Math.pow(2, this.reconnectAttempt - 1),
      this.config.reconnectMaxDelay
    );
    const jitter = Math.random() * 0.3 * delay;
    await this.sleep(delay + jitter);
    try {
      this.state = ConnectionState.DISCONNECTED;
      await this.connect();
      await this.resubscribe();
    } catch (e) {
      console.warn(`Reconnect attempt ${this.reconnectAttempt} failed:`, e);
      void this.reconnect();
    }
  }
  async resubscribe() {
    const handlers = new Map(this.subscriptions);
    this.subscriptions.clear();
    for (const [type, handler] of handlers) {
      try {
        if (type === SubscriptionType.BLOCKS) {
          await this.subscribeBlocks(handler);
        } else if (type === SubscriptionType.EPOCHS) {
          await this.subscribeEpochs(handler);
        }
      } catch (e) {
        console.error(`Failed to resubscribe to ${type}:`, e);
      }
    }
  }
  cleanupPendingRequests(error) {
    for (const [_id, pending] of this.pendingRequests) {
      clearTimeout(pending.timeout);
      pending.reject(error);
    }
    this.pendingRequests.clear();
  }
  schedulePing() {
    this.cancelPing();
    this.pingTimeout = setTimeout(() => {
      if (this.state === ConnectionState.READY) {
        try {
          this.ping();
        } catch (e) {
          console.warn("Ping failed:", e);
        }
        this.schedulePing();
      }
    }, this.config.pingInterval);
  }
  cancelPing() {
    if (this.pingTimeout) {
      clearTimeout(this.pingTimeout);
      this.pingTimeout = null;
    }
  }
  ping() {
    const type = this.getType("PingRequest");
    const message = type.create({ timestamp: Long.fromNumber(Date.now()) });
    const encodedPayload = type.encode(message).finish();
    const requestId = this.nextRequestId();
    const fullMessage = this.buildMessage(
      WebSocketRequestOpcode.PING,
      requestId,
      encodedPayload
    );
    this.send(fullMessage);
  }
  emit(event, data) {
    const handlers = this.eventHandlers.get(event);
    if (handlers) {
      for (const handler of handlers) {
        try {
          handler(data);
        } catch (e) {
          console.error(`Error in event handler for ${event}:`, e);
        }
      }
    }
  }
  sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
}

var SubmissionStatus = /* @__PURE__ */ ((SubmissionStatus2) => {
  SubmissionStatus2["ACCEPTED"] = "accepted";
  SubmissionStatus2["REJECTED"] = "rejected";
  return SubmissionStatus2;
})(SubmissionStatus || {});

class EpochDifficultyConverter {
  /**
   * Convert matching bits to actual difficulty value
   * Difficulty = 2^bits
   *
   * This ensures that:
   * - 20 bits = difficulty of 1,048,576
   * - 30 bits = difficulty of 1,073,741,824
   * - 40 bits = difficulty of 1,099,511,627,776
   *
   * So a 40-bit share is worth 1,048,576x more than a 20-bit share,
   * not just 2x more
   */
  static bitsToScaledDifficulty(bits) {
    return 2n ** BigInt(Math.max(0, bits));
  }
  /**
   * Format difficulty for display
   */
  static formatDifficulty(difficulty) {
    if (difficulty < 1000n) {
      return difficulty.toString();
    } else if (difficulty < BigInt(1e6)) {
      return (difficulty / BigInt(1e3)).toString() + "K";
    } else if (difficulty < BigInt(1e9)) {
      return (difficulty / BigInt(1e6)).toString() + "M";
    } else if (difficulty < BigInt(1e12)) {
      return (difficulty / BigInt(1e9)).toString() + "G";
    } else if (difficulty < BigInt(1e15)) {
      return (difficulty / BigInt(1e12)).toString() + "T";
    } else {
      return (difficulty / BigInt(1e15)).toString() + "P";
    }
  }
}

var BitcoinAbiTypes = /* @__PURE__ */ ((BitcoinAbiTypes2) => {
  BitcoinAbiTypes2["Function"] = "function";
  BitcoinAbiTypes2["Event"] = "event";
  return BitcoinAbiTypes2;
})(BitcoinAbiTypes || {});

class BitcoinInterface {
  abi;
  constructor(abi) {
    this.verifyAbi(abi);
    this.abi = abi;
  }
  static from(abi) {
    if (abi instanceof BitcoinInterface) {
      return abi;
    }
    return new BitcoinInterface(abi);
  }
  hasFunction(name) {
    return this.abi.some(
      (element) => element.name === name && element.type === BitcoinAbiTypes.Function
    );
  }
  hasEvent(name) {
    return this.abi.some(
      (element) => element.name === name && element.type === BitcoinAbiTypes.Event
    );
  }
  verifyAbi(abi) {
    if (abi.length === 0) {
      throw new Error("The ABI provided is empty.");
    }
    for (let i = 0; i < abi.length; i++) {
      const element = abi[i];
      if (!element.name) {
        throw new Error("The ABI provided is missing a name.");
      }
      if (!element.type) {
        throw new Error("The ABI provided is missing a type.");
      }
      if (element.type === BitcoinAbiTypes.Function) {
        if (element.inputs && element.inputs?.length) this.verifyAbiValues(element.inputs);
        if (element.outputs && element.outputs?.length) {
          this.verifyAbiValues(element.outputs);
        }
      } else if (element.type === BitcoinAbiTypes.Event) {
        if (element.values && element.values?.length) this.verifyAbiValues(element.values);
      }
    }
  }
  verifyAbiValues(inputs) {
    for (let j = 0; j < inputs.length; j++) {
      const input = inputs[j];
      if (!input.name) {
        throw new Error("The ABI provided is missing an input name.");
      }
      if (!input.type) {
        throw new Error("The ABI provided is missing an input type.");
      }
    }
  }
}

class OPNetEvent extends NetEvent {
  constructor(type, data) {
    super(type, data);
    this.type = type;
    this.data = data;
  }
  properties = {};
  values = [];
  setDecoded(decoded) {
    this.properties = Object.freeze(decoded.obj);
    this.values.push(...decoded.values);
  }
}

const AbiTypeToStr = {
  [ABIDataTypes.ADDRESS]: "address",
  [ABIDataTypes.BOOL]: "bool",
  [ABIDataTypes.BYTES]: "bytes",
  [ABIDataTypes.UINT256]: "uint256",
  [ABIDataTypes.UINT128]: "uint128",
  [ABIDataTypes.UINT64]: "uint64",
  [ABIDataTypes.INT128]: "int128",
  [ABIDataTypes.UINT32]: "uint32",
  [ABIDataTypes.UINT16]: "uint16",
  [ABIDataTypes.UINT8]: "uint8",
  [ABIDataTypes.STRING]: "string",
  [ABIDataTypes.BYTES32]: "bytes32",
  [ABIDataTypes.BYTES4]: "bytes4",
  [ABIDataTypes.ADDRESS_UINT256_TUPLE]: "tuple(address,uint256)[]",
  [ABIDataTypes.ARRAY_OF_ADDRESSES]: "address[]",
  [ABIDataTypes.ARRAY_OF_UINT256]: "uint256[]",
  [ABIDataTypes.ARRAY_OF_UINT128]: "uint128[]",
  [ABIDataTypes.ARRAY_OF_UINT64]: "uint64[]",
  [ABIDataTypes.ARRAY_OF_UINT32]: "uint32[]",
  [ABIDataTypes.ARRAY_OF_UINT16]: "uint16[]",
  [ABIDataTypes.ARRAY_OF_UINT8]: "uint8[]",
  [ABIDataTypes.ARRAY_OF_BYTES]: "bytes[]",
  [ABIDataTypes.ARRAY_OF_STRING]: "string[]",
  [ABIDataTypes.ARRAY_OF_BUFFERS]: "buffer[]"
};

const internal = /* @__PURE__ */ Symbol.for("_btc_internal");
const bitcoinAbiCoder = new ABICoder();
class IBaseContract {
  /**
   * The address of the contract.
   */
  address;
  /**
   * The address of the contract.
   */
  network;
  /**
   * The interface of the contract.
   */
  interface;
  /**
   * A generic provider for the contract.
   */
  provider;
  /**
   * Who is sending the transaction.
   */
  from;
  /**
   * The internal functions of the contract.
   * @protected
   */
  [internal];
  events = /* @__PURE__ */ new Map();
  gasParameters;
  fetchGasParametersAfter = 1e3 * 10;
  currentTxDetails;
  simulatedHeight = void 0;
  accessList;
  _rlAddress;
  constructor(address, abi, provider, network, from) {
    if (typeof address === "string") {
      const type = AddressVerificator.detectAddressType(address, network);
      if (type !== AddressTypes.P2OP && type !== AddressTypes.P2PK) {
        throw new Error(
          `Oops! The address provided is not a valid P2OP or P2PK address ${address}.`
        );
      }
    }
    this.address = address;
    this.provider = provider;
    this.interface = BitcoinInterface.from(abi);
    this.network = network;
    this.from = from;
    Object.defineProperty(this, internal, { value: {} });
    this.defineInternalFunctions();
  }
  /**
   * The P2OP address of the contract.
   * @returns {string} The P2OP address of the contract.
   */
  get p2op() {
    if (typeof this.address !== "string") {
      return this.address.p2op(this.network);
    }
    return this.address;
  }
  /**
   * Gets the contract address as an Address object.
   * @return {Promise<Address>} The contract address as an Address object.
   */
  get contractAddress() {
    if (typeof this.address === "string") {
      if (!this._rlAddress) {
        this._rlAddress = this.provider.getPublicKeyInfo(this.address, true);
      }
      return this._rlAddress;
    }
    return Promise.resolve(this.address);
  }
  /**
   * Sets the sender of the transaction.
   * @param {Address} sender The sender of the transaction.
   */
  setSender(sender) {
    this.from = sender;
  }
  /**
   * Decodes the events from the contract.
   * @param {NetEvent[] | ContractEvents} events The events to decode.
   * @returns {OPNetEvent[]} The decoded events.
   */
  decodeEvents(events) {
    const decodedEvents = [];
    if (!Array.isArray(events)) {
      const tempEvents = events;
      events = tempEvents[this.p2op];
      if (!Array.isArray(events) && typeof this.address === "string" && this.address.startsWith("0x")) {
        const addy = Address.fromString(this.address);
        const p2op = addy.p2op(this.network);
        events = tempEvents[p2op];
      }
      if (!Array.isArray(events)) {
        return [];
      }
    }
    for (const event of events) {
      decodedEvents.push(this.decodeEvent(event));
    }
    return decodedEvents;
  }
  /**
   * Decodes a single event.
   * @param {NetEvent} event The event to decode.
   * @returns {OPNetEvent} The decoded event.
   */
  decodeEvent(event) {
    const eventData = this.events.get(event.type);
    if (!eventData || eventData.values.length === 0) {
      return new OPNetEvent(event.type, event.data);
    }
    const binaryReader = new BinaryReader(event.data);
    const out = this.decodeOutput(eventData.values, binaryReader);
    const decodedEvent = new OPNetEvent(event.type, event.data);
    decodedEvent.setDecoded(out);
    return decodedEvent;
  }
  /**
   * Encodes the calldata for a function.
   * @param {string} functionName The name of the function.
   * @param {unknown[]} args The arguments for the function.
   * @returns {Buffer} The encoded calldata.
   */
  encodeCalldata(functionName, args) {
    for (const element of this.interface.abi) {
      if (element.name === functionName) {
        const data = this.encodeFunctionData(element, args);
        return Buffer.from(data.getBuffer().buffer);
      }
    }
    throw new Error(`Function not found: ${functionName}`);
  }
  async currentGasParameters() {
    if (this.gasParameters && this.gasParameters.cachedAt + this.fetchGasParametersAfter > Date.now()) {
      return this.gasParameters.params;
    }
    this.gasParameters = {
      cachedAt: Date.now(),
      params: this.provider.gasParameters()
    };
    return await this.gasParameters.params;
  }
  setTransactionDetails(tx) {
    for (let i = 0; i < tx.outputs.length; i++) {
      const input = tx.outputs[i];
      if (input.index === 0) {
        throw new Error(`Outputs 0 is reserved for the contract internal use.`);
      }
    }
    this.currentTxDetails = tx;
  }
  setAccessList(accessList) {
    this.accessList = accessList;
  }
  setSimulatedHeight(height) {
    this.simulatedHeight = height;
  }
  getFunction(name) {
    const key = name;
    return this[key];
  }
  /**
   * Defines the internal functions of the contract. These functions are generated for the ABI provided.
   * @private
   */
  defineInternalFunctions() {
    for (const element of this.interface.abi) {
      switch (element.type) {
        case BitcoinAbiTypes.Function: {
          if (this.getFunction(element.name)) {
            continue;
          }
          Object.defineProperty(this, element.name, {
            value: this.callFunction(element).bind(this)
          });
          break;
        }
        case BitcoinAbiTypes.Event: {
          if (this.events.has(element.name)) {
            throw new Error(`Duplicate event found in the ABI: ${element.name}.`);
          }
          this.events.set(element.name, element);
          break;
        }
        default:
          throw new Error(`Unsupported type.`);
      }
    }
  }
  getSelector(element) {
    let name = element.name;
    name += "(";
    if (element.inputs && element.inputs.length) {
      for (let i = 0; i < element.inputs.length; i++) {
        const input = element.inputs[i];
        const str = AbiTypeToStr[input.type];
        if (!str) {
          throw new Error(`Unsupported type: ${input.type}`);
        }
        if (i > 0) {
          name += ",";
        }
        name += str;
      }
    }
    name += ")";
    return name;
  }
  encodeFunctionData(element, args) {
    const writer = new BinaryWriter();
    const selectorStr = this.getSelector(element);
    let str = bitcoinAbiCoder.encodeSelector(selectorStr);
    if (str.includes(",")) {
      const array = str.split(",").map((s) => Number(s));
      const buffer = Buffer.from(array);
      str = buffer.toString("hex");
    }
    const selector = Number("0x" + str);
    writer.writeSelector(selector);
    if (args.length !== (element.inputs?.length ?? 0)) {
      throw new Error("Invalid number of arguments provided");
    }
    if (!element.inputs || element.inputs && element.inputs.length === 0) {
      return writer;
    }
    for (let i = 0; i < element.inputs.length; i++) {
      this.encodeInput(writer, element.inputs[i], args[i]);
    }
    return writer;
  }
  encodeInput(writer, abi, value) {
    const type = abi.type;
    const name = abi.name;
    switch (type) {
      case ABIDataTypes.INT128: {
        if (typeof value !== "bigint") {
          throw new Error(`Expected value to be of type bigint (${name})`);
        }
        writer.writeI128(value);
        break;
      }
      case ABIDataTypes.UINT256: {
        if (typeof value !== "bigint") {
          throw new Error(`Expected value to be of type bigint (${name})`);
        }
        writer.writeU256(value);
        break;
      }
      case ABIDataTypes.BOOL: {
        if (typeof value !== "boolean") {
          throw new Error(`Expected value to be of type boolean (${name})`);
        }
        writer.writeBoolean(value);
        break;
      }
      case ABIDataTypes.STRING: {
        if (typeof value !== "string") {
          throw new Error(`Expected value to be of type string (${name})`);
        }
        writer.writeStringWithLength(value);
        break;
      }
      case ABIDataTypes.ADDRESS: {
        if (!value) throw new Error(`Expected value to be of type Address (${name})`);
        if (!("equals" in value)) {
          throw new Error(
            `Expected value to be of type Address (${name}) was ${typeof value}`
          );
        }
        writer.writeAddress(value);
        break;
      }
      case ABIDataTypes.UINT8: {
        if (typeof value !== "number") {
          throw new Error(`Expected value to be of type number (${name})`);
        }
        writer.writeU8(value);
        break;
      }
      case ABIDataTypes.UINT16: {
        if (typeof value !== "number") {
          throw new Error(`Expected value to be of type number (${name})`);
        }
        writer.writeU16(value);
        break;
      }
      case ABIDataTypes.UINT32: {
        if (typeof value !== "number") {
          throw new Error(`Expected value to be of type number (${name})`);
        }
        writer.writeU32(value);
        break;
      }
      case ABIDataTypes.BYTES32: {
        if (!(value instanceof Uint8Array)) {
          throw new Error(`Expected value to be of type Uint8Array (${name})`);
        }
        writer.writeBytes(value);
        break;
      }
      case ABIDataTypes.BYTES4: {
        if (!(value instanceof Uint8Array)) {
          throw new Error(`Expected value to be of type Uint8Array (${name})`);
        }
        writer.writeBytes(value);
        break;
      }
      case ABIDataTypes.ADDRESS_UINT256_TUPLE: {
        writer.writeAddressValueTuple(value);
        break;
      }
      case ABIDataTypes.BYTES: {
        if (!(value instanceof Uint8Array)) {
          throw new Error(`Expected value to be of type Uint8Array (${name})`);
        }
        writer.writeBytesWithLength(value);
        break;
      }
      case ABIDataTypes.UINT64: {
        if (typeof value !== "bigint") {
          throw new Error(`Expected value to be of type bigint (${name})`);
        }
        writer.writeU64(value);
        break;
      }
      case ABIDataTypes.ARRAY_OF_ADDRESSES: {
        if (!(value instanceof Array)) {
          throw new Error(`Expected value to be of type Array (${name})`);
        }
        writer.writeAddressArray(value);
        break;
      }
      case ABIDataTypes.ARRAY_OF_UINT256: {
        if (!(value instanceof Array)) {
          throw new Error(`Expected value to be of type Array (${name})`);
        }
        writer.writeU256Array(value);
        break;
      }
      case ABIDataTypes.ARRAY_OF_UINT32: {
        if (!(value instanceof Array)) {
          throw new Error(`Expected value to be of type Array (${name})`);
        }
        writer.writeU32Array(value);
        break;
      }
      case ABIDataTypes.ARRAY_OF_STRING: {
        if (!(value instanceof Array)) {
          throw new Error(`Expected value to be of type Array (${name})`);
        }
        writer.writeStringArray(value);
        break;
      }
      case ABIDataTypes.ARRAY_OF_BYTES: {
        if (!(value instanceof Array)) {
          throw new Error(`Expected value to be of type Array (${name})`);
        }
        writer.writeBytesArray(value);
        break;
      }
      case ABIDataTypes.ARRAY_OF_UINT64: {
        if (!(value instanceof Array)) {
          throw new Error(`Expected value to be of type Array (${name})`);
        }
        writer.writeU64Array(value);
        break;
      }
      case ABIDataTypes.ARRAY_OF_UINT8: {
        if (!(value instanceof Array)) {
          throw new Error(`Expected value to be of type Array (${name})`);
        }
        writer.writeU8Array(value);
        break;
      }
      case ABIDataTypes.ARRAY_OF_UINT16: {
        if (!(value instanceof Array)) {
          throw new Error(`Expected value to be of type Array (${name})`);
        }
        writer.writeU16Array(value);
        break;
      }
      case ABIDataTypes.UINT128: {
        if (typeof value !== "bigint") {
          throw new Error(`Expected value to be of type bigint (${name})`);
        }
        writer.writeU128(value);
        break;
      }
      case ABIDataTypes.ARRAY_OF_UINT128: {
        if (!(value instanceof Array)) {
          throw new Error(`Expected value to be of type Array (${name})`);
        }
        writer.writeU128Array(value);
        break;
      }
      case ABIDataTypes.ARRAY_OF_BUFFERS: {
        if (!(value instanceof Array)) {
          throw new Error(`Expected value to be of type Array (${name})`);
        }
        writer.writeArrayOfBuffer(value);
        break;
      }
      default: {
        throw new Error(`Unsupported type: ${type} (${name})`);
      }
    }
  }
  decodeOutput(abi, reader) {
    const result = [];
    const obj = {};
    for (let i = 0; i < abi.length; i++) {
      const type = abi[i].type;
      const name = abi[i].name;
      let decodedResult;
      switch (type) {
        case ABIDataTypes.INT128:
          decodedResult = reader.readI128();
          break;
        case ABIDataTypes.UINT256:
          decodedResult = reader.readU256();
          break;
        case ABIDataTypes.BOOL:
          decodedResult = reader.readBoolean();
          break;
        case ABIDataTypes.STRING:
          decodedResult = reader.readStringWithLength();
          break;
        case ABIDataTypes.ADDRESS:
          decodedResult = reader.readAddress();
          break;
        case ABIDataTypes.UINT8:
          decodedResult = reader.readU8();
          break;
        case ABIDataTypes.UINT16:
          decodedResult = reader.readU16();
          break;
        case ABIDataTypes.UINT32:
          decodedResult = reader.readU32();
          break;
        case ABIDataTypes.BYTES32:
          decodedResult = reader.readBytes(32);
          break;
        case ABIDataTypes.BYTES4:
          decodedResult = reader.readBytes(4);
          break;
        case ABIDataTypes.ADDRESS_UINT256_TUPLE:
          decodedResult = reader.readAddressValueTuple();
          break;
        case ABIDataTypes.BYTES: {
          decodedResult = reader.readBytesWithLength();
          break;
        }
        case ABIDataTypes.UINT64: {
          decodedResult = reader.readU64();
          break;
        }
        case ABIDataTypes.ARRAY_OF_ADDRESSES: {
          decodedResult = reader.readAddressArray();
          break;
        }
        case ABIDataTypes.ARRAY_OF_UINT256: {
          decodedResult = reader.readU256Array();
          break;
        }
        case ABIDataTypes.ARRAY_OF_UINT32: {
          decodedResult = reader.readU32Array();
          break;
        }
        case ABIDataTypes.ARRAY_OF_STRING: {
          decodedResult = reader.readStringArray();
          break;
        }
        case ABIDataTypes.ARRAY_OF_BYTES: {
          decodedResult = reader.readBytesArray();
          break;
        }
        case ABIDataTypes.ARRAY_OF_UINT64: {
          decodedResult = reader.readU64Array();
          break;
        }
        case ABIDataTypes.ARRAY_OF_UINT8: {
          decodedResult = reader.readU8Array();
          break;
        }
        case ABIDataTypes.ARRAY_OF_UINT16: {
          decodedResult = reader.readU16Array();
          break;
        }
        case ABIDataTypes.UINT128: {
          decodedResult = reader.readU128();
          break;
        }
        case ABIDataTypes.ARRAY_OF_UINT128: {
          decodedResult = reader.readU128Array();
          break;
        }
        case ABIDataTypes.ARRAY_OF_BUFFERS: {
          decodedResult = reader.readArrayOfBuffer();
          break;
        }
        default: {
          throw new Error(`Unsupported type: ${type} (${name})`);
        }
      }
      result.push(decodedResult);
      obj[name] = decodedResult;
    }
    return {
      values: result,
      obj
    };
  }
  estimateGas(gas, gasParameters) {
    const gasPerSat = gasParameters.gasPerSat;
    const exactGas = gas * gasPerSat / 1000000000000n;
    const finalGas = exactGas * 100n / (100n - 30n);
    return this.max(finalGas, 297n);
  }
  max(a, b) {
    return a > b ? a : b;
  }
  callFunction(element) {
    return async (...args) => {
      const address = await this.contractAddress;
      const txDetails = this.currentTxDetails;
      const accessList = this.accessList;
      this.currentTxDetails = void 0;
      this.accessList = void 0;
      const data = this.encodeFunctionData(element, args);
      const original = data.getBuffer().buffer;
      const buffer = Buffer.from(original);
      const response = await this.provider.call(
        this.address,
        buffer,
        this.from,
        this.simulatedHeight,
        txDetails,
        accessList
      );
      if ("error" in response) {
        throw new Error(`Error in calling function: ${response.error}`);
      }
      if (response.revert) {
        throw new Error(`Execution Reverted: ${response.revert}`);
      }
      const decoded = element.outputs ? this.decodeOutput(element.outputs, response.result) : { values: [], obj: {} };
      response.setTo(this.p2op, address);
      response.setFromAddress(this.from);
      response.setDecoded(decoded);
      response.setCalldata(buffer);
      const gasParameters = await this.currentGasParameters();
      const gas = this.estimateGas(response.estimatedGas || 0n, gasParameters);
      const gasRefunded = this.estimateGas(response.refundedGas || 0n, gasParameters);
      response.setBitcoinFee(gasParameters.bitcoin);
      response.setGasEstimation(gas, gasRefunded);
      response.setEvents(this.decodeEvents(response.rawEvents));
      return response;
    };
  }
}
class BaseContract extends IBaseContract {
  constructor(address, abi, provider, network, sender) {
    super(address, abi, provider, network, sender);
    return this.proxify();
  }
  /**
   * Proxifies the contract to allow for type checking.
   * @private
   */
  proxify() {
    return new Proxy(this, {
      get: (target, prop, receiver) => {
        if (typeof prop === "symbol" || prop in target) {
          return Reflect.get(target, prop, receiver);
        }
        try {
          return this.getFunction(prop);
        } catch (error) {
          if (!(error instanceof Error)) {
            throw new Error(
              `Something went wrong when trying to get the function: ${error}`
            );
          } else {
            throw error;
          }
        }
      },
      has: (target, prop) => {
        if (typeof prop === "symbol" || prop in target) {
          return Reflect.has(target, prop);
        }
        return target.interface.hasFunction(prop);
      }
    });
  }
}
function contractBase() {
  return BaseContract;
}
function getContract(address, abi, provider, network, sender) {
  const base = contractBase();
  return new base(address, abi, provider, network, sender);
}

BigNumber.config({
  EXPONENTIAL_AT: 1e9,
  DECIMAL_PLACES: 18
});
class BitcoinUtils {
  /**
   * Get Satoshis or any other unit, bitcoin by default.
   * @description This function is used to format a value in satoshis to Bitcoin.
   * @param value Value in satoshis or any other unit
   * @param decimals Default is 8
   */
  static formatUnits(value, decimals = 8) {
    const bn = new BigNumber(value.toString());
    return bn.dividedBy(new BigNumber(10).pow(decimals)).toString();
  }
  /**
   * Convert number or string to BigInt
   * @param {number | string} n
   * @param {number | string} decimals
   * @returns {bigint}
   */
  static expandToDecimals(n, decimals) {
    const amount = new BigNumber(n).multipliedBy(new BigNumber(10).pow(decimals)).decimalPlaces(0);
    return BigInt(amount.toString());
  }
}

var JSONRPCErrorCode = /* @__PURE__ */ ((JSONRPCErrorCode2) => {
  JSONRPCErrorCode2[JSONRPCErrorCode2["PARSE_ERROR"] = -32700] = "PARSE_ERROR";
  JSONRPCErrorCode2[JSONRPCErrorCode2["INVALID_REQUEST"] = -32600] = "INVALID_REQUEST";
  JSONRPCErrorCode2[JSONRPCErrorCode2["METHOD_NOT_FOUND"] = -32601] = "METHOD_NOT_FOUND";
  JSONRPCErrorCode2[JSONRPCErrorCode2["INVALID_PARAMS"] = -32602] = "INVALID_PARAMS";
  JSONRPCErrorCode2[JSONRPCErrorCode2["INTERNAL_ERROR"] = -32603] = "INTERNAL_ERROR";
  JSONRPCErrorCode2[JSONRPCErrorCode2["SERVER_ERROR"] = -32e3] = "SERVER_ERROR";
  JSONRPCErrorCode2[JSONRPCErrorCode2["APPLICATION_ERROR"] = -32099] = "APPLICATION_ERROR";
  JSONRPCErrorCode2[JSONRPCErrorCode2["SYSTEM_ERROR"] = -32098] = "SYSTEM_ERROR";
  JSONRPCErrorCode2[JSONRPCErrorCode2["TRANSPORT_ERROR"] = -32097] = "TRANSPORT_ERROR";
  JSONRPCErrorCode2[JSONRPCErrorCode2["GENERIC_ERROR"] = -32096] = "GENERIC_ERROR";
  return JSONRPCErrorCode2;
})(JSONRPCErrorCode || {});
var JSONRPCErrorHttpCodes = /* @__PURE__ */ ((JSONRPCErrorHttpCodes2) => {
  JSONRPCErrorHttpCodes2[JSONRPCErrorHttpCodes2["PARSE_ERROR"] = 500] = "PARSE_ERROR";
  JSONRPCErrorHttpCodes2[JSONRPCErrorHttpCodes2["INVALID_REQUEST"] = 400] = "INVALID_REQUEST";
  JSONRPCErrorHttpCodes2[JSONRPCErrorHttpCodes2["METHOD_NOT_FOUND"] = 404] = "METHOD_NOT_FOUND";
  JSONRPCErrorHttpCodes2[JSONRPCErrorHttpCodes2["INVALID_PARAMS"] = 400] = "INVALID_PARAMS";
  JSONRPCErrorHttpCodes2[JSONRPCErrorHttpCodes2["INTERNAL_ERROR"] = 500] = "INTERNAL_ERROR";
  JSONRPCErrorHttpCodes2[JSONRPCErrorHttpCodes2["SERVER_ERROR"] = 500] = "SERVER_ERROR";
  JSONRPCErrorHttpCodes2[JSONRPCErrorHttpCodes2["APPLICATION_ERROR"] = 500] = "APPLICATION_ERROR";
  JSONRPCErrorHttpCodes2[JSONRPCErrorHttpCodes2["SYSTEM_ERROR"] = 500] = "SYSTEM_ERROR";
  JSONRPCErrorHttpCodes2[JSONRPCErrorHttpCodes2["TRANSPORT_ERROR"] = 500] = "TRANSPORT_ERROR";
  JSONRPCErrorHttpCodes2[JSONRPCErrorHttpCodes2["GENERIC_ERROR"] = 500] = "GENERIC_ERROR";
  return JSONRPCErrorHttpCodes2;
})(JSONRPCErrorHttpCodes || {});

const StackingEvents = [
  {
    name: "Stake",
    values: [
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "Unstake",
    values: [
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "Claim",
    values: [
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Event
  }
];
const STAKING_ABI = [
  {
    name: "stake",
    inputs: [
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "unstake",
    inputs: [],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "stakedAmount",
    inputs: [
      {
        name: "address",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: [
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "stakedReward",
    inputs: [
      {
        name: "address",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: [
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "claim",
    inputs: [],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "rewardPool",
    inputs: [],
    outputs: [
      {
        name: "reward",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "totalStaked",
    inputs: [],
    outputs: [
      {
        name: "total",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  // EVENTS
  ...StackingEvents
];

const OP_NET_ABI = [
  {
    name: "address",
    type: BitcoinAbiTypes.Function,
    inputs: [],
    outputs: [
      {
        name: "address",
        type: ABIDataTypes.ADDRESS
      }
    ]
  },
  {
    name: "deployer",
    type: BitcoinAbiTypes.Function,
    inputs: [],
    outputs: [
      {
        name: "deployer",
        type: ABIDataTypes.ADDRESS
      }
    ]
  }
];

const OP20Events = [
  {
    name: "Transferred",
    values: [
      {
        name: "operator",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "from",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "Approved",
    values: [
      {
        name: "owner",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "spender",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "Burned",
    values: [
      { name: "from", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 }
    ],
    type: BitcoinAbiTypes.Event
  }
];
const OP_20_ABI = [
  // Properties
  {
    name: "name",
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "name",
        type: ABIDataTypes.STRING
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "symbol",
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "symbol",
        type: ABIDataTypes.STRING
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "icon",
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "icon",
        type: ABIDataTypes.STRING
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "decimals",
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "decimals",
        type: ABIDataTypes.UINT8
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "totalSupply",
    inputs: [],
    outputs: [
      {
        name: "totalSupply",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "maximumSupply",
    inputs: [],
    outputs: [
      {
        name: "maximumSupply",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "domainSeparator",
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "domainSeparator",
        type: ABIDataTypes.BYTES32
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "balanceOf",
    inputs: [
      {
        name: "owner",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: [
      {
        name: "balance",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "nonceOf",
    constant: true,
    inputs: [{ name: "owner", type: ABIDataTypes.ADDRESS }],
    outputs: [
      {
        name: "nonce",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "allowance",
    inputs: [
      {
        name: "owner",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "spender",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: [
      {
        name: "remaining",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "transfer",
    inputs: [
      { name: "to", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "transferFrom",
    inputs: [
      { name: "from", type: ABIDataTypes.ADDRESS },
      { name: "to", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "safeTransfer",
    inputs: [
      { name: "to", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 },
      { name: "data", type: ABIDataTypes.BYTES }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "safeTransferFrom",
    inputs: [
      { name: "from", type: ABIDataTypes.ADDRESS },
      { name: "to", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 },
      { name: "data", type: ABIDataTypes.BYTES }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "increaseAllowance",
    inputs: [
      { name: "spender", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "decreaseAllowance",
    inputs: [
      { name: "spender", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "increaseAllowanceBySignature",
    inputs: [
      { name: "owner", type: ABIDataTypes.BYTES32 },
      { name: "ownerTweakedPublicKey", type: ABIDataTypes.BYTES32 },
      { name: "spender", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 },
      { name: "deadline", type: ABIDataTypes.UINT64 },
      { name: "signature", type: ABIDataTypes.BYTES }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "decreaseAllowanceBySignature",
    inputs: [
      { name: "owner", type: ABIDataTypes.BYTES32 },
      { name: "ownerTweakedPublicKey", type: ABIDataTypes.BYTES32 },
      { name: "spender", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 },
      { name: "deadline", type: ABIDataTypes.UINT64 },
      { name: "signature", type: ABIDataTypes.BYTES }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "burn",
    inputs: [{ name: "amount", type: ABIDataTypes.UINT256 }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "metadata",
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "name",
        type: ABIDataTypes.STRING
      },
      {
        name: "symbol",
        type: ABIDataTypes.STRING
      },
      {
        name: "icon",
        type: ABIDataTypes.STRING
      },
      {
        name: "decimals",
        type: ABIDataTypes.UINT8
      },
      {
        name: "totalSupply",
        type: ABIDataTypes.UINT256
      },
      {
        name: "domainSeparator",
        type: ABIDataTypes.BYTES32
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  // Events
  ...OP20Events,
  // OP_NET
  ...OP_NET_ABI
];

const MOTO_ABI = [
  {
    name: "admin",
    type: BitcoinAbiTypes.Function,
    inputs: [],
    outputs: [
      {
        name: "adminAddress",
        type: ABIDataTypes.ADDRESS
      }
    ]
  },
  {
    name: "changeAdmin",
    type: BitcoinAbiTypes.Function,
    inputs: [{ name: "to", type: ABIDataTypes.ADDRESS }],
    outputs: []
  },
  {
    name: "adminMint",
    type: BitcoinAbiTypes.Function,
    inputs: [
      { name: "to", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 }
    ],
    outputs: []
  },
  {
    name: "adminBurn",
    type: BitcoinAbiTypes.Function,
    inputs: [
      { name: "from", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 }
    ],
    outputs: []
  },
  // OP_20
  ...OP_20_ABI
];

const OwnableEvents = [
  {
    name: "OwnershipTransferred",
    values: [
      {
        name: "previousOwner",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "newOwner",
        type: ABIDataTypes.ADDRESS
      }
    ],
    type: BitcoinAbiTypes.Event
  }
];
const OWNABLE_ABI = [
  {
    name: "owner",
    type: BitcoinAbiTypes.Function,
    inputs: [],
    outputs: [
      {
        name: "owner",
        type: ABIDataTypes.ADDRESS
      }
    ]
  },
  {
    name: "renounceOwnership",
    type: BitcoinAbiTypes.Function,
    inputs: [],
    outputs: []
  },
  {
    name: "transferOwnership",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "newOwner",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: []
  }
];
const MotoChefEvents = [
  {
    name: "PoolAdded",
    values: [
      {
        name: "poolId",
        type: ABIDataTypes.UINT32
      },
      {
        name: "allocPoint",
        type: ABIDataTypes.UINT256
      },
      {
        name: "lpToken",
        type: ABIDataTypes.ADDRESS
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "Initialized",
    values: [],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "PoolUpdated",
    values: [
      {
        name: "poolId",
        type: ABIDataTypes.UINT32
      },
      {
        name: "lastRewardBlock",
        type: ABIDataTypes.UINT64
      },
      {
        name: "lpSupply",
        type: ABIDataTypes.UINT256
      },
      {
        name: "accMotoPerShare",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "BTCStaked",
    values: [
      {
        name: "user",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "netAmount",
        type: ABIDataTypes.UINT256
      },
      {
        name: "stakeTxId",
        type: ABIDataTypes.UINT256
      },
      {
        name: "stakeIndex",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "BTCUnstaked",
    values: [
      {
        name: "user",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "pendingMoto",
        type: ABIDataTypes.UINT256
      },
      {
        name: "storedTxId",
        type: ABIDataTypes.UINT256
      },
      {
        name: "storedIndex",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "BTCStakeRemoved",
    values: [
      {
        name: "user",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "storedTxId",
        type: ABIDataTypes.UINT256
      },
      {
        name: "storedIndex",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "PoolSet",
    values: [
      {
        name: "poolId",
        type: ABIDataTypes.UINT32
      },
      {
        name: "allocPoint",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "Deposited",
    values: [
      {
        name: "user",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "poolId",
        type: ABIDataTypes.UINT32
      },
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      },
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "Withdrawn",
    values: [
      {
        name: "user",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "poolId",
        type: ABIDataTypes.UINT32
      },
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      },
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "Harvested",
    values: [
      {
        name: "user",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "poolId",
        type: ABIDataTypes.UINT32
      },
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "EmergencyWithdrawn",
    values: [
      {
        name: "user",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "poolId",
        type: ABIDataTypes.UINT32
      },
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      },
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      }
    ],
    type: BitcoinAbiTypes.Event
  }
];
const MOTOCHEF_ABI = [
  {
    name: "initialize",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "motoAddress",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "premineAmount",
        type: ABIDataTypes.UINT256
      },
      {
        name: "devAddress",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "motoPerBlock",
        type: ABIDataTypes.UINT256
      },
      {
        name: "bonusEndBlock",
        type: ABIDataTypes.UINT256
      },
      {
        name: "bonusMultiplier",
        type: ABIDataTypes.UINT256
      },
      {
        name: "treasuryAddress",
        type: ABIDataTypes.STRING
      },
      {
        name: "BTCAllocPoint",
        type: ABIDataTypes.UINT256
      },
      {
        name: "MOTOAllocPoint",
        type: ABIDataTypes.UINT256
      }
    ],
    outputs: []
  },
  {
    name: "totalAllocPoint",
    type: BitcoinAbiTypes.Function,
    inputs: [],
    outputs: [
      {
        name: "totalAllocPoint",
        type: ABIDataTypes.UINT256
      }
    ]
  },
  {
    name: "devAddress",
    type: BitcoinAbiTypes.Function,
    inputs: [],
    outputs: [
      {
        name: "devAddress",
        type: ABIDataTypes.ADDRESS
      }
    ]
  },
  {
    name: "getMotoPerBlock",
    type: BitcoinAbiTypes.Function,
    inputs: [],
    outputs: [
      {
        name: "motoPerBlock",
        type: ABIDataTypes.UINT256
      }
    ]
  },
  {
    name: "getBonusEndBlock",
    type: BitcoinAbiTypes.Function,
    inputs: [],
    outputs: [
      {
        name: "bonusEndBlock",
        type: ABIDataTypes.UINT256
      }
    ]
  },
  {
    name: "getBonusMultiplier",
    type: BitcoinAbiTypes.Function,
    inputs: [],
    outputs: [
      {
        name: "bonusMultiplier",
        type: ABIDataTypes.UINT256
      }
    ]
  },
  {
    name: "getLpTokens",
    type: BitcoinAbiTypes.Function,
    inputs: [],
    outputs: [
      {
        name: "lpTokens",
        type: ABIDataTypes.ARRAY_OF_ADDRESSES
      }
    ]
  },
  {
    name: "getPoolsLength",
    type: BitcoinAbiTypes.Function,
    inputs: [],
    outputs: [
      {
        name: "poolsLength",
        type: ABIDataTypes.UINT32
      }
    ]
  },
  {
    name: "getLpToken",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "poolId",
        type: ABIDataTypes.UINT32
      }
    ],
    outputs: [
      {
        name: "lpToken",
        type: ABIDataTypes.ADDRESS
      }
    ]
  },
  {
    name: "getPoolInfo",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "poolId",
        type: ABIDataTypes.UINT32
      }
    ],
    outputs: [
      {
        name: "accMotoPerShare",
        type: ABIDataTypes.UINT256
      },
      {
        name: "lastRewardBlock",
        type: ABIDataTypes.UINT64
      },
      {
        name: "allocPoint",
        type: ABIDataTypes.UINT64
      }
    ]
  },
  {
    name: "getUserInfo",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "poolId",
        type: ABIDataTypes.UINT32
      },
      {
        name: "user",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: [
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      },
      {
        name: "rewardDebt",
        type: ABIDataTypes.INT128
      }
    ]
  },
  {
    name: "getMultiplier",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "from",
        type: ABIDataTypes.UINT256
      },
      {
        name: "to",
        type: ABIDataTypes.UINT256
      }
    ],
    outputs: [
      {
        name: "multiplier",
        type: ABIDataTypes.UINT256
      }
    ]
  },
  {
    name: "pendingMoto",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "poolId",
        type: ABIDataTypes.UINT32
      },
      {
        name: "user",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: [
      {
        name: "pendingMoto",
        type: ABIDataTypes.UINT256
      }
    ]
  },
  {
    name: "treasuryAddress",
    type: BitcoinAbiTypes.Function,
    inputs: [],
    outputs: [
      {
        name: "treasuryAddress",
        type: ABIDataTypes.STRING
      }
    ]
  },
  {
    name: "getStakingTxId",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "user",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: [
      {
        name: "stakingTxId",
        type: ABIDataTypes.UINT256
      }
    ]
  },
  {
    name: "getStakingIndex",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "user",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: [
      {
        name: "stakingIndex",
        type: ABIDataTypes.UINT256
      }
    ]
  },
  {
    name: "totalBTCStaked",
    type: BitcoinAbiTypes.Function,
    inputs: [],
    outputs: [
      {
        name: "totalBTCStaked",
        type: ABIDataTypes.UINT256
      }
    ]
  },
  {
    name: "stakeBTC",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      }
    ],
    outputs: []
  },
  {
    name: "unstakeBTC",
    type: BitcoinAbiTypes.Function,
    inputs: [],
    outputs: []
  },
  {
    name: "removeBTCStake",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "user",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: []
  },
  {
    name: "add",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "allocPoint",
        type: ABIDataTypes.UINT256
      },
      {
        name: "lpToken",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: []
  },
  {
    name: "set",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "poolId",
        type: ABIDataTypes.UINT32
      },
      {
        name: "allocPoint",
        type: ABIDataTypes.UINT256
      }
    ],
    outputs: []
  },
  {
    name: "updatePool",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "poolId",
        type: ABIDataTypes.UINT32
      }
    ],
    outputs: [
      {
        name: "accMotoPerShare",
        type: ABIDataTypes.UINT256
      },
      {
        name: "lastRewardBlock",
        type: ABIDataTypes.UINT64
      },
      {
        name: "allocPoint",
        type: ABIDataTypes.UINT64
      }
    ]
  },
  {
    name: "massUpdatePools",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "length",
        type: ABIDataTypes.UINT16
      },
      {
        name: "poolIds",
        type: ABIDataTypes.ARRAY_OF_UINT32
      }
    ],
    outputs: []
  },
  {
    name: "deposit",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "poolId",
        type: ABIDataTypes.UINT32
      },
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      },
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: []
  },
  {
    name: "withdraw",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "poolId",
        type: ABIDataTypes.UINT32
      },
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      },
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: []
  },
  {
    name: "harvest",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "poolId",
        type: ABIDataTypes.UINT32
      },
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: []
  },
  {
    name: "withdrawAndHarvest",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "poolId",
        type: ABIDataTypes.UINT32
      },
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      },
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: []
  },
  {
    name: "emergencyWithdraw",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "poolId",
        type: ABIDataTypes.UINT32
      },
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: []
  },
  {
    name: "onOP20Received",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "operator",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "from",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      },
      {
        name: "data",
        type: ABIDataTypes.BYTES
      }
    ],
    outputs: [
      {
        name: "selector",
        type: ABIDataTypes.BYTES4
      }
    ]
  },
  {
    name: "setMotoPerBlock",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "motoPerBlock",
        type: ABIDataTypes.UINT256
      }
    ],
    outputs: []
  },
  {
    name: "setBonusEndBlock",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "bonusEndBlock",
        type: ABIDataTypes.UINT256
      }
    ],
    outputs: []
  },
  {
    name: "setBonusMultiplier",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "bonusMultiplier",
        type: ABIDataTypes.UINT256
      }
    ],
    outputs: []
  },
  {
    name: "setDev",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "devAddress",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: []
  },
  // Ownable
  ...OwnableEvents,
  ...OWNABLE_ABI,
  // Events
  ...MotoChefEvents,
  // OP_NET
  ...OP_NET_ABI
];

const MotoSwapFactoryEvents = [
  {
    name: "PoolCreated",
    values: [
      {
        name: "token0",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "token1",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "pool",
        type: ABIDataTypes.ADDRESS
      }
    ],
    type: BitcoinAbiTypes.Event
  }
];
const MotoSwapFactoryAbi = [
  {
    name: "createPool",
    inputs: [
      {
        name: "tokenA",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "tokenB",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: [
      {
        name: "address",
        type: ABIDataTypes.ADDRESS
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "getPool",
    inputs: [
      {
        name: "tokenA",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "tokenB",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: [
      {
        name: "pool",
        type: ABIDataTypes.ADDRESS
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "setStakingContractAddress",
    inputs: [
      {
        name: "stakingContractAddress",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "getStakingContractAddress",
    inputs: [],
    outputs: [
      {
        name: "stakingContractAddress",
        type: ABIDataTypes.ADDRESS
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  ...MotoSwapFactoryEvents,
  // OP_NET
  ...OP_NET_ABI
];

const MotoSwapPoolEvents = [
  {
    name: "LiquidityRemoved",
    values: [
      {
        name: "sender",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "amount0",
        type: ABIDataTypes.UINT256
      },
      {
        name: "amount1",
        type: ABIDataTypes.UINT256
      },
      { name: "to", type: ABIDataTypes.ADDRESS }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "LiquidityAdded",
    values: [
      {
        name: "sender",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "amount0",
        type: ABIDataTypes.UINT256
      },
      {
        name: "amount1",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "Swapped",
    values: [
      {
        name: "sender",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "amount0In",
        type: ABIDataTypes.UINT256
      },
      {
        name: "amount1In",
        type: ABIDataTypes.UINT256
      },
      {
        name: "amount0Out",
        type: ABIDataTypes.UINT256
      },
      {
        name: "amount1Out",
        type: ABIDataTypes.UINT256
      },
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "Synced",
    values: [
      {
        name: "reserve0",
        type: ABIDataTypes.UINT256
      },
      {
        name: "reserve1",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Event
  }
];
const MotoswapPoolAbi = [
  {
    name: "initialize",
    inputs: [
      {
        name: "token0",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "token1",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "swap",
    inputs: [
      {
        name: "amount0Out",
        type: ABIDataTypes.UINT256
      },
      {
        name: "amount1Out",
        type: ABIDataTypes.UINT256
      },
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "data",
        type: ABIDataTypes.BYTES
      }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "skim",
    inputs: [],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "getReserves",
    inputs: [],
    outputs: [
      {
        name: "reserve0",
        type: ABIDataTypes.UINT256
      },
      {
        name: "reserve1",
        type: ABIDataTypes.UINT256
      },
      {
        name: "blockTimestampLast",
        type: ABIDataTypes.UINT64
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "token0",
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "token0",
        type: ABIDataTypes.ADDRESS
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "token1",
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "token1",
        type: ABIDataTypes.ADDRESS
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "price0CumulativeLast",
    inputs: [],
    outputs: [
      {
        name: "price0CumulativeLast",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "price1CumulativeLast",
    inputs: [],
    outputs: [
      {
        name: "price1CumulativeLast",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "kLast",
    inputs: [],
    outputs: [
      {
        name: "kLast",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "blockTimestampLast",
    inputs: [],
    outputs: [
      {
        name: "blockTimestampLast",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "sync",
    inputs: [],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "MINIMUM_LIQUIDITY",
    inputs: [],
    outputs: [
      {
        name: "MINIMUM_LIQUIDITY",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  // Overwrites
  {
    name: "mint",
    inputs: [],
    outputs: [
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "burn",
    inputs: [
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: [
      {
        name: "amount0",
        type: ABIDataTypes.UINT256
      },
      {
        name: "amount1",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  // OP_20
  ...OP_20_ABI,
  // EVENTS
  ...MotoSwapPoolEvents
];

const MOTOSWAP_ROUTER_ABI = [
  /** Liquidity functions */
  {
    name: "addLiquidity",
    inputs: [
      {
        name: "tokenA",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "tokenB",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "amountADesired",
        type: ABIDataTypes.UINT256
      },
      {
        name: "amountBDesired",
        type: ABIDataTypes.UINT256
      },
      {
        name: "amountAMin",
        type: ABIDataTypes.UINT256
      },
      {
        name: "amountBMin",
        type: ABIDataTypes.UINT256
      },
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "deadline",
        type: ABIDataTypes.UINT64
      }
    ],
    outputs: [
      {
        name: "amountA",
        type: ABIDataTypes.UINT256
      },
      {
        name: "amountB",
        type: ABIDataTypes.UINT256
      },
      {
        name: "liquidity",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "removeLiquidity",
    inputs: [
      {
        name: "tokenA",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "tokenB",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "liquidity",
        type: ABIDataTypes.UINT256
      },
      {
        name: "amountAMin",
        type: ABIDataTypes.UINT256
      },
      {
        name: "amountBMin",
        type: ABIDataTypes.UINT256
      },
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "deadline",
        type: ABIDataTypes.UINT64
      }
    ],
    outputs: [
      {
        name: "amountA",
        type: ABIDataTypes.UINT256
      },
      {
        name: "amountB",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  /** Common functions */
  {
    name: "quote",
    inputs: [
      {
        name: "amountA",
        type: ABIDataTypes.UINT256
      },
      {
        name: "reserveA",
        type: ABIDataTypes.UINT256
      },
      {
        name: "reserveB",
        type: ABIDataTypes.UINT256
      }
    ],
    outputs: [
      {
        name: "quote",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "getAmountOut",
    inputs: [
      {
        name: "amountIn",
        type: ABIDataTypes.UINT256
      },
      {
        name: "reserveIn",
        type: ABIDataTypes.UINT256
      },
      {
        name: "reserveOut",
        type: ABIDataTypes.UINT256
      }
    ],
    outputs: [
      {
        name: "amountOut",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "getAmountIn",
    inputs: [
      {
        name: "amountOut",
        type: ABIDataTypes.UINT256
      },
      {
        name: "reserveIn",
        type: ABIDataTypes.UINT256
      },
      {
        name: "reserveOut",
        type: ABIDataTypes.UINT256
      }
    ],
    outputs: [
      {
        name: "amountIn",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "getAmountsOut",
    inputs: [
      {
        name: "amountIn",
        type: ABIDataTypes.UINT256
      },
      {
        name: "path",
        type: ABIDataTypes.ARRAY_OF_ADDRESSES
      }
    ],
    outputs: [
      {
        name: "amountsOut",
        type: ABIDataTypes.ARRAY_OF_UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "getAmountsIn",
    inputs: [
      {
        name: "amountOut",
        type: ABIDataTypes.UINT256
      },
      {
        name: "path",
        type: ABIDataTypes.ARRAY_OF_ADDRESSES
      }
    ],
    outputs: [
      {
        name: "amountsIn",
        type: ABIDataTypes.ARRAY_OF_UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  /** Swap Functions */
  {
    name: "swapExactTokensForTokensSupportingFeeOnTransferTokens",
    inputs: [
      {
        name: "amountIn",
        type: ABIDataTypes.UINT256
      },
      {
        name: "amountOutMin",
        type: ABIDataTypes.UINT256
      },
      {
        name: "path",
        type: ABIDataTypes.ARRAY_OF_ADDRESSES
      },
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "deadline",
        type: ABIDataTypes.UINT64
      }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  /** Views */
  {
    name: "factory",
    inputs: [],
    outputs: [
      {
        name: "factory",
        type: ABIDataTypes.ADDRESS
      }
    ],
    type: BitcoinAbiTypes.Function
  },
  /** Events */
  ...MotoSwapFactoryEvents,
  ...OP20Events,
  ...MotoSwapPoolEvents,
  // OP_NET
  ...OP_NET_ABI
];

const NativeSwapEvents = [
  {
    name: "LiquidityAdded",
    values: [
      { name: "totalTokensContributed", type: ABIDataTypes.UINT256 },
      { name: "virtualTokenExchanged", type: ABIDataTypes.UINT256 },
      { name: "totalSatoshisSpent", type: ABIDataTypes.UINT64 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "LiquidityListed",
    values: [
      { name: "totalLiquidity", type: ABIDataTypes.UINT128 },
      { name: "provider", type: ABIDataTypes.STRING }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "LiquidityRemoved",
    values: [
      { name: "providerId", type: ABIDataTypes.UINT256 },
      { name: "satoshisOwed", type: ABIDataTypes.UINT64 },
      { name: "tokenAmount", type: ABIDataTypes.UINT128 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "LiquidityReserved",
    values: [
      { name: "depositAddress", type: ABIDataTypes.STRING },
      { name: "satoshisAmount", type: ABIDataTypes.UINT64 },
      { name: "providerId", type: ABIDataTypes.UINT256 },
      { name: "tokenAmount", type: ABIDataTypes.UINT128 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "ListingCanceled",
    values: [
      { name: "amount", type: ABIDataTypes.UINT128 },
      { name: "penalty", type: ABIDataTypes.UINT128 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "ProviderActivated",
    values: [
      { name: "providerId", type: ABIDataTypes.UINT256 },
      { name: "listingAmount", type: ABIDataTypes.UINT128 },
      { name: "btcToRemove", type: ABIDataTypes.UINT64 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "ProviderConsumed",
    values: [
      { name: "providerId", type: ABIDataTypes.UINT256 },
      { name: "amountUsed", type: ABIDataTypes.UINT128 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "ProviderFulfilled",
    values: [
      { name: "providerId", type: ABIDataTypes.UINT256 },
      { name: "removalCompleted", type: ABIDataTypes.BOOL },
      { name: "stakedAmount", type: ABIDataTypes.UINT256 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "ReservationFallback",
    values: [
      { name: "reservationId", type: ABIDataTypes.UINT128 },
      { name: "expirationBlock", type: ABIDataTypes.UINT64 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "ReservationCreated",
    values: [
      { name: "expectedAmountOut", type: ABIDataTypes.UINT256 },
      { name: "totalSatoshis", type: ABIDataTypes.UINT64 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "ReservationPurged",
    values: [
      { name: "reservationId", type: ABIDataTypes.UINT128 },
      { name: "currentBlock", type: ABIDataTypes.UINT64 },
      { name: "purgingBlock", type: ABIDataTypes.UINT64 },
      { name: "purgeIndex", type: ABIDataTypes.UINT32 },
      { name: "providerCount", type: ABIDataTypes.UINT32 },
      { name: "purgedAmount", type: ABIDataTypes.UINT256 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "SwapExecuted",
    values: [
      { name: "buyer", type: ABIDataTypes.ADDRESS },
      { name: "amountIn", type: ABIDataTypes.UINT64 },
      { name: "amountOut", type: ABIDataTypes.UINT256 },
      { name: "totalFees", type: ABIDataTypes.UINT256 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "WithdrawListing",
    values: [
      { name: "amount", type: ABIDataTypes.UINT128 },
      { name: "tokenAddress", type: ABIDataTypes.ADDRESS },
      { name: "providerId", type: ABIDataTypes.UINT256 },
      { name: "sender", type: ABIDataTypes.ADDRESS }
    ],
    type: BitcoinAbiTypes.Event
  }
];
const NativeSwapAbi = [
  //=================================================
  // RESERVE
  //=================================================
  {
    name: "reserve",
    inputs: [
      { name: "token", type: ABIDataTypes.ADDRESS },
      { name: "maximumAmountIn", type: ABIDataTypes.UINT64 },
      { name: "minimumAmountOut", type: ABIDataTypes.UINT256 },
      { name: "activationDelay", type: ABIDataTypes.UINT8 }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // SWAP
  //=================================================
  {
    name: "swap",
    inputs: [{ name: "token", type: ABIDataTypes.ADDRESS }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // LIST LIQUIDITY
  //=================================================
  {
    name: "listLiquidity",
    inputs: [
      { name: "token", type: ABIDataTypes.ADDRESS },
      { name: "receiver", type: ABIDataTypes.BYTES },
      { name: "receiverStr", type: ABIDataTypes.STRING },
      { name: "amountIn", type: ABIDataTypes.UINT128 },
      { name: "priority", type: ABIDataTypes.BOOL }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // CANCEL LISTING
  //=================================================
  {
    name: "cancelListing",
    inputs: [{ name: "token", type: ABIDataTypes.ADDRESS }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // WITHDRAW LISTING
  //=================================================
  {
    name: "withdrawListing",
    inputs: [{ name: "token", type: ABIDataTypes.ADDRESS }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // CREATE POOL
  //=================================================
  {
    name: "createPool",
    inputs: [
      { name: "token", type: ABIDataTypes.ADDRESS },
      { name: "floorPrice", type: ABIDataTypes.UINT256 },
      { name: "initialLiquidity", type: ABIDataTypes.UINT128 },
      { name: "receiver", type: ABIDataTypes.BYTES },
      { name: "receiverStr", type: ABIDataTypes.STRING },
      { name: "antiBotEnabledFor", type: ABIDataTypes.UINT16 },
      { name: "antiBotMaximumTokensPerReservation", type: ABIDataTypes.UINT256 },
      { name: "maxReservesIn5BlocksPercent", type: ABIDataTypes.UINT16 },
      { name: "poolType", type: ABIDataTypes.UINT8 },
      { name: "amplification", type: ABIDataTypes.UINT64 },
      { name: "pegStalenessThreshold", type: ABIDataTypes.UINT64 }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // SET FEES
  //=================================================
  {
    name: "setFees",
    inputs: [
      { name: "reservationBaseFee", type: ABIDataTypes.UINT64 },
      { name: "priorityQueueBaseFee", type: ABIDataTypes.UINT64 }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // SET STAKING CONTRACT ADDRESS
  //=================================================
  {
    name: "setStakingContractAddress",
    inputs: [{ name: "address", type: ABIDataTypes.ADDRESS }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // SET FEES ADDRESS
  //=================================================
  {
    name: "setFeesAddress",
    inputs: [{ name: "address", type: ABIDataTypes.STRING }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // PAUSE
  //=================================================
  {
    name: "pause",
    inputs: [],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // UNPAUSE
  //=================================================
  {
    name: "unpause",
    inputs: [],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // ACTIVATE WITHDRAW MODE
  //=================================================
  {
    name: "activateWithdrawMode",
    inputs: [],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // VIEW FUNCTIONS - READ ONLY
  //=================================================
  //=================================================
  // IS PAUSED
  //=================================================
  {
    name: "isPaused",
    inputs: [],
    outputs: [{ name: "paused", type: ABIDataTypes.BOOL }],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // IS WITHDRAW MODE ACTIVE
  //=================================================
  {
    name: "isWithdrawModeActive",
    inputs: [],
    outputs: [{ name: "active", type: ABIDataTypes.BOOL }],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // GET RESERVE
  //=================================================
  {
    name: "getReserve",
    inputs: [{ name: "token", type: ABIDataTypes.ADDRESS }],
    outputs: [
      { name: "liquidity", type: ABIDataTypes.UINT256 },
      { name: "reservedLiquidity", type: ABIDataTypes.UINT256 },
      { name: "virtualBTCReserve", type: ABIDataTypes.UINT64 },
      { name: "virtualTokenReserve", type: ABIDataTypes.UINT256 }
    ],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // GET QUOTE
  //=================================================
  {
    name: "getQuote",
    inputs: [
      { name: "token", type: ABIDataTypes.ADDRESS },
      { name: "satoshisIn", type: ABIDataTypes.UINT64 }
    ],
    outputs: [
      { name: "tokensOut", type: ABIDataTypes.UINT256 },
      { name: "requiredSatoshis", type: ABIDataTypes.UINT64 },
      { name: "price", type: ABIDataTypes.UINT256 },
      { name: "scale", type: ABIDataTypes.UINT64 }
    ],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // GET PROVIDER DETAILS
  //=================================================
  {
    name: "getProviderDetails",
    inputs: [{ name: "token", type: ABIDataTypes.ADDRESS }],
    outputs: [
      { name: "id", type: ABIDataTypes.UINT256 },
      { name: "liquidity", type: ABIDataTypes.UINT128 },
      { name: "reserved", type: ABIDataTypes.UINT128 },
      { name: "btcReceiver", type: ABIDataTypes.STRING },
      { name: "indexedAt", type: ABIDataTypes.UINT32 },
      { name: "isPriority", type: ABIDataTypes.BOOL },
      { name: "purgeIndex", type: ABIDataTypes.UINT32 },
      { name: "isActive", type: ABIDataTypes.BOOL },
      { name: "lastListedTokensAtBlock", type: ABIDataTypes.UINT64 },
      { name: "isPurged", type: ABIDataTypes.BOOL },
      { name: "isLiquidityProvisionAllowed", type: ABIDataTypes.BOOL },
      { name: "toReset", type: ABIDataTypes.BOOL }
    ],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // GET PROVIDER DETAILS BY ID
  //=================================================
  {
    name: "getProviderDetailsById",
    inputs: [{ name: "providerId", type: ABIDataTypes.UINT256 }],
    outputs: [
      { name: "id", type: ABIDataTypes.UINT256 },
      { name: "liquidity", type: ABIDataTypes.UINT128 },
      { name: "reserved", type: ABIDataTypes.UINT128 },
      { name: "btcReceiver", type: ABIDataTypes.STRING },
      { name: "indexedAt", type: ABIDataTypes.UINT32 },
      { name: "isPriority", type: ABIDataTypes.BOOL },
      { name: "purgeIndex", type: ABIDataTypes.UINT32 },
      { name: "isActive", type: ABIDataTypes.BOOL },
      { name: "lastListedTokensAtBlock", type: ABIDataTypes.UINT64 },
      { name: "isPurged", type: ABIDataTypes.BOOL },
      { name: "isLiquidityProvisionAllowed", type: ABIDataTypes.BOOL },
      { name: "toReset", type: ABIDataTypes.BOOL }
    ],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // GET QUEUE DETAILS
  //=================================================
  {
    name: "getQueueDetails",
    inputs: [{ name: "token", type: ABIDataTypes.ADDRESS }],
    outputs: [
      { name: "lastPurgedBlock", type: ABIDataTypes.UINT64 },
      { name: "blockWithReservationsLength", type: ABIDataTypes.UINT32 },
      { name: "priorityQueueLength", type: ABIDataTypes.UINT32 },
      { name: "priorityQueueStartingIndex", type: ABIDataTypes.UINT32 },
      { name: "standardQueueLength", type: ABIDataTypes.UINT32 },
      { name: "standardQueueStartingIndex", type: ABIDataTypes.UINT32 },
      { name: "priorityPurgeQueueLength", type: ABIDataTypes.UINT32 },
      { name: "standardPurgeQueueLength", type: ABIDataTypes.UINT32 }
    ],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // GET PRIORITY QUEUE COST
  //=================================================
  {
    name: "getPriorityQueueCost",
    inputs: [],
    outputs: [{ name: "cost", type: ABIDataTypes.UINT64 }],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // GET FEES
  //=================================================
  {
    name: "getFees",
    inputs: [],
    outputs: [
      { name: "reservationBaseFee", type: ABIDataTypes.UINT64 },
      { name: "priorityQueueBaseFee", type: ABIDataTypes.UINT64 }
    ],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // GET ANTIBOT SETTINGS
  //=================================================
  {
    name: "getAntibotSettings",
    inputs: [{ name: "token", type: ABIDataTypes.ADDRESS }],
    outputs: [
      { name: "antiBotExpirationBlock", type: ABIDataTypes.UINT64 },
      { name: "maxTokensPerReservation", type: ABIDataTypes.UINT256 }
    ],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // GET STAKING CONTRACT ADDRESS
  //=================================================
  {
    name: "getStakingContractAddress",
    inputs: [],
    outputs: [{ name: "stakingAddress", type: ABIDataTypes.ADDRESS }],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // GET FEES ADDRESS
  //=================================================
  {
    name: "getFeesAddress",
    inputs: [],
    outputs: [{ name: "feesAddress", type: ABIDataTypes.STRING }],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // GET POOL INFO
  //=================================================
  {
    name: "getPoolInfo",
    inputs: [{ name: "token", type: ABIDataTypes.ADDRESS }],
    outputs: [
      { name: "poolType", type: ABIDataTypes.UINT8 },
      { name: "amplification", type: ABIDataTypes.UINT64 },
      { name: "pegStalenessThreshold", type: ABIDataTypes.UINT64 }
    ],
    type: BitcoinAbiTypes.Function
  },
  //=================================================
  // All Event Definitions
  //=================================================
  ...NativeSwapEvents,
  //=================================================
  // OP_NET Base ABI
  //=================================================
  ...OP_NET_ABI
];

const OP20SEvents = [
  {
    name: "PegRateUpdated",
    values: [
      { name: "oldRate", type: ABIDataTypes.UINT256 },
      { name: "newRate", type: ABIDataTypes.UINT256 },
      { name: "updatedAt", type: ABIDataTypes.UINT64 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "MaxStalenessUpdated",
    values: [
      { name: "oldStaleness", type: ABIDataTypes.UINT64 },
      { name: "newStaleness", type: ABIDataTypes.UINT64 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "PegAuthorityTransferStarted",
    values: [
      { name: "currentAuthority", type: ABIDataTypes.ADDRESS },
      { name: "pendingAuthority", type: ABIDataTypes.ADDRESS }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "PegAuthorityTransferred",
    values: [
      { name: "previousAuthority", type: ABIDataTypes.ADDRESS },
      { name: "newAuthority", type: ABIDataTypes.ADDRESS }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "PegAuthorityRenounced",
    values: [{ name: "previousAuthority", type: ABIDataTypes.ADDRESS }],
    type: BitcoinAbiTypes.Event
  }
];
const OP_20S_ABI = [
  {
    name: "pegRate",
    inputs: [],
    outputs: [{ name: "rate", type: ABIDataTypes.UINT256 }],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "pegAuthority",
    inputs: [],
    outputs: [{ name: "authority", type: ABIDataTypes.ADDRESS }],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "pegUpdatedAt",
    inputs: [],
    outputs: [{ name: "updatedAt", type: ABIDataTypes.UINT64 }],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "maxStaleness",
    inputs: [],
    outputs: [{ name: "staleness", type: ABIDataTypes.UINT64 }],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "isStale",
    inputs: [],
    outputs: [{ name: "stale", type: ABIDataTypes.BOOL }],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "updatePegRate",
    inputs: [{ name: "newRate", type: ABIDataTypes.UINT256 }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "updateMaxStaleness",
    inputs: [{ name: "newStaleness", type: ABIDataTypes.UINT64 }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "transferPegAuthority",
    inputs: [{ name: "newAuthority", type: ABIDataTypes.ADDRESS }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "acceptPegAuthority",
    inputs: [],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "renouncePegAuthority",
    inputs: [],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  ...OP20SEvents,
  ...OP_20_ABI
];

const MOTOSWAP_OWNABLE_REENTRANCY_GUARD_ABI = [
  // Ownable
  {
    name: "admin",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [],
    outputs: [
      {
        name: "adminAddress",
        type: ABIDataTypes.ADDRESS
      }
    ]
  },
  {
    name: "changeAdmin",
    type: BitcoinAbiTypes.Function,
    constant: false,
    payable: false,
    inputs: [
      {
        name: "newAdmin",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: []
  },
  // Reentrancy guard
  {
    name: "status",
    inputs: [],
    outputs: [
      {
        name: "status",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Function
  }
];
const MotoswapStakingEvents = [
  {
    name: "RewardTokenAdded",
    type: BitcoinAbiTypes.Event,
    values: [
      {
        name: "token",
        type: ABIDataTypes.ADDRESS
      }
    ]
  },
  {
    name: "RewardTokenRemoved",
    type: BitcoinAbiTypes.Event,
    values: [
      {
        name: "token",
        type: ABIDataTypes.ADDRESS
      }
    ]
  }
];
const MOTOSWAP_STAKING_ABI = [
  {
    name: "balanceOf",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [{ name: "address", type: ABIDataTypes.ADDRESS }],
    outputs: [{ name: "balance", type: ABIDataTypes.UINT256 }]
  },
  {
    name: "motoAddress",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [],
    outputs: [{ name: "motoAddress", type: ABIDataTypes.ADDRESS }]
  },
  {
    name: "totalSupply",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [],
    outputs: [{ name: "totalSupply", type: ABIDataTypes.UINT256 }]
  },
  {
    name: "lastInteractedBlock",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [{ name: "address", type: ABIDataTypes.ADDRESS }],
    outputs: [{ name: "lastInteractedBlock", type: ABIDataTypes.UINT256 }]
  },
  {
    name: "rewardDebt",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [
      { name: "user", type: ABIDataTypes.ADDRESS },
      { name: "rewardToken", type: ABIDataTypes.ADDRESS }
    ],
    outputs: [{ name: "rewardDebt", type: ABIDataTypes.UINT256 }]
  },
  {
    name: "rewardBalance",
    type: BitcoinAbiTypes.Function,
    constant: false,
    inputs: [
      { name: "user", type: ABIDataTypes.ADDRESS },
      { name: "rewardToken", type: ABIDataTypes.ADDRESS }
    ],
    outputs: [{ name: "rewardBalance", type: ABIDataTypes.UINT256 }]
  },
  {
    name: "pendingReward",
    type: BitcoinAbiTypes.Function,
    constant: true,
    payable: false,
    inputs: [
      { name: "user", type: ABIDataTypes.ADDRESS },
      { name: "rewardToken", type: ABIDataTypes.ADDRESS }
    ],
    outputs: [{ name: "pendingReward", type: ABIDataTypes.UINT256 }]
  },
  {
    name: "calculateSlashingFee",
    type: BitcoinAbiTypes.Function,
    constant: true,
    inputs: [
      { name: "user", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 }
    ],
    outputs: [{ name: "rewardDebt", type: ABIDataTypes.UINT256 }]
  },
  {
    name: "enabledRewardTokens",
    type: BitcoinAbiTypes.Function,
    constant: false,
    inputs: [],
    outputs: [{ name: "enabledRewardTokens", type: ABIDataTypes.ARRAY_OF_ADDRESSES }]
  },
  {
    name: "stake",
    type: BitcoinAbiTypes.Function,
    constant: false,
    payable: false,
    inputs: [{ name: "amount", type: ABIDataTypes.UINT256 }],
    outputs: []
  },
  {
    name: "unstake",
    type: BitcoinAbiTypes.Function,
    constant: false,
    payable: false,
    inputs: [],
    outputs: []
  },
  {
    name: "claimRewards",
    type: BitcoinAbiTypes.Function,
    constant: false,
    payable: false,
    inputs: [],
    outputs: []
  },
  {
    name: "adminAddRewardToken",
    type: BitcoinAbiTypes.Function,
    constant: false,
    payable: false,
    inputs: [{ name: "token", type: ABIDataTypes.ADDRESS }],
    outputs: []
  },
  {
    name: "adminRemoveRewardToken",
    type: BitcoinAbiTypes.Function,
    constant: false,
    payable: false,
    inputs: [{ name: "token", type: ABIDataTypes.ADDRESS }],
    outputs: []
  },
  {
    name: "adminChangeMotoAddress",
    type: BitcoinAbiTypes.Function,
    constant: false,
    payable: false,
    inputs: [{ name: "token", type: ABIDataTypes.ADDRESS }],
    outputs: []
  },
  {
    name: "adminChangeLockupParameters",
    type: BitcoinAbiTypes.Function,
    constant: false,
    payable: false,
    inputs: [
      { name: "newLockupDuration", type: ABIDataTypes.UINT256 },
      { name: "newMaxSlashingFeePercent", type: ABIDataTypes.UINT256 },
      { name: "newBlocksPerOnePercentSlashingFeeReduction", type: ABIDataTypes.UINT256 }
    ],
    outputs: []
  },
  {
    name: "adminEnableEmergencyWithdrawals",
    type: BitcoinAbiTypes.Function,
    constant: false,
    payable: false,
    inputs: [],
    outputs: []
  },
  // Ownable Reentrancy Guard
  ...MOTOSWAP_OWNABLE_REENTRANCY_GUARD_ABI,
  // Events
  ...MotoswapStakingEvents,
  // OP_NET
  ...OP_NET_ABI
];

const OP721Events = [
  {
    name: "Transferred",
    values: [
      {
        name: "operator",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "from",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "Approved",
    values: [
      {
        name: "owner",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "spender",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "ApprovedForAll",
    values: [
      {
        name: "account",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "operator",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "approved",
        type: ABIDataTypes.BOOL
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "URI",
    values: [
      {
        name: "value",
        type: ABIDataTypes.STRING
      },
      {
        name: "id",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Event
  }
];
const OP_721_ABI = [
  {
    name: "name",
    type: BitcoinAbiTypes.Function,
    inputs: [],
    outputs: [
      {
        name: "name",
        type: ABIDataTypes.STRING
      }
    ]
  },
  {
    name: "symbol",
    type: BitcoinAbiTypes.Function,
    inputs: [],
    outputs: [
      {
        name: "symbol",
        type: ABIDataTypes.STRING
      }
    ]
  },
  {
    name: "maxSupply",
    type: BitcoinAbiTypes.Function,
    inputs: [],
    outputs: [
      {
        name: "maxSupply",
        type: ABIDataTypes.UINT256
      }
    ]
  },
  {
    name: "collectionInfo",
    type: BitcoinAbiTypes.Function,
    inputs: [],
    outputs: [
      {
        name: "icon",
        type: ABIDataTypes.STRING
      },
      {
        name: "banner",
        type: ABIDataTypes.STRING
      },
      {
        name: "description",
        type: ABIDataTypes.STRING
      },
      {
        name: "website",
        type: ABIDataTypes.STRING
      }
    ]
  },
  {
    name: "tokenURI",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "tokenId",
        type: ABIDataTypes.UINT256
      }
    ],
    outputs: [
      {
        name: "uri",
        type: ABIDataTypes.STRING
      }
    ]
  },
  {
    name: "changeMetadata",
    type: BitcoinAbiTypes.Function,
    inputs: [],
    outputs: []
  },
  {
    name: "totalSupply",
    type: BitcoinAbiTypes.Function,
    inputs: [],
    outputs: [
      {
        name: "totalSupply",
        type: ABIDataTypes.UINT256
      }
    ]
  },
  {
    name: "balanceOf",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "owner",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: [
      {
        name: "balance",
        type: ABIDataTypes.UINT256
      }
    ]
  },
  {
    name: "ownerOf",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "tokenId",
        type: ABIDataTypes.UINT256
      }
    ],
    outputs: [
      {
        name: "owner",
        type: ABIDataTypes.ADDRESS
      }
    ]
  },
  {
    name: "safeTransfer",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "tokenId",
        type: ABIDataTypes.UINT256
      },
      {
        name: "data",
        type: ABIDataTypes.BYTES
      }
    ],
    outputs: []
  },
  {
    name: "safeTransferFrom",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "from",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "to",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "tokenId",
        type: ABIDataTypes.UINT256
      },
      {
        name: "data",
        type: ABIDataTypes.BYTES
      }
    ],
    outputs: []
  },
  {
    name: "approve",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "operator",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "tokenId",
        type: ABIDataTypes.UINT256
      }
    ],
    outputs: []
  },
  {
    name: "getApproved",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "tokenId",
        type: ABIDataTypes.UINT256
      }
    ],
    outputs: []
  },
  {
    name: "setApprovalForAll",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "operator",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "approved",
        type: ABIDataTypes.BOOL
      }
    ],
    outputs: []
  },
  {
    name: "isApprovedForAll",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "owner",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "operator",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: [
      {
        name: "approved",
        type: ABIDataTypes.BOOL
      }
    ]
  },
  {
    name: "approveBySignature",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "owner",
        type: ABIDataTypes.BYTES32
      },
      {
        name: "ownerTweakedPublicKey",
        type: ABIDataTypes.BYTES32
      },
      {
        name: "operator",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "tokenId",
        type: ABIDataTypes.UINT256
      },
      {
        name: "deadline",
        type: ABIDataTypes.UINT64
      },
      {
        name: "signature",
        type: ABIDataTypes.BYTES
      }
    ],
    outputs: []
  },
  {
    name: "setApprovalForAllBySignature",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "owner",
        type: ABIDataTypes.BYTES32
      },
      {
        name: "ownerTweakedPublicKey",
        type: ABIDataTypes.BYTES32
      },
      {
        name: "operator",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "approved",
        type: ABIDataTypes.BOOL
      },
      {
        name: "deadline",
        type: ABIDataTypes.UINT64
      },
      {
        name: "signature",
        type: ABIDataTypes.BYTES
      }
    ],
    outputs: []
  },
  {
    name: "burn",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "tokenId",
        type: ABIDataTypes.UINT256
      }
    ],
    outputs: []
  },
  {
    name: "domainSeparator",
    type: BitcoinAbiTypes.Function,
    inputs: [],
    outputs: [
      {
        name: "domainSeparator",
        type: ABIDataTypes.BYTES32
      }
    ]
  },
  {
    name: "tokenOfOwnerByIndex",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "owner",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "index",
        type: ABIDataTypes.UINT256
      }
    ],
    outputs: [
      {
        name: "tokenId",
        type: ABIDataTypes.UINT256
      }
    ]
  },
  {
    name: "getApproveNonce",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "owner",
        type: ABIDataTypes.ADDRESS
      }
    ],
    outputs: [
      {
        name: "nonce",
        type: ABIDataTypes.UINT256
      }
    ]
  },
  {
    name: "setBaseURI",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "baseURI",
        type: ABIDataTypes.STRING
      }
    ],
    outputs: []
  },
  {
    name: "metadata",
    type: BitcoinAbiTypes.Function,
    inputs: [],
    outputs: [
      {
        name: "name",
        type: ABIDataTypes.STRING
      },
      {
        name: "symbol",
        type: ABIDataTypes.STRING
      },
      {
        name: "icon",
        type: ABIDataTypes.STRING
      },
      {
        name: "banner",
        type: ABIDataTypes.STRING
      },
      {
        name: "description",
        type: ABIDataTypes.STRING
      },
      {
        name: "website",
        type: ABIDataTypes.STRING
      },
      {
        name: "totalSupply",
        type: ABIDataTypes.UINT256
      },
      {
        name: "domainSeparator",
        type: ABIDataTypes.BYTES32
      }
    ]
  },
  ...OP721Events,
  // OP_NET
  ...OP_NET_ABI
];
const EXTENDED_OP721_EVENTS = [
  {
    name: "MintStatusChanged",
    values: [
      {
        name: "enabled",
        type: ABIDataTypes.BOOL
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "ReservationCreated",
    values: [
      {
        name: "user",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      },
      {
        name: "block",
        type: ABIDataTypes.UINT64
      },
      {
        name: "feePaid",
        type: ABIDataTypes.UINT64
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "ReservationClaimed",
    values: [
      {
        name: "user",
        type: ABIDataTypes.ADDRESS
      },
      {
        name: "amount",
        type: ABIDataTypes.UINT256
      },
      {
        name: "firstTokenId",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "ReservationExpired",
    values: [
      {
        name: "block",
        type: ABIDataTypes.UINT64
      },
      {
        name: "amountRecovered",
        type: ABIDataTypes.UINT256
      }
    ],
    type: BitcoinAbiTypes.Event
  }
];
const EXTENDED_OP721_ABI = [
  {
    name: "setMintEnabled",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "enabled",
        type: ABIDataTypes.BOOL
      }
    ],
    outputs: []
  },
  {
    name: "isMintEnabled",
    type: BitcoinAbiTypes.Function,
    inputs: [],
    outputs: [
      {
        name: "enabled",
        type: ABIDataTypes.BOOL
      }
    ]
  },
  {
    name: "reserve",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "quantity",
        type: ABIDataTypes.UINT256
      }
    ],
    outputs: [
      {
        name: "remainingPayment",
        type: ABIDataTypes.UINT64
      },
      {
        name: "reservationBlock",
        type: ABIDataTypes.UINT64
      }
    ]
  },
  {
    name: "claim",
    type: BitcoinAbiTypes.Function,
    inputs: [],
    outputs: []
  },
  {
    name: "purgeExpired",
    type: BitcoinAbiTypes.Function,
    inputs: [],
    outputs: []
  },
  {
    name: "getStatus",
    type: BitcoinAbiTypes.Function,
    inputs: [],
    outputs: [
      {
        name: "minted",
        type: ABIDataTypes.UINT256
      },
      {
        name: "reserved",
        type: ABIDataTypes.UINT256
      },
      {
        name: "available",
        type: ABIDataTypes.UINT256
      },
      {
        name: "maxSupply",
        type: ABIDataTypes.UINT256
      },
      {
        name: "blocksWithReservations",
        type: ABIDataTypes.UINT32
      },
      {
        name: "pricePerToken",
        type: ABIDataTypes.UINT64
      },
      {
        name: "reservationFeePercent",
        type: ABIDataTypes.UINT64
      },
      {
        name: "minReservationFee",
        type: ABIDataTypes.UINT64
      }
    ]
  },
  {
    name: "airdrop",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "addresses",
        type: ABIDataTypes.ARRAY_OF_ADDRESSES
      },
      {
        name: "amounts",
        type: ABIDataTypes.ARRAY_OF_UINT8
      }
    ],
    outputs: []
  },
  {
    name: "setTokenURI",
    type: BitcoinAbiTypes.Function,
    inputs: [
      {
        name: "tokenId",
        type: ABIDataTypes.UINT256
      },
      {
        name: "uri",
        type: ABIDataTypes.STRING
      }
    ],
    outputs: []
  },
  ...EXTENDED_OP721_EVENTS,
  ...OP_721_ABI
];

const MultiOracleStablecoinEvents = [
  {
    name: "OracleAdded",
    values: [
      { name: "oracle", type: ABIDataTypes.ADDRESS },
      { name: "addedBy", type: ABIDataTypes.ADDRESS }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "OracleRemoved",
    values: [
      { name: "oracle", type: ABIDataTypes.ADDRESS },
      { name: "removedBy", type: ABIDataTypes.ADDRESS }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "PriceSubmitted",
    values: [
      { name: "oracle", type: ABIDataTypes.ADDRESS },
      { name: "price", type: ABIDataTypes.UINT256 },
      { name: "blockNumber", type: ABIDataTypes.UINT64 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "PriceAggregated",
    values: [
      { name: "medianPrice", type: ABIDataTypes.UINT256 },
      { name: "oracleCount", type: ABIDataTypes.UINT32 },
      { name: "blockNumber", type: ABIDataTypes.UINT64 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "Minted",
    values: [
      { name: "to", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 }
    ],
    type: BitcoinAbiTypes.Event
  }
];
const MultiOracleStablecoin_ABI = [
  {
    name: "addOracle",
    inputs: [{ name: "oracle", type: ABIDataTypes.ADDRESS }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "removeOracle",
    inputs: [{ name: "oracle", type: ABIDataTypes.ADDRESS }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "submitPrice",
    inputs: [{ name: "price", type: ABIDataTypes.UINT256 }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "aggregatePrice",
    inputs: [{ name: "oracles", type: ABIDataTypes.ARRAY_OF_ADDRESSES }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "mint",
    inputs: [
      { name: "to", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "oracleCount",
    inputs: [],
    outputs: [{ name: "count", type: ABIDataTypes.UINT256 }],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "minOracles",
    inputs: [],
    outputs: [{ name: "min", type: ABIDataTypes.UINT256 }],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "isOracleActive",
    inputs: [{ name: "oracle", type: ABIDataTypes.ADDRESS }],
    outputs: [{ name: "active", type: ABIDataTypes.BOOL }],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "oracleSubmission",
    inputs: [{ name: "oracle", type: ABIDataTypes.ADDRESS }],
    outputs: [{ name: "price", type: ABIDataTypes.UINT256 }],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "admin",
    inputs: [],
    outputs: [{ name: "admin", type: ABIDataTypes.ADDRESS }],
    type: BitcoinAbiTypes.Function
  },
  ...MultiOracleStablecoinEvents,
  ...OP_20S_ABI
];

const StableCoinEvents = [
  {
    name: "Minted",
    values: [
      { name: "to", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "Burned",
    values: [
      { name: "from", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "Blacklisted",
    values: [
      { name: "account", type: ABIDataTypes.ADDRESS },
      { name: "blacklister", type: ABIDataTypes.ADDRESS }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "Unblacklisted",
    values: [
      { name: "account", type: ABIDataTypes.ADDRESS },
      { name: "blacklister", type: ABIDataTypes.ADDRESS }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "Paused",
    values: [{ name: "pauser", type: ABIDataTypes.ADDRESS }],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "Unpaused",
    values: [{ name: "pauser", type: ABIDataTypes.ADDRESS }],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "OwnershipTransferStarted",
    values: [
      { name: "currentOwner", type: ABIDataTypes.ADDRESS },
      { name: "pendingOwner", type: ABIDataTypes.ADDRESS }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "OwnershipTransferred",
    values: [
      { name: "previousOwner", type: ABIDataTypes.ADDRESS },
      { name: "newOwner", type: ABIDataTypes.ADDRESS }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "MinterChanged",
    values: [
      { name: "previousMinter", type: ABIDataTypes.ADDRESS },
      { name: "newMinter", type: ABIDataTypes.ADDRESS }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "BlacklisterChanged",
    values: [
      { name: "previousBlacklister", type: ABIDataTypes.ADDRESS },
      { name: "newBlacklister", type: ABIDataTypes.ADDRESS }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "PauserChanged",
    values: [
      { name: "previousPauser", type: ABIDataTypes.ADDRESS },
      { name: "newPauser", type: ABIDataTypes.ADDRESS }
    ],
    type: BitcoinAbiTypes.Event
  }
];
const StableCoin_ABI = [
  {
    name: "mint",
    inputs: [
      { name: "to", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "burnFrom",
    inputs: [
      { name: "from", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "blacklist",
    inputs: [{ name: "account", type: ABIDataTypes.ADDRESS }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "unblacklist",
    inputs: [{ name: "account", type: ABIDataTypes.ADDRESS }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "isBlacklisted",
    inputs: [{ name: "account", type: ABIDataTypes.ADDRESS }],
    outputs: [{ name: "blacklisted", type: ABIDataTypes.BOOL }],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "pause",
    inputs: [],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "unpause",
    inputs: [],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "isPaused",
    inputs: [],
    outputs: [{ name: "paused", type: ABIDataTypes.BOOL }],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "transferOwnership",
    inputs: [{ name: "newOwner", type: ABIDataTypes.ADDRESS }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "acceptOwnership",
    inputs: [],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "setMinter",
    inputs: [{ name: "newMinter", type: ABIDataTypes.ADDRESS }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "setBlacklister",
    inputs: [{ name: "newBlacklister", type: ABIDataTypes.ADDRESS }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "setPauser",
    inputs: [{ name: "newPauser", type: ABIDataTypes.ADDRESS }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "owner",
    inputs: [],
    outputs: [{ name: "owner", type: ABIDataTypes.ADDRESS }],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "minter",
    inputs: [],
    outputs: [{ name: "minter", type: ABIDataTypes.ADDRESS }],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "blacklister",
    inputs: [],
    outputs: [{ name: "blacklister", type: ABIDataTypes.ADDRESS }],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "pauser",
    inputs: [],
    outputs: [{ name: "pauser", type: ABIDataTypes.ADDRESS }],
    type: BitcoinAbiTypes.Function
  },
  ...StableCoinEvents,
  ...OP_20S_ABI
];

const PeggedTokenEvents = [
  {
    name: "Minted",
    values: [
      { name: "to", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "Burned",
    values: [
      { name: "from", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 }
    ],
    type: BitcoinAbiTypes.Event
  },
  {
    name: "CustodianChanged",
    values: [
      { name: "previousCustodian", type: ABIDataTypes.ADDRESS },
      { name: "newCustodian", type: ABIDataTypes.ADDRESS }
    ],
    type: BitcoinAbiTypes.Event
  }
];
const PeggedToken_ABI = [
  {
    name: "mint",
    inputs: [
      { name: "to", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "burnFrom",
    inputs: [
      { name: "from", type: ABIDataTypes.ADDRESS },
      { name: "amount", type: ABIDataTypes.UINT256 }
    ],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "transferCustodian",
    inputs: [{ name: "newCustodian", type: ABIDataTypes.ADDRESS }],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "acceptCustodian",
    inputs: [],
    outputs: [],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "custodian",
    inputs: [],
    outputs: [{ name: "custodian", type: ABIDataTypes.ADDRESS }],
    type: BitcoinAbiTypes.Function
  },
  {
    name: "pendingCustodian",
    inputs: [],
    outputs: [{ name: "pendingCustodian", type: ABIDataTypes.ADDRESS }],
    type: BitcoinAbiTypes.Function
  },
  ...PeggedTokenEvents,
  ...OP_20S_ABI
];

const opnet = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    get ABIDataTypes () { return ABIDataTypes; },
    AbiTypeToStr,
    AbstractRpcProvider,
    AuthError,
    BaseContract,
    BitcoinAbiTypes,
    BitcoinInterface,
    BitcoinUtils,
    Block,
    BlockGasParameters,
    BlockWitness,
    BlockWitnessAPI,
    CallResult,
    CallResultSerializer,
    ConnectionState,
    ContractData,
    DEFAULT_CONFIG,
    DeploymentTransaction,
    EXTENDED_OP721_ABI,
    EXTENDED_OP721_EVENTS,
    Epoch,
    EpochDifficultyConverter,
    EpochMiner,
    EpochSubmission,
    EpochTemplate,
    EpochWithSubmissions,
    ErrorMessages,
    GenericTransaction,
    IBaseContract,
    InteractionTransaction,
    InternalError,
    JSONRPCErrorCode,
    JSONRPCErrorHttpCodes,
    JSONRpcMethods,
    JSONRpcProvider,
    MOTOCHEF_ABI,
    MOTOSWAP_ROUTER_ABI,
    MOTOSWAP_STAKING_ABI,
    MOTO_ABI,
    MotoSwapFactoryAbi,
    MotoSwapFactoryEvents,
    MotoSwapPoolEvents,
    MotoswapPoolAbi,
    MultiOracleStablecoinEvents,
    MultiOracleStablecoin_ABI,
    NativeSwapAbi,
    NetworkName,
    OP20Events,
    OP721Events,
    OPNetError,
    OPNetEvent,
    OPNetTransactionTypes,
    OP_20S_ABI,
    OP_20_ABI,
    OP_721_ABI,
    OP_NET_ABI,
    PeggedTokenEvents,
    PeggedToken_ABI,
    ProtocolError,
    ResourceError,
    STAKING_ABI,
    StableCoinEvents,
    StableCoin_ABI,
    StoredValue,
    SubmissionStatus,
    SubmittedEpoch,
    SubscriptionType,
    TransactionBase,
    TransactionInput,
    TransactionInputFlags,
    TransactionOutput,
    TransactionOutputFlags,
    TransactionParser,
    TransactionReceipt,
    UTXO,
    UTXOsManager,
    ValidationError,
    WebSocketClientEvent,
    WebSocketRequestOpcode,
    WebSocketResponseOpcode,
    WebSocketRpcProvider,
    clearProtobufCache,
    decodeRevertData,
    getConnectionStateName,
    getContract,
    getErrorMessage,
    getProtobufType,
    getSubscriptionTypeName,
    loadProtobufSchema,
    parseBlockWitnesses,
    stringBase64ToBuffer,
    stringToBuffer,
    version
}, Symbol.toStringTag, { value: 'Module' }));

export { ABIDataTypes, AbiTypeToStr, AbstractRpcProvider, AuthError, BaseContract, BitcoinAbiTypes, BitcoinInterface, BitcoinUtils, Block, BlockGasParameters, BlockWitness, BlockWitnessAPI, CallResult, CallResultSerializer, ConnectionState, ContractData, DEFAULT_CONFIG, DeploymentTransaction, EXTENDED_OP721_ABI, EXTENDED_OP721_EVENTS, Epoch, EpochDifficultyConverter, EpochMiner, EpochSubmission, EpochTemplate, EpochWithSubmissions, ErrorMessages, GenericTransaction, IBaseContract, InteractionTransaction, InternalError, JSONRPCErrorCode, JSONRPCErrorHttpCodes, JSONRpcMethods, JSONRpcProvider, MOTOCHEF_ABI, MOTOSWAP_ROUTER_ABI, MOTOSWAP_STAKING_ABI, MOTO_ABI, MotoSwapFactoryAbi, MotoSwapFactoryEvents, MotoSwapPoolEvents, MotoswapPoolAbi, MultiOracleStablecoinEvents, MultiOracleStablecoin_ABI, NativeSwapAbi, NetworkName, OP20Events, OP721Events, OPNetError, OPNetEvent, OPNetTransactionTypes, OP_20S_ABI, OP_20_ABI, OP_721_ABI, OP_NET_ABI, PeggedTokenEvents, PeggedToken_ABI, ProtocolError, ResourceError, STAKING_ABI, StableCoinEvents, StableCoin_ABI, StoredValue, SubmissionStatus, SubmittedEpoch, SubscriptionType, TransactionBase, TransactionInput, TransactionInputFlags, TransactionOutput, TransactionOutputFlags, TransactionParser, TransactionReceipt, UTXO, UTXOsManager, ValidationError, WebSocketClientEvent, WebSocketRequestOpcode, WebSocketResponseOpcode, WebSocketRpcProvider, clearProtobufCache, decodeRevertData, getConnectionStateName, getContract, getErrorMessage, getProtobufType, getSubscriptionTypeName, loadProtobufSchema, opnet, parseBlockWitnesses, stringBase64ToBuffer, stringToBuffer, version };
