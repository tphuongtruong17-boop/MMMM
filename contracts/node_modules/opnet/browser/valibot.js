var dist = {};

var hasRequiredDist;

function requireDist () {
	if (hasRequiredDist) return dist;
	hasRequiredDist = 1;
	let store$4;
	function setGlobalConfig(config$1) {
	  store$4 = {
	    ...store$4,
	    ...config$1
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function getGlobalConfig(config$1) {
	  return {
	    lang: config$1?.lang ?? store$4?.lang,
	    message: config$1?.message,
	    abortEarly: config$1?.abortEarly ?? store$4?.abortEarly,
	    abortPipeEarly: config$1?.abortPipeEarly ?? store$4?.abortPipeEarly
	  };
	}
	function deleteGlobalConfig() {
	  store$4 = void 0;
	}
	let store$3;
	function setGlobalMessage(message$1, lang) {
	  if (!store$3) store$3 = /* @__PURE__ */ new Map();
	  store$3.set(lang, message$1);
	}
	// @__NO_SIDE_EFFECTS__
	function getGlobalMessage(lang) {
	  return store$3?.get(lang);
	}
	function deleteGlobalMessage(lang) {
	  store$3?.delete(lang);
	}
	let store$2;
	function setSchemaMessage(message$1, lang) {
	  if (!store$2) store$2 = /* @__PURE__ */ new Map();
	  store$2.set(lang, message$1);
	}
	// @__NO_SIDE_EFFECTS__
	function getSchemaMessage(lang) {
	  return store$2?.get(lang);
	}
	function deleteSchemaMessage(lang) {
	  store$2?.delete(lang);
	}
	let store$1;
	function setSpecificMessage(reference, message$1, lang) {
	  if (!store$1) store$1 = /* @__PURE__ */ new Map();
	  if (!store$1.get(reference)) store$1.set(reference, /* @__PURE__ */ new Map());
	  store$1.get(reference).set(lang, message$1);
	}
	// @__NO_SIDE_EFFECTS__
	function getSpecificMessage(reference, lang) {
	  return store$1?.get(reference)?.get(lang);
	}
	function deleteSpecificMessage(reference, lang) {
	  store$1?.get(reference)?.delete(lang);
	}
	// @__NO_SIDE_EFFECTS__
	function _stringify(input) {
	  const type = typeof input;
	  if (type === "string") return `"${input}"`;
	  if (type === "number" || type === "bigint" || type === "boolean") return `${input}`;
	  if (type === "object" || type === "function") return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? "null";
	  return type;
	}
	function _addIssue(context, label, dataset, config$1, other) {
	  const input = other && "input" in other ? other.input : dataset.value;
	  const expected = other?.expected ?? context.expects ?? null;
	  const received = other?.received ?? /* @__PURE__ */ _stringify(input);
	  const issue = {
	    kind: context.kind,
	    type: context.type,
	    input,
	    expected,
	    received,
	    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : "R"}eceived ${received}`,
	    requirement: context.requirement,
	    path: other?.path,
	    issues: other?.issues,
	    lang: config$1.lang,
	    abortEarly: config$1.abortEarly,
	    abortPipeEarly: config$1.abortPipeEarly
	  };
	  const isSchema = context.kind === "schema";
	  const message$1 = other?.message ?? context.message ?? /* @__PURE__ */ getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? /* @__PURE__ */ getSchemaMessage(issue.lang) : null) ?? config$1.message ?? /* @__PURE__ */ getGlobalMessage(issue.lang);
	  if (message$1 !== void 0) issue.message = typeof message$1 === "function" ? message$1(issue) : message$1;
	  if (isSchema) dataset.typed = false;
	  if (dataset.issues) dataset.issues.push(issue);
	  else dataset.issues = [issue];
	}
	let textEncoder;
	// @__NO_SIDE_EFFECTS__
	function _getByteCount(input) {
	  if (!textEncoder) textEncoder = new TextEncoder();
	  return textEncoder.encode(input).length;
	}
	let segmenter;
	// @__NO_SIDE_EFFECTS__
	function _getGraphemeCount(input) {
	  if (!segmenter) segmenter = new Intl.Segmenter();
	  const segments = segmenter.segment(input);
	  let count = 0;
	  for (const _ of segments) count++;
	  return count;
	}
	// @__NO_SIDE_EFFECTS__
	function _getLastMetadata(schema, type) {
	  if ("pipe" in schema) {
	    const nestedSchemas = [];
	    for (let index = schema.pipe.length - 1; index >= 0; index--) {
	      const item = schema.pipe[index];
	      if (item.kind === "schema" && "pipe" in item) nestedSchemas.push(item);
	      else if (item.kind === "metadata" && item.type === type) return item[type];
	    }
	    for (const nestedSchema of nestedSchemas) {
	      const result = /* @__PURE__ */ _getLastMetadata(nestedSchema, type);
	      if (result !== void 0) return result;
	    }
	  }
	}
	// @__NO_SIDE_EFFECTS__
	function _getStandardProps(context) {
	  return {
	    version: 1,
	    vendor: "valibot",
	    validate(value$1) {
	      return context["~run"]({ value: value$1 }, /* @__PURE__ */ getGlobalConfig());
	    }
	  };
	}
	let store;
	// @__NO_SIDE_EFFECTS__
	function _getWordCount(locales, input) {
	  if (!store) store = /* @__PURE__ */ new Map();
	  if (!store.get(locales)) store.set(locales, new Intl.Segmenter(locales, { granularity: "word" }));
	  const segments = store.get(locales).segment(input);
	  let count = 0;
	  for (const segment of segments) if (segment.isWordLike) count++;
	  return count;
	}
	const NON_DIGIT_REGEX = /\D/gu;
	// @__NO_SIDE_EFFECTS__
	function _isLuhnAlgo(input) {
	  const number$1 = input.replace(NON_DIGIT_REGEX, "");
	  let length$1 = number$1.length;
	  let bit = 1;
	  let sum = 0;
	  while (length$1) {
	    const value$1 = +number$1[--length$1];
	    bit ^= 1;
	    sum += bit ? [
	      0,
	      2,
	      4,
	      6,
	      8,
	      1,
	      3,
	      5,
	      7,
	      9
	    ][value$1] : value$1;
	  }
	  return sum % 10 === 0;
	}
	// @__NO_SIDE_EFFECTS__
	function _isValidObjectKey(object$1, key) {
	  return Object.hasOwn(object$1, key) && key !== "__proto__" && key !== "prototype" && key !== "constructor";
	}
	// @__NO_SIDE_EFFECTS__
	function _joinExpects(values$1, separator) {
	  const list = [...new Set(values$1)];
	  if (list.length > 1) return `(${list.join(` ${separator} `)})`;
	  return list[0] ?? "never";
	}
	// @__NO_SIDE_EFFECTS__
	function entriesFromList(list, schema) {
	  const entries$1 = {};
	  for (const key of list) entries$1[key] = schema;
	  return entries$1;
	}
	// @__NO_SIDE_EFFECTS__
	function entriesFromObjects(schemas) {
	  const entries$1 = {};
	  for (const schema of schemas) Object.assign(entries$1, schema.entries);
	  return entries$1;
	}
	// @__NO_SIDE_EFFECTS__
	function getDotPath(issue) {
	  if (issue.path) {
	    let key = "";
	    for (const item of issue.path) if (typeof item.key === "string" || typeof item.key === "number") if (key) key += `.${item.key}`;
	    else key += item.key;
	    else return null;
	    return key;
	  }
	  return null;
	}
	// @__NO_SIDE_EFFECTS__
	function isOfKind(kind, object$1) {
	  return object$1.kind === kind;
	}
	// @__NO_SIDE_EFFECTS__
	function isOfType(type, object$1) {
	  return object$1.type === type;
	}
	// @__NO_SIDE_EFFECTS__
	function isValiError(error) {
	  return error instanceof ValiError;
	}
	var ValiError = class extends Error {
	  /**
	  * Creates a Valibot error with useful information.
	  *
	  * @param issues The error issues.
	  */
	  constructor(issues) {
	    super(issues[0].message);
	    this.name = "ValiError";
	    this.issues = issues;
	  }
	};
	// @__NO_SIDE_EFFECTS__
	function args(schema) {
	  return {
	    kind: "transformation",
	    type: "args",
	    reference: args,
	    async: false,
	    schema,
	    "~run"(dataset, config$1) {
	      const func = dataset.value;
	      dataset.value = (...args_) => {
	        const argsDataset = this.schema["~run"]({ value: args_ }, config$1);
	        if (argsDataset.issues) throw new ValiError(argsDataset.issues);
	        return func(...argsDataset.value);
	      };
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function argsAsync(schema) {
	  return {
	    kind: "transformation",
	    type: "args",
	    reference: argsAsync,
	    async: false,
	    schema,
	    "~run"(dataset, config$1) {
	      const func = dataset.value;
	      dataset.value = async (...args$1) => {
	        const argsDataset = await schema["~run"]({ value: args$1 }, config$1);
	        if (argsDataset.issues) throw new ValiError(argsDataset.issues);
	        return func(...argsDataset.value);
	      };
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function awaitAsync() {
	  return {
	    kind: "transformation",
	    type: "await",
	    reference: awaitAsync,
	    async: true,
	    async "~run"(dataset) {
	      dataset.value = await dataset.value;
	      return dataset;
	    }
	  };
	}
	const BASE64_REGEX = /^(?:[\da-z+/]{4})*(?:[\da-z+/]{2}==|[\da-z+/]{3}=)?$/iu;
	const BIC_REGEX = /^[A-Z]{6}(?!00)[\dA-Z]{2}(?:[\dA-Z]{3})?$/u;
	const CUID2_REGEX = /^[a-z][\da-z]*$/u;
	const DECIMAL_REGEX = /^[+-]?(?:\d*\.)?\d+$/u;
	const DIGITS_REGEX = /^\d+$/u;
	const EMAIL_REGEX = /^[\w+-]+(?:\.[\w+-]+)*@[\da-z]+(?:[.-][\da-z]+)*\.[a-z]{2,}$/iu;
	const EMOJI_REGEX = /^(?:[\u{1F1E6}-\u{1F1FF}]{2}|\u{1F3F4}[\u{E0061}-\u{E007A}]{2}[\u{E0030}-\u{E0039}\u{E0061}-\u{E007A}]{1,3}\u{E007F}|(?:\p{Emoji}\uFE0F\u20E3?|\p{Emoji_Modifier_Base}\p{Emoji_Modifier}?|(?![\p{Emoji_Modifier_Base}\u{1F1E6}-\u{1F1FF}])\p{Emoji_Presentation})(?:\u200D(?:\p{Emoji}\uFE0F\u20E3?|\p{Emoji_Modifier_Base}\p{Emoji_Modifier}?|(?![\p{Emoji_Modifier_Base}\u{1F1E6}-\u{1F1FF}])\p{Emoji_Presentation}))*)+$/u;
	const HEXADECIMAL_REGEX = /^(?:0[hx])?[\da-fA-F]+$/u;
	const HEX_COLOR_REGEX = /^#(?:[\da-fA-F]{3,4}|[\da-fA-F]{6}|[\da-fA-F]{8})$/u;
	const IMEI_REGEX = /^\d{15}$|^\d{2}-\d{6}-\d{6}-\d$/u;
	const IPV4_REGEX = /^(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])(?:\.(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])){3}$/u;
	const IPV6_REGEX = /^(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:|(?:[\da-f]{1,4}:){1,6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,5}(?::[\da-f]{1,4}){1,2}|(?:[\da-f]{1,4}:){1,4}(?::[\da-f]{1,4}){1,3}|(?:[\da-f]{1,4}:){1,3}(?::[\da-f]{1,4}){1,4}|(?:[\da-f]{1,4}:){1,2}(?::[\da-f]{1,4}){1,5}|[\da-f]{1,4}:(?::[\da-f]{1,4}){1,6}|:(?:(?::[\da-f]{1,4}){1,7}|:)|fe80:(?::[\da-f]{0,4}){0,4}%[\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d)|(?:[\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d))$/iu;
	const IP_REGEX = /^(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])(?:\.(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])){3}$|^(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:|(?:[\da-f]{1,4}:){1,6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,5}(?::[\da-f]{1,4}){1,2}|(?:[\da-f]{1,4}:){1,4}(?::[\da-f]{1,4}){1,3}|(?:[\da-f]{1,4}:){1,3}(?::[\da-f]{1,4}){1,4}|(?:[\da-f]{1,4}:){1,2}(?::[\da-f]{1,4}){1,5}|[\da-f]{1,4}:(?::[\da-f]{1,4}){1,6}|:(?:(?::[\da-f]{1,4}){1,7}|:)|fe80:(?::[\da-f]{0,4}){0,4}%[\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d)|(?:[\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d))$/iu;
	const ISO_DATE_REGEX = /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])$/u;
	const ISO_DATE_TIME_REGEX = /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])[T ](?:0\d|1\d|2[0-3]):[0-5]\d$/u;
	const ISO_TIME_REGEX = /^(?:0\d|1\d|2[0-3]):[0-5]\d$/u;
	const ISO_TIME_SECOND_REGEX = /^(?:0\d|1\d|2[0-3])(?::[0-5]\d){2}$/u;
	const ISO_TIMESTAMP_REGEX = /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])[T ](?:0\d|1\d|2[0-3])(?::[0-5]\d){2}(?:\.\d{1,9})?(?:Z|[+-](?:0\d|1\d|2[0-3])(?::?[0-5]\d)?)$/u;
	const ISO_WEEK_REGEX = /^\d{4}-W(?:0[1-9]|[1-4]\d|5[0-3])$/u;
	const MAC48_REGEX = /^(?:[\da-f]{2}:){5}[\da-f]{2}$|^(?:[\da-f]{2}-){5}[\da-f]{2}$|^(?:[\da-f]{4}\.){2}[\da-f]{4}$/iu;
	const MAC64_REGEX = /^(?:[\da-f]{2}:){7}[\da-f]{2}$|^(?:[\da-f]{2}-){7}[\da-f]{2}$|^(?:[\da-f]{4}\.){3}[\da-f]{4}$|^(?:[\da-f]{4}:){3}[\da-f]{4}$/iu;
	const MAC_REGEX = /^(?:[\da-f]{2}:){5}[\da-f]{2}$|^(?:[\da-f]{2}-){5}[\da-f]{2}$|^(?:[\da-f]{4}\.){2}[\da-f]{4}$|^(?:[\da-f]{2}:){7}[\da-f]{2}$|^(?:[\da-f]{2}-){7}[\da-f]{2}$|^(?:[\da-f]{4}\.){3}[\da-f]{4}$|^(?:[\da-f]{4}:){3}[\da-f]{4}$/iu;
	const NANO_ID_REGEX = /^[\w-]+$/u;
	const OCTAL_REGEX = /^(?:0o)?[0-7]+$/u;
	const RFC_EMAIL_REGEX = /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
	const SLUG_REGEX = /^[\da-z]+(?:[-_][\da-z]+)*$/u;
	const ULID_REGEX = /^[\da-hjkmnp-tv-zA-HJKMNP-TV-Z]{26}$/u;
	const UUID_REGEX = /^[\da-f]{8}(?:-[\da-f]{4}){3}-[\da-f]{12}$/iu;
	// @__NO_SIDE_EFFECTS__
	function base64(message$1) {
	  return {
	    kind: "validation",
	    type: "base64",
	    reference: base64,
	    async: false,
	    expects: null,
	    requirement: BASE64_REGEX,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "Base64", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function bic(message$1) {
	  return {
	    kind: "validation",
	    type: "bic",
	    reference: bic,
	    async: false,
	    expects: null,
	    requirement: BIC_REGEX,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "BIC", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function brand(name) {
	  return {
	    kind: "transformation",
	    type: "brand",
	    reference: brand,
	    async: false,
	    name,
	    "~run"(dataset) {
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function bytes(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "bytes",
	    reference: bytes,
	    async: false,
	    expects: `${requirement}`,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed) {
	        const length$1 = /* @__PURE__ */ _getByteCount(dataset.value);
	        if (length$1 !== this.requirement) _addIssue(this, "bytes", dataset, config$1, { received: `${length$1}` });
	      }
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function check(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "check",
	    reference: check,
	    async: false,
	    expects: null,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "input", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function checkAsync(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "check",
	    reference: checkAsync,
	    async: true,
	    expects: null,
	    requirement,
	    message: message$1,
	    async "~run"(dataset, config$1) {
	      if (dataset.typed && !await this.requirement(dataset.value)) _addIssue(this, "input", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function checkItems(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "check_items",
	    reference: checkItems,
	    async: false,
	    expects: null,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed) for (let index = 0; index < dataset.value.length; index++) {
	        const item = dataset.value[index];
	        if (!this.requirement(item, index, dataset.value)) _addIssue(this, "item", dataset, config$1, {
	          input: item,
	          path: [{
	            type: "array",
	            origin: "value",
	            input: dataset.value,
	            key: index,
	            value: item
	          }]
	        });
	      }
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function checkItemsAsync(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "check_items",
	    reference: checkItemsAsync,
	    async: true,
	    expects: null,
	    requirement,
	    message: message$1,
	    async "~run"(dataset, config$1) {
	      if (dataset.typed) {
	        const requirementResults = await Promise.all(dataset.value.map(this.requirement));
	        for (let index = 0; index < dataset.value.length; index++) if (!requirementResults[index]) {
	          const item = dataset.value[index];
	          _addIssue(this, "item", dataset, config$1, {
	            input: item,
	            path: [{
	              type: "array",
	              origin: "value",
	              input: dataset.value,
	              key: index,
	              value: item
	            }]
	          });
	        }
	      }
	      return dataset;
	    }
	  };
	}
	const CREDIT_CARD_REGEX = /^(?:\d{14,19}|\d{4}(?: \d{3,6}){2,4}|\d{4}(?:-\d{3,6}){2,4})$/u;
	const SANITIZE_REGEX = /[- ]/gu;
	const PROVIDER_REGEX_LIST = [
	  /^3[47]\d{13}$/u,
	  /^3(?:0[0-5]|[68]\d)\d{11,13}$/u,
	  /^6(?:011|5\d{2})\d{12,15}$/u,
	  /^(?:2131|1800|35\d{3})\d{11}$/u,
	  /^5[1-5]\d{2}|(?:222\d|22[3-9]\d|2[3-6]\d{2}|27[01]\d|2720)\d{12}$/u,
	  /^(?:6[27]\d{14,17}|81\d{14,17})$/u,
	  /^4\d{12}(?:\d{3,6})?$/u
	];
	// @__NO_SIDE_EFFECTS__
	function creditCard(message$1) {
	  return {
	    kind: "validation",
	    type: "credit_card",
	    reference: creditCard,
	    async: false,
	    expects: null,
	    requirement(input) {
	      let sanitized;
	      return CREDIT_CARD_REGEX.test(input) && (sanitized = input.replace(SANITIZE_REGEX, "")) && PROVIDER_REGEX_LIST.some((regex$1) => regex$1.test(sanitized)) && /* @__PURE__ */ _isLuhnAlgo(sanitized);
	    },
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "credit card", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function cuid2(message$1) {
	  return {
	    kind: "validation",
	    type: "cuid2",
	    reference: cuid2,
	    async: false,
	    expects: null,
	    requirement: CUID2_REGEX,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "Cuid2", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function decimal(message$1) {
	  return {
	    kind: "validation",
	    type: "decimal",
	    reference: decimal,
	    async: false,
	    expects: null,
	    requirement: DECIMAL_REGEX,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "decimal", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function description(description_) {
	  return {
	    kind: "metadata",
	    type: "description",
	    reference: description,
	    description: description_
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function digits(message$1) {
	  return {
	    kind: "validation",
	    type: "digits",
	    reference: digits,
	    async: false,
	    expects: null,
	    requirement: DIGITS_REGEX,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "digits", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function email(message$1) {
	  return {
	    kind: "validation",
	    type: "email",
	    reference: email,
	    expects: null,
	    async: false,
	    requirement: EMAIL_REGEX,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "email", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function emoji(message$1) {
	  return {
	    kind: "validation",
	    type: "emoji",
	    reference: emoji,
	    async: false,
	    expects: null,
	    requirement: EMOJI_REGEX,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "emoji", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function empty(message$1) {
	  return {
	    kind: "validation",
	    type: "empty",
	    reference: empty,
	    async: false,
	    expects: "0",
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && dataset.value.length > 0) _addIssue(this, "length", dataset, config$1, { received: `${dataset.value.length}` });
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function endsWith(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "ends_with",
	    reference: endsWith,
	    async: false,
	    expects: `"${requirement}"`,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !dataset.value.endsWith(this.requirement)) _addIssue(this, "end", dataset, config$1, { received: `"${dataset.value.slice(-this.requirement.length)}"` });
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function entries(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "entries",
	    reference: entries,
	    async: false,
	    expects: `${requirement}`,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (!dataset.typed) return dataset;
	      const count = Object.keys(dataset.value).length;
	      if (dataset.typed && count !== this.requirement) _addIssue(this, "entries", dataset, config$1, { received: `${count}` });
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function everyItem(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "every_item",
	    reference: everyItem,
	    async: false,
	    expects: null,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !dataset.value.every(this.requirement)) _addIssue(this, "item", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function examples(examples_) {
	  return {
	    kind: "metadata",
	    type: "examples",
	    reference: examples,
	    examples: examples_
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function excludes(requirement, message$1) {
	  const received = /* @__PURE__ */ _stringify(requirement);
	  return {
	    kind: "validation",
	    type: "excludes",
	    reference: excludes,
	    async: false,
	    expects: `!${received}`,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && dataset.value.includes(this.requirement)) _addIssue(this, "content", dataset, config$1, { received });
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function filterItems(operation) {
	  return {
	    kind: "transformation",
	    type: "filter_items",
	    reference: filterItems,
	    async: false,
	    operation,
	    "~run"(dataset) {
	      dataset.value = dataset.value.filter(this.operation);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function findItem(operation) {
	  return {
	    kind: "transformation",
	    type: "find_item",
	    reference: findItem,
	    async: false,
	    operation,
	    "~run"(dataset) {
	      dataset.value = dataset.value.find(this.operation);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function finite(message$1) {
	  return {
	    kind: "validation",
	    type: "finite",
	    reference: finite,
	    async: false,
	    expects: null,
	    requirement: Number.isFinite,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "finite", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function flavor(name) {
	  return {
	    kind: "transformation",
	    type: "flavor",
	    reference: flavor,
	    async: false,
	    name,
	    "~run"(dataset) {
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function graphemes(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "graphemes",
	    reference: graphemes,
	    async: false,
	    expects: `${requirement}`,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed) {
	        const count = /* @__PURE__ */ _getGraphemeCount(dataset.value);
	        if (count !== this.requirement) _addIssue(this, "graphemes", dataset, config$1, { received: `${count}` });
	      }
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function gtValue(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "gt_value",
	    reference: gtValue,
	    async: false,
	    expects: `>${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !(dataset.value > this.requirement)) _addIssue(this, "value", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });
	      return dataset;
	    }
	  };
	}
	const HASH_LENGTHS = {
	  md4: 32,
	  md5: 32,
	  sha1: 40,
	  sha256: 64,
	  sha384: 96,
	  sha512: 128,
	  ripemd128: 32,
	  ripemd160: 40,
	  tiger128: 32,
	  tiger160: 40,
	  tiger192: 48,
	  crc32: 8,
	  crc32b: 8,
	  adler32: 8
	};
	// @__NO_SIDE_EFFECTS__
	function hash(types, message$1) {
	  return {
	    kind: "validation",
	    type: "hash",
	    reference: hash,
	    expects: null,
	    async: false,
	    requirement: RegExp(types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join("|"), "iu"),
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "hash", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function hexadecimal(message$1) {
	  return {
	    kind: "validation",
	    type: "hexadecimal",
	    reference: hexadecimal,
	    async: false,
	    expects: null,
	    requirement: HEXADECIMAL_REGEX,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "hexadecimal", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function hexColor(message$1) {
	  return {
	    kind: "validation",
	    type: "hex_color",
	    reference: hexColor,
	    async: false,
	    expects: null,
	    requirement: HEX_COLOR_REGEX,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "hex color", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function imei(message$1) {
	  return {
	    kind: "validation",
	    type: "imei",
	    reference: imei,
	    async: false,
	    expects: null,
	    requirement(input) {
	      return IMEI_REGEX.test(input) && /* @__PURE__ */ _isLuhnAlgo(input);
	    },
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "IMEI", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function includes(requirement, message$1) {
	  const expects = /* @__PURE__ */ _stringify(requirement);
	  return {
	    kind: "validation",
	    type: "includes",
	    reference: includes,
	    async: false,
	    expects,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !dataset.value.includes(this.requirement)) _addIssue(this, "content", dataset, config$1, { received: `!${expects}` });
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function integer(message$1) {
	  return {
	    kind: "validation",
	    type: "integer",
	    reference: integer,
	    async: false,
	    expects: null,
	    requirement: Number.isInteger,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "integer", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function ip(message$1) {
	  return {
	    kind: "validation",
	    type: "ip",
	    reference: ip,
	    async: false,
	    expects: null,
	    requirement: IP_REGEX,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "IP", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function ipv4(message$1) {
	  return {
	    kind: "validation",
	    type: "ipv4",
	    reference: ipv4,
	    async: false,
	    expects: null,
	    requirement: IPV4_REGEX,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "IPv4", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function ipv6(message$1) {
	  return {
	    kind: "validation",
	    type: "ipv6",
	    reference: ipv6,
	    async: false,
	    expects: null,
	    requirement: IPV6_REGEX,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "IPv6", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function isoDate(message$1) {
	  return {
	    kind: "validation",
	    type: "iso_date",
	    reference: isoDate,
	    async: false,
	    expects: null,
	    requirement: ISO_DATE_REGEX,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "date", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function isoDateTime(message$1) {
	  return {
	    kind: "validation",
	    type: "iso_date_time",
	    reference: isoDateTime,
	    async: false,
	    expects: null,
	    requirement: ISO_DATE_TIME_REGEX,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "date-time", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function isoTime(message$1) {
	  return {
	    kind: "validation",
	    type: "iso_time",
	    reference: isoTime,
	    async: false,
	    expects: null,
	    requirement: ISO_TIME_REGEX,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "time", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function isoTimeSecond(message$1) {
	  return {
	    kind: "validation",
	    type: "iso_time_second",
	    reference: isoTimeSecond,
	    async: false,
	    expects: null,
	    requirement: ISO_TIME_SECOND_REGEX,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "time-second", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function isoTimestamp(message$1) {
	  return {
	    kind: "validation",
	    type: "iso_timestamp",
	    reference: isoTimestamp,
	    async: false,
	    expects: null,
	    requirement: ISO_TIMESTAMP_REGEX,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "timestamp", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function isoWeek(message$1) {
	  return {
	    kind: "validation",
	    type: "iso_week",
	    reference: isoWeek,
	    async: false,
	    expects: null,
	    requirement: ISO_WEEK_REGEX,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "week", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function length(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "length",
	    reference: length,
	    async: false,
	    expects: `${requirement}`,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && dataset.value.length !== this.requirement) _addIssue(this, "length", dataset, config$1, { received: `${dataset.value.length}` });
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function ltValue(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "lt_value",
	    reference: ltValue,
	    async: false,
	    expects: `<${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !(dataset.value < this.requirement)) _addIssue(this, "value", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function mac(message$1) {
	  return {
	    kind: "validation",
	    type: "mac",
	    reference: mac,
	    async: false,
	    expects: null,
	    requirement: MAC_REGEX,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "MAC", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function mac48(message$1) {
	  return {
	    kind: "validation",
	    type: "mac48",
	    reference: mac48,
	    async: false,
	    expects: null,
	    requirement: MAC48_REGEX,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "48-bit MAC", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function mac64(message$1) {
	  return {
	    kind: "validation",
	    type: "mac64",
	    reference: mac64,
	    async: false,
	    expects: null,
	    requirement: MAC64_REGEX,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "64-bit MAC", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function mapItems(operation) {
	  return {
	    kind: "transformation",
	    type: "map_items",
	    reference: mapItems,
	    async: false,
	    operation,
	    "~run"(dataset) {
	      dataset.value = dataset.value.map(this.operation);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function maxBytes(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "max_bytes",
	    reference: maxBytes,
	    async: false,
	    expects: `<=${requirement}`,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed) {
	        const length$1 = /* @__PURE__ */ _getByteCount(dataset.value);
	        if (length$1 > this.requirement) _addIssue(this, "bytes", dataset, config$1, { received: `${length$1}` });
	      }
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function maxEntries(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "max_entries",
	    reference: maxEntries,
	    async: false,
	    expects: `<=${requirement}`,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (!dataset.typed) return dataset;
	      const count = Object.keys(dataset.value).length;
	      if (dataset.typed && count > this.requirement) _addIssue(this, "entries", dataset, config$1, { received: `${count}` });
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function maxGraphemes(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "max_graphemes",
	    reference: maxGraphemes,
	    async: false,
	    expects: `<=${requirement}`,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed) {
	        const count = /* @__PURE__ */ _getGraphemeCount(dataset.value);
	        if (count > this.requirement) _addIssue(this, "graphemes", dataset, config$1, { received: `${count}` });
	      }
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function maxLength(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "max_length",
	    reference: maxLength,
	    async: false,
	    expects: `<=${requirement}`,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && dataset.value.length > this.requirement) _addIssue(this, "length", dataset, config$1, { received: `${dataset.value.length}` });
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function maxSize(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "max_size",
	    reference: maxSize,
	    async: false,
	    expects: `<=${requirement}`,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && dataset.value.size > this.requirement) _addIssue(this, "size", dataset, config$1, { received: `${dataset.value.size}` });
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function maxValue(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "max_value",
	    reference: maxValue,
	    async: false,
	    expects: `<=${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !(dataset.value <= this.requirement)) _addIssue(this, "value", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function maxWords(locales, requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "max_words",
	    reference: maxWords,
	    async: false,
	    expects: `<=${requirement}`,
	    locales,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed) {
	        const count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);
	        if (count > this.requirement) _addIssue(this, "words", dataset, config$1, { received: `${count}` });
	      }
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function metadata(metadata_) {
	  return {
	    kind: "metadata",
	    type: "metadata",
	    reference: metadata,
	    metadata: metadata_
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function mimeType(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "mime_type",
	    reference: mimeType,
	    async: false,
	    expects: /* @__PURE__ */ _joinExpects(requirement.map((option) => `"${option}"`), "|"),
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement.includes(dataset.value.type)) _addIssue(this, "MIME type", dataset, config$1, { received: `"${dataset.value.type}"` });
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function minBytes(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "min_bytes",
	    reference: minBytes,
	    async: false,
	    expects: `>=${requirement}`,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed) {
	        const length$1 = /* @__PURE__ */ _getByteCount(dataset.value);
	        if (length$1 < this.requirement) _addIssue(this, "bytes", dataset, config$1, { received: `${length$1}` });
	      }
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function minEntries(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "min_entries",
	    reference: minEntries,
	    async: false,
	    expects: `>=${requirement}`,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (!dataset.typed) return dataset;
	      const count = Object.keys(dataset.value).length;
	      if (dataset.typed && count < this.requirement) _addIssue(this, "entries", dataset, config$1, { received: `${count}` });
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function minGraphemes(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "min_graphemes",
	    reference: minGraphemes,
	    async: false,
	    expects: `>=${requirement}`,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed) {
	        const count = /* @__PURE__ */ _getGraphemeCount(dataset.value);
	        if (count < this.requirement) _addIssue(this, "graphemes", dataset, config$1, { received: `${count}` });
	      }
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function minLength(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "min_length",
	    reference: minLength,
	    async: false,
	    expects: `>=${requirement}`,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && dataset.value.length < this.requirement) _addIssue(this, "length", dataset, config$1, { received: `${dataset.value.length}` });
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function minSize(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "min_size",
	    reference: minSize,
	    async: false,
	    expects: `>=${requirement}`,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && dataset.value.size < this.requirement) _addIssue(this, "size", dataset, config$1, { received: `${dataset.value.size}` });
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function minValue(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "min_value",
	    reference: minValue,
	    async: false,
	    expects: `>=${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !(dataset.value >= this.requirement)) _addIssue(this, "value", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function minWords(locales, requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "min_words",
	    reference: minWords,
	    async: false,
	    expects: `>=${requirement}`,
	    locales,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed) {
	        const count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);
	        if (count < this.requirement) _addIssue(this, "words", dataset, config$1, { received: `${count}` });
	      }
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function multipleOf(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "multiple_of",
	    reference: multipleOf,
	    async: false,
	    expects: `%${requirement}`,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && dataset.value % this.requirement != 0) _addIssue(this, "multiple", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function nanoid(message$1) {
	  return {
	    kind: "validation",
	    type: "nanoid",
	    reference: nanoid,
	    async: false,
	    expects: null,
	    requirement: NANO_ID_REGEX,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "Nano ID", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function nonEmpty(message$1) {
	  return {
	    kind: "validation",
	    type: "non_empty",
	    reference: nonEmpty,
	    async: false,
	    expects: "!0",
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && dataset.value.length === 0) _addIssue(this, "length", dataset, config$1, { received: "0" });
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function normalize(form) {
	  return {
	    kind: "transformation",
	    type: "normalize",
	    reference: normalize,
	    async: false,
	    form,
	    "~run"(dataset) {
	      dataset.value = dataset.value.normalize(this.form);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function notBytes(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "not_bytes",
	    reference: notBytes,
	    async: false,
	    expects: `!${requirement}`,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed) {
	        const length$1 = /* @__PURE__ */ _getByteCount(dataset.value);
	        if (length$1 === this.requirement) _addIssue(this, "bytes", dataset, config$1, { received: `${length$1}` });
	      }
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function notEntries(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "not_entries",
	    reference: notEntries,
	    async: false,
	    expects: `!${requirement}`,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (!dataset.typed) return dataset;
	      const count = Object.keys(dataset.value).length;
	      if (dataset.typed && count === this.requirement) _addIssue(this, "entries", dataset, config$1, { received: `${count}` });
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function notGraphemes(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "not_graphemes",
	    reference: notGraphemes,
	    async: false,
	    expects: `!${requirement}`,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed) {
	        const count = /* @__PURE__ */ _getGraphemeCount(dataset.value);
	        if (count === this.requirement) _addIssue(this, "graphemes", dataset, config$1, { received: `${count}` });
	      }
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function notLength(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "not_length",
	    reference: notLength,
	    async: false,
	    expects: `!${requirement}`,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && dataset.value.length === this.requirement) _addIssue(this, "length", dataset, config$1, { received: `${dataset.value.length}` });
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function notSize(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "not_size",
	    reference: notSize,
	    async: false,
	    expects: `!${requirement}`,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && dataset.value.size === this.requirement) _addIssue(this, "size", dataset, config$1, { received: `${dataset.value.size}` });
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function notValue(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "not_value",
	    reference: notValue,
	    async: false,
	    expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${/* @__PURE__ */ _stringify(requirement)}`,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) _addIssue(this, "value", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function notValues(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "not_values",
	    reference: notValues,
	    async: false,
	    expects: `!${/* @__PURE__ */ _joinExpects(requirement.map((value$1) => value$1 instanceof Date ? value$1.toJSON() : /* @__PURE__ */ _stringify(value$1)), "|")}`,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && this.requirement.some((value$1) => value$1 <= dataset.value && value$1 >= dataset.value)) _addIssue(this, "value", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function notWords(locales, requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "not_words",
	    reference: notWords,
	    async: false,
	    expects: `!${requirement}`,
	    locales,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed) {
	        const count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);
	        if (count === this.requirement) _addIssue(this, "words", dataset, config$1, { received: `${count}` });
	      }
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function octal(message$1) {
	  return {
	    kind: "validation",
	    type: "octal",
	    reference: octal,
	    async: false,
	    expects: null,
	    requirement: OCTAL_REGEX,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "octal", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function parseJson(config$1, message$1) {
	  return {
	    kind: "transformation",
	    type: "parse_json",
	    reference: parseJson,
	    config: config$1,
	    message: message$1,
	    async: false,
	    "~run"(dataset, config$2) {
	      try {
	        dataset.value = JSON.parse(dataset.value, this.config?.reviver);
	      } catch (error) {
	        if (error instanceof Error) {
	          _addIssue(this, "JSON", dataset, config$2, { received: `"${error.message}"` });
	          dataset.typed = false;
	        } else throw error;
	      }
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function _isPartiallyTyped(dataset, paths) {
	  if (dataset.issues) for (const path of paths) for (const issue of dataset.issues) {
	    let typed = false;
	    const bound = Math.min(path.length, issue.path?.length ?? 0);
	    for (let index = 0; index < bound; index++) if (path[index] !== issue.path[index].key && (path[index] !== "$" || issue.path[index].type !== "array")) {
	      typed = true;
	      break;
	    }
	    if (!typed) return false;
	  }
	  return true;
	}
	// @__NO_SIDE_EFFECTS__
	function partialCheck(paths, requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "partial_check",
	    reference: partialCheck,
	    async: false,
	    expects: null,
	    paths,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if ((dataset.typed || /* @__PURE__ */ _isPartiallyTyped(dataset, paths)) && !this.requirement(dataset.value)) _addIssue(this, "input", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function partialCheckAsync(paths, requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "partial_check",
	    reference: partialCheckAsync,
	    async: true,
	    expects: null,
	    paths,
	    requirement,
	    message: message$1,
	    async "~run"(dataset, config$1) {
	      if ((dataset.typed || /* @__PURE__ */ _isPartiallyTyped(dataset, paths)) && !await this.requirement(dataset.value)) _addIssue(this, "input", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function rawCheck(action) {
	  return {
	    kind: "validation",
	    type: "raw_check",
	    reference: rawCheck,
	    async: false,
	    expects: null,
	    "~run"(dataset, config$1) {
	      action({
	        dataset,
	        config: config$1,
	        addIssue: (info) => _addIssue(this, info?.label ?? "input", dataset, config$1, info)
	      });
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function rawCheckAsync(action) {
	  return {
	    kind: "validation",
	    type: "raw_check",
	    reference: rawCheckAsync,
	    async: true,
	    expects: null,
	    async "~run"(dataset, config$1) {
	      await action({
	        dataset,
	        config: config$1,
	        addIssue: (info) => _addIssue(this, info?.label ?? "input", dataset, config$1, info)
	      });
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function rawTransform(action) {
	  return {
	    kind: "transformation",
	    type: "raw_transform",
	    reference: rawTransform,
	    async: false,
	    "~run"(dataset, config$1) {
	      const output = action({
	        dataset,
	        config: config$1,
	        addIssue: (info) => _addIssue(this, info?.label ?? "input", dataset, config$1, info),
	        NEVER: null
	      });
	      if (dataset.issues) dataset.typed = false;
	      else dataset.value = output;
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function rawTransformAsync(action) {
	  return {
	    kind: "transformation",
	    type: "raw_transform",
	    reference: rawTransformAsync,
	    async: true,
	    async "~run"(dataset, config$1) {
	      const output = await action({
	        dataset,
	        config: config$1,
	        addIssue: (info) => _addIssue(this, info?.label ?? "input", dataset, config$1, info),
	        NEVER: null
	      });
	      if (dataset.issues) dataset.typed = false;
	      else dataset.value = output;
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function readonly() {
	  return {
	    kind: "transformation",
	    type: "readonly",
	    reference: readonly,
	    async: false,
	    "~run"(dataset) {
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function reduceItems(operation, initial) {
	  return {
	    kind: "transformation",
	    type: "reduce_items",
	    reference: reduceItems,
	    async: false,
	    operation,
	    initial,
	    "~run"(dataset) {
	      dataset.value = dataset.value.reduce(this.operation, this.initial);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function regex(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "regex",
	    reference: regex,
	    async: false,
	    expects: `${requirement}`,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "format", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function returns(schema) {
	  return {
	    kind: "transformation",
	    type: "returns",
	    reference: returns,
	    async: false,
	    schema,
	    "~run"(dataset, config$1) {
	      const func = dataset.value;
	      dataset.value = (...args_) => {
	        const returnsDataset = this.schema["~run"]({ value: func(...args_) }, config$1);
	        if (returnsDataset.issues) throw new ValiError(returnsDataset.issues);
	        return returnsDataset.value;
	      };
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function returnsAsync(schema) {
	  return {
	    kind: "transformation",
	    type: "returns",
	    reference: returnsAsync,
	    async: false,
	    schema,
	    "~run"(dataset, config$1) {
	      const func = dataset.value;
	      dataset.value = async (...args_) => {
	        const returnsDataset = await this.schema["~run"]({ value: await func(...args_) }, config$1);
	        if (returnsDataset.issues) throw new ValiError(returnsDataset.issues);
	        return returnsDataset.value;
	      };
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function rfcEmail(message$1) {
	  return {
	    kind: "validation",
	    type: "rfc_email",
	    reference: rfcEmail,
	    expects: null,
	    async: false,
	    requirement: RFC_EMAIL_REGEX,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "email", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function safeInteger(message$1) {
	  return {
	    kind: "validation",
	    type: "safe_integer",
	    reference: safeInteger,
	    async: false,
	    expects: null,
	    requirement: Number.isSafeInteger,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "safe integer", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function size(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "size",
	    reference: size,
	    async: false,
	    expects: `${requirement}`,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && dataset.value.size !== this.requirement) _addIssue(this, "size", dataset, config$1, { received: `${dataset.value.size}` });
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function slug(message$1) {
	  return {
	    kind: "validation",
	    type: "slug",
	    reference: slug,
	    async: false,
	    expects: null,
	    requirement: SLUG_REGEX,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "slug", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function someItem(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "some_item",
	    reference: someItem,
	    async: false,
	    expects: null,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !dataset.value.some(this.requirement)) _addIssue(this, "item", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function sortItems(operation) {
	  return {
	    kind: "transformation",
	    type: "sort_items",
	    reference: sortItems,
	    async: false,
	    operation,
	    "~run"(dataset) {
	      dataset.value = dataset.value.sort(this.operation);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function startsWith(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "starts_with",
	    reference: startsWith,
	    async: false,
	    expects: `"${requirement}"`,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !dataset.value.startsWith(this.requirement)) _addIssue(this, "start", dataset, config$1, { received: `"${dataset.value.slice(0, this.requirement.length)}"` });
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function stringifyJson(config$1, message$1) {
	  return {
	    kind: "transformation",
	    type: "stringify_json",
	    reference: stringifyJson,
	    message: message$1,
	    config: config$1,
	    async: false,
	    "~run"(dataset, config$2) {
	      try {
	        const output = JSON.stringify(dataset.value, this.config?.replacer, this.config?.space);
	        if (output === void 0) {
	          _addIssue(this, "JSON", dataset, config$2);
	          dataset.typed = false;
	        }
	        dataset.value = output;
	      } catch (error) {
	        if (error instanceof Error) {
	          _addIssue(this, "JSON", dataset, config$2, { received: `"${error.message}"` });
	          dataset.typed = false;
	        } else throw error;
	      }
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function title(title_) {
	  return {
	    kind: "metadata",
	    type: "title",
	    reference: title,
	    title: title_
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function toBigint(message$1) {
	  return {
	    kind: "transformation",
	    type: "to_bigint",
	    reference: toBigint,
	    async: false,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      try {
	        dataset.value = BigInt(dataset.value);
	      } catch {
	        _addIssue(this, "bigint", dataset, config$1);
	        dataset.typed = false;
	      }
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function toBoolean() {
	  return {
	    kind: "transformation",
	    type: "to_boolean",
	    reference: toBoolean,
	    async: false,
	    "~run"(dataset) {
	      dataset.value = Boolean(dataset.value);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function toDate(message$1) {
	  return {
	    kind: "transformation",
	    type: "to_date",
	    reference: toDate,
	    async: false,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      try {
	        dataset.value = new Date(dataset.value);
	        if (isNaN(dataset.value)) {
	          _addIssue(this, "date", dataset, config$1, { received: '"Invalid Date"' });
	          dataset.typed = false;
	        }
	      } catch {
	        _addIssue(this, "date", dataset, config$1);
	        dataset.typed = false;
	      }
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function toLowerCase() {
	  return {
	    kind: "transformation",
	    type: "to_lower_case",
	    reference: toLowerCase,
	    async: false,
	    "~run"(dataset) {
	      dataset.value = dataset.value.toLowerCase();
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function toMaxValue(requirement) {
	  return {
	    kind: "transformation",
	    type: "to_max_value",
	    reference: toMaxValue,
	    async: false,
	    requirement,
	    "~run"(dataset) {
	      dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function toMinValue(requirement) {
	  return {
	    kind: "transformation",
	    type: "to_min_value",
	    reference: toMinValue,
	    async: false,
	    requirement,
	    "~run"(dataset) {
	      dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function toNumber(message$1) {
	  return {
	    kind: "transformation",
	    type: "to_number",
	    reference: toNumber,
	    async: false,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      try {
	        dataset.value = Number(dataset.value);
	        if (isNaN(dataset.value)) {
	          _addIssue(this, "number", dataset, config$1);
	          dataset.typed = false;
	        }
	      } catch {
	        _addIssue(this, "number", dataset, config$1);
	        dataset.typed = false;
	      }
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function toString(message$1) {
	  return {
	    kind: "transformation",
	    type: "to_string",
	    reference: toString,
	    async: false,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      try {
	        dataset.value = String(dataset.value);
	      } catch {
	        _addIssue(this, "string", dataset, config$1);
	        dataset.typed = false;
	      }
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function toUpperCase() {
	  return {
	    kind: "transformation",
	    type: "to_upper_case",
	    reference: toUpperCase,
	    async: false,
	    "~run"(dataset) {
	      dataset.value = dataset.value.toUpperCase();
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function transform(operation) {
	  return {
	    kind: "transformation",
	    type: "transform",
	    reference: transform,
	    async: false,
	    operation,
	    "~run"(dataset) {
	      dataset.value = this.operation(dataset.value);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function transformAsync(operation) {
	  return {
	    kind: "transformation",
	    type: "transform",
	    reference: transformAsync,
	    async: true,
	    operation,
	    async "~run"(dataset) {
	      dataset.value = await this.operation(dataset.value);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function trim() {
	  return {
	    kind: "transformation",
	    type: "trim",
	    reference: trim,
	    async: false,
	    "~run"(dataset) {
	      dataset.value = dataset.value.trim();
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function trimEnd() {
	  return {
	    kind: "transformation",
	    type: "trim_end",
	    reference: trimEnd,
	    async: false,
	    "~run"(dataset) {
	      dataset.value = dataset.value.trimEnd();
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function trimStart() {
	  return {
	    kind: "transformation",
	    type: "trim_start",
	    reference: trimStart,
	    async: false,
	    "~run"(dataset) {
	      dataset.value = dataset.value.trimStart();
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function ulid(message$1) {
	  return {
	    kind: "validation",
	    type: "ulid",
	    reference: ulid,
	    async: false,
	    expects: null,
	    requirement: ULID_REGEX,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "ULID", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function url(message$1) {
	  return {
	    kind: "validation",
	    type: "url",
	    reference: url,
	    async: false,
	    expects: null,
	    requirement(input) {
	      try {
	        new URL(input);
	        return true;
	      } catch {
	        return false;
	      }
	    },
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "URL", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function uuid(message$1) {
	  return {
	    kind: "validation",
	    type: "uuid",
	    reference: uuid,
	    async: false,
	    expects: null,
	    requirement: UUID_REGEX,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "UUID", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function value(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "value",
	    reference: value,
	    async: false,
	    expects: requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement),
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) _addIssue(this, "value", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function values(requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "values",
	    reference: values,
	    async: false,
	    expects: `${/* @__PURE__ */ _joinExpects(requirement.map((value$1) => value$1 instanceof Date ? value$1.toJSON() : /* @__PURE__ */ _stringify(value$1)), "|")}`,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed && !this.requirement.some((value$1) => value$1 <= dataset.value && value$1 >= dataset.value)) _addIssue(this, "value", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function words(locales, requirement, message$1) {
	  return {
	    kind: "validation",
	    type: "words",
	    reference: words,
	    async: false,
	    expects: `${requirement}`,
	    locales,
	    requirement,
	    message: message$1,
	    "~run"(dataset, config$1) {
	      if (dataset.typed) {
	        const count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);
	        if (count !== this.requirement) _addIssue(this, "words", dataset, config$1, { received: `${count}` });
	      }
	      return dataset;
	    }
	  };
	}
	function assert(schema, input) {
	  const issues = schema["~run"]({ value: input }, { abortEarly: true }).issues;
	  if (issues) throw new ValiError(issues);
	}
	// @__NO_SIDE_EFFECTS__
	function config(schema, config$1) {
	  return {
	    ...schema,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config_) {
	      return schema["~run"](dataset, {
	        ...config_,
	        ...config$1
	      });
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function getFallback(schema, dataset, config$1) {
	  return typeof schema.fallback === "function" ? schema.fallback(dataset, config$1) : schema.fallback;
	}
	// @__NO_SIDE_EFFECTS__
	function fallback(schema, fallback$1) {
	  return {
	    ...schema,
	    fallback: fallback$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      const outputDataset = schema["~run"](dataset, config$1);
	      return outputDataset.issues ? {
	        typed: true,
	        value: /* @__PURE__ */ getFallback(this, outputDataset, config$1)
	      } : outputDataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function fallbackAsync(schema, fallback$1) {
	  return {
	    ...schema,
	    fallback: fallback$1,
	    async: true,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    async "~run"(dataset, config$1) {
	      const outputDataset = await schema["~run"](dataset, config$1);
	      return outputDataset.issues ? {
	        typed: true,
	        value: await /* @__PURE__ */ getFallback(this, outputDataset, config$1)
	      } : outputDataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function flatten(issues) {
	  const flatErrors = {};
	  for (const issue of issues) if (issue.path) {
	    const dotPath = /* @__PURE__ */ getDotPath(issue);
	    if (dotPath) {
	      if (!flatErrors.nested) flatErrors.nested = {};
	      if (flatErrors.nested[dotPath]) flatErrors.nested[dotPath].push(issue.message);
	      else flatErrors.nested[dotPath] = [issue.message];
	    } else if (flatErrors.other) flatErrors.other.push(issue.message);
	    else flatErrors.other = [issue.message];
	  } else if (flatErrors.root) flatErrors.root.push(issue.message);
	  else flatErrors.root = [issue.message];
	  return flatErrors;
	}
	// @__NO_SIDE_EFFECTS__
	function forward(action, path) {
	  return {
	    ...action,
	    "~run"(dataset, config$1) {
	      const prevIssues = dataset.issues && [...dataset.issues];
	      dataset = action["~run"](dataset, config$1);
	      if (dataset.issues) {
	        for (const issue of dataset.issues) if (!prevIssues?.includes(issue)) {
	          let pathInput = dataset.value;
	          for (const key of path) {
	            const pathValue = pathInput[key];
	            const pathItem = {
	              type: "unknown",
	              origin: "value",
	              input: pathInput,
	              key,
	              value: pathValue
	            };
	            if (issue.path) issue.path.push(pathItem);
	            else issue.path = [pathItem];
	            if (!pathValue) break;
	            pathInput = pathValue;
	          }
	        }
	      }
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function forwardAsync(action, path) {
	  return {
	    ...action,
	    async: true,
	    async "~run"(dataset, config$1) {
	      const prevIssues = dataset.issues && [...dataset.issues];
	      dataset = await action["~run"](dataset, config$1);
	      if (dataset.issues) {
	        for (const issue of dataset.issues) if (!prevIssues?.includes(issue)) {
	          let pathInput = dataset.value;
	          for (const key of path) {
	            const pathValue = pathInput[key];
	            const pathItem = {
	              type: "unknown",
	              origin: "value",
	              input: pathInput,
	              key,
	              value: pathValue
	            };
	            if (issue.path) issue.path.push(pathItem);
	            else issue.path = [pathItem];
	            if (!pathValue) break;
	            pathInput = pathValue;
	          }
	        }
	      }
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function getDefault(schema, dataset, config$1) {
	  return typeof schema.default === "function" ? schema.default(dataset, config$1) : schema.default;
	}
	// @__NO_SIDE_EFFECTS__
	function getDefaults(schema) {
	  if ("entries" in schema) {
	    const object$1 = {};
	    for (const key in schema.entries) object$1[key] = /* @__PURE__ */ getDefaults(schema.entries[key]);
	    return object$1;
	  }
	  if ("items" in schema) return schema.items.map(getDefaults);
	  return /* @__PURE__ */ getDefault(schema);
	}
	// @__NO_SIDE_EFFECTS__
	async function getDefaultsAsync(schema) {
	  if ("entries" in schema) return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key, value$1]) => [key, await /* @__PURE__ */ getDefaultsAsync(value$1)])));
	  if ("items" in schema) return Promise.all(schema.items.map(getDefaultsAsync));
	  return /* @__PURE__ */ getDefault(schema);
	}
	// @__NO_SIDE_EFFECTS__
	function getDescription(schema) {
	  return /* @__PURE__ */ _getLastMetadata(schema, "description");
	}
	// @__NO_SIDE_EFFECTS__
	function getExamples(schema) {
	  const examples$1 = [];
	  function depthFirstCollect(schema$1) {
	    if ("pipe" in schema$1) {
	      for (const item of schema$1.pipe) if (item.kind === "schema" && "pipe" in item) depthFirstCollect(item);
	      else if (item.kind === "metadata" && item.type === "examples") examples$1.push(...item.examples);
	    }
	  }
	  depthFirstCollect(schema);
	  return examples$1;
	}
	// @__NO_SIDE_EFFECTS__
	function getFallbacks(schema) {
	  if ("entries" in schema) {
	    const object$1 = {};
	    for (const key in schema.entries) object$1[key] = /* @__PURE__ */ getFallbacks(schema.entries[key]);
	    return object$1;
	  }
	  if ("items" in schema) return schema.items.map(getFallbacks);
	  return /* @__PURE__ */ getFallback(schema);
	}
	// @__NO_SIDE_EFFECTS__
	async function getFallbacksAsync(schema) {
	  if ("entries" in schema) return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key, value$1]) => [key, await /* @__PURE__ */ getFallbacksAsync(value$1)])));
	  if ("items" in schema) return Promise.all(schema.items.map(getFallbacksAsync));
	  return /* @__PURE__ */ getFallback(schema);
	}
	// @__NO_SIDE_EFFECTS__
	function getMetadata(schema) {
	  const result = {};
	  function depthFirstMerge(schema$1) {
	    if ("pipe" in schema$1) {
	      for (const item of schema$1.pipe) if (item.kind === "schema" && "pipe" in item) depthFirstMerge(item);
	      else if (item.kind === "metadata" && item.type === "metadata") Object.assign(result, item.metadata);
	    }
	  }
	  depthFirstMerge(schema);
	  return result;
	}
	// @__NO_SIDE_EFFECTS__
	function getTitle(schema) {
	  return /* @__PURE__ */ _getLastMetadata(schema, "title");
	}
	// @__NO_SIDE_EFFECTS__
	function is(schema, input) {
	  return !schema["~run"]({ value: input }, { abortEarly: true }).issues;
	}
	// @__NO_SIDE_EFFECTS__
	function any() {
	  return {
	    kind: "schema",
	    type: "any",
	    reference: any,
	    expects: "any",
	    async: false,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset) {
	      dataset.typed = true;
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function array(item, message$1) {
	  return {
	    kind: "schema",
	    type: "array",
	    reference: array,
	    expects: "Array",
	    async: false,
	    item,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      const input = dataset.value;
	      if (Array.isArray(input)) {
	        dataset.typed = true;
	        dataset.value = [];
	        for (let key = 0; key < input.length; key++) {
	          const value$1 = input[key];
	          const itemDataset = this.item["~run"]({ value: value$1 }, config$1);
	          if (itemDataset.issues) {
	            const pathItem = {
	              type: "array",
	              origin: "value",
	              input,
	              key,
	              value: value$1
	            };
	            for (const issue of itemDataset.issues) {
	              if (issue.path) issue.path.unshift(pathItem);
	              else issue.path = [pathItem];
	              dataset.issues?.push(issue);
	            }
	            if (!dataset.issues) dataset.issues = itemDataset.issues;
	            if (config$1.abortEarly) {
	              dataset.typed = false;
	              break;
	            }
	          }
	          if (!itemDataset.typed) dataset.typed = false;
	          dataset.value.push(itemDataset.value);
	        }
	      } else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function arrayAsync(item, message$1) {
	  return {
	    kind: "schema",
	    type: "array",
	    reference: arrayAsync,
	    expects: "Array",
	    async: true,
	    item,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    async "~run"(dataset, config$1) {
	      const input = dataset.value;
	      if (Array.isArray(input)) {
	        dataset.typed = true;
	        dataset.value = [];
	        const itemDatasets = await Promise.all(input.map((value$1) => this.item["~run"]({ value: value$1 }, config$1)));
	        for (let key = 0; key < itemDatasets.length; key++) {
	          const itemDataset = itemDatasets[key];
	          if (itemDataset.issues) {
	            const pathItem = {
	              type: "array",
	              origin: "value",
	              input,
	              key,
	              value: input[key]
	            };
	            for (const issue of itemDataset.issues) {
	              if (issue.path) issue.path.unshift(pathItem);
	              else issue.path = [pathItem];
	              dataset.issues?.push(issue);
	            }
	            if (!dataset.issues) dataset.issues = itemDataset.issues;
	            if (config$1.abortEarly) {
	              dataset.typed = false;
	              break;
	            }
	          }
	          if (!itemDataset.typed) dataset.typed = false;
	          dataset.value.push(itemDataset.value);
	        }
	      } else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function bigint(message$1) {
	  return {
	    kind: "schema",
	    type: "bigint",
	    reference: bigint,
	    expects: "bigint",
	    async: false,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      if (typeof dataset.value === "bigint") dataset.typed = true;
	      else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function blob(message$1) {
	  return {
	    kind: "schema",
	    type: "blob",
	    reference: blob,
	    expects: "Blob",
	    async: false,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      if (dataset.value instanceof Blob) dataset.typed = true;
	      else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function boolean(message$1) {
	  return {
	    kind: "schema",
	    type: "boolean",
	    reference: boolean,
	    expects: "boolean",
	    async: false,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      if (typeof dataset.value === "boolean") dataset.typed = true;
	      else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function custom(check$1, message$1) {
	  return {
	    kind: "schema",
	    type: "custom",
	    reference: custom,
	    expects: "unknown",
	    async: false,
	    check: check$1,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      if (this.check(dataset.value)) dataset.typed = true;
	      else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function customAsync(check$1, message$1) {
	  return {
	    kind: "schema",
	    type: "custom",
	    reference: customAsync,
	    expects: "unknown",
	    async: true,
	    check: check$1,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    async "~run"(dataset, config$1) {
	      if (await this.check(dataset.value)) dataset.typed = true;
	      else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function date(message$1) {
	  return {
	    kind: "schema",
	    type: "date",
	    reference: date,
	    expects: "Date",
	    async: false,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      if (dataset.value instanceof Date) if (!isNaN(dataset.value)) dataset.typed = true;
	      else _addIssue(this, "type", dataset, config$1, { received: '"Invalid Date"' });
	      else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function enum_(enum__, message$1) {
	  const options = [];
	  for (const key in enum__) if (`${+key}` !== key || typeof enum__[key] !== "string" || !Object.is(enum__[enum__[key]], +key)) options.push(enum__[key]);
	  return {
	    kind: "schema",
	    type: "enum",
	    reference: enum_,
	    expects: /* @__PURE__ */ _joinExpects(options.map(_stringify), "|"),
	    async: false,
	    enum: enum__,
	    options,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      if (this.options.includes(dataset.value)) dataset.typed = true;
	      else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function exactOptional(wrapped, default_) {
	  return {
	    kind: "schema",
	    type: "exact_optional",
	    reference: exactOptional,
	    expects: wrapped.expects,
	    async: false,
	    wrapped,
	    default: default_,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      return this.wrapped["~run"](dataset, config$1);
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function exactOptionalAsync(wrapped, default_) {
	  return {
	    kind: "schema",
	    type: "exact_optional",
	    reference: exactOptionalAsync,
	    expects: wrapped.expects,
	    async: true,
	    wrapped,
	    default: default_,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    async "~run"(dataset, config$1) {
	      return this.wrapped["~run"](dataset, config$1);
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function file(message$1) {
	  return {
	    kind: "schema",
	    type: "file",
	    reference: file,
	    expects: "File",
	    async: false,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      if (dataset.value instanceof File) dataset.typed = true;
	      else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function function_(message$1) {
	  return {
	    kind: "schema",
	    type: "function",
	    reference: function_,
	    expects: "Function",
	    async: false,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      if (typeof dataset.value === "function") dataset.typed = true;
	      else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function instance(class_, message$1) {
	  return {
	    kind: "schema",
	    type: "instance",
	    reference: instance,
	    expects: class_.name,
	    async: false,
	    class: class_,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      if (dataset.value instanceof this.class) dataset.typed = true;
	      else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function _merge(value1, value2) {
	  if (typeof value1 === typeof value2) {
	    if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) return { value: value1 };
	    if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {
	      for (const key in value2) if (key in value1) {
	        const dataset = /* @__PURE__ */ _merge(value1[key], value2[key]);
	        if (dataset.issue) return dataset;
	        value1[key] = dataset.value;
	      } else value1[key] = value2[key];
	      return { value: value1 };
	    }
	    if (Array.isArray(value1) && Array.isArray(value2)) {
	      if (value1.length === value2.length) {
	        for (let index = 0; index < value1.length; index++) {
	          const dataset = /* @__PURE__ */ _merge(value1[index], value2[index]);
	          if (dataset.issue) return dataset;
	          value1[index] = dataset.value;
	        }
	        return { value: value1 };
	      }
	    }
	  }
	  return { issue: true };
	}
	// @__NO_SIDE_EFFECTS__
	function intersect(options, message$1) {
	  return {
	    kind: "schema",
	    type: "intersect",
	    reference: intersect,
	    expects: /* @__PURE__ */ _joinExpects(options.map((option) => option.expects), "&"),
	    async: false,
	    options,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      if (this.options.length) {
	        const input = dataset.value;
	        let outputs;
	        dataset.typed = true;
	        for (const schema of this.options) {
	          const optionDataset = schema["~run"]({ value: input }, config$1);
	          if (optionDataset.issues) {
	            if (dataset.issues) dataset.issues.push(...optionDataset.issues);
	            else dataset.issues = optionDataset.issues;
	            if (config$1.abortEarly) {
	              dataset.typed = false;
	              break;
	            }
	          }
	          if (!optionDataset.typed) dataset.typed = false;
	          if (dataset.typed) if (outputs) outputs.push(optionDataset.value);
	          else outputs = [optionDataset.value];
	        }
	        if (dataset.typed) {
	          dataset.value = outputs[0];
	          for (let index = 1; index < outputs.length; index++) {
	            const mergeDataset = /* @__PURE__ */ _merge(dataset.value, outputs[index]);
	            if (mergeDataset.issue) {
	              _addIssue(this, "type", dataset, config$1, { received: "unknown" });
	              break;
	            }
	            dataset.value = mergeDataset.value;
	          }
	        }
	      } else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function intersectAsync(options, message$1) {
	  return {
	    kind: "schema",
	    type: "intersect",
	    reference: intersectAsync,
	    expects: /* @__PURE__ */ _joinExpects(options.map((option) => option.expects), "&"),
	    async: true,
	    options,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    async "~run"(dataset, config$1) {
	      if (this.options.length) {
	        const input = dataset.value;
	        let outputs;
	        dataset.typed = true;
	        const optionDatasets = await Promise.all(this.options.map((schema) => schema["~run"]({ value: input }, config$1)));
	        for (const optionDataset of optionDatasets) {
	          if (optionDataset.issues) {
	            if (dataset.issues) dataset.issues.push(...optionDataset.issues);
	            else dataset.issues = optionDataset.issues;
	            if (config$1.abortEarly) {
	              dataset.typed = false;
	              break;
	            }
	          }
	          if (!optionDataset.typed) dataset.typed = false;
	          if (dataset.typed) if (outputs) outputs.push(optionDataset.value);
	          else outputs = [optionDataset.value];
	        }
	        if (dataset.typed) {
	          dataset.value = outputs[0];
	          for (let index = 1; index < outputs.length; index++) {
	            const mergeDataset = /* @__PURE__ */ _merge(dataset.value, outputs[index]);
	            if (mergeDataset.issue) {
	              _addIssue(this, "type", dataset, config$1, { received: "unknown" });
	              break;
	            }
	            dataset.value = mergeDataset.value;
	          }
	        }
	      } else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function lazy(getter) {
	  return {
	    kind: "schema",
	    type: "lazy",
	    reference: lazy,
	    expects: "unknown",
	    async: false,
	    getter,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      return this.getter(dataset.value)["~run"](dataset, config$1);
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function lazyAsync(getter) {
	  return {
	    kind: "schema",
	    type: "lazy",
	    reference: lazyAsync,
	    expects: "unknown",
	    async: true,
	    getter,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    async "~run"(dataset, config$1) {
	      return (await this.getter(dataset.value))["~run"](dataset, config$1);
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function literal(literal_, message$1) {
	  return {
	    kind: "schema",
	    type: "literal",
	    reference: literal,
	    expects: /* @__PURE__ */ _stringify(literal_),
	    async: false,
	    literal: literal_,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      if (dataset.value === this.literal) dataset.typed = true;
	      else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function looseObject(entries$1, message$1) {
	  return {
	    kind: "schema",
	    type: "loose_object",
	    reference: looseObject,
	    expects: "Object",
	    async: false,
	    entries: entries$1,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      const input = dataset.value;
	      if (input && typeof input === "object") {
	        dataset.typed = true;
	        dataset.value = {};
	        for (const key in this.entries) {
	          const valueSchema = this.entries[key];
	          if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
	            const value$1 = key in input ? input[key] : /* @__PURE__ */ getDefault(valueSchema);
	            const valueDataset = valueSchema["~run"]({ value: value$1 }, config$1);
	            if (valueDataset.issues) {
	              const pathItem = {
	                type: "object",
	                origin: "value",
	                input,
	                key,
	                value: value$1
	              };
	              for (const issue of valueDataset.issues) {
	                if (issue.path) issue.path.unshift(pathItem);
	                else issue.path = [pathItem];
	                dataset.issues?.push(issue);
	              }
	              if (!dataset.issues) dataset.issues = valueDataset.issues;
	              if (config$1.abortEarly) {
	                dataset.typed = false;
	                break;
	              }
	            }
	            if (!valueDataset.typed) dataset.typed = false;
	            dataset.value[key] = valueDataset.value;
	          } else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */ getFallback(valueSchema);
	          else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
	            _addIssue(this, "key", dataset, config$1, {
	              input: void 0,
	              expected: `"${key}"`,
	              path: [{
	                type: "object",
	                origin: "key",
	                input,
	                key,
	                value: input[key]
	              }]
	            });
	            if (config$1.abortEarly) break;
	          }
	        }
	        if (!dataset.issues || !config$1.abortEarly) {
	          for (const key in input) if (/* @__PURE__ */ _isValidObjectKey(input, key) && !(key in this.entries)) dataset.value[key] = input[key];
	        }
	      } else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function looseObjectAsync(entries$1, message$1) {
	  return {
	    kind: "schema",
	    type: "loose_object",
	    reference: looseObjectAsync,
	    expects: "Object",
	    async: true,
	    entries: entries$1,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    async "~run"(dataset, config$1) {
	      const input = dataset.value;
	      if (input && typeof input === "object") {
	        dataset.typed = true;
	        dataset.value = {};
	        const valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema]) => {
	          if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
	            const value$1 = key in input ? input[key] : await /* @__PURE__ */ getDefault(valueSchema);
	            return [
	              key,
	              value$1,
	              valueSchema,
	              await valueSchema["~run"]({ value: value$1 }, config$1)
	            ];
	          }
	          return [
	            key,
	            input[key],
	            valueSchema,
	            null
	          ];
	        }));
	        for (const [key, value$1, valueSchema, valueDataset] of valueDatasets) if (valueDataset) {
	          if (valueDataset.issues) {
	            const pathItem = {
	              type: "object",
	              origin: "value",
	              input,
	              key,
	              value: value$1
	            };
	            for (const issue of valueDataset.issues) {
	              if (issue.path) issue.path.unshift(pathItem);
	              else issue.path = [pathItem];
	              dataset.issues?.push(issue);
	            }
	            if (!dataset.issues) dataset.issues = valueDataset.issues;
	            if (config$1.abortEarly) {
	              dataset.typed = false;
	              break;
	            }
	          }
	          if (!valueDataset.typed) dataset.typed = false;
	          dataset.value[key] = valueDataset.value;
	        } else if (valueSchema.fallback !== void 0) dataset.value[key] = await /* @__PURE__ */ getFallback(valueSchema);
	        else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
	          _addIssue(this, "key", dataset, config$1, {
	            input: void 0,
	            expected: `"${key}"`,
	            path: [{
	              type: "object",
	              origin: "key",
	              input,
	              key,
	              value: value$1
	            }]
	          });
	          if (config$1.abortEarly) break;
	        }
	        if (!dataset.issues || !config$1.abortEarly) {
	          for (const key in input) if (/* @__PURE__ */ _isValidObjectKey(input, key) && !(key in this.entries)) dataset.value[key] = input[key];
	        }
	      } else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function looseTuple(items, message$1) {
	  return {
	    kind: "schema",
	    type: "loose_tuple",
	    reference: looseTuple,
	    expects: "Array",
	    async: false,
	    items,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      const input = dataset.value;
	      if (Array.isArray(input)) {
	        dataset.typed = true;
	        dataset.value = [];
	        for (let key = 0; key < this.items.length; key++) {
	          const value$1 = input[key];
	          const itemDataset = this.items[key]["~run"]({ value: value$1 }, config$1);
	          if (itemDataset.issues) {
	            const pathItem = {
	              type: "array",
	              origin: "value",
	              input,
	              key,
	              value: value$1
	            };
	            for (const issue of itemDataset.issues) {
	              if (issue.path) issue.path.unshift(pathItem);
	              else issue.path = [pathItem];
	              dataset.issues?.push(issue);
	            }
	            if (!dataset.issues) dataset.issues = itemDataset.issues;
	            if (config$1.abortEarly) {
	              dataset.typed = false;
	              break;
	            }
	          }
	          if (!itemDataset.typed) dataset.typed = false;
	          dataset.value.push(itemDataset.value);
	        }
	        if (!dataset.issues || !config$1.abortEarly) for (let key = this.items.length; key < input.length; key++) dataset.value.push(input[key]);
	      } else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function looseTupleAsync(items, message$1) {
	  return {
	    kind: "schema",
	    type: "loose_tuple",
	    reference: looseTupleAsync,
	    expects: "Array",
	    async: true,
	    items,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    async "~run"(dataset, config$1) {
	      const input = dataset.value;
	      if (Array.isArray(input)) {
	        dataset.typed = true;
	        dataset.value = [];
	        const itemDatasets = await Promise.all(this.items.map(async (item, key) => {
	          const value$1 = input[key];
	          return [
	            key,
	            value$1,
	            await item["~run"]({ value: value$1 }, config$1)
	          ];
	        }));
	        for (const [key, value$1, itemDataset] of itemDatasets) {
	          if (itemDataset.issues) {
	            const pathItem = {
	              type: "array",
	              origin: "value",
	              input,
	              key,
	              value: value$1
	            };
	            for (const issue of itemDataset.issues) {
	              if (issue.path) issue.path.unshift(pathItem);
	              else issue.path = [pathItem];
	              dataset.issues?.push(issue);
	            }
	            if (!dataset.issues) dataset.issues = itemDataset.issues;
	            if (config$1.abortEarly) {
	              dataset.typed = false;
	              break;
	            }
	          }
	          if (!itemDataset.typed) dataset.typed = false;
	          dataset.value.push(itemDataset.value);
	        }
	        if (!dataset.issues || !config$1.abortEarly) for (let key = this.items.length; key < input.length; key++) dataset.value.push(input[key]);
	      } else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function map(key, value$1, message$1) {
	  return {
	    kind: "schema",
	    type: "map",
	    reference: map,
	    expects: "Map",
	    async: false,
	    key,
	    value: value$1,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      const input = dataset.value;
	      if (input instanceof Map) {
	        dataset.typed = true;
	        dataset.value = /* @__PURE__ */ new Map();
	        for (const [inputKey, inputValue] of input) {
	          const keyDataset = this.key["~run"]({ value: inputKey }, config$1);
	          if (keyDataset.issues) {
	            const pathItem = {
	              type: "map",
	              origin: "key",
	              input,
	              key: inputKey,
	              value: inputValue
	            };
	            for (const issue of keyDataset.issues) {
	              if (issue.path) issue.path.unshift(pathItem);
	              else issue.path = [pathItem];
	              dataset.issues?.push(issue);
	            }
	            if (!dataset.issues) dataset.issues = keyDataset.issues;
	            if (config$1.abortEarly) {
	              dataset.typed = false;
	              break;
	            }
	          }
	          const valueDataset = this.value["~run"]({ value: inputValue }, config$1);
	          if (valueDataset.issues) {
	            const pathItem = {
	              type: "map",
	              origin: "value",
	              input,
	              key: inputKey,
	              value: inputValue
	            };
	            for (const issue of valueDataset.issues) {
	              if (issue.path) issue.path.unshift(pathItem);
	              else issue.path = [pathItem];
	              dataset.issues?.push(issue);
	            }
	            if (!dataset.issues) dataset.issues = valueDataset.issues;
	            if (config$1.abortEarly) {
	              dataset.typed = false;
	              break;
	            }
	          }
	          if (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;
	          dataset.value.set(keyDataset.value, valueDataset.value);
	        }
	      } else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function mapAsync(key, value$1, message$1) {
	  return {
	    kind: "schema",
	    type: "map",
	    reference: mapAsync,
	    expects: "Map",
	    async: true,
	    key,
	    value: value$1,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    async "~run"(dataset, config$1) {
	      const input = dataset.value;
	      if (input instanceof Map) {
	        dataset.typed = true;
	        dataset.value = /* @__PURE__ */ new Map();
	        const datasets = await Promise.all([...input].map(([inputKey, inputValue]) => Promise.all([
	          inputKey,
	          inputValue,
	          this.key["~run"]({ value: inputKey }, config$1),
	          this.value["~run"]({ value: inputValue }, config$1)
	        ])));
	        for (const [inputKey, inputValue, keyDataset, valueDataset] of datasets) {
	          if (keyDataset.issues) {
	            const pathItem = {
	              type: "map",
	              origin: "key",
	              input,
	              key: inputKey,
	              value: inputValue
	            };
	            for (const issue of keyDataset.issues) {
	              if (issue.path) issue.path.unshift(pathItem);
	              else issue.path = [pathItem];
	              dataset.issues?.push(issue);
	            }
	            if (!dataset.issues) dataset.issues = keyDataset.issues;
	            if (config$1.abortEarly) {
	              dataset.typed = false;
	              break;
	            }
	          }
	          if (valueDataset.issues) {
	            const pathItem = {
	              type: "map",
	              origin: "value",
	              input,
	              key: inputKey,
	              value: inputValue
	            };
	            for (const issue of valueDataset.issues) {
	              if (issue.path) issue.path.unshift(pathItem);
	              else issue.path = [pathItem];
	              dataset.issues?.push(issue);
	            }
	            if (!dataset.issues) dataset.issues = valueDataset.issues;
	            if (config$1.abortEarly) {
	              dataset.typed = false;
	              break;
	            }
	          }
	          if (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;
	          dataset.value.set(keyDataset.value, valueDataset.value);
	        }
	      } else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function nan(message$1) {
	  return {
	    kind: "schema",
	    type: "nan",
	    reference: nan,
	    expects: "NaN",
	    async: false,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      if (Number.isNaN(dataset.value)) dataset.typed = true;
	      else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function never(message$1) {
	  return {
	    kind: "schema",
	    type: "never",
	    reference: never,
	    expects: "never",
	    async: false,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function nonNullable(wrapped, message$1) {
	  return {
	    kind: "schema",
	    type: "non_nullable",
	    reference: nonNullable,
	    expects: "!null",
	    async: false,
	    wrapped,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      if (dataset.value !== null) dataset = this.wrapped["~run"](dataset, config$1);
	      if (dataset.value === null) _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function nonNullableAsync(wrapped, message$1) {
	  return {
	    kind: "schema",
	    type: "non_nullable",
	    reference: nonNullableAsync,
	    expects: "!null",
	    async: true,
	    wrapped,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    async "~run"(dataset, config$1) {
	      if (dataset.value !== null) dataset = await this.wrapped["~run"](dataset, config$1);
	      if (dataset.value === null) _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function nonNullish(wrapped, message$1) {
	  return {
	    kind: "schema",
	    type: "non_nullish",
	    reference: nonNullish,
	    expects: "(!null & !undefined)",
	    async: false,
	    wrapped,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      if (!(dataset.value === null || dataset.value === void 0)) dataset = this.wrapped["~run"](dataset, config$1);
	      if (dataset.value === null || dataset.value === void 0) _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function nonNullishAsync(wrapped, message$1) {
	  return {
	    kind: "schema",
	    type: "non_nullish",
	    reference: nonNullishAsync,
	    expects: "(!null & !undefined)",
	    async: true,
	    wrapped,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    async "~run"(dataset, config$1) {
	      if (!(dataset.value === null || dataset.value === void 0)) dataset = await this.wrapped["~run"](dataset, config$1);
	      if (dataset.value === null || dataset.value === void 0) _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function nonOptional(wrapped, message$1) {
	  return {
	    kind: "schema",
	    type: "non_optional",
	    reference: nonOptional,
	    expects: "!undefined",
	    async: false,
	    wrapped,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      if (dataset.value !== void 0) dataset = this.wrapped["~run"](dataset, config$1);
	      if (dataset.value === void 0) _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function nonOptionalAsync(wrapped, message$1) {
	  return {
	    kind: "schema",
	    type: "non_optional",
	    reference: nonOptionalAsync,
	    expects: "!undefined",
	    async: true,
	    wrapped,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    async "~run"(dataset, config$1) {
	      if (dataset.value !== void 0) dataset = await this.wrapped["~run"](dataset, config$1);
	      if (dataset.value === void 0) _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function null_(message$1) {
	  return {
	    kind: "schema",
	    type: "null",
	    reference: null_,
	    expects: "null",
	    async: false,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      if (dataset.value === null) dataset.typed = true;
	      else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function nullable(wrapped, default_) {
	  return {
	    kind: "schema",
	    type: "nullable",
	    reference: nullable,
	    expects: `(${wrapped.expects} | null)`,
	    async: false,
	    wrapped,
	    default: default_,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      if (dataset.value === null) {
	        if (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);
	        if (dataset.value === null) {
	          dataset.typed = true;
	          return dataset;
	        }
	      }
	      return this.wrapped["~run"](dataset, config$1);
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function nullableAsync(wrapped, default_) {
	  return {
	    kind: "schema",
	    type: "nullable",
	    reference: nullableAsync,
	    expects: `(${wrapped.expects} | null)`,
	    async: true,
	    wrapped,
	    default: default_,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    async "~run"(dataset, config$1) {
	      if (dataset.value === null) {
	        if (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);
	        if (dataset.value === null) {
	          dataset.typed = true;
	          return dataset;
	        }
	      }
	      return this.wrapped["~run"](dataset, config$1);
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function nullish(wrapped, default_) {
	  return {
	    kind: "schema",
	    type: "nullish",
	    reference: nullish,
	    expects: `(${wrapped.expects} | null | undefined)`,
	    async: false,
	    wrapped,
	    default: default_,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      if (dataset.value === null || dataset.value === void 0) {
	        if (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);
	        if (dataset.value === null || dataset.value === void 0) {
	          dataset.typed = true;
	          return dataset;
	        }
	      }
	      return this.wrapped["~run"](dataset, config$1);
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function nullishAsync(wrapped, default_) {
	  return {
	    kind: "schema",
	    type: "nullish",
	    reference: nullishAsync,
	    expects: `(${wrapped.expects} | null | undefined)`,
	    async: true,
	    wrapped,
	    default: default_,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    async "~run"(dataset, config$1) {
	      if (dataset.value === null || dataset.value === void 0) {
	        if (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);
	        if (dataset.value === null || dataset.value === void 0) {
	          dataset.typed = true;
	          return dataset;
	        }
	      }
	      return this.wrapped["~run"](dataset, config$1);
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function number(message$1) {
	  return {
	    kind: "schema",
	    type: "number",
	    reference: number,
	    expects: "number",
	    async: false,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      if (typeof dataset.value === "number" && !isNaN(dataset.value)) dataset.typed = true;
	      else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function object(entries$1, message$1) {
	  return {
	    kind: "schema",
	    type: "object",
	    reference: object,
	    expects: "Object",
	    async: false,
	    entries: entries$1,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      const input = dataset.value;
	      if (input && typeof input === "object") {
	        dataset.typed = true;
	        dataset.value = {};
	        for (const key in this.entries) {
	          const valueSchema = this.entries[key];
	          if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
	            const value$1 = key in input ? input[key] : /* @__PURE__ */ getDefault(valueSchema);
	            const valueDataset = valueSchema["~run"]({ value: value$1 }, config$1);
	            if (valueDataset.issues) {
	              const pathItem = {
	                type: "object",
	                origin: "value",
	                input,
	                key,
	                value: value$1
	              };
	              for (const issue of valueDataset.issues) {
	                if (issue.path) issue.path.unshift(pathItem);
	                else issue.path = [pathItem];
	                dataset.issues?.push(issue);
	              }
	              if (!dataset.issues) dataset.issues = valueDataset.issues;
	              if (config$1.abortEarly) {
	                dataset.typed = false;
	                break;
	              }
	            }
	            if (!valueDataset.typed) dataset.typed = false;
	            dataset.value[key] = valueDataset.value;
	          } else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */ getFallback(valueSchema);
	          else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
	            _addIssue(this, "key", dataset, config$1, {
	              input: void 0,
	              expected: `"${key}"`,
	              path: [{
	                type: "object",
	                origin: "key",
	                input,
	                key,
	                value: input[key]
	              }]
	            });
	            if (config$1.abortEarly) break;
	          }
	        }
	      } else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function objectAsync(entries$1, message$1) {
	  return {
	    kind: "schema",
	    type: "object",
	    reference: objectAsync,
	    expects: "Object",
	    async: true,
	    entries: entries$1,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    async "~run"(dataset, config$1) {
	      const input = dataset.value;
	      if (input && typeof input === "object") {
	        dataset.typed = true;
	        dataset.value = {};
	        const valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema]) => {
	          if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
	            const value$1 = key in input ? input[key] : await /* @__PURE__ */ getDefault(valueSchema);
	            return [
	              key,
	              value$1,
	              valueSchema,
	              await valueSchema["~run"]({ value: value$1 }, config$1)
	            ];
	          }
	          return [
	            key,
	            input[key],
	            valueSchema,
	            null
	          ];
	        }));
	        for (const [key, value$1, valueSchema, valueDataset] of valueDatasets) if (valueDataset) {
	          if (valueDataset.issues) {
	            const pathItem = {
	              type: "object",
	              origin: "value",
	              input,
	              key,
	              value: value$1
	            };
	            for (const issue of valueDataset.issues) {
	              if (issue.path) issue.path.unshift(pathItem);
	              else issue.path = [pathItem];
	              dataset.issues?.push(issue);
	            }
	            if (!dataset.issues) dataset.issues = valueDataset.issues;
	            if (config$1.abortEarly) {
	              dataset.typed = false;
	              break;
	            }
	          }
	          if (!valueDataset.typed) dataset.typed = false;
	          dataset.value[key] = valueDataset.value;
	        } else if (valueSchema.fallback !== void 0) dataset.value[key] = await /* @__PURE__ */ getFallback(valueSchema);
	        else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
	          _addIssue(this, "key", dataset, config$1, {
	            input: void 0,
	            expected: `"${key}"`,
	            path: [{
	              type: "object",
	              origin: "key",
	              input,
	              key,
	              value: value$1
	            }]
	          });
	          if (config$1.abortEarly) break;
	        }
	      } else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function objectWithRest(entries$1, rest, message$1) {
	  return {
	    kind: "schema",
	    type: "object_with_rest",
	    reference: objectWithRest,
	    expects: "Object",
	    async: false,
	    entries: entries$1,
	    rest,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      const input = dataset.value;
	      if (input && typeof input === "object") {
	        dataset.typed = true;
	        dataset.value = {};
	        for (const key in this.entries) {
	          const valueSchema = this.entries[key];
	          if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
	            const value$1 = key in input ? input[key] : /* @__PURE__ */ getDefault(valueSchema);
	            const valueDataset = valueSchema["~run"]({ value: value$1 }, config$1);
	            if (valueDataset.issues) {
	              const pathItem = {
	                type: "object",
	                origin: "value",
	                input,
	                key,
	                value: value$1
	              };
	              for (const issue of valueDataset.issues) {
	                if (issue.path) issue.path.unshift(pathItem);
	                else issue.path = [pathItem];
	                dataset.issues?.push(issue);
	              }
	              if (!dataset.issues) dataset.issues = valueDataset.issues;
	              if (config$1.abortEarly) {
	                dataset.typed = false;
	                break;
	              }
	            }
	            if (!valueDataset.typed) dataset.typed = false;
	            dataset.value[key] = valueDataset.value;
	          } else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */ getFallback(valueSchema);
	          else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
	            _addIssue(this, "key", dataset, config$1, {
	              input: void 0,
	              expected: `"${key}"`,
	              path: [{
	                type: "object",
	                origin: "key",
	                input,
	                key,
	                value: input[key]
	              }]
	            });
	            if (config$1.abortEarly) break;
	          }
	        }
	        if (!dataset.issues || !config$1.abortEarly) {
	          for (const key in input) if (/* @__PURE__ */ _isValidObjectKey(input, key) && !(key in this.entries)) {
	            const valueDataset = this.rest["~run"]({ value: input[key] }, config$1);
	            if (valueDataset.issues) {
	              const pathItem = {
	                type: "object",
	                origin: "value",
	                input,
	                key,
	                value: input[key]
	              };
	              for (const issue of valueDataset.issues) {
	                if (issue.path) issue.path.unshift(pathItem);
	                else issue.path = [pathItem];
	                dataset.issues?.push(issue);
	              }
	              if (!dataset.issues) dataset.issues = valueDataset.issues;
	              if (config$1.abortEarly) {
	                dataset.typed = false;
	                break;
	              }
	            }
	            if (!valueDataset.typed) dataset.typed = false;
	            dataset.value[key] = valueDataset.value;
	          }
	        }
	      } else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function objectWithRestAsync(entries$1, rest, message$1) {
	  return {
	    kind: "schema",
	    type: "object_with_rest",
	    reference: objectWithRestAsync,
	    expects: "Object",
	    async: true,
	    entries: entries$1,
	    rest,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    async "~run"(dataset, config$1) {
	      const input = dataset.value;
	      if (input && typeof input === "object") {
	        dataset.typed = true;
	        dataset.value = {};
	        const [normalDatasets, restDatasets] = await Promise.all([Promise.all(Object.entries(this.entries).map(async ([key, valueSchema]) => {
	          if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
	            const value$1 = key in input ? input[key] : await /* @__PURE__ */ getDefault(valueSchema);
	            return [
	              key,
	              value$1,
	              valueSchema,
	              await valueSchema["~run"]({ value: value$1 }, config$1)
	            ];
	          }
	          return [
	            key,
	            input[key],
	            valueSchema,
	            null
	          ];
	        })), Promise.all(Object.entries(input).filter(([key]) => /* @__PURE__ */ _isValidObjectKey(input, key) && !(key in this.entries)).map(async ([key, value$1]) => [
	          key,
	          value$1,
	          await this.rest["~run"]({ value: value$1 }, config$1)
	        ]))]);
	        for (const [key, value$1, valueSchema, valueDataset] of normalDatasets) if (valueDataset) {
	          if (valueDataset.issues) {
	            const pathItem = {
	              type: "object",
	              origin: "value",
	              input,
	              key,
	              value: value$1
	            };
	            for (const issue of valueDataset.issues) {
	              if (issue.path) issue.path.unshift(pathItem);
	              else issue.path = [pathItem];
	              dataset.issues?.push(issue);
	            }
	            if (!dataset.issues) dataset.issues = valueDataset.issues;
	            if (config$1.abortEarly) {
	              dataset.typed = false;
	              break;
	            }
	          }
	          if (!valueDataset.typed) dataset.typed = false;
	          dataset.value[key] = valueDataset.value;
	        } else if (valueSchema.fallback !== void 0) dataset.value[key] = await /* @__PURE__ */ getFallback(valueSchema);
	        else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
	          _addIssue(this, "key", dataset, config$1, {
	            input: void 0,
	            expected: `"${key}"`,
	            path: [{
	              type: "object",
	              origin: "key",
	              input,
	              key,
	              value: value$1
	            }]
	          });
	          if (config$1.abortEarly) break;
	        }
	        if (!dataset.issues || !config$1.abortEarly) for (const [key, value$1, valueDataset] of restDatasets) {
	          if (valueDataset.issues) {
	            const pathItem = {
	              type: "object",
	              origin: "value",
	              input,
	              key,
	              value: value$1
	            };
	            for (const issue of valueDataset.issues) {
	              if (issue.path) issue.path.unshift(pathItem);
	              else issue.path = [pathItem];
	              dataset.issues?.push(issue);
	            }
	            if (!dataset.issues) dataset.issues = valueDataset.issues;
	            if (config$1.abortEarly) {
	              dataset.typed = false;
	              break;
	            }
	          }
	          if (!valueDataset.typed) dataset.typed = false;
	          dataset.value[key] = valueDataset.value;
	        }
	      } else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function optional(wrapped, default_) {
	  return {
	    kind: "schema",
	    type: "optional",
	    reference: optional,
	    expects: `(${wrapped.expects} | undefined)`,
	    async: false,
	    wrapped,
	    default: default_,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      if (dataset.value === void 0) {
	        if (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);
	        if (dataset.value === void 0) {
	          dataset.typed = true;
	          return dataset;
	        }
	      }
	      return this.wrapped["~run"](dataset, config$1);
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function optionalAsync(wrapped, default_) {
	  return {
	    kind: "schema",
	    type: "optional",
	    reference: optionalAsync,
	    expects: `(${wrapped.expects} | undefined)`,
	    async: true,
	    wrapped,
	    default: default_,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    async "~run"(dataset, config$1) {
	      if (dataset.value === void 0) {
	        if (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);
	        if (dataset.value === void 0) {
	          dataset.typed = true;
	          return dataset;
	        }
	      }
	      return this.wrapped["~run"](dataset, config$1);
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function picklist(options, message$1) {
	  return {
	    kind: "schema",
	    type: "picklist",
	    reference: picklist,
	    expects: /* @__PURE__ */ _joinExpects(options.map(_stringify), "|"),
	    async: false,
	    options,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      if (this.options.includes(dataset.value)) dataset.typed = true;
	      else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function promise(message$1) {
	  return {
	    kind: "schema",
	    type: "promise",
	    reference: promise,
	    expects: "Promise",
	    async: false,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      if (dataset.value instanceof Promise) dataset.typed = true;
	      else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function record(key, value$1, message$1) {
	  return {
	    kind: "schema",
	    type: "record",
	    reference: record,
	    expects: "Object",
	    async: false,
	    key,
	    value: value$1,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      const input = dataset.value;
	      if (input && typeof input === "object") {
	        dataset.typed = true;
	        dataset.value = {};
	        for (const entryKey in input) if (/* @__PURE__ */ _isValidObjectKey(input, entryKey)) {
	          const entryValue = input[entryKey];
	          const keyDataset = this.key["~run"]({ value: entryKey }, config$1);
	          if (keyDataset.issues) {
	            const pathItem = {
	              type: "object",
	              origin: "key",
	              input,
	              key: entryKey,
	              value: entryValue
	            };
	            for (const issue of keyDataset.issues) {
	              issue.path = [pathItem];
	              dataset.issues?.push(issue);
	            }
	            if (!dataset.issues) dataset.issues = keyDataset.issues;
	            if (config$1.abortEarly) {
	              dataset.typed = false;
	              break;
	            }
	          }
	          const valueDataset = this.value["~run"]({ value: entryValue }, config$1);
	          if (valueDataset.issues) {
	            const pathItem = {
	              type: "object",
	              origin: "value",
	              input,
	              key: entryKey,
	              value: entryValue
	            };
	            for (const issue of valueDataset.issues) {
	              if (issue.path) issue.path.unshift(pathItem);
	              else issue.path = [pathItem];
	              dataset.issues?.push(issue);
	            }
	            if (!dataset.issues) dataset.issues = valueDataset.issues;
	            if (config$1.abortEarly) {
	              dataset.typed = false;
	              break;
	            }
	          }
	          if (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;
	          if (keyDataset.typed) dataset.value[keyDataset.value] = valueDataset.value;
	        }
	      } else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function recordAsync(key, value$1, message$1) {
	  return {
	    kind: "schema",
	    type: "record",
	    reference: recordAsync,
	    expects: "Object",
	    async: true,
	    key,
	    value: value$1,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    async "~run"(dataset, config$1) {
	      const input = dataset.value;
	      if (input && typeof input === "object") {
	        dataset.typed = true;
	        dataset.value = {};
	        const datasets = await Promise.all(Object.entries(input).filter(([key$1]) => /* @__PURE__ */ _isValidObjectKey(input, key$1)).map(([entryKey, entryValue]) => Promise.all([
	          entryKey,
	          entryValue,
	          this.key["~run"]({ value: entryKey }, config$1),
	          this.value["~run"]({ value: entryValue }, config$1)
	        ])));
	        for (const [entryKey, entryValue, keyDataset, valueDataset] of datasets) {
	          if (keyDataset.issues) {
	            const pathItem = {
	              type: "object",
	              origin: "key",
	              input,
	              key: entryKey,
	              value: entryValue
	            };
	            for (const issue of keyDataset.issues) {
	              issue.path = [pathItem];
	              dataset.issues?.push(issue);
	            }
	            if (!dataset.issues) dataset.issues = keyDataset.issues;
	            if (config$1.abortEarly) {
	              dataset.typed = false;
	              break;
	            }
	          }
	          if (valueDataset.issues) {
	            const pathItem = {
	              type: "object",
	              origin: "value",
	              input,
	              key: entryKey,
	              value: entryValue
	            };
	            for (const issue of valueDataset.issues) {
	              if (issue.path) issue.path.unshift(pathItem);
	              else issue.path = [pathItem];
	              dataset.issues?.push(issue);
	            }
	            if (!dataset.issues) dataset.issues = valueDataset.issues;
	            if (config$1.abortEarly) {
	              dataset.typed = false;
	              break;
	            }
	          }
	          if (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;
	          if (keyDataset.typed) dataset.value[keyDataset.value] = valueDataset.value;
	        }
	      } else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function set(value$1, message$1) {
	  return {
	    kind: "schema",
	    type: "set",
	    reference: set,
	    expects: "Set",
	    async: false,
	    value: value$1,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      const input = dataset.value;
	      if (input instanceof Set) {
	        dataset.typed = true;
	        dataset.value = /* @__PURE__ */ new Set();
	        for (const inputValue of input) {
	          const valueDataset = this.value["~run"]({ value: inputValue }, config$1);
	          if (valueDataset.issues) {
	            const pathItem = {
	              type: "set",
	              origin: "value",
	              input,
	              key: null,
	              value: inputValue
	            };
	            for (const issue of valueDataset.issues) {
	              if (issue.path) issue.path.unshift(pathItem);
	              else issue.path = [pathItem];
	              dataset.issues?.push(issue);
	            }
	            if (!dataset.issues) dataset.issues = valueDataset.issues;
	            if (config$1.abortEarly) {
	              dataset.typed = false;
	              break;
	            }
	          }
	          if (!valueDataset.typed) dataset.typed = false;
	          dataset.value.add(valueDataset.value);
	        }
	      } else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function setAsync(value$1, message$1) {
	  return {
	    kind: "schema",
	    type: "set",
	    reference: setAsync,
	    expects: "Set",
	    async: true,
	    value: value$1,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    async "~run"(dataset, config$1) {
	      const input = dataset.value;
	      if (input instanceof Set) {
	        dataset.typed = true;
	        dataset.value = /* @__PURE__ */ new Set();
	        const valueDatasets = await Promise.all([...input].map(async (inputValue) => [inputValue, await this.value["~run"]({ value: inputValue }, config$1)]));
	        for (const [inputValue, valueDataset] of valueDatasets) {
	          if (valueDataset.issues) {
	            const pathItem = {
	              type: "set",
	              origin: "value",
	              input,
	              key: null,
	              value: inputValue
	            };
	            for (const issue of valueDataset.issues) {
	              if (issue.path) issue.path.unshift(pathItem);
	              else issue.path = [pathItem];
	              dataset.issues?.push(issue);
	            }
	            if (!dataset.issues) dataset.issues = valueDataset.issues;
	            if (config$1.abortEarly) {
	              dataset.typed = false;
	              break;
	            }
	          }
	          if (!valueDataset.typed) dataset.typed = false;
	          dataset.value.add(valueDataset.value);
	        }
	      } else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function strictObject(entries$1, message$1) {
	  return {
	    kind: "schema",
	    type: "strict_object",
	    reference: strictObject,
	    expects: "Object",
	    async: false,
	    entries: entries$1,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      const input = dataset.value;
	      if (input && typeof input === "object") {
	        dataset.typed = true;
	        dataset.value = {};
	        for (const key in this.entries) {
	          const valueSchema = this.entries[key];
	          if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
	            const value$1 = key in input ? input[key] : /* @__PURE__ */ getDefault(valueSchema);
	            const valueDataset = valueSchema["~run"]({ value: value$1 }, config$1);
	            if (valueDataset.issues) {
	              const pathItem = {
	                type: "object",
	                origin: "value",
	                input,
	                key,
	                value: value$1
	              };
	              for (const issue of valueDataset.issues) {
	                if (issue.path) issue.path.unshift(pathItem);
	                else issue.path = [pathItem];
	                dataset.issues?.push(issue);
	              }
	              if (!dataset.issues) dataset.issues = valueDataset.issues;
	              if (config$1.abortEarly) {
	                dataset.typed = false;
	                break;
	              }
	            }
	            if (!valueDataset.typed) dataset.typed = false;
	            dataset.value[key] = valueDataset.value;
	          } else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */ getFallback(valueSchema);
	          else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
	            _addIssue(this, "key", dataset, config$1, {
	              input: void 0,
	              expected: `"${key}"`,
	              path: [{
	                type: "object",
	                origin: "key",
	                input,
	                key,
	                value: input[key]
	              }]
	            });
	            if (config$1.abortEarly) break;
	          }
	        }
	        if (!dataset.issues || !config$1.abortEarly) {
	          for (const key in input) if (!(key in this.entries)) {
	            _addIssue(this, "key", dataset, config$1, {
	              input: key,
	              expected: "never",
	              path: [{
	                type: "object",
	                origin: "key",
	                input,
	                key,
	                value: input[key]
	              }]
	            });
	            break;
	          }
	        }
	      } else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function strictObjectAsync(entries$1, message$1) {
	  return {
	    kind: "schema",
	    type: "strict_object",
	    reference: strictObjectAsync,
	    expects: "Object",
	    async: true,
	    entries: entries$1,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    async "~run"(dataset, config$1) {
	      const input = dataset.value;
	      if (input && typeof input === "object") {
	        dataset.typed = true;
	        dataset.value = {};
	        const valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema]) => {
	          if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
	            const value$1 = key in input ? input[key] : await /* @__PURE__ */ getDefault(valueSchema);
	            return [
	              key,
	              value$1,
	              valueSchema,
	              await valueSchema["~run"]({ value: value$1 }, config$1)
	            ];
	          }
	          return [
	            key,
	            input[key],
	            valueSchema,
	            null
	          ];
	        }));
	        for (const [key, value$1, valueSchema, valueDataset] of valueDatasets) if (valueDataset) {
	          if (valueDataset.issues) {
	            const pathItem = {
	              type: "object",
	              origin: "value",
	              input,
	              key,
	              value: value$1
	            };
	            for (const issue of valueDataset.issues) {
	              if (issue.path) issue.path.unshift(pathItem);
	              else issue.path = [pathItem];
	              dataset.issues?.push(issue);
	            }
	            if (!dataset.issues) dataset.issues = valueDataset.issues;
	            if (config$1.abortEarly) {
	              dataset.typed = false;
	              break;
	            }
	          }
	          if (!valueDataset.typed) dataset.typed = false;
	          dataset.value[key] = valueDataset.value;
	        } else if (valueSchema.fallback !== void 0) dataset.value[key] = await /* @__PURE__ */ getFallback(valueSchema);
	        else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
	          _addIssue(this, "key", dataset, config$1, {
	            input: void 0,
	            expected: `"${key}"`,
	            path: [{
	              type: "object",
	              origin: "key",
	              input,
	              key,
	              value: value$1
	            }]
	          });
	          if (config$1.abortEarly) break;
	        }
	        if (!dataset.issues || !config$1.abortEarly) {
	          for (const key in input) if (!(key in this.entries)) {
	            _addIssue(this, "key", dataset, config$1, {
	              input: key,
	              expected: "never",
	              path: [{
	                type: "object",
	                origin: "key",
	                input,
	                key,
	                value: input[key]
	              }]
	            });
	            break;
	          }
	        }
	      } else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function strictTuple(items, message$1) {
	  return {
	    kind: "schema",
	    type: "strict_tuple",
	    reference: strictTuple,
	    expects: "Array",
	    async: false,
	    items,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      const input = dataset.value;
	      if (Array.isArray(input)) {
	        dataset.typed = true;
	        dataset.value = [];
	        for (let key = 0; key < this.items.length; key++) {
	          const value$1 = input[key];
	          const itemDataset = this.items[key]["~run"]({ value: value$1 }, config$1);
	          if (itemDataset.issues) {
	            const pathItem = {
	              type: "array",
	              origin: "value",
	              input,
	              key,
	              value: value$1
	            };
	            for (const issue of itemDataset.issues) {
	              if (issue.path) issue.path.unshift(pathItem);
	              else issue.path = [pathItem];
	              dataset.issues?.push(issue);
	            }
	            if (!dataset.issues) dataset.issues = itemDataset.issues;
	            if (config$1.abortEarly) {
	              dataset.typed = false;
	              break;
	            }
	          }
	          if (!itemDataset.typed) dataset.typed = false;
	          dataset.value.push(itemDataset.value);
	        }
	        if (!(dataset.issues && config$1.abortEarly) && this.items.length < input.length) _addIssue(this, "type", dataset, config$1, {
	          input: input[this.items.length],
	          expected: "never",
	          path: [{
	            type: "array",
	            origin: "value",
	            input,
	            key: this.items.length,
	            value: input[this.items.length]
	          }]
	        });
	      } else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function strictTupleAsync(items, message$1) {
	  return {
	    kind: "schema",
	    type: "strict_tuple",
	    reference: strictTupleAsync,
	    expects: "Array",
	    async: true,
	    items,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    async "~run"(dataset, config$1) {
	      const input = dataset.value;
	      if (Array.isArray(input)) {
	        dataset.typed = true;
	        dataset.value = [];
	        const itemDatasets = await Promise.all(this.items.map(async (item, key) => {
	          const value$1 = input[key];
	          return [
	            key,
	            value$1,
	            await item["~run"]({ value: value$1 }, config$1)
	          ];
	        }));
	        for (const [key, value$1, itemDataset] of itemDatasets) {
	          if (itemDataset.issues) {
	            const pathItem = {
	              type: "array",
	              origin: "value",
	              input,
	              key,
	              value: value$1
	            };
	            for (const issue of itemDataset.issues) {
	              if (issue.path) issue.path.unshift(pathItem);
	              else issue.path = [pathItem];
	              dataset.issues?.push(issue);
	            }
	            if (!dataset.issues) dataset.issues = itemDataset.issues;
	            if (config$1.abortEarly) {
	              dataset.typed = false;
	              break;
	            }
	          }
	          if (!itemDataset.typed) dataset.typed = false;
	          dataset.value.push(itemDataset.value);
	        }
	        if (!(dataset.issues && config$1.abortEarly) && this.items.length < input.length) _addIssue(this, "type", dataset, config$1, {
	          input: input[this.items.length],
	          expected: "never",
	          path: [{
	            type: "array",
	            origin: "value",
	            input,
	            key: this.items.length,
	            value: input[this.items.length]
	          }]
	        });
	      } else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function string(message$1) {
	  return {
	    kind: "schema",
	    type: "string",
	    reference: string,
	    expects: "string",
	    async: false,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      if (typeof dataset.value === "string") dataset.typed = true;
	      else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function symbol(message$1) {
	  return {
	    kind: "schema",
	    type: "symbol",
	    reference: symbol,
	    expects: "symbol",
	    async: false,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      if (typeof dataset.value === "symbol") dataset.typed = true;
	      else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function tuple(items, message$1) {
	  return {
	    kind: "schema",
	    type: "tuple",
	    reference: tuple,
	    expects: "Array",
	    async: false,
	    items,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      const input = dataset.value;
	      if (Array.isArray(input)) {
	        dataset.typed = true;
	        dataset.value = [];
	        for (let key = 0; key < this.items.length; key++) {
	          const value$1 = input[key];
	          const itemDataset = this.items[key]["~run"]({ value: value$1 }, config$1);
	          if (itemDataset.issues) {
	            const pathItem = {
	              type: "array",
	              origin: "value",
	              input,
	              key,
	              value: value$1
	            };
	            for (const issue of itemDataset.issues) {
	              if (issue.path) issue.path.unshift(pathItem);
	              else issue.path = [pathItem];
	              dataset.issues?.push(issue);
	            }
	            if (!dataset.issues) dataset.issues = itemDataset.issues;
	            if (config$1.abortEarly) {
	              dataset.typed = false;
	              break;
	            }
	          }
	          if (!itemDataset.typed) dataset.typed = false;
	          dataset.value.push(itemDataset.value);
	        }
	      } else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function tupleAsync(items, message$1) {
	  return {
	    kind: "schema",
	    type: "tuple",
	    reference: tupleAsync,
	    expects: "Array",
	    async: true,
	    items,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    async "~run"(dataset, config$1) {
	      const input = dataset.value;
	      if (Array.isArray(input)) {
	        dataset.typed = true;
	        dataset.value = [];
	        const itemDatasets = await Promise.all(this.items.map(async (item, key) => {
	          const value$1 = input[key];
	          return [
	            key,
	            value$1,
	            await item["~run"]({ value: value$1 }, config$1)
	          ];
	        }));
	        for (const [key, value$1, itemDataset] of itemDatasets) {
	          if (itemDataset.issues) {
	            const pathItem = {
	              type: "array",
	              origin: "value",
	              input,
	              key,
	              value: value$1
	            };
	            for (const issue of itemDataset.issues) {
	              if (issue.path) issue.path.unshift(pathItem);
	              else issue.path = [pathItem];
	              dataset.issues?.push(issue);
	            }
	            if (!dataset.issues) dataset.issues = itemDataset.issues;
	            if (config$1.abortEarly) {
	              dataset.typed = false;
	              break;
	            }
	          }
	          if (!itemDataset.typed) dataset.typed = false;
	          dataset.value.push(itemDataset.value);
	        }
	      } else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function tupleWithRest(items, rest, message$1) {
	  return {
	    kind: "schema",
	    type: "tuple_with_rest",
	    reference: tupleWithRest,
	    expects: "Array",
	    async: false,
	    items,
	    rest,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      const input = dataset.value;
	      if (Array.isArray(input)) {
	        dataset.typed = true;
	        dataset.value = [];
	        for (let key = 0; key < this.items.length; key++) {
	          const value$1 = input[key];
	          const itemDataset = this.items[key]["~run"]({ value: value$1 }, config$1);
	          if (itemDataset.issues) {
	            const pathItem = {
	              type: "array",
	              origin: "value",
	              input,
	              key,
	              value: value$1
	            };
	            for (const issue of itemDataset.issues) {
	              if (issue.path) issue.path.unshift(pathItem);
	              else issue.path = [pathItem];
	              dataset.issues?.push(issue);
	            }
	            if (!dataset.issues) dataset.issues = itemDataset.issues;
	            if (config$1.abortEarly) {
	              dataset.typed = false;
	              break;
	            }
	          }
	          if (!itemDataset.typed) dataset.typed = false;
	          dataset.value.push(itemDataset.value);
	        }
	        if (!dataset.issues || !config$1.abortEarly) for (let key = this.items.length; key < input.length; key++) {
	          const value$1 = input[key];
	          const itemDataset = this.rest["~run"]({ value: value$1 }, config$1);
	          if (itemDataset.issues) {
	            const pathItem = {
	              type: "array",
	              origin: "value",
	              input,
	              key,
	              value: value$1
	            };
	            for (const issue of itemDataset.issues) {
	              if (issue.path) issue.path.unshift(pathItem);
	              else issue.path = [pathItem];
	              dataset.issues?.push(issue);
	            }
	            if (!dataset.issues) dataset.issues = itemDataset.issues;
	            if (config$1.abortEarly) {
	              dataset.typed = false;
	              break;
	            }
	          }
	          if (!itemDataset.typed) dataset.typed = false;
	          dataset.value.push(itemDataset.value);
	        }
	      } else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function tupleWithRestAsync(items, rest, message$1) {
	  return {
	    kind: "schema",
	    type: "tuple_with_rest",
	    reference: tupleWithRestAsync,
	    expects: "Array",
	    async: true,
	    items,
	    rest,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    async "~run"(dataset, config$1) {
	      const input = dataset.value;
	      if (Array.isArray(input)) {
	        dataset.typed = true;
	        dataset.value = [];
	        const [normalDatasets, restDatasets] = await Promise.all([Promise.all(this.items.map(async (item, key) => {
	          const value$1 = input[key];
	          return [
	            key,
	            value$1,
	            await item["~run"]({ value: value$1 }, config$1)
	          ];
	        })), Promise.all(input.slice(this.items.length).map(async (value$1, key) => {
	          return [
	            key + this.items.length,
	            value$1,
	            await this.rest["~run"]({ value: value$1 }, config$1)
	          ];
	        }))]);
	        for (const [key, value$1, itemDataset] of normalDatasets) {
	          if (itemDataset.issues) {
	            const pathItem = {
	              type: "array",
	              origin: "value",
	              input,
	              key,
	              value: value$1
	            };
	            for (const issue of itemDataset.issues) {
	              if (issue.path) issue.path.unshift(pathItem);
	              else issue.path = [pathItem];
	              dataset.issues?.push(issue);
	            }
	            if (!dataset.issues) dataset.issues = itemDataset.issues;
	            if (config$1.abortEarly) {
	              dataset.typed = false;
	              break;
	            }
	          }
	          if (!itemDataset.typed) dataset.typed = false;
	          dataset.value.push(itemDataset.value);
	        }
	        if (!dataset.issues || !config$1.abortEarly) for (const [key, value$1, itemDataset] of restDatasets) {
	          if (itemDataset.issues) {
	            const pathItem = {
	              type: "array",
	              origin: "value",
	              input,
	              key,
	              value: value$1
	            };
	            for (const issue of itemDataset.issues) {
	              if (issue.path) issue.path.unshift(pathItem);
	              else issue.path = [pathItem];
	              dataset.issues?.push(issue);
	            }
	            if (!dataset.issues) dataset.issues = itemDataset.issues;
	            if (config$1.abortEarly) {
	              dataset.typed = false;
	              break;
	            }
	          }
	          if (!itemDataset.typed) dataset.typed = false;
	          dataset.value.push(itemDataset.value);
	        }
	      } else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function undefined_(message$1) {
	  return {
	    kind: "schema",
	    type: "undefined",
	    reference: undefined_,
	    expects: "undefined",
	    async: false,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      if (dataset.value === void 0) dataset.typed = true;
	      else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function undefinedable(wrapped, default_) {
	  return {
	    kind: "schema",
	    type: "undefinedable",
	    reference: undefinedable,
	    expects: `(${wrapped.expects} | undefined)`,
	    async: false,
	    wrapped,
	    default: default_,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      if (dataset.value === void 0) {
	        if (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);
	        if (dataset.value === void 0) {
	          dataset.typed = true;
	          return dataset;
	        }
	      }
	      return this.wrapped["~run"](dataset, config$1);
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function undefinedableAsync(wrapped, default_) {
	  return {
	    kind: "schema",
	    type: "undefinedable",
	    reference: undefinedableAsync,
	    expects: `(${wrapped.expects} | undefined)`,
	    async: true,
	    wrapped,
	    default: default_,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    async "~run"(dataset, config$1) {
	      if (dataset.value === void 0) {
	        if (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);
	        if (dataset.value === void 0) {
	          dataset.typed = true;
	          return dataset;
	        }
	      }
	      return this.wrapped["~run"](dataset, config$1);
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function _subIssues(datasets) {
	  let issues;
	  if (datasets) for (const dataset of datasets) if (issues) issues.push(...dataset.issues);
	  else issues = dataset.issues;
	  return issues;
	}
	// @__NO_SIDE_EFFECTS__
	function union(options, message$1) {
	  return {
	    kind: "schema",
	    type: "union",
	    reference: union,
	    expects: /* @__PURE__ */ _joinExpects(options.map((option) => option.expects), "|"),
	    async: false,
	    options,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      let validDataset;
	      let typedDatasets;
	      let untypedDatasets;
	      for (const schema of this.options) {
	        const optionDataset = schema["~run"]({ value: dataset.value }, config$1);
	        if (optionDataset.typed) if (optionDataset.issues) if (typedDatasets) typedDatasets.push(optionDataset);
	        else typedDatasets = [optionDataset];
	        else {
	          validDataset = optionDataset;
	          break;
	        }
	        else if (untypedDatasets) untypedDatasets.push(optionDataset);
	        else untypedDatasets = [optionDataset];
	      }
	      if (validDataset) return validDataset;
	      if (typedDatasets) {
	        if (typedDatasets.length === 1) return typedDatasets[0];
	        _addIssue(this, "type", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(typedDatasets) });
	        dataset.typed = true;
	      } else if (untypedDatasets?.length === 1) return untypedDatasets[0];
	      else _addIssue(this, "type", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(untypedDatasets) });
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function unionAsync(options, message$1) {
	  return {
	    kind: "schema",
	    type: "union",
	    reference: unionAsync,
	    expects: /* @__PURE__ */ _joinExpects(options.map((option) => option.expects), "|"),
	    async: true,
	    options,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    async "~run"(dataset, config$1) {
	      let validDataset;
	      let typedDatasets;
	      let untypedDatasets;
	      for (const schema of this.options) {
	        const optionDataset = await schema["~run"]({ value: dataset.value }, config$1);
	        if (optionDataset.typed) if (optionDataset.issues) if (typedDatasets) typedDatasets.push(optionDataset);
	        else typedDatasets = [optionDataset];
	        else {
	          validDataset = optionDataset;
	          break;
	        }
	        else if (untypedDatasets) untypedDatasets.push(optionDataset);
	        else untypedDatasets = [optionDataset];
	      }
	      if (validDataset) return validDataset;
	      if (typedDatasets) {
	        if (typedDatasets.length === 1) return typedDatasets[0];
	        _addIssue(this, "type", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(typedDatasets) });
	        dataset.typed = true;
	      } else if (untypedDatasets?.length === 1) return untypedDatasets[0];
	      else _addIssue(this, "type", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(untypedDatasets) });
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function unknown() {
	  return {
	    kind: "schema",
	    type: "unknown",
	    reference: unknown,
	    expects: "unknown",
	    async: false,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset) {
	      dataset.typed = true;
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function variant(key, options, message$1) {
	  return {
	    kind: "schema",
	    type: "variant",
	    reference: variant,
	    expects: "Object",
	    async: false,
	    key,
	    options,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      const input = dataset.value;
	      if (input && typeof input === "object") {
	        let outputDataset;
	        let maxDiscriminatorPriority = 0;
	        let invalidDiscriminatorKey = this.key;
	        let expectedDiscriminators = [];
	        const parseOptions = (variant$1, allKeys) => {
	          for (const schema of variant$1.options) {
	            if (schema.type === "variant") parseOptions(schema, new Set(allKeys).add(schema.key));
	            else {
	              let keysAreValid = true;
	              let currentPriority = 0;
	              for (const currentKey of allKeys) {
	                const discriminatorSchema = schema.entries[currentKey];
	                if (currentKey in input ? discriminatorSchema["~run"]({
	                  typed: false,
	                  value: input[currentKey]
	                }, { abortEarly: true }).issues : discriminatorSchema.type !== "exact_optional" && discriminatorSchema.type !== "optional" && discriminatorSchema.type !== "nullish") {
	                  keysAreValid = false;
	                  if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {
	                    maxDiscriminatorPriority = currentPriority;
	                    invalidDiscriminatorKey = currentKey;
	                    expectedDiscriminators = [];
	                  }
	                  if (invalidDiscriminatorKey === currentKey) expectedDiscriminators.push(schema.entries[currentKey].expects);
	                  break;
	                }
	                currentPriority++;
	              }
	              if (keysAreValid) {
	                const optionDataset = schema["~run"]({ value: input }, config$1);
	                if (!outputDataset || !outputDataset.typed && optionDataset.typed) outputDataset = optionDataset;
	              }
	            }
	            if (outputDataset && !outputDataset.issues) break;
	          }
	        };
	        parseOptions(this, /* @__PURE__ */ new Set([this.key]));
	        if (outputDataset) return outputDataset;
	        _addIssue(this, "type", dataset, config$1, {
	          input: input[invalidDiscriminatorKey],
	          expected: /* @__PURE__ */ _joinExpects(expectedDiscriminators, "|"),
	          path: [{
	            type: "object",
	            origin: "value",
	            input,
	            key: invalidDiscriminatorKey,
	            value: input[invalidDiscriminatorKey]
	          }]
	        });
	      } else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function variantAsync(key, options, message$1) {
	  return {
	    kind: "schema",
	    type: "variant",
	    reference: variantAsync,
	    expects: "Object",
	    async: true,
	    key,
	    options,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    async "~run"(dataset, config$1) {
	      const input = dataset.value;
	      if (input && typeof input === "object") {
	        let outputDataset;
	        let maxDiscriminatorPriority = 0;
	        let invalidDiscriminatorKey = this.key;
	        let expectedDiscriminators = [];
	        const parseOptions = async (variant$1, allKeys) => {
	          for (const schema of variant$1.options) {
	            if (schema.type === "variant") await parseOptions(schema, new Set(allKeys).add(schema.key));
	            else {
	              let keysAreValid = true;
	              let currentPriority = 0;
	              for (const currentKey of allKeys) {
	                const discriminatorSchema = schema.entries[currentKey];
	                if (currentKey in input ? (await discriminatorSchema["~run"]({
	                  typed: false,
	                  value: input[currentKey]
	                }, { abortEarly: true })).issues : discriminatorSchema.type !== "exact_optional" && discriminatorSchema.type !== "optional" && discriminatorSchema.type !== "nullish") {
	                  keysAreValid = false;
	                  if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {
	                    maxDiscriminatorPriority = currentPriority;
	                    invalidDiscriminatorKey = currentKey;
	                    expectedDiscriminators = [];
	                  }
	                  if (invalidDiscriminatorKey === currentKey) expectedDiscriminators.push(schema.entries[currentKey].expects);
	                  break;
	                }
	                currentPriority++;
	              }
	              if (keysAreValid) {
	                const optionDataset = await schema["~run"]({ value: input }, config$1);
	                if (!outputDataset || !outputDataset.typed && optionDataset.typed) outputDataset = optionDataset;
	              }
	            }
	            if (outputDataset && !outputDataset.issues) break;
	          }
	        };
	        await parseOptions(this, /* @__PURE__ */ new Set([this.key]));
	        if (outputDataset) return outputDataset;
	        _addIssue(this, "type", dataset, config$1, {
	          input: input[invalidDiscriminatorKey],
	          expected: /* @__PURE__ */ _joinExpects(expectedDiscriminators, "|"),
	          path: [{
	            type: "object",
	            origin: "value",
	            input,
	            key: invalidDiscriminatorKey,
	            value: input[invalidDiscriminatorKey]
	          }]
	        });
	      } else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function void_(message$1) {
	  return {
	    kind: "schema",
	    type: "void",
	    reference: void_,
	    expects: "void",
	    async: false,
	    message: message$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      if (dataset.value === void 0) dataset.typed = true;
	      else _addIssue(this, "type", dataset, config$1);
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function keyof(schema, message$1) {
	  return /* @__PURE__ */ picklist(Object.keys(schema.entries), message$1);
	}
	// @__NO_SIDE_EFFECTS__
	function message(schema, message_) {
	  return {
	    ...schema,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      return schema["~run"](dataset, {
	        ...config$1,
	        message: message_
	      });
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function omit(schema, keys) {
	  const entries$1 = { ...schema.entries };
	  for (const key of keys) delete entries$1[key];
	  return {
	    ...schema,
	    entries: entries$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    }
	  };
	}
	function parse(schema, input, config$1) {
	  const dataset = schema["~run"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));
	  if (dataset.issues) throw new ValiError(dataset.issues);
	  return dataset.value;
	}
	async function parseAsync(schema, input, config$1) {
	  const dataset = await schema["~run"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));
	  if (dataset.issues) throw new ValiError(dataset.issues);
	  return dataset.value;
	}
	// @__NO_SIDE_EFFECTS__
	function parser(schema, config$1) {
	  const func = (input) => parse(schema, input, config$1);
	  func.schema = schema;
	  func.config = config$1;
	  return func;
	}
	// @__NO_SIDE_EFFECTS__
	function parserAsync(schema, config$1) {
	  const func = (input) => parseAsync(schema, input, config$1);
	  func.schema = schema;
	  func.config = config$1;
	  return func;
	}
	// @__NO_SIDE_EFFECTS__
	function partial(schema, keys) {
	  const entries$1 = {};
	  for (const key in schema.entries) entries$1[key] = !keys || keys.includes(key) ? /* @__PURE__ */ optional(schema.entries[key]) : schema.entries[key];
	  return {
	    ...schema,
	    entries: entries$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function partialAsync(schema, keys) {
	  const entries$1 = {};
	  for (const key in schema.entries) entries$1[key] = !keys || keys.includes(key) ? /* @__PURE__ */ optionalAsync(schema.entries[key]) : schema.entries[key];
	  return {
	    ...schema,
	    entries: entries$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function pick(schema, keys) {
	  const entries$1 = {};
	  for (const key of keys) entries$1[key] = schema.entries[key];
	  return {
	    ...schema,
	    entries: entries$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function pipe(...pipe$1) {
	  return {
	    ...pipe$1[0],
	    pipe: pipe$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    "~run"(dataset, config$1) {
	      for (const item of pipe$1) if (item.kind !== "metadata") {
	        if (dataset.issues && (item.kind === "schema" || item.kind === "transformation")) {
	          dataset.typed = false;
	          break;
	        }
	        if (!dataset.issues || !config$1.abortEarly && !config$1.abortPipeEarly) dataset = item["~run"](dataset, config$1);
	      }
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function pipeAsync(...pipe$1) {
	  return {
	    ...pipe$1[0],
	    pipe: pipe$1,
	    async: true,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    },
	    async "~run"(dataset, config$1) {
	      for (const item of pipe$1) if (item.kind !== "metadata") {
	        if (dataset.issues && (item.kind === "schema" || item.kind === "transformation")) {
	          dataset.typed = false;
	          break;
	        }
	        if (!dataset.issues || !config$1.abortEarly && !config$1.abortPipeEarly) dataset = await item["~run"](dataset, config$1);
	      }
	      return dataset;
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function required(schema, arg2, arg3) {
	  const keys = Array.isArray(arg2) ? arg2 : void 0;
	  const message$1 = Array.isArray(arg2) ? arg3 : arg2;
	  const entries$1 = {};
	  for (const key in schema.entries) entries$1[key] = !keys || keys.includes(key) ? /* @__PURE__ */ nonOptional(schema.entries[key], message$1) : schema.entries[key];
	  return {
	    ...schema,
	    entries: entries$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function requiredAsync(schema, arg2, arg3) {
	  const keys = Array.isArray(arg2) ? arg2 : void 0;
	  const message$1 = Array.isArray(arg2) ? arg3 : arg2;
	  const entries$1 = {};
	  for (const key in schema.entries) entries$1[key] = !keys || keys.includes(key) ? /* @__PURE__ */ nonOptionalAsync(schema.entries[key], message$1) : schema.entries[key];
	  return {
	    ...schema,
	    entries: entries$1,
	    get "~standard"() {
	      return /* @__PURE__ */ _getStandardProps(this);
	    }
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function safeParse(schema, input, config$1) {
	  const dataset = schema["~run"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));
	  return {
	    typed: dataset.typed,
	    success: !dataset.issues,
	    output: dataset.value,
	    issues: dataset.issues
	  };
	}
	// @__NO_SIDE_EFFECTS__
	async function safeParseAsync(schema, input, config$1) {
	  const dataset = await schema["~run"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));
	  return {
	    typed: dataset.typed,
	    success: !dataset.issues,
	    output: dataset.value,
	    issues: dataset.issues
	  };
	}
	// @__NO_SIDE_EFFECTS__
	function safeParser(schema, config$1) {
	  const func = (input) => /* @__PURE__ */ safeParse(schema, input, config$1);
	  func.schema = schema;
	  func.config = config$1;
	  return func;
	}
	// @__NO_SIDE_EFFECTS__
	function safeParserAsync(schema, config$1) {
	  const func = (input) => /* @__PURE__ */ safeParseAsync(schema, input, config$1);
	  func.schema = schema;
	  func.config = config$1;
	  return func;
	}
	// @__NO_SIDE_EFFECTS__
	function summarize(issues) {
	  let summary = "";
	  for (const issue of issues) {
	    if (summary) summary += "\n";
	    summary += ` ${issue.message}`;
	    const dotPath = /* @__PURE__ */ getDotPath(issue);
	    if (dotPath) summary += `
   at ${dotPath}`;
	  }
	  return summary;
	}
	// @__NO_SIDE_EFFECTS__
	function unwrap(schema) {
	  return schema.wrapped;
	}
	dist.BASE64_REGEX = BASE64_REGEX;
	dist.BIC_REGEX = BIC_REGEX;
	dist.CUID2_REGEX = CUID2_REGEX;
	dist.DECIMAL_REGEX = DECIMAL_REGEX;
	dist.DIGITS_REGEX = DIGITS_REGEX;
	dist.EMAIL_REGEX = EMAIL_REGEX;
	dist.EMOJI_REGEX = EMOJI_REGEX;
	dist.HEXADECIMAL_REGEX = HEXADECIMAL_REGEX;
	dist.HEX_COLOR_REGEX = HEX_COLOR_REGEX;
	dist.IMEI_REGEX = IMEI_REGEX;
	dist.IPV4_REGEX = IPV4_REGEX;
	dist.IPV6_REGEX = IPV6_REGEX;
	dist.IP_REGEX = IP_REGEX;
	dist.ISO_DATE_REGEX = ISO_DATE_REGEX;
	dist.ISO_DATE_TIME_REGEX = ISO_DATE_TIME_REGEX;
	dist.ISO_TIMESTAMP_REGEX = ISO_TIMESTAMP_REGEX;
	dist.ISO_TIME_REGEX = ISO_TIME_REGEX;
	dist.ISO_TIME_SECOND_REGEX = ISO_TIME_SECOND_REGEX;
	dist.ISO_WEEK_REGEX = ISO_WEEK_REGEX;
	dist.MAC48_REGEX = MAC48_REGEX;
	dist.MAC64_REGEX = MAC64_REGEX;
	dist.MAC_REGEX = MAC_REGEX;
	dist.NANO_ID_REGEX = NANO_ID_REGEX;
	dist.OCTAL_REGEX = OCTAL_REGEX;
	dist.RFC_EMAIL_REGEX = RFC_EMAIL_REGEX;
	dist.SLUG_REGEX = SLUG_REGEX;
	dist.ULID_REGEX = ULID_REGEX;
	dist.UUID_REGEX = UUID_REGEX;
	dist.ValiError = ValiError;
	dist._addIssue = _addIssue;
	dist._getByteCount = _getByteCount;
	dist._getGraphemeCount = _getGraphemeCount;
	dist._getLastMetadata = _getLastMetadata;
	dist._getStandardProps = _getStandardProps;
	dist._getWordCount = _getWordCount;
	dist._isLuhnAlgo = _isLuhnAlgo;
	dist._isValidObjectKey = _isValidObjectKey;
	dist._joinExpects = _joinExpects;
	dist._stringify = _stringify;
	dist.any = any;
	dist.args = args;
	dist.argsAsync = argsAsync;
	dist.array = array;
	dist.arrayAsync = arrayAsync;
	dist.assert = assert;
	dist.awaitAsync = awaitAsync;
	dist.base64 = base64;
	dist.bic = bic;
	dist.bigint = bigint;
	dist.blob = blob;
	dist.boolean = boolean;
	dist.brand = brand;
	dist.bytes = bytes;
	dist.check = check;
	dist.checkAsync = checkAsync;
	dist.checkItems = checkItems;
	dist.checkItemsAsync = checkItemsAsync;
	dist.config = config;
	dist.creditCard = creditCard;
	dist.cuid2 = cuid2;
	dist.custom = custom;
	dist.customAsync = customAsync;
	dist.date = date;
	dist.decimal = decimal;
	dist.deleteGlobalConfig = deleteGlobalConfig;
	dist.deleteGlobalMessage = deleteGlobalMessage;
	dist.deleteSchemaMessage = deleteSchemaMessage;
	dist.deleteSpecificMessage = deleteSpecificMessage;
	dist.description = description;
	dist.digits = digits;
	dist.email = email;
	dist.emoji = emoji;
	dist.empty = empty;
	dist.endsWith = endsWith;
	dist.entries = entries;
	dist.entriesFromList = entriesFromList;
	dist.entriesFromObjects = entriesFromObjects;
	dist.enum = enum_;
	dist.enum_ = enum_;
	dist.everyItem = everyItem;
	dist.exactOptional = exactOptional;
	dist.exactOptionalAsync = exactOptionalAsync;
	dist.examples = examples;
	dist.excludes = excludes;
	dist.fallback = fallback;
	dist.fallbackAsync = fallbackAsync;
	dist.file = file;
	dist.filterItems = filterItems;
	dist.findItem = findItem;
	dist.finite = finite;
	dist.flatten = flatten;
	dist.flavor = flavor;
	dist.forward = forward;
	dist.forwardAsync = forwardAsync;
	dist.function = function_;
	dist.function_ = function_;
	dist.getDefault = getDefault;
	dist.getDefaults = getDefaults;
	dist.getDefaultsAsync = getDefaultsAsync;
	dist.getDescription = getDescription;
	dist.getDotPath = getDotPath;
	dist.getExamples = getExamples;
	dist.getFallback = getFallback;
	dist.getFallbacks = getFallbacks;
	dist.getFallbacksAsync = getFallbacksAsync;
	dist.getGlobalConfig = getGlobalConfig;
	dist.getGlobalMessage = getGlobalMessage;
	dist.getMetadata = getMetadata;
	dist.getSchemaMessage = getSchemaMessage;
	dist.getSpecificMessage = getSpecificMessage;
	dist.getTitle = getTitle;
	dist.graphemes = graphemes;
	dist.gtValue = gtValue;
	dist.hash = hash;
	dist.hexColor = hexColor;
	dist.hexadecimal = hexadecimal;
	dist.imei = imei;
	dist.includes = includes;
	dist.instance = instance;
	dist.integer = integer;
	dist.intersect = intersect;
	dist.intersectAsync = intersectAsync;
	dist.ip = ip;
	dist.ipv4 = ipv4;
	dist.ipv6 = ipv6;
	dist.is = is;
	dist.isOfKind = isOfKind;
	dist.isOfType = isOfType;
	dist.isValiError = isValiError;
	dist.isoDate = isoDate;
	dist.isoDateTime = isoDateTime;
	dist.isoTime = isoTime;
	dist.isoTimeSecond = isoTimeSecond;
	dist.isoTimestamp = isoTimestamp;
	dist.isoWeek = isoWeek;
	dist.keyof = keyof;
	dist.lazy = lazy;
	dist.lazyAsync = lazyAsync;
	dist.length = length;
	dist.literal = literal;
	dist.looseObject = looseObject;
	dist.looseObjectAsync = looseObjectAsync;
	dist.looseTuple = looseTuple;
	dist.looseTupleAsync = looseTupleAsync;
	dist.ltValue = ltValue;
	dist.mac = mac;
	dist.mac48 = mac48;
	dist.mac64 = mac64;
	dist.map = map;
	dist.mapAsync = mapAsync;
	dist.mapItems = mapItems;
	dist.maxBytes = maxBytes;
	dist.maxEntries = maxEntries;
	dist.maxGraphemes = maxGraphemes;
	dist.maxLength = maxLength;
	dist.maxSize = maxSize;
	dist.maxValue = maxValue;
	dist.maxWords = maxWords;
	dist.message = message;
	dist.metadata = metadata;
	dist.mimeType = mimeType;
	dist.minBytes = minBytes;
	dist.minEntries = minEntries;
	dist.minGraphemes = minGraphemes;
	dist.minLength = minLength;
	dist.minSize = minSize;
	dist.minValue = minValue;
	dist.minWords = minWords;
	dist.multipleOf = multipleOf;
	dist.nan = nan;
	dist.nanoid = nanoid;
	dist.never = never;
	dist.nonEmpty = nonEmpty;
	dist.nonNullable = nonNullable;
	dist.nonNullableAsync = nonNullableAsync;
	dist.nonNullish = nonNullish;
	dist.nonNullishAsync = nonNullishAsync;
	dist.nonOptional = nonOptional;
	dist.nonOptionalAsync = nonOptionalAsync;
	dist.normalize = normalize;
	dist.notBytes = notBytes;
	dist.notEntries = notEntries;
	dist.notGraphemes = notGraphemes;
	dist.notLength = notLength;
	dist.notSize = notSize;
	dist.notValue = notValue;
	dist.notValues = notValues;
	dist.notWords = notWords;
	dist.null = null_;
	dist.null_ = null_;
	dist.nullable = nullable;
	dist.nullableAsync = nullableAsync;
	dist.nullish = nullish;
	dist.nullishAsync = nullishAsync;
	dist.number = number;
	dist.object = object;
	dist.objectAsync = objectAsync;
	dist.objectWithRest = objectWithRest;
	dist.objectWithRestAsync = objectWithRestAsync;
	dist.octal = octal;
	dist.omit = omit;
	dist.optional = optional;
	dist.optionalAsync = optionalAsync;
	dist.parse = parse;
	dist.parseAsync = parseAsync;
	dist.parseJson = parseJson;
	dist.parser = parser;
	dist.parserAsync = parserAsync;
	dist.partial = partial;
	dist.partialAsync = partialAsync;
	dist.partialCheck = partialCheck;
	dist.partialCheckAsync = partialCheckAsync;
	dist.pick = pick;
	dist.picklist = picklist;
	dist.pipe = pipe;
	dist.pipeAsync = pipeAsync;
	dist.promise = promise;
	dist.rawCheck = rawCheck;
	dist.rawCheckAsync = rawCheckAsync;
	dist.rawTransform = rawTransform;
	dist.rawTransformAsync = rawTransformAsync;
	dist.readonly = readonly;
	dist.record = record;
	dist.recordAsync = recordAsync;
	dist.reduceItems = reduceItems;
	dist.regex = regex;
	dist.required = required;
	dist.requiredAsync = requiredAsync;
	dist.returns = returns;
	dist.returnsAsync = returnsAsync;
	dist.rfcEmail = rfcEmail;
	dist.safeInteger = safeInteger;
	dist.safeParse = safeParse;
	dist.safeParseAsync = safeParseAsync;
	dist.safeParser = safeParser;
	dist.safeParserAsync = safeParserAsync;
	dist.set = set;
	dist.setAsync = setAsync;
	dist.setGlobalConfig = setGlobalConfig;
	dist.setGlobalMessage = setGlobalMessage;
	dist.setSchemaMessage = setSchemaMessage;
	dist.setSpecificMessage = setSpecificMessage;
	dist.size = size;
	dist.slug = slug;
	dist.someItem = someItem;
	dist.sortItems = sortItems;
	dist.startsWith = startsWith;
	dist.strictObject = strictObject;
	dist.strictObjectAsync = strictObjectAsync;
	dist.strictTuple = strictTuple;
	dist.strictTupleAsync = strictTupleAsync;
	dist.string = string;
	dist.stringifyJson = stringifyJson;
	dist.summarize = summarize;
	dist.symbol = symbol;
	dist.title = title;
	dist.toBigint = toBigint;
	dist.toBoolean = toBoolean;
	dist.toDate = toDate;
	dist.toLowerCase = toLowerCase;
	dist.toMaxValue = toMaxValue;
	dist.toMinValue = toMinValue;
	dist.toNumber = toNumber;
	dist.toString = toString;
	dist.toUpperCase = toUpperCase;
	dist.transform = transform;
	dist.transformAsync = transformAsync;
	dist.trim = trim;
	dist.trimEnd = trimEnd;
	dist.trimStart = trimStart;
	dist.tuple = tuple;
	dist.tupleAsync = tupleAsync;
	dist.tupleWithRest = tupleWithRest;
	dist.tupleWithRestAsync = tupleWithRestAsync;
	dist.ulid = ulid;
	dist.undefined = undefined_;
	dist.undefined_ = undefined_;
	dist.undefinedable = undefinedable;
	dist.undefinedableAsync = undefinedableAsync;
	dist.union = union;
	dist.unionAsync = unionAsync;
	dist.unknown = unknown;
	dist.unwrap = unwrap;
	dist.url = url;
	dist.uuid = uuid;
	dist.value = value;
	dist.values = values;
	dist.variant = variant;
	dist.variantAsync = variantAsync;
	dist.void = void_;
	dist.void_ = void_;
	dist.words = words;
	return dist;
}

export { requireDist as r };
