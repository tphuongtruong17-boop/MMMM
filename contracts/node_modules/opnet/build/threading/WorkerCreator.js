export const isNode = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;
export async function createWorker(workerScript) {
    if (isNode) {
        const { Worker } = await import('worker_threads');
        const worker = new Worker(workerScript, { eval: true });
        worker.on('error', (err) => {
            console.error('[WorkerCreator] Worker error:', err);
        });
        let messageCallback = null;
        worker.on('message', (msg) => {
            if (messageCallback)
                messageCallback(msg);
        });
        worker.unref();
        return {
            postMessage: (msg, transferables) => {
                if (transferables && transferables.length > 0) {
                    worker.postMessage(msg, transferables);
                }
                else {
                    worker.postMessage(msg);
                }
            },
            onMessage: (callback) => {
                messageCallback = callback;
            },
            terminate: async () => {
                await worker.terminate();
            },
        };
    }
    else {
        const blob = new Blob([workerScript], { type: 'application/javascript' });
        const url = URL.createObjectURL(blob);
        const worker = new Worker(url);
        worker.onerror = (err) => {
            console.error('[WorkerCreator] Worker error:', err);
        };
        return {
            postMessage: (msg, transferables) => {
                if (transferables && transferables.length > 0) {
                    worker.postMessage(msg, transferables);
                }
                else {
                    worker.postMessage(msg);
                }
            },
            onMessage: (callback) => {
                worker.onmessage = (e) => callback(e.data);
            },
            terminate: () => {
                worker.terminate();
                URL.revokeObjectURL(url);
            },
        };
    }
}
