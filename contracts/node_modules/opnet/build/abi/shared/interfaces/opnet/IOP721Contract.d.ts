import { Address } from '@btc-vision/transaction';
import { CallResult } from '../../../../contracts/CallResult.js';
import { OPNetEvent } from '../../../../contracts/OPNetEvent.js';
import { IOP_NETContract } from './IOP_NETContract.js';
export type TransferredEventNFT = {
    readonly operator: Address;
    readonly from: Address;
    readonly to: Address;
    readonly amount: bigint;
};
export type ApprovedEventNFT = {
    readonly owner: Address;
    readonly spender: Address;
    readonly amount: bigint;
};
export type ApprovedForAllEventNFT = {
    readonly account: Address;
    readonly operator: Address;
    readonly approved: boolean;
};
export type URIEventNFT = {
    readonly value: string;
    readonly id: bigint;
};
export type NameNFT = CallResult<{
    name: string;
}, [
]>;
export type SymbolNFT = CallResult<{
    symbol: string;
}, [
]>;
export type MaxSupplyNFT = CallResult<{
    maxSupply: bigint;
}, [
]>;
export type CollectionInfo = CallResult<{
    icon: string;
    banner: string;
    description: string;
    website: string;
}, [
]>;
export type TokenURI = CallResult<{
    uri: string;
}, [
]>;
export type ChangeMetadata = CallResult<{}, []>;
export type TotalSupplyNFT = CallResult<{
    totalSupply: bigint;
}, [
]>;
export type BalanceOfNFT = CallResult<{
    balance: bigint;
}, [
]>;
export type OwnerOfNFT = CallResult<{
    owner: Address;
}, [
]>;
export type SafeTransferNFT = CallResult<{}, [OPNetEvent<TransferredEventNFT>]>;
export type SafeTransferFromNFT = CallResult<{}, [OPNetEvent<TransferredEventNFT>]>;
export type ApproveNFT = CallResult<{}, [OPNetEvent<ApprovedEventNFT>]>;
export type GetApprovedNFT = CallResult<{}, []>;
export type SetApprovalForAllNFT = CallResult<{}, [OPNetEvent<ApprovedForAllEventNFT>]>;
export type IsApprovedForAllNFT = CallResult<{
    approved: boolean;
}, [
]>;
export type ApproveBySignatureNFT = CallResult<{}, [OPNetEvent<ApprovedEventNFT>]>;
export type SetApprovalForAllBySignatureNFT = CallResult<{}, [OPNetEvent<ApprovedForAllEventNFT>]>;
export type BurnNFT = CallResult<{}, [OPNetEvent<TransferredEventNFT>]>;
export type DomainSeparatorNFT = CallResult<{
    domainSeparator: Uint8Array;
}, [
]>;
export type TokenOfOwnerByIndex = CallResult<{
    tokenId: bigint;
}, [
]>;
export type GetApproveNonce = CallResult<{
    nonce: bigint;
}, [
]>;
export type SetBaseURI = CallResult<{}, [OPNetEvent<URIEventNFT>]>;
export type MetadataNFT = CallResult<{
    name: string;
    symbol: string;
    icon: string;
    banner: string;
    description: string;
    website: string;
    totalSupply: bigint;
    domainSeparator: Uint8Array;
}, [
]>;
export interface IOP721Contract extends IOP_NETContract {
    name(): Promise<NameNFT>;
    symbol(): Promise<SymbolNFT>;
    maxSupply(): Promise<MaxSupplyNFT>;
    collectionInfo(): Promise<CollectionInfo>;
    tokenURI(tokenId: bigint): Promise<TokenURI>;
    changeMetadata(): Promise<ChangeMetadata>;
    totalSupply(): Promise<TotalSupplyNFT>;
    balanceOf(owner: Address): Promise<BalanceOfNFT>;
    ownerOf(tokenId: bigint): Promise<OwnerOfNFT>;
    safeTransfer(to: Address, tokenId: bigint, data: Uint8Array): Promise<SafeTransferNFT>;
    safeTransferFrom(from: Address, to: Address, tokenId: bigint, data: Uint8Array): Promise<SafeTransferFromNFT>;
    approve(operator: Address, tokenId: bigint): Promise<ApproveNFT>;
    getApproved(tokenId: bigint): Promise<GetApprovedNFT>;
    setApprovalForAll(operator: Address, approved: boolean): Promise<SetApprovalForAllNFT>;
    isApprovedForAll(owner: Address, operator: Address): Promise<IsApprovedForAllNFT>;
    approveBySignature(owner: Uint8Array, ownerTweakedPublicKey: Uint8Array, operator: Address, tokenId: bigint, deadline: bigint, signature: Uint8Array): Promise<ApproveBySignatureNFT>;
    setApprovalForAllBySignature(owner: Uint8Array, ownerTweakedPublicKey: Uint8Array, operator: Address, approved: boolean, deadline: bigint, signature: Uint8Array): Promise<SetApprovalForAllBySignatureNFT>;
    burn(tokenId: bigint): Promise<BurnNFT>;
    domainSeparator(): Promise<DomainSeparatorNFT>;
    tokenOfOwnerByIndex(owner: Address, index: bigint): Promise<TokenOfOwnerByIndex>;
    getApproveNonce(owner: Address): Promise<GetApproveNonce>;
    setBaseURI(baseURI: string): Promise<SetBaseURI>;
    metadata(): Promise<MetadataNFT>;
}
export type IOP721 = IOP721Contract;
