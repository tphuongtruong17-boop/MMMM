import { NetEvent } from '@btc-vision/transaction';
import { getP2op } from '../../cache/P2OPCache.js';
import { decodeRevertData } from '../../utils/RevertDecoder.js';
export class TransactionReceipt {
    receipt;
    receiptProofs;
    events;
    rawEvents = {};
    rawRevert;
    revert;
    gasUsed;
    specialGasUsed;
    constructor(receipt, network) {
        this.receipt = receipt.receipt
            ? Buffer.from(receipt.receipt, 'base64')
            : undefined;
        this.receiptProofs = receipt.receiptProofs || [];
        this.events = receipt.events ? this.parseEvents(receipt.events, network) : {};
        this.rawRevert = receipt.revert
            ? Buffer.from(receipt.revert, 'base64')
            : undefined;
        this.revert = this.rawRevert ? decodeRevertData(this.rawRevert) : undefined;
        this.gasUsed = BigInt(receipt.gasUsed || '0x00') || 0n;
        this.specialGasUsed = BigInt(receipt.specialGasUsed || '0x00') || 0n;
    }
    parseEvents(events, network) {
        const parsedEvents = {};
        if (!Array.isArray(events)) {
            for (const [key, value] of Object.entries(events)) {
                const caP2op = getP2op(key, network);
                const v = value.map((event) => {
                    return this.decodeEvent(event);
                });
                parsedEvents[caP2op] = v;
                this.rawEvents[key] = v;
            }
        }
        else {
            for (const event of events) {
                const parsedEvent = this.decodeEvent(event);
                const contractAddress = event.contractAddress;
                const caP2op = getP2op(contractAddress, network);
                if (!parsedEvents[caP2op]) {
                    parsedEvents[caP2op] = [];
                }
                parsedEvents[caP2op].push(parsedEvent);
                if (!this.rawEvents[contractAddress]) {
                    this.rawEvents[contractAddress] = [];
                }
                this.rawEvents[contractAddress].push(parsedEvent);
            }
        }
        return parsedEvents;
    }
    decodeEvent(event) {
        let eventData;
        if (typeof event.data === 'string') {
            const buf = Buffer.from(event.data, 'base64');
            eventData = new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
        }
        else {
            eventData = event.data;
        }
        return new NetEvent(event.type, eventData);
    }
}
