import { LEAF_VERSION_TAPSCRIPT, MAX_TAPTREE_DEPTH, rootHashFromPath, tapleafHash, tweakKey, } from '../payments/bip341.js';
import { p2tr } from '../payments/p2tr.js';
import { Transaction } from '../transaction.js';
import { isTapleaf, isTaptree } from '../types.js';
import { isP2TR, pubkeyPositionInScript, signatureBlocksAction, witnessStackToScriptWitness, } from './psbtutils.js';
export function tapScriptFinalizer(inputIndex, input, tapLeafHashToFinalize) {
    const tapLeaf = findTapLeafToFinalize(input, inputIndex, tapLeafHashToFinalize);
    try {
        const sigs = sortSignatures(input, tapLeaf);
        const witness = sigs.concat(tapLeaf.script).concat(tapLeaf.controlBlock);
        return { finalScriptWitness: witnessStackToScriptWitness(witness) };
    }
    catch (err) {
        throw new Error(`Can not finalize taproot input #${inputIndex}: ${err}`);
    }
}
export function serializeTaprootSignature(sig, sighashType) {
    const sighashTypeByte = sighashType ? Buffer.from([sighashType]) : Buffer.from([]);
    return Buffer.concat([sig, sighashTypeByte]);
}
export function isTaprootInput(input) {
    return (input &&
        !!(input.tapInternalKey ||
            input.tapMerkleRoot ||
            (input.tapLeafScript && input.tapLeafScript.length) ||
            (input.tapBip32Derivation && input.tapBip32Derivation.length) ||
            (input.witnessUtxo && isP2TR(input.witnessUtxo.script))));
}
export function isTaprootOutput(output, script) {
    return (output &&
        !!(output.tapInternalKey ||
            output.tapTree ||
            (output.tapBip32Derivation && output.tapBip32Derivation.length) ||
            (script && isP2TR(script))));
}
export function checkTaprootInputFields(inputData, newInputData, action) {
    checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action);
    checkIfTapLeafInTree(inputData, newInputData, action);
}
export function checkTaprootOutputFields(outputData, newOutputData, action) {
    checkMixedTaprootAndNonTaprootOutputFields(outputData, newOutputData, action);
    checkTaprootScriptPubkey(outputData, newOutputData);
}
function checkTaprootScriptPubkey(outputData, newOutputData) {
    if (!newOutputData.tapTree && !newOutputData.tapInternalKey)
        return;
    const tapInternalKey = newOutputData.tapInternalKey || outputData.tapInternalKey;
    const tapTree = newOutputData.tapTree || outputData.tapTree;
    if (tapInternalKey) {
        const scriptPubkey = outputData.script;
        const script = getTaprootScripPubkey(tapInternalKey, tapTree);
        if (scriptPubkey && !scriptPubkey.equals(script))
            throw new Error('Error adding output. Script or address missmatch.');
    }
}
function getTaprootScripPubkey(tapInternalKey, tapTree) {
    const scriptTree = tapTree && tapTreeFromList(tapTree.leaves);
    const { output } = p2tr({
        internalPubkey: tapInternalKey,
        scriptTree,
    });
    if (!output)
        throw new Error('Failed to generate taproot script pubkey');
    return output;
}
export function tweakInternalPubKey(inputIndex, input) {
    const tapInternalKey = input.tapInternalKey;
    const outputKey = tapInternalKey && tweakKey(tapInternalKey, input.tapMerkleRoot);
    if (!outputKey)
        throw new Error(`Cannot tweak tap internal key for input #${inputIndex}. Public key: ${tapInternalKey && tapInternalKey.toString('hex')}`);
    return outputKey.x;
}
export function tapTreeToList(tree) {
    if (!isTaptree(tree))
        throw new Error('Cannot convert taptree to tapleaf list. Expecting a tapree structure.');
    return _tapTreeToList(tree);
}
export function tapTreeFromList(leaves = []) {
    if (leaves.length === 1 && leaves[0].depth === 0)
        return {
            output: leaves[0].script,
            version: leaves[0].leafVersion,
        };
    return insertLeavesInTree(leaves);
}
export function checkTaprootInputForSigs(input, action) {
    const sigs = extractTaprootSigs(input);
    return sigs.some((sig) => signatureBlocksAction(sig, decodeSchnorrSignature, action));
}
function decodeSchnorrSignature(signature) {
    return {
        signature: signature.subarray(0, 64),
        hashType: signature.subarray(64)[0] || Transaction.SIGHASH_DEFAULT,
    };
}
function extractTaprootSigs(input) {
    const sigs = [];
    if (input.tapKeySig)
        sigs.push(input.tapKeySig);
    if (input.tapScriptSig)
        sigs.push(...input.tapScriptSig.map((s) => s.signature));
    if (!sigs.length) {
        const finalTapKeySig = getTapKeySigFromWitness(input.finalScriptWitness);
        if (finalTapKeySig)
            sigs.push(finalTapKeySig);
    }
    return sigs;
}
export function getTapKeySigFromWitness(finalScriptWitness) {
    if (!finalScriptWitness)
        return;
    const witness = finalScriptWitness.subarray(2);
    if (witness.length === 64 || witness.length === 65)
        return witness;
}
function _tapTreeToList(tree, leaves = [], depth = 0) {
    if (depth > MAX_TAPTREE_DEPTH)
        throw new Error('Max taptree depth exceeded.');
    if (!tree)
        return [];
    if (isTapleaf(tree)) {
        leaves.push({
            depth,
            leafVersion: tree.version || LEAF_VERSION_TAPSCRIPT,
            script: tree.output,
        });
        return leaves;
    }
    if (tree[0])
        _tapTreeToList(tree[0], leaves, depth + 1);
    if (tree[1])
        _tapTreeToList(tree[1], leaves, depth + 1);
    return leaves;
}
function insertLeavesInTree(leaves) {
    let tree;
    for (const leaf of leaves) {
        tree = insertLeafInTree(leaf, tree);
        if (!tree)
            throw new Error(`No room left to insert tapleaf in tree`);
    }
    return tree;
}
function insertLeafInTree(leaf, tree, depth = 0) {
    if (depth > MAX_TAPTREE_DEPTH)
        throw new Error('Max taptree depth exceeded.');
    if (leaf.depth === depth) {
        if (!tree)
            return {
                output: leaf.script,
                version: leaf.leafVersion,
            };
        return;
    }
    if (isTapleaf(tree))
        return;
    const leftSide = insertLeafInTree(leaf, tree && tree[0], depth + 1);
    if (leftSide)
        return [leftSide, tree && tree[1]];
    const rightSide = insertLeafInTree(leaf, tree && tree[1], depth + 1);
    if (rightSide)
        return [tree && tree[0], rightSide];
}
function checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action) {
    const isBadTaprootUpdate = isTaprootInput(inputData) && hasNonTaprootFields(newInputData);
    const isBadNonTaprootUpdate = hasNonTaprootFields(inputData) && isTaprootInput(newInputData);
    const hasMixedFields = inputData === newInputData &&
        isTaprootInput(newInputData) &&
        hasNonTaprootFields(newInputData);
    if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)
        throw new Error(`Invalid arguments for Psbt.${action}. ` +
            `Cannot use both taproot and non-taproot fields.`);
}
function checkMixedTaprootAndNonTaprootOutputFields(inputData, newInputData, action) {
    const isBadTaprootUpdate = isTaprootOutput(inputData) && hasNonTaprootFields(newInputData);
    const isBadNonTaprootUpdate = hasNonTaprootFields(inputData) && isTaprootOutput(newInputData);
    const hasMixedFields = inputData === newInputData &&
        isTaprootOutput(newInputData) &&
        hasNonTaprootFields(newInputData);
    if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)
        throw new Error(`Invalid arguments for Psbt.${action}. ` +
            `Cannot use both taproot and non-taproot fields.`);
}
function checkIfTapLeafInTree(inputData, newInputData, action) {
    if (newInputData.tapMerkleRoot) {
        const newLeafsInTree = (newInputData.tapLeafScript || []).every((l) => isTapLeafInTree(l, newInputData.tapMerkleRoot));
        const oldLeafsInTree = (inputData.tapLeafScript || []).every((l) => isTapLeafInTree(l, newInputData.tapMerkleRoot));
        if (!newLeafsInTree || !oldLeafsInTree)
            throw new Error(`Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`);
    }
    else if (inputData.tapMerkleRoot) {
        const newLeafsInTree = (newInputData.tapLeafScript || []).every((l) => isTapLeafInTree(l, inputData.tapMerkleRoot));
        if (!newLeafsInTree)
            throw new Error(`Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`);
    }
}
function isTapLeafInTree(tapLeaf, merkleRoot) {
    if (!merkleRoot)
        return true;
    const leafHash = tapleafHash({
        output: tapLeaf.script,
        version: tapLeaf.leafVersion,
    });
    const rootHash = rootHashFromPath(tapLeaf.controlBlock, leafHash);
    return rootHash.equals(merkleRoot);
}
function sortSignatures(input, tapLeaf) {
    const leafHash = tapleafHash({
        output: tapLeaf.script,
        version: tapLeaf.leafVersion,
    });
    return (input.tapScriptSig || [])
        .filter((tss) => tss.leafHash.equals(leafHash))
        .map((tss) => addPubkeyPositionInScript(tapLeaf.script, tss))
        .sort((t1, t2) => t2.positionInScript - t1.positionInScript)
        .map((t) => t.signature);
}
function addPubkeyPositionInScript(script, tss) {
    return Object.assign({
        positionInScript: pubkeyPositionInScript(tss.pubkey, script),
    }, tss);
}
function findTapLeafToFinalize(input, inputIndex, leafHashToFinalize) {
    const { tapScriptSig } = input;
    if (!tapScriptSig || !tapScriptSig.length)
        throw new Error(`Can not finalize taproot input #${inputIndex}. No tapleaf script signature provided.`);
    const tapLeaf = (input.tapLeafScript || [])
        .sort((a, b) => a.controlBlock.length - b.controlBlock.length)
        .find((leaf) => canFinalizeLeaf(leaf, tapScriptSig, leafHashToFinalize));
    if (!tapLeaf)
        throw new Error(`Can not finalize taproot input #${inputIndex}. Signature for tapleaf script not found.`);
    return tapLeaf;
}
function canFinalizeLeaf(leaf, tapScriptSig, hash) {
    const leafHash = tapleafHash({
        output: leaf.script,
        version: leaf.leafVersion,
    });
    const whiteListedHash = !hash || hash.equals(leafHash);
    return (whiteListedHash && tapScriptSig.find((tss) => tss.leafHash.equals(leafHash)) !== undefined);
}
function hasNonTaprootFields(io) {
    return (io &&
        !!(io.redeemScript || io.witnessScript || (io.bip32Derivation && io.bip32Derivation.length)));
}
