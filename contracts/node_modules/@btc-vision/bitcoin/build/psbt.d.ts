import { Psbt as PsbtBase } from 'bip174';
import { KeyValue, PartialSig, PsbtGlobal, PsbtGlobalUpdate, PsbtInput, PsbtInputUpdate, PsbtOutput, PsbtOutputUpdate } from 'bip174/src/lib/interfaces.js';
import { BIP32Interface } from '@btc-vision/bip32';
import { ECPairInterface } from 'ecpair';
import { Network } from './networks.js';
import { Transaction } from './transaction.js';
export interface TransactionInput {
    hash: string | Buffer;
    index: number;
    sequence?: number;
}
export interface PsbtTxInput extends TransactionInput {
    hash: Buffer;
}
export interface TransactionOutput {
    script: Buffer;
    value: number;
}
export interface PsbtTxOutput extends TransactionOutput {
    address: string | undefined;
}
export type ValidateSigFunction = (pubkey: Buffer, msghash: Buffer, signature: Buffer) => boolean;
export interface PsbtBaseExtended extends Omit<PsbtBase, 'inputs'> {
    inputs: PsbtInput[];
    globalMap: PsbtGlobal;
}
export declare class Psbt {
    data: PsbtBaseExtended;
    private readonly __CACHE;
    private readonly opts;
    constructor(opts?: PsbtOptsOptional, data?: PsbtBaseExtended);
    get inputCount(): number;
    get version(): number;
    set version(version: number);
    get locktime(): number;
    set locktime(locktime: number);
    get txInputs(): PsbtTxInput[];
    get txOutputs(): PsbtTxOutput[];
    static fromBase64(data: string, opts?: PsbtOptsOptional): Psbt;
    static fromHex(data: string, opts?: PsbtOptsOptional): Psbt;
    static fromBuffer(buffer: Buffer, opts?: PsbtOptsOptional): Psbt;
    combine(...those: Psbt[]): this;
    clone(): Psbt;
    setMaximumFeeRate(satoshiPerByte: number): void;
    setVersion(version: number): this;
    setVersionTRUC(): this;
    setLocktime(locktime: number): this;
    setInputSequence(inputIndex: number, sequence: number): this;
    addInputs(inputDatas: PsbtInputExtended[], checkPartialSigs?: boolean): this;
    addInput(inputData: PsbtInputExtended, checkPartialSigs?: boolean): this;
    addOutputs(outputDatas: PsbtOutputExtended[]): this;
    addOutput(outputData: PsbtOutputExtended): this;
    extractTransaction(disableFeeCheck?: boolean, disableOutputChecks?: boolean): Transaction;
    getFeeRate(disableOutputChecks?: boolean): number;
    getFee(disableOutputChecks?: boolean): number;
    finalizeAllInputs(): this;
    finalizeInput(inputIndex: number, finalScriptsFunc?: FinalScriptsFunc | FinalTaprootScriptsFunc, canRunChecks?: boolean): this;
    finalizeTaprootInput(inputIndex: number, tapLeafHashToFinalize?: Buffer, finalScriptsFunc?: FinalTaprootScriptsFunc): this;
    getInputType(inputIndex: number): AllScriptType;
    inputHasPubkey(inputIndex: number, pubkey: Buffer): boolean;
    inputHasHDKey(inputIndex: number, root: HDSigner): boolean;
    outputHasPubkey(outputIndex: number, pubkey: Buffer): boolean;
    outputHasHDKey(outputIndex: number, root: HDSigner): boolean;
    validateSignaturesOfAllInputs(validator: ValidateSigFunction): boolean;
    validateSignaturesOfInput(inputIndex: number, validator: ValidateSigFunction, pubkey?: Buffer): boolean;
    signAllInputsHD(hdKeyPair: HDSigner, sighashTypes?: number[]): this;
    signAllInputsHDAsync(hdKeyPair: HDSigner | HDSignerAsync, sighashTypes?: number[]): Promise<void>;
    signInputHD(inputIndex: number, hdKeyPair: HDSigner, sighashTypes?: number[]): this;
    signInputHDAsync(inputIndex: number, hdKeyPair: HDSigner | HDSignerAsync, sighashTypes?: number[]): Promise<void>;
    signAllInputs(keyPair: Signer | SignerAlternative | BIP32Interface | ECPairInterface, sighashTypes?: number[]): this;
    signAllInputsAsync(keyPair: Signer | SignerAlternative | SignerAsync | BIP32Interface | ECPairInterface, sighashTypes?: number[]): Promise<void>;
    signInput(inputIndex: number, keyPair: Signer | SignerAlternative | BIP32Interface | ECPairInterface, sighashTypes?: number[]): this;
    signTaprootInput(inputIndex: number, keyPair: Signer | SignerAlternative | BIP32Interface | ECPairInterface, tapLeafHashToSign?: Buffer, sighashTypes?: number[]): this;
    signInputAsync(inputIndex: number, keyPair: Signer | SignerAlternative | SignerAsync | BIP32Interface | ECPairInterface, sighashTypes?: number[]): Promise<void>;
    signTaprootInputAsync(inputIndex: number, keyPair: Signer | SignerAlternative | SignerAsync | BIP32Interface | ECPairInterface, tapLeafHash?: Buffer, sighashTypes?: number[]): Promise<void>;
    toBuffer(): Buffer;
    toHex(): string;
    toBase64(): string;
    updateGlobal(updateData: PsbtGlobalUpdate): this;
    updateInput(inputIndex: number, updateData: PsbtInputUpdate): this;
    updateOutput(outputIndex: number, updateData: PsbtOutputUpdate): this;
    addUnknownKeyValToGlobal(keyVal: KeyValue): this;
    addUnknownKeyValToInput(inputIndex: number, keyVal: KeyValue): this;
    addUnknownKeyValToOutput(outputIndex: number, keyVal: KeyValue): this;
    clearFinalizedInput(inputIndex: number): this;
    checkTaprootHashesForSig(inputIndex: number, input: PsbtInput, keyPair: Signer | SignerAlternative | SignerAsync | BIP32Interface | ECPairInterface, tapLeafHashToSign?: Buffer, allowedSighashTypes?: number[]): {
        hash: Buffer;
        leafHash?: Buffer;
    }[];
    private _finalizeInput;
    private _finalizeTaprootInput;
    private _validateSignaturesOfInput;
    private validateSignaturesOfTaprootInput;
    private _signInput;
    private _signTaprootInput;
    private _signInputAsync;
    private _signTaprootInputAsync;
}
export interface PsbtOptsOptional {
    network?: Network;
    maximumFeeRate?: number;
    version?: 1 | 2 | 3;
}
export interface PsbtOpts {
    network: Network;
    maximumFeeRate: number;
}
export interface PsbtInputExtended extends PsbtInput, TransactionInput {
    isPayToAnchor?: boolean;
}
export type PsbtOutputExtended = PsbtOutputExtendedAddress | PsbtOutputExtendedScript;
export interface PsbtOutputExtendedAddress extends PsbtOutput {
    address: string;
    value: number;
}
export interface PsbtOutputExtendedScript extends PsbtOutput {
    script: Buffer;
    value: number;
}
interface HDSignerBase {
    publicKey: Buffer;
    fingerprint: Buffer;
}
export interface HDSigner extends HDSignerBase {
    derivePath(path: string): HDSigner;
    sign(hash: Buffer): Buffer;
}
export interface HDSignerAsync extends HDSignerBase {
    derivePath(path: string): HDSignerAsync;
    sign(hash: Buffer): Promise<Buffer>;
}
export interface SignerAlternative {
    publicKey: Buffer;
    lowR: boolean;
    sign(hash: Buffer, lowR?: boolean): Buffer;
    verify(hash: Buffer, signature: Buffer): boolean;
    signSchnorr(hash: Buffer): Buffer;
    verifySchnorr(hash: Buffer, signature: Buffer): boolean;
}
export interface Signer {
    publicKey: Buffer;
    network?: Network;
    sign(hash: Buffer, lowR?: boolean): Buffer;
    signSchnorr?(hash: Buffer): Buffer;
    getPublicKey?(): Buffer;
}
export interface SignerAsync {
    publicKey: Buffer;
    network?: Network;
    sign(hash: Buffer, lowR?: boolean): Promise<Buffer>;
    signSchnorr?(hash: Buffer): Promise<Buffer>;
    getPublicKey?(): Buffer;
}
type FinalScriptsFunc = (inputIndex: number, input: PsbtInput, script: Buffer, isSegwit: boolean, isP2SH: boolean, isP2WSH: boolean, canRunChecks: boolean) => {
    finalScriptSig: Buffer | undefined;
    finalScriptWitness: Buffer | undefined;
};
type FinalTaprootScriptsFunc = (inputIndex: number, input: PsbtInput, tapLeafHashToFinalize?: Buffer) => {
    finalScriptWitness: Buffer | undefined;
};
export declare function getFinalScripts(inputIndex: number, input: PsbtInput, script: Buffer, isSegwit: boolean, isP2SH: boolean, isP2WSH: boolean, canRunChecks?: boolean, solution?: Buffer[]): {
    finalScriptSig: Buffer | undefined;
    finalScriptWitness: Buffer | undefined;
};
export declare function prepareFinalScripts(script: Buffer, scriptType: string, partialSig: PartialSig[], isSegwit: boolean, isP2SH: boolean, isP2WSH: boolean, solution?: Buffer[]): {
    finalScriptSig: Buffer | undefined;
    finalScriptWitness: Buffer | undefined;
};
type AllScriptType = 'witnesspubkeyhash' | 'pubkeyhash' | 'multisig' | 'pubkey' | 'nonstandard' | 'p2sh-witnesspubkeyhash' | 'p2sh-pubkeyhash' | 'p2sh-multisig' | 'p2sh-pubkey' | 'p2sh-nonstandard' | 'p2wsh-pubkeyhash' | 'p2wsh-multisig' | 'p2wsh-pubkey' | 'p2wsh-nonstandard' | 'p2sh-p2wsh-pubkeyhash' | 'p2sh-p2wsh-multisig' | 'p2sh-p2wsh-pubkey' | 'p2sh-p2wsh-nonstandard';
export {};
