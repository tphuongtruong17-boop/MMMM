import { Point } from '@noble/secp256k1';
export const toXOnly = (pubKey) => {
    const buffer = pubKey.length === 32 ? pubKey : pubKey.subarray(1, 33);
    return Buffer.isBuffer(buffer) ? buffer : Buffer.from(buffer);
};
export function bigIntTo32Bytes(num) {
    let hex = num.toString(16);
    hex = hex.padStart(64, '0');
    if (hex.length > 64) {
        hex = hex.slice(-64);
    }
    return Buffer.from(hex, 'hex');
}
export function decompressPublicKey(realPubKey) {
    if (realPubKey.length === 32) {
        return;
    }
    if (![33, 65].includes(realPubKey.length)) {
        console.warn(`Unsupported key length=${realPubKey.length}. Must be 33 (compressed) or 65 (uncompressed).`);
        return;
    }
    let point;
    try {
        point = Point.fromHex(Buffer.from(realPubKey).toString('hex'));
    }
    catch (err) {
        throw new Error('Invalid secp256k1 public key bytes. Cannot parse.');
    }
    const xBuf = bigIntTo32Bytes(point.x);
    const yBuf = bigIntTo32Bytes(point.y);
    const isEven = point.y % 2n === 0n;
    const prefix = isEven ? 0x06 : 0x07;
    const hybridPubKey = Buffer.alloc(65);
    hybridPubKey[0] = prefix;
    xBuf.copy(hybridPubKey, 1);
    yBuf.copy(hybridPubKey, 33);
    const uncompressedPubKey = Buffer.concat([Buffer.from([0x04]), xBuf, yBuf]);
    return {
        hybrid: hybridPubKey,
        uncompressed: uncompressedPubKey,
    };
}
export function pubkeysMatch(a, b) {
    if (a.equals(b))
        return true;
    if (a.length === 65 && b.length === 65) {
        const aCopy = Buffer.from(a);
        const bCopy = Buffer.from(b);
        if (aCopy[0] === 0x06 || aCopy[0] === 0x07)
            aCopy[0] = 0x04;
        if (bCopy[0] === 0x06 || bCopy[0] === 0x07)
            bCopy[0] = 0x04;
        return aCopy.equals(bCopy);
    }
    return false;
}
