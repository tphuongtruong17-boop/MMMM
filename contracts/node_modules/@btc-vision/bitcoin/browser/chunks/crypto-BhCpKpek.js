var ut = {}, rt = {};
rt.byteLength = sr;
rt.toByteArray = cr;
rt.fromByteArray = pr;
var N = [], S = [], nr = typeof Uint8Array < "u" ? Uint8Array : Array, ht = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var Y = 0, or = ht.length; Y < or; ++Y)
  N[Y] = ht[Y], S[ht.charCodeAt(Y)] = Y;
S[45] = 62;
S[95] = 63;
function Lt(c) {
  var h = c.length;
  if (h % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var p = c.indexOf("=");
  p === -1 && (p = h);
  var f = p === h ? 0 : 4 - p % 4;
  return [p, f];
}
function sr(c) {
  var h = Lt(c), p = h[0], f = h[1];
  return (p + f) * 3 / 4 - f;
}
function hr(c, h, p) {
  return (h + p) * 3 / 4 - p;
}
function cr(c) {
  var h, p = Lt(c), f = p[0], y = p[1], a = new nr(hr(c, f, y)), l = 0, d = y > 0 ? f - 4 : f, w;
  for (w = 0; w < d; w += 4)
    h = S[c.charCodeAt(w)] << 18 | S[c.charCodeAt(w + 1)] << 12 | S[c.charCodeAt(w + 2)] << 6 | S[c.charCodeAt(w + 3)], a[l++] = h >> 16 & 255, a[l++] = h >> 8 & 255, a[l++] = h & 255;
  return y === 2 && (h = S[c.charCodeAt(w)] << 2 | S[c.charCodeAt(w + 1)] >> 4, a[l++] = h & 255), y === 1 && (h = S[c.charCodeAt(w)] << 10 | S[c.charCodeAt(w + 1)] << 4 | S[c.charCodeAt(w + 2)] >> 2, a[l++] = h >> 8 & 255, a[l++] = h & 255), a;
}
function ur(c) {
  return N[c >> 18 & 63] + N[c >> 12 & 63] + N[c >> 6 & 63] + N[c & 63];
}
function ar(c, h, p) {
  for (var f, y = [], a = h; a < p; a += 3)
    f = (c[a] << 16 & 16711680) + (c[a + 1] << 8 & 65280) + (c[a + 2] & 255), y.push(ur(f));
  return y.join("");
}
function pr(c) {
  for (var h, p = c.length, f = p % 3, y = [], a = 16383, l = 0, d = p - f; l < d; l += a)
    y.push(ar(c, l, l + a > d ? d : l + a));
  return f === 1 ? (h = c[p - 1], y.push(
    N[h >> 2] + N[h << 4 & 63] + "=="
  )) : f === 2 && (h = (c[p - 2] << 8) + c[p - 1], y.push(
    N[h >> 10] + N[h >> 4 & 63] + N[h << 2 & 63] + "="
  )), y.join("");
}
var at = {};
at.read = function(c, h, p, f, y) {
  var a, l, d = y * 8 - f - 1, w = (1 << d) - 1, g = w >> 1, o = -7, B = p ? y - 1 : 0, U = p ? -1 : 1, m = c[h + B];
  for (B += U, a = m & (1 << -o) - 1, m >>= -o, o += d; o > 0; a = a * 256 + c[h + B], B += U, o -= 8)
    ;
  for (l = a & (1 << -o) - 1, a >>= -o, o += f; o > 0; l = l * 256 + c[h + B], B += U, o -= 8)
    ;
  if (a === 0)
    a = 1 - g;
  else {
    if (a === w)
      return l ? NaN : (m ? -1 : 1) * (1 / 0);
    l = l + Math.pow(2, f), a = a - g;
  }
  return (m ? -1 : 1) * l * Math.pow(2, a - f);
};
at.write = function(c, h, p, f, y, a) {
  var l, d, w, g = a * 8 - y - 1, o = (1 << g) - 1, B = o >> 1, U = y === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, m = f ? 0 : a - 1, _ = f ? 1 : -1, P = h < 0 || h === 0 && 1 / h < 0 ? 1 : 0;
  for (h = Math.abs(h), isNaN(h) || h === 1 / 0 ? (d = isNaN(h) ? 1 : 0, l = o) : (l = Math.floor(Math.log(h) / Math.LN2), h * (w = Math.pow(2, -l)) < 1 && (l--, w *= 2), l + B >= 1 ? h += U / w : h += U * Math.pow(2, 1 - B), h * w >= 2 && (l++, w /= 2), l + B >= o ? (d = 0, l = o) : l + B >= 1 ? (d = (h * w - 1) * Math.pow(2, y), l = l + B) : (d = h * Math.pow(2, B - 1) * Math.pow(2, y), l = 0)); y >= 8; c[p + m] = d & 255, m += _, d /= 256, y -= 8)
    ;
  for (l = l << y | d, g += y; g > 0; c[p + m] = l & 255, m += _, l /= 256, g -= 8)
    ;
  c[p + m - _] |= P * 128;
};
(function(c) {
  const h = rt, p = at, f = typeof Symbol == "function" && typeof Symbol.for == "function" ? /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom") : null;
  c.Buffer = o, c.SlowBuffer = C, c.INSPECT_MAX_BYTES = 50;
  const y = 2147483647;
  c.kMaxLength = y;
  const { Uint8Array: a, ArrayBuffer: l, SharedArrayBuffer: d } = globalThis;
  o.TYPED_ARRAY_SUPPORT = w(), !o.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function w() {
    try {
      const e = new a(1), t = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(t, a.prototype), Object.setPrototypeOf(e, t), e.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(o.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (o.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(o.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (o.isBuffer(this))
        return this.byteOffset;
    }
  });
  function g(e) {
    if (e > y)
      throw new RangeError('The value "' + e + '" is invalid for option "size"');
    const t = new a(e);
    return Object.setPrototypeOf(t, o.prototype), t;
  }
  function o(e, t, r) {
    if (typeof e == "number") {
      if (typeof t == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return _(e);
    }
    return B(e, t, r);
  }
  o.poolSize = 8192;
  function B(e, t, r) {
    if (typeof e == "string")
      return P(e, t);
    if (l.isView(e))
      return et(e);
    if (e == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e
      );
    if (k(e, l) || e && k(e.buffer, l) || typeof d < "u" && (k(e, d) || e && k(e.buffer, d)))
      return X(e, t, r);
    if (typeof e == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const i = e.valueOf && e.valueOf();
    if (i != null && i !== e)
      return o.from(i, t, r);
    const n = it(e);
    if (n) return n;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] == "function")
      return o.from(e[Symbol.toPrimitive]("string"), t, r);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e
    );
  }
  o.from = function(e, t, r) {
    return B(e, t, r);
  }, Object.setPrototypeOf(o.prototype, a.prototype), Object.setPrototypeOf(o, a);
  function U(e) {
    if (typeof e != "number")
      throw new TypeError('"size" argument must be of type number');
    if (e < 0)
      throw new RangeError('The value "' + e + '" is invalid for option "size"');
  }
  function m(e, t, r) {
    return U(e), e <= 0 ? g(e) : t !== void 0 ? typeof r == "string" ? g(e).fill(t, r) : g(e).fill(t) : g(e);
  }
  o.alloc = function(e, t, r) {
    return m(e, t, r);
  };
  function _(e) {
    return U(e), g(e < 0 ? 0 : J(e) | 0);
  }
  o.allocUnsafe = function(e) {
    return _(e);
  }, o.allocUnsafeSlow = function(e) {
    return _(e);
  };
  function P(e, t) {
    if ((typeof t != "string" || t === "") && (t = "utf8"), !o.isEncoding(t))
      throw new TypeError("Unknown encoding: " + t);
    const r = W(e, t) | 0;
    let i = g(r);
    const n = i.write(e, t);
    return n !== r && (i = i.slice(0, n)), i;
  }
  function q(e) {
    const t = e.length < 0 ? 0 : J(e.length) | 0, r = g(t);
    for (let i = 0; i < t; i += 1)
      r[i] = e[i] & 255;
    return r;
  }
  function et(e) {
    if (k(e, a)) {
      const t = new a(e);
      return X(t.buffer, t.byteOffset, t.byteLength);
    }
    return q(e);
  }
  function X(e, t, r) {
    if (t < 0 || e.byteLength < t)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (e.byteLength < t + (r || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let i;
    return t === void 0 && r === void 0 ? i = new a(e) : r === void 0 ? i = new a(e, t) : i = new a(e, t, r), Object.setPrototypeOf(i, o.prototype), i;
  }
  function it(e) {
    if (o.isBuffer(e)) {
      const t = J(e.length) | 0, r = g(t);
      return r.length === 0 || e.copy(r, 0, 0, t), r;
    }
    if (e.length !== void 0)
      return typeof e.length != "number" || st(e.length) ? g(0) : q(e);
    if (e.type === "Buffer" && Array.isArray(e.data))
      return q(e.data);
  }
  function J(e) {
    if (e >= y)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + y.toString(16) + " bytes");
    return e | 0;
  }
  function C(e) {
    return +e != e && (e = 0), o.alloc(+e);
  }
  o.isBuffer = function(t) {
    return t != null && t._isBuffer === !0 && t !== o.prototype;
  }, o.compare = function(t, r) {
    if (k(t, a) && (t = o.from(t, t.offset, t.byteLength)), k(r, a) && (r = o.from(r, r.offset, r.byteLength)), !o.isBuffer(t) || !o.isBuffer(r))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (t === r) return 0;
    let i = t.length, n = r.length;
    for (let s = 0, u = Math.min(i, n); s < u; ++s)
      if (t[s] !== r[s]) {
        i = t[s], n = r[s];
        break;
      }
    return i < n ? -1 : n < i ? 1 : 0;
  }, o.isEncoding = function(t) {
    switch (String(t).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, o.concat = function(t, r) {
    if (!Array.isArray(t))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (t.length === 0)
      return o.alloc(0);
    let i;
    if (r === void 0)
      for (r = 0, i = 0; i < t.length; ++i)
        r += t[i].length;
    const n = o.allocUnsafe(r);
    let s = 0;
    for (i = 0; i < t.length; ++i) {
      let u = t[i];
      if (k(u, a))
        s + u.length > n.length ? (o.isBuffer(u) || (u = o.from(u)), u.copy(n, s)) : a.prototype.set.call(
          n,
          u,
          s
        );
      else if (o.isBuffer(u))
        u.copy(n, s);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      s += u.length;
    }
    return n;
  };
  function W(e, t) {
    if (o.isBuffer(e))
      return e.length;
    if (l.isView(e) || k(e, l))
      return e.byteLength;
    if (typeof e != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e
      );
    const r = e.length, i = arguments.length > 2 && arguments[2] === !0;
    if (!i && r === 0) return 0;
    let n = !1;
    for (; ; )
      switch (t) {
        case "ascii":
        case "latin1":
        case "binary":
          return r;
        case "utf8":
        case "utf-8":
          return ot(e).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return r * 2;
        case "hex":
          return r >>> 1;
        case "base64":
          return bt(e).length;
        default:
          if (n)
            return i ? -1 : ot(e).length;
          t = ("" + t).toLowerCase(), n = !0;
      }
  }
  o.byteLength = W;
  function Ot(e, t, r) {
    let i = !1;
    if ((t === void 0 || t < 0) && (t = 0), t > this.length || ((r === void 0 || r > this.length) && (r = this.length), r <= 0) || (r >>>= 0, t >>>= 0, r <= t))
      return "";
    for (e || (e = "utf8"); ; )
      switch (e) {
        case "hex":
          return Jt(this, t, r);
        case "utf8":
        case "utf-8":
          return wt(this, t, r);
        case "ascii":
          return qt(this, t, r);
        case "latin1":
        case "binary":
          return Xt(this, t, r);
        case "base64":
          return Kt(this, t, r);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Zt(this, t, r);
        default:
          if (i) throw new TypeError("Unknown encoding: " + e);
          e = (e + "").toLowerCase(), i = !0;
      }
  }
  o.prototype._isBuffer = !0;
  function H(e, t, r) {
    const i = e[t];
    e[t] = e[r], e[r] = i;
  }
  o.prototype.swap16 = function() {
    const t = this.length;
    if (t % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let r = 0; r < t; r += 2)
      H(this, r, r + 1);
    return this;
  }, o.prototype.swap32 = function() {
    const t = this.length;
    if (t % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let r = 0; r < t; r += 4)
      H(this, r, r + 3), H(this, r + 1, r + 2);
    return this;
  }, o.prototype.swap64 = function() {
    const t = this.length;
    if (t % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let r = 0; r < t; r += 8)
      H(this, r, r + 7), H(this, r + 1, r + 6), H(this, r + 2, r + 5), H(this, r + 3, r + 4);
    return this;
  }, o.prototype.toString = function() {
    const t = this.length;
    return t === 0 ? "" : arguments.length === 0 ? wt(this, 0, t) : Ot.apply(this, arguments);
  }, o.prototype.toLocaleString = o.prototype.toString, o.prototype.equals = function(t) {
    if (!o.isBuffer(t)) throw new TypeError("Argument must be a Buffer");
    return this === t ? !0 : o.compare(this, t) === 0;
  }, o.prototype.inspect = function() {
    let t = "";
    const r = c.INSPECT_MAX_BYTES;
    return t = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (t += " ... "), "<Buffer " + t + ">";
  }, f && (o.prototype[f] = o.prototype.inspect), o.prototype.compare = function(t, r, i, n, s) {
    if (k(t, a) && (t = o.from(t, t.offset, t.byteLength)), !o.isBuffer(t))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t
      );
    if (r === void 0 && (r = 0), i === void 0 && (i = t ? t.length : 0), n === void 0 && (n = 0), s === void 0 && (s = this.length), r < 0 || i > t.length || n < 0 || s > this.length)
      throw new RangeError("out of range index");
    if (n >= s && r >= i)
      return 0;
    if (n >= s)
      return -1;
    if (r >= i)
      return 1;
    if (r >>>= 0, i >>>= 0, n >>>= 0, s >>>= 0, this === t) return 0;
    let u = s - n, E = i - r;
    const A = Math.min(u, E), x = this.slice(n, s), b = t.slice(r, i);
    for (let I = 0; I < A; ++I)
      if (x[I] !== b[I]) {
        u = x[I], E = b[I];
        break;
      }
    return u < E ? -1 : E < u ? 1 : 0;
  };
  function lt(e, t, r, i, n) {
    if (e.length === 0) return -1;
    if (typeof r == "string" ? (i = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, st(r) && (r = n ? 0 : e.length - 1), r < 0 && (r = e.length + r), r >= e.length) {
      if (n) return -1;
      r = e.length - 1;
    } else if (r < 0)
      if (n) r = 0;
      else return -1;
    if (typeof t == "string" && (t = o.from(t, i)), o.isBuffer(t))
      return t.length === 0 ? -1 : yt(e, t, r, i, n);
    if (typeof t == "number")
      return t = t & 255, typeof a.prototype.indexOf == "function" ? n ? a.prototype.indexOf.call(e, t, r) : a.prototype.lastIndexOf.call(e, t, r) : yt(e, [t], r, i, n);
    throw new TypeError("val must be string, number or Buffer");
  }
  function yt(e, t, r, i, n) {
    let s = 1, u = e.length, E = t.length;
    if (i !== void 0 && (i = String(i).toLowerCase(), i === "ucs2" || i === "ucs-2" || i === "utf16le" || i === "utf-16le")) {
      if (e.length < 2 || t.length < 2)
        return -1;
      s = 2, u /= 2, E /= 2, r /= 2;
    }
    function A(b, I) {
      return s === 1 ? b[I] : b.readUInt16BE(I * s);
    }
    let x;
    if (n) {
      let b = -1;
      for (x = r; x < u; x++)
        if (A(e, x) === A(t, b === -1 ? 0 : x - b)) {
          if (b === -1 && (b = x), x - b + 1 === E) return b * s;
        } else
          b !== -1 && (x -= x - b), b = -1;
    } else
      for (r + E > u && (r = u - E), x = r; x >= 0; x--) {
        let b = !0;
        for (let I = 0; I < E; I++)
          if (A(e, x + I) !== A(t, I)) {
            b = !1;
            break;
          }
        if (b) return x;
      }
    return -1;
  }
  o.prototype.includes = function(t, r, i) {
    return this.indexOf(t, r, i) !== -1;
  }, o.prototype.indexOf = function(t, r, i) {
    return lt(this, t, r, i, !0);
  }, o.prototype.lastIndexOf = function(t, r, i) {
    return lt(this, t, r, i, !1);
  };
  function Ht(e, t, r, i) {
    r = Number(r) || 0;
    const n = e.length - r;
    i ? (i = Number(i), i > n && (i = n)) : i = n;
    const s = t.length;
    i > s / 2 && (i = s / 2);
    let u;
    for (u = 0; u < i; ++u) {
      const E = parseInt(t.substr(u * 2, 2), 16);
      if (st(E)) return u;
      e[r + u] = E;
    }
    return u;
  }
  function Gt(e, t, r, i) {
    return z(ot(t, e.length - r), e, r, i);
  }
  function jt(e, t, r, i) {
    return z(tr(t), e, r, i);
  }
  function Wt(e, t, r, i) {
    return z(bt(t), e, r, i);
  }
  function Vt(e, t, r, i) {
    return z(rr(t, e.length - r), e, r, i);
  }
  o.prototype.write = function(t, r, i, n) {
    if (r === void 0)
      n = "utf8", i = this.length, r = 0;
    else if (i === void 0 && typeof r == "string")
      n = r, i = this.length, r = 0;
    else if (isFinite(r))
      r = r >>> 0, isFinite(i) ? (i = i >>> 0, n === void 0 && (n = "utf8")) : (n = i, i = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const s = this.length - r;
    if ((i === void 0 || i > s) && (i = s), t.length > 0 && (i < 0 || r < 0) || r > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    n || (n = "utf8");
    let u = !1;
    for (; ; )
      switch (n) {
        case "hex":
          return Ht(this, t, r, i);
        case "utf8":
        case "utf-8":
          return Gt(this, t, r, i);
        case "ascii":
        case "latin1":
        case "binary":
          return jt(this, t, r, i);
        case "base64":
          return Wt(this, t, r, i);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Vt(this, t, r, i);
        default:
          if (u) throw new TypeError("Unknown encoding: " + n);
          n = ("" + n).toLowerCase(), u = !0;
      }
  }, o.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function Kt(e, t, r) {
    return t === 0 && r === e.length ? h.fromByteArray(e) : h.fromByteArray(e.slice(t, r));
  }
  function wt(e, t, r) {
    r = Math.min(e.length, r);
    const i = [];
    let n = t;
    for (; n < r; ) {
      const s = e[n];
      let u = null, E = s > 239 ? 4 : s > 223 ? 3 : s > 191 ? 2 : 1;
      if (n + E <= r) {
        let A, x, b, I;
        switch (E) {
          case 1:
            s < 128 && (u = s);
            break;
          case 2:
            A = e[n + 1], (A & 192) === 128 && (I = (s & 31) << 6 | A & 63, I > 127 && (u = I));
            break;
          case 3:
            A = e[n + 1], x = e[n + 2], (A & 192) === 128 && (x & 192) === 128 && (I = (s & 15) << 12 | (A & 63) << 6 | x & 63, I > 2047 && (I < 55296 || I > 57343) && (u = I));
            break;
          case 4:
            A = e[n + 1], x = e[n + 2], b = e[n + 3], (A & 192) === 128 && (x & 192) === 128 && (b & 192) === 128 && (I = (s & 15) << 18 | (A & 63) << 12 | (x & 63) << 6 | b & 63, I > 65535 && I < 1114112 && (u = I));
        }
      }
      u === null ? (u = 65533, E = 1) : u > 65535 && (u -= 65536, i.push(u >>> 10 & 1023 | 55296), u = 56320 | u & 1023), i.push(u), n += E;
    }
    return Yt(i);
  }
  const dt = 4096;
  function Yt(e) {
    const t = e.length;
    if (t <= dt)
      return String.fromCharCode.apply(String, e);
    let r = "", i = 0;
    for (; i < t; )
      r += String.fromCharCode.apply(
        String,
        e.slice(i, i += dt)
      );
    return r;
  }
  function qt(e, t, r) {
    let i = "";
    r = Math.min(e.length, r);
    for (let n = t; n < r; ++n)
      i += String.fromCharCode(e[n] & 127);
    return i;
  }
  function Xt(e, t, r) {
    let i = "";
    r = Math.min(e.length, r);
    for (let n = t; n < r; ++n)
      i += String.fromCharCode(e[n]);
    return i;
  }
  function Jt(e, t, r) {
    const i = e.length;
    (!t || t < 0) && (t = 0), (!r || r < 0 || r > i) && (r = i);
    let n = "";
    for (let s = t; s < r; ++s)
      n += er[e[s]];
    return n;
  }
  function Zt(e, t, r) {
    const i = e.slice(t, r);
    let n = "";
    for (let s = 0; s < i.length - 1; s += 2)
      n += String.fromCharCode(i[s] + i[s + 1] * 256);
    return n;
  }
  o.prototype.slice = function(t, r) {
    const i = this.length;
    t = ~~t, r = r === void 0 ? i : ~~r, t < 0 ? (t += i, t < 0 && (t = 0)) : t > i && (t = i), r < 0 ? (r += i, r < 0 && (r = 0)) : r > i && (r = i), r < t && (r = t);
    const n = this.subarray(t, r);
    return Object.setPrototypeOf(n, o.prototype), n;
  };
  function T(e, t, r) {
    if (e % 1 !== 0 || e < 0) throw new RangeError("offset is not uint");
    if (e + t > r) throw new RangeError("Trying to access beyond buffer length");
  }
  o.prototype.readUintLE = o.prototype.readUIntLE = function(t, r, i) {
    t = t >>> 0, r = r >>> 0, i || T(t, r, this.length);
    let n = this[t], s = 1, u = 0;
    for (; ++u < r && (s *= 256); )
      n += this[t + u] * s;
    return n;
  }, o.prototype.readUintBE = o.prototype.readUIntBE = function(t, r, i) {
    t = t >>> 0, r = r >>> 0, i || T(t, r, this.length);
    let n = this[t + --r], s = 1;
    for (; r > 0 && (s *= 256); )
      n += this[t + --r] * s;
    return n;
  }, o.prototype.readUint8 = o.prototype.readUInt8 = function(t, r) {
    return t = t >>> 0, r || T(t, 1, this.length), this[t];
  }, o.prototype.readUint16LE = o.prototype.readUInt16LE = function(t, r) {
    return t = t >>> 0, r || T(t, 2, this.length), this[t] | this[t + 1] << 8;
  }, o.prototype.readUint16BE = o.prototype.readUInt16BE = function(t, r) {
    return t = t >>> 0, r || T(t, 2, this.length), this[t] << 8 | this[t + 1];
  }, o.prototype.readUint32LE = o.prototype.readUInt32LE = function(t, r) {
    return t = t >>> 0, r || T(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + this[t + 3] * 16777216;
  }, o.prototype.readUint32BE = o.prototype.readUInt32BE = function(t, r) {
    return t = t >>> 0, r || T(t, 4, this.length), this[t] * 16777216 + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]);
  }, o.prototype.readBigUInt64LE = D(function(t) {
    t = t >>> 0, K(t, "offset");
    const r = this[t], i = this[t + 7];
    (r === void 0 || i === void 0) && Z(t, this.length - 8);
    const n = r + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24, s = this[++t] + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + i * 2 ** 24;
    return BigInt(n) + (BigInt(s) << BigInt(32));
  }), o.prototype.readBigUInt64BE = D(function(t) {
    t = t >>> 0, K(t, "offset");
    const r = this[t], i = this[t + 7];
    (r === void 0 || i === void 0) && Z(t, this.length - 8);
    const n = r * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t], s = this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + i;
    return (BigInt(n) << BigInt(32)) + BigInt(s);
  }), o.prototype.readIntLE = function(t, r, i) {
    t = t >>> 0, r = r >>> 0, i || T(t, r, this.length);
    let n = this[t], s = 1, u = 0;
    for (; ++u < r && (s *= 256); )
      n += this[t + u] * s;
    return s *= 128, n >= s && (n -= Math.pow(2, 8 * r)), n;
  }, o.prototype.readIntBE = function(t, r, i) {
    t = t >>> 0, r = r >>> 0, i || T(t, r, this.length);
    let n = r, s = 1, u = this[t + --n];
    for (; n > 0 && (s *= 256); )
      u += this[t + --n] * s;
    return s *= 128, u >= s && (u -= Math.pow(2, 8 * r)), u;
  }, o.prototype.readInt8 = function(t, r) {
    return t = t >>> 0, r || T(t, 1, this.length), this[t] & 128 ? (255 - this[t] + 1) * -1 : this[t];
  }, o.prototype.readInt16LE = function(t, r) {
    t = t >>> 0, r || T(t, 2, this.length);
    const i = this[t] | this[t + 1] << 8;
    return i & 32768 ? i | 4294901760 : i;
  }, o.prototype.readInt16BE = function(t, r) {
    t = t >>> 0, r || T(t, 2, this.length);
    const i = this[t + 1] | this[t] << 8;
    return i & 32768 ? i | 4294901760 : i;
  }, o.prototype.readInt32LE = function(t, r) {
    return t = t >>> 0, r || T(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24;
  }, o.prototype.readInt32BE = function(t, r) {
    return t = t >>> 0, r || T(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3];
  }, o.prototype.readBigInt64LE = D(function(t) {
    t = t >>> 0, K(t, "offset");
    const r = this[t], i = this[t + 7];
    (r === void 0 || i === void 0) && Z(t, this.length - 8);
    const n = this[t + 4] + this[t + 5] * 2 ** 8 + this[t + 6] * 2 ** 16 + (i << 24);
    return (BigInt(n) << BigInt(32)) + BigInt(r + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24);
  }), o.prototype.readBigInt64BE = D(function(t) {
    t = t >>> 0, K(t, "offset");
    const r = this[t], i = this[t + 7];
    (r === void 0 || i === void 0) && Z(t, this.length - 8);
    const n = (r << 24) + // Overflow
    this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t];
    return (BigInt(n) << BigInt(32)) + BigInt(this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + i);
  }), o.prototype.readFloatLE = function(t, r) {
    return t = t >>> 0, r || T(t, 4, this.length), p.read(this, t, !0, 23, 4);
  }, o.prototype.readFloatBE = function(t, r) {
    return t = t >>> 0, r || T(t, 4, this.length), p.read(this, t, !1, 23, 4);
  }, o.prototype.readDoubleLE = function(t, r) {
    return t = t >>> 0, r || T(t, 8, this.length), p.read(this, t, !0, 52, 8);
  }, o.prototype.readDoubleBE = function(t, r) {
    return t = t >>> 0, r || T(t, 8, this.length), p.read(this, t, !1, 52, 8);
  };
  function R(e, t, r, i, n, s) {
    if (!o.isBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (t > n || t < s) throw new RangeError('"value" argument is out of bounds');
    if (r + i > e.length) throw new RangeError("Index out of range");
  }
  o.prototype.writeUintLE = o.prototype.writeUIntLE = function(t, r, i, n) {
    if (t = +t, r = r >>> 0, i = i >>> 0, !n) {
      const E = Math.pow(2, 8 * i) - 1;
      R(this, t, r, i, E, 0);
    }
    let s = 1, u = 0;
    for (this[r] = t & 255; ++u < i && (s *= 256); )
      this[r + u] = t / s & 255;
    return r + i;
  }, o.prototype.writeUintBE = o.prototype.writeUIntBE = function(t, r, i, n) {
    if (t = +t, r = r >>> 0, i = i >>> 0, !n) {
      const E = Math.pow(2, 8 * i) - 1;
      R(this, t, r, i, E, 0);
    }
    let s = i - 1, u = 1;
    for (this[r + s] = t & 255; --s >= 0 && (u *= 256); )
      this[r + s] = t / u & 255;
    return r + i;
  }, o.prototype.writeUint8 = o.prototype.writeUInt8 = function(t, r, i) {
    return t = +t, r = r >>> 0, i || R(this, t, r, 1, 255, 0), this[r] = t & 255, r + 1;
  }, o.prototype.writeUint16LE = o.prototype.writeUInt16LE = function(t, r, i) {
    return t = +t, r = r >>> 0, i || R(this, t, r, 2, 65535, 0), this[r] = t & 255, this[r + 1] = t >>> 8, r + 2;
  }, o.prototype.writeUint16BE = o.prototype.writeUInt16BE = function(t, r, i) {
    return t = +t, r = r >>> 0, i || R(this, t, r, 2, 65535, 0), this[r] = t >>> 8, this[r + 1] = t & 255, r + 2;
  }, o.prototype.writeUint32LE = o.prototype.writeUInt32LE = function(t, r, i) {
    return t = +t, r = r >>> 0, i || R(this, t, r, 4, 4294967295, 0), this[r + 3] = t >>> 24, this[r + 2] = t >>> 16, this[r + 1] = t >>> 8, this[r] = t & 255, r + 4;
  }, o.prototype.writeUint32BE = o.prototype.writeUInt32BE = function(t, r, i) {
    return t = +t, r = r >>> 0, i || R(this, t, r, 4, 4294967295, 0), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = t & 255, r + 4;
  };
  function Bt(e, t, r, i, n) {
    At(t, i, n, e, r, 7);
    let s = Number(t & BigInt(4294967295));
    e[r++] = s, s = s >> 8, e[r++] = s, s = s >> 8, e[r++] = s, s = s >> 8, e[r++] = s;
    let u = Number(t >> BigInt(32) & BigInt(4294967295));
    return e[r++] = u, u = u >> 8, e[r++] = u, u = u >> 8, e[r++] = u, u = u >> 8, e[r++] = u, r;
  }
  function gt(e, t, r, i, n) {
    At(t, i, n, e, r, 7);
    let s = Number(t & BigInt(4294967295));
    e[r + 7] = s, s = s >> 8, e[r + 6] = s, s = s >> 8, e[r + 5] = s, s = s >> 8, e[r + 4] = s;
    let u = Number(t >> BigInt(32) & BigInt(4294967295));
    return e[r + 3] = u, u = u >> 8, e[r + 2] = u, u = u >> 8, e[r + 1] = u, u = u >> 8, e[r] = u, r + 8;
  }
  o.prototype.writeBigUInt64LE = D(function(t, r = 0) {
    return Bt(this, t, r, BigInt(0), BigInt("0xffffffffffffffff"));
  }), o.prototype.writeBigUInt64BE = D(function(t, r = 0) {
    return gt(this, t, r, BigInt(0), BigInt("0xffffffffffffffff"));
  }), o.prototype.writeIntLE = function(t, r, i, n) {
    if (t = +t, r = r >>> 0, !n) {
      const A = Math.pow(2, 8 * i - 1);
      R(this, t, r, i, A - 1, -A);
    }
    let s = 0, u = 1, E = 0;
    for (this[r] = t & 255; ++s < i && (u *= 256); )
      t < 0 && E === 0 && this[r + s - 1] !== 0 && (E = 1), this[r + s] = (t / u >> 0) - E & 255;
    return r + i;
  }, o.prototype.writeIntBE = function(t, r, i, n) {
    if (t = +t, r = r >>> 0, !n) {
      const A = Math.pow(2, 8 * i - 1);
      R(this, t, r, i, A - 1, -A);
    }
    let s = i - 1, u = 1, E = 0;
    for (this[r + s] = t & 255; --s >= 0 && (u *= 256); )
      t < 0 && E === 0 && this[r + s + 1] !== 0 && (E = 1), this[r + s] = (t / u >> 0) - E & 255;
    return r + i;
  }, o.prototype.writeInt8 = function(t, r, i) {
    return t = +t, r = r >>> 0, i || R(this, t, r, 1, 127, -128), t < 0 && (t = 255 + t + 1), this[r] = t & 255, r + 1;
  }, o.prototype.writeInt16LE = function(t, r, i) {
    return t = +t, r = r >>> 0, i || R(this, t, r, 2, 32767, -32768), this[r] = t & 255, this[r + 1] = t >>> 8, r + 2;
  }, o.prototype.writeInt16BE = function(t, r, i) {
    return t = +t, r = r >>> 0, i || R(this, t, r, 2, 32767, -32768), this[r] = t >>> 8, this[r + 1] = t & 255, r + 2;
  }, o.prototype.writeInt32LE = function(t, r, i) {
    return t = +t, r = r >>> 0, i || R(this, t, r, 4, 2147483647, -2147483648), this[r] = t & 255, this[r + 1] = t >>> 8, this[r + 2] = t >>> 16, this[r + 3] = t >>> 24, r + 4;
  }, o.prototype.writeInt32BE = function(t, r, i) {
    return t = +t, r = r >>> 0, i || R(this, t, r, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = t & 255, r + 4;
  }, o.prototype.writeBigInt64LE = D(function(t, r = 0) {
    return Bt(this, t, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), o.prototype.writeBigInt64BE = D(function(t, r = 0) {
    return gt(this, t, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Et(e, t, r, i, n, s) {
    if (r + i > e.length) throw new RangeError("Index out of range");
    if (r < 0) throw new RangeError("Index out of range");
  }
  function mt(e, t, r, i, n) {
    return t = +t, r = r >>> 0, n || Et(e, t, r, 4), p.write(e, t, r, i, 23, 4), r + 4;
  }
  o.prototype.writeFloatLE = function(t, r, i) {
    return mt(this, t, r, !0, i);
  }, o.prototype.writeFloatBE = function(t, r, i) {
    return mt(this, t, r, !1, i);
  };
  function It(e, t, r, i, n) {
    return t = +t, r = r >>> 0, n || Et(e, t, r, 8), p.write(e, t, r, i, 52, 8), r + 8;
  }
  o.prototype.writeDoubleLE = function(t, r, i) {
    return It(this, t, r, !0, i);
  }, o.prototype.writeDoubleBE = function(t, r, i) {
    return It(this, t, r, !1, i);
  }, o.prototype.copy = function(t, r, i, n) {
    if (!o.isBuffer(t)) throw new TypeError("argument should be a Buffer");
    if (i || (i = 0), !n && n !== 0 && (n = this.length), r >= t.length && (r = t.length), r || (r = 0), n > 0 && n < i && (n = i), n === i || t.length === 0 || this.length === 0) return 0;
    if (r < 0)
      throw new RangeError("targetStart out of bounds");
    if (i < 0 || i >= this.length) throw new RangeError("Index out of range");
    if (n < 0) throw new RangeError("sourceEnd out of bounds");
    n > this.length && (n = this.length), t.length - r < n - i && (n = t.length - r + i);
    const s = n - i;
    return this === t && typeof a.prototype.copyWithin == "function" ? this.copyWithin(r, i, n) : a.prototype.set.call(
      t,
      this.subarray(i, n),
      r
    ), s;
  }, o.prototype.fill = function(t, r, i, n) {
    if (typeof t == "string") {
      if (typeof r == "string" ? (n = r, r = 0, i = this.length) : typeof i == "string" && (n = i, i = this.length), n !== void 0 && typeof n != "string")
        throw new TypeError("encoding must be a string");
      if (typeof n == "string" && !o.isEncoding(n))
        throw new TypeError("Unknown encoding: " + n);
      if (t.length === 1) {
        const u = t.charCodeAt(0);
        (n === "utf8" && u < 128 || n === "latin1") && (t = u);
      }
    } else typeof t == "number" ? t = t & 255 : typeof t == "boolean" && (t = Number(t));
    if (r < 0 || this.length < r || this.length < i)
      throw new RangeError("Out of range index");
    if (i <= r)
      return this;
    r = r >>> 0, i = i === void 0 ? this.length : i >>> 0, t || (t = 0);
    let s;
    if (typeof t == "number")
      for (s = r; s < i; ++s)
        this[s] = t;
    else {
      const u = o.isBuffer(t) ? t : o.from(t, n), E = u.length;
      if (E === 0)
        throw new TypeError('The value "' + t + '" is invalid for argument "value"');
      for (s = 0; s < i - r; ++s)
        this[s + r] = u[s % E];
    }
    return this;
  };
  const V = {};
  function nt(e, t, r) {
    V[e] = class extends r {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: t.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${e}]`, this.stack, delete this.name;
      }
      get code() {
        return e;
      }
      set code(n) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: n,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${e}]: ${this.message}`;
      }
    };
  }
  nt(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(e) {
      return e ? `${e} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), nt(
    "ERR_INVALID_ARG_TYPE",
    function(e, t) {
      return `The "${e}" argument must be of type number. Received type ${typeof t}`;
    },
    TypeError
  ), nt(
    "ERR_OUT_OF_RANGE",
    function(e, t, r) {
      let i = `The value of "${e}" is out of range.`, n = r;
      return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? n = xt(String(r)) : typeof r == "bigint" && (n = String(r), (r > BigInt(2) ** BigInt(32) || r < -(BigInt(2) ** BigInt(32))) && (n = xt(n)), n += "n"), i += ` It must be ${t}. Received ${n}`, i;
    },
    RangeError
  );
  function xt(e) {
    let t = "", r = e.length;
    const i = e[0] === "-" ? 1 : 0;
    for (; r >= i + 4; r -= 3)
      t = `_${e.slice(r - 3, r)}${t}`;
    return `${e.slice(0, r)}${t}`;
  }
  function Qt(e, t, r) {
    K(t, "offset"), (e[t] === void 0 || e[t + r] === void 0) && Z(t, e.length - (r + 1));
  }
  function At(e, t, r, i, n, s) {
    if (e > r || e < t) {
      const u = typeof t == "bigint" ? "n" : "";
      let E;
      throw t === 0 || t === BigInt(0) ? E = `>= 0${u} and < 2${u} ** ${(s + 1) * 8}${u}` : E = `>= -(2${u} ** ${(s + 1) * 8 - 1}${u}) and < 2 ** ${(s + 1) * 8 - 1}${u}`, new V.ERR_OUT_OF_RANGE("value", E, e);
    }
    Qt(i, n, s);
  }
  function K(e, t) {
    if (typeof e != "number")
      throw new V.ERR_INVALID_ARG_TYPE(t, "number", e);
  }
  function Z(e, t, r) {
    throw Math.floor(e) !== e ? (K(e, r), new V.ERR_OUT_OF_RANGE("offset", "an integer", e)) : t < 0 ? new V.ERR_BUFFER_OUT_OF_BOUNDS() : new V.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${t}`,
      e
    );
  }
  const zt = /[^+/0-9A-Za-z-_]/g;
  function vt(e) {
    if (e = e.split("=")[0], e = e.trim().replace(zt, ""), e.length < 2) return "";
    for (; e.length % 4 !== 0; )
      e = e + "=";
    return e;
  }
  function ot(e, t) {
    t = t || 1 / 0;
    let r;
    const i = e.length;
    let n = null;
    const s = [];
    for (let u = 0; u < i; ++u) {
      if (r = e.charCodeAt(u), r > 55295 && r < 57344) {
        if (!n) {
          if (r > 56319) {
            (t -= 3) > -1 && s.push(239, 191, 189);
            continue;
          } else if (u + 1 === i) {
            (t -= 3) > -1 && s.push(239, 191, 189);
            continue;
          }
          n = r;
          continue;
        }
        if (r < 56320) {
          (t -= 3) > -1 && s.push(239, 191, 189), n = r;
          continue;
        }
        r = (n - 55296 << 10 | r - 56320) + 65536;
      } else n && (t -= 3) > -1 && s.push(239, 191, 189);
      if (n = null, r < 128) {
        if ((t -= 1) < 0) break;
        s.push(r);
      } else if (r < 2048) {
        if ((t -= 2) < 0) break;
        s.push(
          r >> 6 | 192,
          r & 63 | 128
        );
      } else if (r < 65536) {
        if ((t -= 3) < 0) break;
        s.push(
          r >> 12 | 224,
          r >> 6 & 63 | 128,
          r & 63 | 128
        );
      } else if (r < 1114112) {
        if ((t -= 4) < 0) break;
        s.push(
          r >> 18 | 240,
          r >> 12 & 63 | 128,
          r >> 6 & 63 | 128,
          r & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return s;
  }
  function tr(e) {
    const t = [];
    for (let r = 0; r < e.length; ++r)
      t.push(e.charCodeAt(r) & 255);
    return t;
  }
  function rr(e, t) {
    let r, i, n;
    const s = [];
    for (let u = 0; u < e.length && !((t -= 2) < 0); ++u)
      r = e.charCodeAt(u), i = r >> 8, n = r % 256, s.push(n), s.push(i);
    return s;
  }
  function bt(e) {
    return h.toByteArray(vt(e));
  }
  function z(e, t, r, i) {
    let n;
    for (n = 0; n < i && !(n + r >= t.length || n >= e.length); ++n)
      t[n + r] = e[n];
    return n;
  }
  function k(e, t) {
    return e instanceof t || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === t.name;
  }
  function st(e) {
    return e !== e;
  }
  const er = (function() {
    const e = "0123456789abcdef", t = new Array(256);
    for (let r = 0; r < 16; ++r) {
      const i = r * 16;
      for (let n = 0; n < 16; ++n)
        t[i + n] = e[r] + e[n];
    }
    return t;
  })();
  function D(e) {
    return typeof BigInt > "u" ? ir : e;
  }
  function ir() {
    throw new Error("BigInt not supported");
  }
})(ut);
const L = ut.Buffer, Nr = ut.Buffer;
function Pr(c) {
  return c && c.__esModule && Object.prototype.hasOwnProperty.call(c, "default") ? c.default : c;
}
function fr(c) {
  return c instanceof Uint8Array || ArrayBuffer.isView(c) && c.constructor.name === "Uint8Array";
}
function Rt(c, h, p = "") {
  const f = fr(c), y = c?.length;
  if (!f || h !== void 0) {
    const l = p && `"${p}" `, d = "", w = f ? `length=${y}` : `type=${typeof c}`;
    throw new Error(l + "expected Uint8Array" + d + ", got " + w);
  }
  return c;
}
function Ut(c, h = !0) {
  if (c.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (h && c.finished)
    throw new Error("Hash#digest() has already been called");
}
function lr(c, h) {
  Rt(c, void 0, "digestInto() output");
  const p = h.outputLen;
  if (c.length < p)
    throw new Error('"digestInto() output" expected to be of length >=' + p);
}
function j(...c) {
  for (let h = 0; h < c.length; h++)
    c[h].fill(0);
}
function ct(c) {
  return new DataView(c.buffer, c.byteOffset, c.byteLength);
}
function M(c, h) {
  return c << 32 - h | c >>> h;
}
function G(c, h) {
  return c << h | c >>> 32 - h >>> 0;
}
function pt(c, h = {}) {
  const p = (y, a) => c(a).update(y).digest(), f = c(void 0);
  return p.outputLen = f.outputLen, p.blockLen = f.blockLen, p.create = (y) => c(y), Object.assign(p, h), Object.freeze(p);
}
const yr = (c) => ({
  oid: Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2, c])
});
function _t(c, h, p) {
  return c & h ^ ~c & p;
}
function St(c, h, p) {
  return c & h ^ c & p ^ h & p;
}
class ft {
  blockLen;
  outputLen;
  padOffset;
  isLE;
  // For partial updates less than block size
  buffer;
  view;
  finished = !1;
  length = 0;
  pos = 0;
  destroyed = !1;
  constructor(h, p, f, y) {
    this.blockLen = h, this.outputLen = p, this.padOffset = f, this.isLE = y, this.buffer = new Uint8Array(h), this.view = ct(this.buffer);
  }
  update(h) {
    Ut(this), Rt(h);
    const { view: p, buffer: f, blockLen: y } = this, a = h.length;
    for (let l = 0; l < a; ) {
      const d = Math.min(y - this.pos, a - l);
      if (d === y) {
        const w = ct(h);
        for (; y <= a - l; l += y)
          this.process(w, l);
        continue;
      }
      f.set(h.subarray(l, l + d), this.pos), this.pos += d, l += d, this.pos === y && (this.process(p, 0), this.pos = 0);
    }
    return this.length += h.length, this.roundClean(), this;
  }
  digestInto(h) {
    Ut(this), lr(h, this), this.finished = !0;
    const { buffer: p, view: f, blockLen: y, isLE: a } = this;
    let { pos: l } = this;
    p[l++] = 128, j(this.buffer.subarray(l)), this.padOffset > y - l && (this.process(f, 0), l = 0);
    for (let B = l; B < y; B++)
      p[B] = 0;
    f.setBigUint64(y - 8, BigInt(this.length * 8), a), this.process(f, 0);
    const d = ct(h), w = this.outputLen;
    if (w % 4)
      throw new Error("_sha2: outputLen must be aligned to 32bit");
    const g = w / 4, o = this.get();
    if (g > o.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let B = 0; B < g; B++)
      d.setUint32(4 * B, o[B], a);
  }
  digest() {
    const { buffer: h, outputLen: p } = this;
    this.digestInto(h);
    const f = h.slice(0, p);
    return this.destroy(), f;
  }
  _cloneInto(h) {
    h ||= new this.constructor(), h.set(...this.get());
    const { blockLen: p, buffer: f, length: y, finished: a, destroyed: l, pos: d } = this;
    return h.destroyed = l, h.finished = a, h.length = y, h.pos = d, y % p && h.buffer.set(f), h;
  }
  clone() {
    return this._cloneInto();
  }
}
const F = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), Q = /* @__PURE__ */ Uint32Array.from([
  1732584193,
  4023233417,
  2562383102,
  271733878,
  3285377520
]), $ = /* @__PURE__ */ new Uint32Array(80);
class wr extends ft {
  A = Q[0] | 0;
  B = Q[1] | 0;
  C = Q[2] | 0;
  D = Q[3] | 0;
  E = Q[4] | 0;
  constructor() {
    super(64, 20, 8, !1);
  }
  get() {
    const { A: h, B: p, C: f, D: y, E: a } = this;
    return [h, p, f, y, a];
  }
  set(h, p, f, y, a) {
    this.A = h | 0, this.B = p | 0, this.C = f | 0, this.D = y | 0, this.E = a | 0;
  }
  process(h, p) {
    for (let w = 0; w < 16; w++, p += 4)
      $[w] = h.getUint32(p, !1);
    for (let w = 16; w < 80; w++)
      $[w] = G($[w - 3] ^ $[w - 8] ^ $[w - 14] ^ $[w - 16], 1);
    let { A: f, B: y, C: a, D: l, E: d } = this;
    for (let w = 0; w < 80; w++) {
      let g, o;
      w < 20 ? (g = _t(y, a, l), o = 1518500249) : w < 40 ? (g = y ^ a ^ l, o = 1859775393) : w < 60 ? (g = St(y, a, l), o = 2400959708) : (g = y ^ a ^ l, o = 3395469782);
      const B = G(f, 5) + g + d + o + $[w] | 0;
      d = l, l = a, a = G(y, 30), y = f, f = B;
    }
    f = f + this.A | 0, y = y + this.B | 0, a = a + this.C | 0, l = l + this.D | 0, d = d + this.E | 0, this.set(f, y, a, l, d);
  }
  roundClean() {
    j($);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0), j(this.buffer);
  }
}
const dr = /* @__PURE__ */ pt(() => new wr()), Br = /* @__PURE__ */ Uint8Array.from([
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8
]), Ct = Uint8Array.from(new Array(16).fill(0).map((c, h) => h)), gr = Ct.map((c) => (9 * c + 5) % 16), kt = /* @__PURE__ */ (() => {
  const p = [[Ct], [gr]];
  for (let f = 0; f < 4; f++)
    for (let y of p)
      y.push(y[f].map((a) => Br[a]));
  return p;
})(), Mt = kt[0], Nt = kt[1], Pt = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((c) => Uint8Array.from(c)), Er = /* @__PURE__ */ Mt.map((c, h) => c.map((p) => Pt[h][p])), mr = /* @__PURE__ */ Nt.map((c, h) => c.map((p) => Pt[h][p])), Ir = /* @__PURE__ */ Uint32Array.from([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]), xr = /* @__PURE__ */ Uint32Array.from([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function Tt(c, h, p, f) {
  return c === 0 ? h ^ p ^ f : c === 1 ? h & p | ~h & f : c === 2 ? (h | ~p) ^ f : c === 3 ? h & f | p & ~f : h ^ (p | ~f);
}
const v = /* @__PURE__ */ new Uint32Array(16);
class Ar extends ft {
  h0 = 1732584193;
  h1 = -271733879;
  h2 = -1732584194;
  h3 = 271733878;
  h4 = -1009589776;
  constructor() {
    super(64, 20, 8, !0);
  }
  get() {
    const { h0: h, h1: p, h2: f, h3: y, h4: a } = this;
    return [h, p, f, y, a];
  }
  set(h, p, f, y, a) {
    this.h0 = h | 0, this.h1 = p | 0, this.h2 = f | 0, this.h3 = y | 0, this.h4 = a | 0;
  }
  process(h, p) {
    for (let m = 0; m < 16; m++, p += 4)
      v[m] = h.getUint32(p, !0);
    let f = this.h0 | 0, y = f, a = this.h1 | 0, l = a, d = this.h2 | 0, w = d, g = this.h3 | 0, o = g, B = this.h4 | 0, U = B;
    for (let m = 0; m < 5; m++) {
      const _ = 4 - m, P = Ir[m], q = xr[m], et = Mt[m], X = Nt[m], it = Er[m], J = mr[m];
      for (let C = 0; C < 16; C++) {
        const W = G(f + Tt(m, a, d, g) + v[et[C]] + P, it[C]) + B | 0;
        f = B, B = g, g = G(d, 10) | 0, d = a, a = W;
      }
      for (let C = 0; C < 16; C++) {
        const W = G(y + Tt(_, l, w, o) + v[X[C]] + q, J[C]) + U | 0;
        y = U, U = o, o = G(w, 10) | 0, w = l, l = W;
      }
    }
    this.set(this.h1 + d + o | 0, this.h2 + g + U | 0, this.h3 + B + y | 0, this.h4 + f + l | 0, this.h0 + a + w | 0);
  }
  roundClean() {
    j(v);
  }
  destroy() {
    this.destroyed = !0, j(this.buffer), this.set(0, 0, 0, 0, 0);
  }
}
const Dt = /* @__PURE__ */ pt(() => new Ar()), br = /* @__PURE__ */ Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), O = /* @__PURE__ */ new Uint32Array(64);
class Ur extends ft {
  constructor(h) {
    super(64, h, 8, !1);
  }
  get() {
    const { A: h, B: p, C: f, D: y, E: a, F: l, G: d, H: w } = this;
    return [h, p, f, y, a, l, d, w];
  }
  // prettier-ignore
  set(h, p, f, y, a, l, d, w) {
    this.A = h | 0, this.B = p | 0, this.C = f | 0, this.D = y | 0, this.E = a | 0, this.F = l | 0, this.G = d | 0, this.H = w | 0;
  }
  process(h, p) {
    for (let B = 0; B < 16; B++, p += 4)
      O[B] = h.getUint32(p, !1);
    for (let B = 16; B < 64; B++) {
      const U = O[B - 15], m = O[B - 2], _ = M(U, 7) ^ M(U, 18) ^ U >>> 3, P = M(m, 17) ^ M(m, 19) ^ m >>> 10;
      O[B] = P + O[B - 7] + _ + O[B - 16] | 0;
    }
    let { A: f, B: y, C: a, D: l, E: d, F: w, G: g, H: o } = this;
    for (let B = 0; B < 64; B++) {
      const U = M(d, 6) ^ M(d, 11) ^ M(d, 25), m = o + U + _t(d, w, g) + br[B] + O[B] | 0, P = (M(f, 2) ^ M(f, 13) ^ M(f, 22)) + St(f, y, a) | 0;
      o = g, g = w, w = d, d = l + m | 0, l = a, a = y, y = f, f = m + P | 0;
    }
    f = f + this.A | 0, y = y + this.B | 0, a = a + this.C | 0, l = l + this.D | 0, d = d + this.E | 0, w = w + this.F | 0, g = g + this.G | 0, o = o + this.H | 0, this.set(f, y, a, l, d, w, g, o);
  }
  roundClean() {
    j(O);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), j(this.buffer);
  }
}
class Tr extends Ur {
  // We cannot use array here since array allows indexing by variable
  // which means optimizer/compiler cannot use registers.
  A = F[0] | 0;
  B = F[1] | 0;
  C = F[2] | 0;
  D = F[3] | 0;
  E = F[4] | 0;
  F = F[5] | 0;
  G = F[6] | 0;
  H = F[7] | 0;
  constructor() {
    super(32);
  }
}
const tt = /* @__PURE__ */ pt(
  () => new Tr(),
  /* @__PURE__ */ yr(1)
);
function Lr(c) {
  return L.from(Dt(Uint8Array.from(c)));
}
function Rr(c) {
  return L.from(dr(Uint8Array.from(c)));
}
function Ft(c) {
  return L.from(tt(Uint8Array.from(c)));
}
function _r(c) {
  return L.from(Dt(tt(Uint8Array.from(c))));
}
function Sr(c) {
  return L.from(tt(tt(Uint8Array.from(c))));
}
const Cr = [
  "BIP0340/challenge",
  "BIP0340/aux",
  "BIP0340/nonce",
  "TapLeaf",
  "TapBranch",
  "TapSighash",
  "TapTweak",
  "KeyAgg list",
  "KeyAgg coefficient"
], $t = {
  "BIP0340/challenge": L.from([
    123,
    181,
    45,
    122,
    159,
    239,
    88,
    50,
    62,
    177,
    191,
    122,
    64,
    125,
    179,
    130,
    210,
    243,
    242,
    216,
    27,
    177,
    34,
    79,
    73,
    254,
    81,
    143,
    109,
    72,
    211,
    124,
    123,
    181,
    45,
    122,
    159,
    239,
    88,
    50,
    62,
    177,
    191,
    122,
    64,
    125,
    179,
    130,
    210,
    243,
    242,
    216,
    27,
    177,
    34,
    79,
    73,
    254,
    81,
    143,
    109,
    72,
    211,
    124
  ]),
  "BIP0340/aux": L.from([
    241,
    239,
    78,
    94,
    192,
    99,
    202,
    218,
    109,
    148,
    202,
    250,
    157,
    152,
    126,
    160,
    105,
    38,
    88,
    57,
    236,
    193,
    31,
    151,
    45,
    119,
    165,
    46,
    216,
    193,
    204,
    144,
    241,
    239,
    78,
    94,
    192,
    99,
    202,
    218,
    109,
    148,
    202,
    250,
    157,
    152,
    126,
    160,
    105,
    38,
    88,
    57,
    236,
    193,
    31,
    151,
    45,
    119,
    165,
    46,
    216,
    193,
    204,
    144
  ]),
  "BIP0340/nonce": L.from([
    7,
    73,
    119,
    52,
    167,
    155,
    203,
    53,
    91,
    155,
    140,
    125,
    3,
    79,
    18,
    28,
    244,
    52,
    215,
    62,
    247,
    45,
    218,
    25,
    135,
    0,
    97,
    251,
    82,
    191,
    235,
    47,
    7,
    73,
    119,
    52,
    167,
    155,
    203,
    53,
    91,
    155,
    140,
    125,
    3,
    79,
    18,
    28,
    244,
    52,
    215,
    62,
    247,
    45,
    218,
    25,
    135,
    0,
    97,
    251,
    82,
    191,
    235,
    47
  ]),
  TapLeaf: L.from([
    174,
    234,
    143,
    220,
    66,
    8,
    152,
    49,
    5,
    115,
    75,
    88,
    8,
    29,
    30,
    38,
    56,
    211,
    95,
    28,
    181,
    64,
    8,
    212,
    211,
    87,
    202,
    3,
    190,
    120,
    233,
    238,
    174,
    234,
    143,
    220,
    66,
    8,
    152,
    49,
    5,
    115,
    75,
    88,
    8,
    29,
    30,
    38,
    56,
    211,
    95,
    28,
    181,
    64,
    8,
    212,
    211,
    87,
    202,
    3,
    190,
    120,
    233,
    238
  ]),
  TapBranch: L.from([
    25,
    65,
    161,
    242,
    229,
    110,
    185,
    95,
    162,
    169,
    241,
    148,
    190,
    92,
    1,
    247,
    33,
    111,
    51,
    237,
    130,
    176,
    145,
    70,
    52,
    144,
    208,
    91,
    245,
    22,
    160,
    21,
    25,
    65,
    161,
    242,
    229,
    110,
    185,
    95,
    162,
    169,
    241,
    148,
    190,
    92,
    1,
    247,
    33,
    111,
    51,
    237,
    130,
    176,
    145,
    70,
    52,
    144,
    208,
    91,
    245,
    22,
    160,
    21
  ]),
  TapSighash: L.from([
    244,
    10,
    72,
    223,
    75,
    42,
    112,
    200,
    180,
    146,
    75,
    242,
    101,
    70,
    97,
    237,
    61,
    149,
    253,
    102,
    163,
    19,
    235,
    135,
    35,
    117,
    151,
    198,
    40,
    228,
    160,
    49,
    244,
    10,
    72,
    223,
    75,
    42,
    112,
    200,
    180,
    146,
    75,
    242,
    101,
    70,
    97,
    237,
    61,
    149,
    253,
    102,
    163,
    19,
    235,
    135,
    35,
    117,
    151,
    198,
    40,
    228,
    160,
    49
  ]),
  TapTweak: L.from([
    232,
    15,
    225,
    99,
    156,
    156,
    160,
    80,
    227,
    175,
    27,
    57,
    193,
    67,
    198,
    62,
    66,
    156,
    188,
    235,
    21,
    217,
    64,
    251,
    181,
    197,
    161,
    244,
    175,
    87,
    197,
    233,
    232,
    15,
    225,
    99,
    156,
    156,
    160,
    80,
    227,
    175,
    27,
    57,
    193,
    67,
    198,
    62,
    66,
    156,
    188,
    235,
    21,
    217,
    64,
    251,
    181,
    197,
    161,
    244,
    175,
    87,
    197,
    233
  ]),
  "KeyAgg list": L.from([
    72,
    28,
    151,
    28,
    60,
    11,
    70,
    215,
    240,
    178,
    117,
    174,
    89,
    141,
    78,
    44,
    126,
    215,
    49,
    156,
    89,
    74,
    92,
    110,
    199,
    158,
    160,
    212,
    153,
    2,
    148,
    240,
    72,
    28,
    151,
    28,
    60,
    11,
    70,
    215,
    240,
    178,
    117,
    174,
    89,
    141,
    78,
    44,
    126,
    215,
    49,
    156,
    89,
    74,
    92,
    110,
    199,
    158,
    160,
    212,
    153,
    2,
    148,
    240
  ]),
  "KeyAgg coefficient": L.from([
    191,
    201,
    4,
    3,
    77,
    28,
    136,
    232,
    200,
    14,
    34,
    229,
    61,
    36,
    86,
    109,
    100,
    130,
    78,
    214,
    66,
    114,
    129,
    192,
    145,
    0,
    249,
    77,
    205,
    82,
    201,
    129,
    191,
    201,
    4,
    3,
    77,
    28,
    136,
    232,
    200,
    14,
    34,
    229,
    61,
    36,
    86,
    109,
    100,
    130,
    78,
    214,
    66,
    114,
    129,
    192,
    145,
    0,
    249,
    77,
    205,
    82,
    201,
    129
  ])
};
function kr(c, h) {
  return Ft(L.concat([$t[c], h]));
}
const Dr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TAGGED_HASH_PREFIXES: $t,
  TAGS: Cr,
  hash160: _r,
  hash256: Sr,
  ripemd160: Lr,
  sha1: Rr,
  sha256: Ft,
  taggedHash: kr
}, Symbol.toStringTag, { value: "Module" }));
export {
  L as B,
  Cr as T,
  Nr as a,
  Sr as b,
  Dr as c,
  Rr as d,
  $t as e,
  Pr as g,
  _r as h,
  Lr as r,
  Ft as s,
  kr as t
};
