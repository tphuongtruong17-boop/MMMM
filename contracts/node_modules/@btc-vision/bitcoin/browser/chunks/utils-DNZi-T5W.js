import { B as A, g as on, a as R } from "./crypto-BhCpKpek.js";
import { o as _ } from "./script-DyPItFEl.js";
function Dn(n) {
  if (n.length < 8 || n.length > 72 || n[0] !== 48 || n[1] !== n.length - 2 || n[2] !== 2) return !1;
  const r = n[3];
  if (r === 0 || 5 + r >= n.length || n[4 + r] !== 2) return !1;
  const t = n[5 + r];
  return !(t === 0 || 6 + r + t !== n.length || n[4] & 128 || r > 1 && n[4] === 0 && !(n[5] & 128) || n[r + 6] & 128 || t > 1 && n[r + 6] === 0 && !(n[r + 7] & 128));
}
function Cn(n) {
  if (n.length < 8) throw new Error("DER sequence length is too short");
  if (n.length > 72) throw new Error("DER sequence length is too long");
  if (n[0] !== 48) throw new Error("Expected DER sequence");
  if (n[1] !== n.length - 2) throw new Error("DER sequence length is invalid");
  if (n[2] !== 2) throw new Error("Expected DER integer");
  const r = n[3];
  if (r === 0) throw new Error("R length is zero");
  if (5 + r >= n.length) throw new Error("R length is too long");
  if (n[4 + r] !== 2) throw new Error("Expected DER integer (2)");
  const t = n[5 + r];
  if (t === 0) throw new Error("S length is zero");
  if (6 + r + t !== n.length) throw new Error("S length is invalid");
  if (n[4] & 128) throw new Error("R value is negative");
  if (r > 1 && n[4] === 0 && !(n[5] & 128))
    throw new Error("R value excessively padded");
  if (n[r + 6] & 128) throw new Error("S value is negative");
  if (t > 1 && n[r + 6] === 0 && !(n[r + 7] & 128))
    throw new Error("S value excessively padded");
  return {
    r: n.subarray(4, 4 + r),
    s: n.subarray(6 + r)
  };
}
function Fn(n, r) {
  const t = n.length, e = r.length;
  if (t === 0) throw new Error("R length is zero");
  if (e === 0) throw new Error("S length is zero");
  if (t > 33) throw new Error("R length is too long");
  if (e > 33) throw new Error("S length is too long");
  if (n[0] & 128) throw new Error("R value is negative");
  if (r[0] & 128) throw new Error("S value is negative");
  if (t > 1 && n[0] === 0 && !(n[1] & 128)) throw new Error("R value excessively padded");
  if (e > 1 && r[0] === 0 && !(r[1] & 128)) throw new Error("S value excessively padded");
  const a = A.allocUnsafe(6 + t + e);
  return a[0] = 48, a[1] = a.length - 2, a[2] = 2, a[3] = n.length, n.copy(a, 4), a[4 + t] = 2, a[5 + t] = r.length, r.copy(a, 6 + t), a;
}
function fn(n) {
  return n < _.OP_PUSHDATA1 ? 1 : n <= 255 ? 2 : n <= 65535 ? 3 : 5;
}
function Mn(n, r, t) {
  const e = fn(r);
  return e === 1 ? n.writeUInt8(r, t) : e === 2 ? (n.writeUInt8(_.OP_PUSHDATA1, t), n.writeUInt8(r, t + 1)) : e === 3 ? (n.writeUInt8(_.OP_PUSHDATA2, t), n.writeUInt16LE(r, t + 1)) : (n.writeUInt8(_.OP_PUSHDATA4, t), n.writeUInt32LE(r, t + 1)), e;
}
function zn(n, r) {
  const t = n.readUInt8(r);
  let e, a;
  if (t < _.OP_PUSHDATA1)
    e = t, a = 1;
  else if (t === _.OP_PUSHDATA1) {
    if (r + 2 > n.length) return null;
    e = n.readUInt8(r + 1), a = 2;
  } else if (t === _.OP_PUSHDATA2) {
    if (r + 3 > n.length) return null;
    e = n.readUInt16LE(r + 1), a = 3;
  } else {
    if (r + 5 > n.length) return null;
    if (t !== _.OP_PUSHDATA4) throw new Error("Unexpected opcode");
    e = n.readUInt32LE(r + 1), a = 5;
  }
  return {
    opcode: t,
    number: e,
    size: a
  };
}
var p, q;
function J() {
  if (q) return p;
  q = 1;
  var n = {
    Array: function(t) {
      return t != null && t.constructor === Array;
    },
    Boolean: function(t) {
      return typeof t == "boolean";
    },
    Function: function(t) {
      return typeof t == "function";
    },
    Nil: function(t) {
      return t == null;
    },
    Number: function(t) {
      return typeof t == "number";
    },
    Object: function(t) {
      return typeof t == "object";
    },
    String: function(t) {
      return typeof t == "string";
    },
    "": function() {
      return !0;
    }
  };
  n.Null = n.Nil;
  for (var r in n)
    n[r].toJSON = function(t) {
      return t;
    }.bind(null, r);
  return p = n, p;
}
var P, H;
function z() {
  if (H) return P;
  H = 1;
  var n = J();
  function r(i) {
    return i.name || i.toString().match(/function (.*?)\s*\(/)[1];
  }
  function t(i) {
    return n.Nil(i) ? "" : r(i.constructor);
  }
  function e(i) {
    return n.Function(i) ? "" : n.String(i) ? JSON.stringify(i) : i && n.Object(i) ? "" : i;
  }
  function a(i, f) {
    Error.captureStackTrace && Error.captureStackTrace(i, f);
  }
  function d(i) {
    return n.Function(i) ? i.toJSON ? i.toJSON() : r(i) : n.Array(i) ? "Array" : i && n.Object(i) ? "Object" : i !== void 0 ? i : "";
  }
  function N(i, f, o) {
    var s = e(f);
    return "Expected " + d(i) + ", got" + (o !== "" ? " " + o : "") + (s !== "" ? " " + s : "");
  }
  function l(i, f, o) {
    o = o || t(f), this.message = N(i, f, o), a(this, l), this.__type = i, this.__value = f, this.__valueTypeName = o;
  }
  l.prototype = Object.create(Error.prototype), l.prototype.constructor = l;
  function E(i, f, o, s, c) {
    var g = '" of type ';
    return f === "key" && (g = '" with key type '), N('property "' + d(o) + g + d(i), s, c);
  }
  function h(i, f, o, s, c) {
    i ? (c = c || t(s), this.message = E(i, o, f, s, c)) : this.message = 'Unexpected property "' + f + '"', a(this, l), this.__label = o, this.__property = f, this.__type = i, this.__value = s, this.__valueTypeName = c;
  }
  h.prototype = Object.create(Error.prototype), h.prototype.constructor = l;
  function S(i, f) {
    return new l(i, {}, f);
  }
  function y(i, f, o) {
    return i instanceof h ? (f = f + "." + i.__property, i = new h(
      i.__type,
      f,
      i.__label,
      i.__value,
      i.__valueTypeName
    )) : i instanceof l && (i = new h(
      i.__type,
      f,
      o,
      i.__value,
      i.__valueTypeName
    )), a(i), i;
  }
  return P = {
    TfTypeError: l,
    TfPropertyTypeError: h,
    tfCustomError: S,
    tfSubError: y,
    tfJSON: d,
    getValueTypeName: t
  }, P;
}
var V, D;
function un() {
  if (D) return V;
  D = 1;
  var n = J(), r = z();
  function t(u) {
    return A.isBuffer(u);
  }
  function e(u) {
    return typeof u == "string" && /^([0-9a-f]{2})+$/i.test(u);
  }
  function a(u, L) {
    var U = u.toJSON();
    function B(O) {
      if (!u(O)) return !1;
      if (O.length === L) return !0;
      throw r.tfCustomError(U + "(Length: " + L + ")", U + "(Length: " + O.length + ")");
    }
    return B.toJSON = function() {
      return U;
    }, B;
  }
  var d = a.bind(null, n.Array), N = a.bind(null, t), l = a.bind(null, e), E = a.bind(null, n.String);
  function h(u, L, U) {
    U = U || n.Number;
    function B(O, en) {
      return U(O, en) && O > u && O < L;
    }
    return B.toJSON = function() {
      return `${U.toJSON()} between [${u}, ${L}]`;
    }, B;
  }
  var S = Math.pow(2, 53) - 1;
  function y(u) {
    return typeof u == "number" && isFinite(u);
  }
  function i(u) {
    return u << 24 >> 24 === u;
  }
  function f(u) {
    return u << 16 >> 16 === u;
  }
  function o(u) {
    return (u | 0) === u;
  }
  function s(u) {
    return typeof u == "number" && u >= -S && u <= S && Math.floor(u) === u;
  }
  function c(u) {
    return (u & 255) === u;
  }
  function g(u) {
    return (u & 65535) === u;
  }
  function m(u) {
    return u >>> 0 === u;
  }
  function I(u) {
    return typeof u == "number" && u >= 0 && u <= S && Math.floor(u) === u;
  }
  var x = {
    ArrayN: d,
    Buffer: t,
    BufferN: N,
    Finite: y,
    Hex: e,
    HexN: l,
    Int8: i,
    Int16: f,
    Int32: o,
    Int53: s,
    Range: h,
    StringN: E,
    UInt8: c,
    UInt16: g,
    UInt32: m,
    UInt53: I
  };
  for (var T in x)
    x[T].toJSON = function(u) {
      return u;
    }.bind(null, T);
  return V = x, V;
}
var j, C;
function sn() {
  if (C) return j;
  C = 1;
  var n = z(), r = J(), t = n.tfJSON, e = n.TfTypeError, a = n.TfPropertyTypeError, d = n.tfSubError, N = n.getValueTypeName, l = {
    arrayOf: function(f, o) {
      f = E(f), o = o || {};
      function s(c, g) {
        return !r.Array(c) || r.Nil(c) || o.minLength !== void 0 && c.length < o.minLength || o.maxLength !== void 0 && c.length > o.maxLength || o.length !== void 0 && c.length !== o.length ? !1 : c.every(function(m, I) {
          try {
            return h(f, m, g);
          } catch (x) {
            throw d(x, I);
          }
        });
      }
      return s.toJSON = function() {
        var c = "[" + t(f) + "]";
        return o.length !== void 0 ? c += "{" + o.length + "}" : (o.minLength !== void 0 || o.maxLength !== void 0) && (c += "{" + (o.minLength === void 0 ? 0 : o.minLength) + "," + (o.maxLength === void 0 ? 1 / 0 : o.maxLength) + "}"), c;
      }, s;
    },
    maybe: function i(f) {
      f = E(f);
      function o(s, c) {
        return r.Nil(s) || f(s, c, i);
      }
      return o.toJSON = function() {
        return "?" + t(f);
      }, o;
    },
    map: function(f, o) {
      f = E(f), o && (o = E(o));
      function s(c, g) {
        if (!r.Object(c) || r.Nil(c)) return !1;
        for (var m in c) {
          try {
            o && h(o, m, g);
          } catch (x) {
            throw d(x, m, "key");
          }
          try {
            var I = c[m];
            h(f, I, g);
          } catch (x) {
            throw d(x, m);
          }
        }
        return !0;
      }
      return o ? s.toJSON = function() {
        return "{" + t(o) + ": " + t(f) + "}";
      } : s.toJSON = function() {
        return "{" + t(f) + "}";
      }, s;
    },
    object: function(f) {
      var o = {};
      for (var s in f)
        o[s] = E(f[s]);
      function c(g, m) {
        if (!r.Object(g) || r.Nil(g)) return !1;
        var I;
        try {
          for (I in o) {
            var x = o[I], T = g[I];
            h(x, T, m);
          }
        } catch (u) {
          throw d(u, I);
        }
        if (m) {
          for (I in g)
            if (!o[I])
              throw new a(void 0, I);
        }
        return !0;
      }
      return c.toJSON = function() {
        return t(o);
      }, c;
    },
    anyOf: function() {
      var f = [].slice.call(arguments).map(E);
      function o(s, c) {
        return f.some(function(g) {
          try {
            return h(g, s, c);
          } catch {
            return !1;
          }
        });
      }
      return o.toJSON = function() {
        return f.map(t).join("|");
      }, o;
    },
    allOf: function() {
      var f = [].slice.call(arguments).map(E);
      function o(s, c) {
        return f.every(function(g) {
          try {
            return h(g, s, c);
          } catch {
            return !1;
          }
        });
      }
      return o.toJSON = function() {
        return f.map(t).join(" & ");
      }, o;
    },
    quacksLike: function(f) {
      function o(s) {
        return f === N(s);
      }
      return o.toJSON = function() {
        return f;
      }, o;
    },
    tuple: function() {
      var f = [].slice.call(arguments).map(E);
      function o(s, c) {
        return r.Nil(s) || r.Nil(s.length) || c && s.length !== f.length ? !1 : f.every(function(g, m) {
          try {
            return h(g, s[m], c);
          } catch (I) {
            throw d(I, m);
          }
        });
      }
      return o.toJSON = function() {
        return "(" + f.map(t).join(", ") + ")";
      }, o;
    },
    value: function(f) {
      function o(s) {
        return s === f;
      }
      return o.toJSON = function() {
        return f;
      }, o;
    }
  };
  l.oneOf = l.anyOf;
  function E(i) {
    if (r.String(i))
      return i[0] === "?" ? l.maybe(i.slice(1)) : r[i] || l.quacksLike(i);
    if (i && r.Object(i)) {
      if (r.Array(i)) {
        if (i.length !== 1) throw new TypeError("Expected compile() parameter of type Array of length 1");
        return l.arrayOf(i[0]);
      }
      return l.object(i);
    } else if (r.Function(i))
      return i;
    return l.value(i);
  }
  function h(i, f, o, s) {
    if (r.Function(i)) {
      if (i(f, o)) return !0;
      throw new e(s || i, f);
    }
    return h(E(i), f, o);
  }
  for (var S in r)
    h[S] = r[S];
  for (S in l)
    h[S] = l[S];
  var y = un();
  for (S in y)
    h[S] = y[S];
  return h.compile = E, h.TfTypeError = e, h.TfPropertyTypeError = a, j = h, j;
}
var cn = sn();
const w = /* @__PURE__ */ on(cn), F = R.alloc(32, 0), M = R.from(
  "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
  "hex"
);
function an(n, r) {
  return n.length !== r.length ? !1 : n.every((t, e) => t.equals(r[e]));
}
function hn(n) {
  if (!R.isBuffer(n) || n.length < 33) return !1;
  const r = n[0], t = n.subarray(1, 33);
  if (t.compare(F) === 0 || t.compare(M) >= 0) return !1;
  if ((r === 2 || r === 3) && n.length === 33)
    return !0;
  if (n.length !== 65) return !1;
  const e = n.subarray(33);
  return e.compare(F) === 0 || e.compare(M) >= 0 ? !1 : r === 4 || r === 6 || r === 7;
}
const ln = 21 * 1e14;
function gn(n) {
  return w.UInt53(n) && n <= ln;
}
const b = 254;
function X(n) {
  if (!n || typeof n != "object" || !("output" in n)) return !1;
  const r = n;
  return R.isBuffer(r.output) ? r.version !== void 0 ? (r.version & b) === r.version : !0 : !1;
}
function G(n) {
  return globalThis.Array.isArray(n) ? n.length !== 2 ? !1 : n.every((r) => G(r)) : X(n);
}
const wn = w.BufferN(32), dn = w.BufferN(20), En = w.BufferN(32), mn = w.Number, In = w.Array, Sn = w.Boolean, xn = w.String, $ = w.Buffer, Nn = w.Hex, Un = w.maybe, v = w.tuple, _n = w.UInt8, k = w.UInt32, On = w.Function, yn = w.BufferN, An = w.Null, Ln = w.oneOf, Bn = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Array: In,
  Boolean: Sn,
  Buffer: $,
  Buffer256bit: wn,
  BufferN: yn,
  Function: On,
  Hash160bit: dn,
  Hash256bit: En,
  Hex: Nn,
  Null: An,
  Number: mn,
  Satoshi: gn,
  String: xn,
  TAPLEAF_VERSION_MASK: b,
  UInt32: k,
  UInt8: _n,
  isPoint: hn,
  isTapleaf: X,
  isTaptree: G,
  maybe: Un,
  oneOf: Ln,
  stacksEqual: an,
  tuple: v,
  typeforce: w
}, Symbol.toStringTag, { value: "Module" })), Y = "0123456789abcdefABCDEF";
Y.split("").map((n) => n.codePointAt(0));
Array(256).fill(!0).map((n, r) => {
  const t = String.fromCodePoint(r), e = Y.indexOf(t);
  return e < 0 ? void 0 : e < 16 ? e : e - 6;
});
new TextEncoder();
new TextDecoder();
function Tn(n, r, t, e) {
  if (r + 2 > n.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (e = e.toUpperCase(), t > 65535)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 65535. Received ${t}`);
  e === "LE" ? (n[r] = t & 255, n[r + 1] = t >> 8 & 255) : (n[r] = t >> 8 & 255, n[r + 1] = t & 255);
}
function Rn(n, r, t, e) {
  if (r + 4 > n.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (e = e.toUpperCase(), t > 4294967295)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${4294967295}. Received ${t}`);
  e === "LE" ? (n[r] = t & 255, n[r + 1] = t >> 8 & 255, n[r + 2] = t >> 16 & 255, n[r + 3] = t >> 24 & 255) : (n[r] = t >> 24 & 255, n[r + 1] = t >> 16 & 255, n[r + 2] = t >> 8 & 255, n[r + 3] = t & 255);
}
function pn(n, r, t, e) {
  if (r + 8 > n.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (e = e.toUpperCase(), t > 0xffffffffffffffffn)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffffffffffffffffn}. Received ${t}`);
  e === "LE" ? (n[r] = Number(t & 0xffn), n[r + 1] = Number(t >> 8n & 0xffn), n[r + 2] = Number(t >> 16n & 0xffn), n[r + 3] = Number(t >> 24n & 0xffn), n[r + 4] = Number(t >> 32n & 0xffn), n[r + 5] = Number(t >> 40n & 0xffn), n[r + 6] = Number(t >> 48n & 0xffn), n[r + 7] = Number(t >> 56n & 0xffn)) : (n[r] = Number(t >> 56n & 0xffn), n[r + 1] = Number(t >> 48n & 0xffn), n[r + 2] = Number(t >> 40n & 0xffn), n[r + 3] = Number(t >> 32n & 0xffn), n[r + 4] = Number(t >> 24n & 0xffn), n[r + 5] = Number(t >> 16n & 0xffn), n[r + 6] = Number(t >> 8n & 0xffn), n[r + 7] = Number(t & 0xffn));
}
function Pn(n, r, t) {
  if (r + 2 > n.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (t = t.toUpperCase(), t === "LE") {
    let e = 0;
    return e = (e << 8) + n[r + 1], e = (e << 8) + n[r], e;
  } else {
    let e = 0;
    return e = (e << 8) + n[r], e = (e << 8) + n[r + 1], e;
  }
}
function Vn(n, r, t) {
  if (r + 4 > n.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (t = t.toUpperCase(), t === "LE") {
    let e = 0;
    return e = (e << 8) + n[r + 3] >>> 0, e = (e << 8) + n[r + 2] >>> 0, e = (e << 8) + n[r + 1] >>> 0, e = (e << 8) + n[r] >>> 0, e;
  } else {
    let e = 0;
    return e = (e << 8) + n[r] >>> 0, e = (e << 8) + n[r + 1] >>> 0, e = (e << 8) + n[r + 2] >>> 0, e = (e << 8) + n[r + 3] >>> 0, e;
  }
}
function jn(n, r, t) {
  if (r + 8 > n.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (t = t.toUpperCase(), t === "LE") {
    let e = 0n;
    return e = (e << 8n) + BigInt(n[r + 7]), e = (e << 8n) + BigInt(n[r + 6]), e = (e << 8n) + BigInt(n[r + 5]), e = (e << 8n) + BigInt(n[r + 4]), e = (e << 8n) + BigInt(n[r + 3]), e = (e << 8n) + BigInt(n[r + 2]), e = (e << 8n) + BigInt(n[r + 1]), e = (e << 8n) + BigInt(n[r]), e;
  } else {
    let e = 0n;
    return e = (e << 8n) + BigInt(n[r]), e = (e << 8n) + BigInt(n[r + 1]), e = (e << 8n) + BigInt(n[r + 2]), e = (e << 8n) + BigInt(n[r + 3]), e = (e << 8n) + BigInt(n[r + 4]), e = (e << 8n) + BigInt(n[r + 5]), e = (e << 8n) + BigInt(n[r + 6]), e = (e << 8n) + BigInt(n[r + 7]), e;
  }
}
const Jn = (n) => {
  if (n < 0 || n > 0xffffffffffffffffn)
    throw new RangeError("value out of range");
};
function $n(n) {
  if (n < 0 || n > Number.MAX_SAFE_INTEGER || n % 1 !== 0)
    throw new RangeError("value out of range");
}
function Z(n) {
  typeof n == "number" ? $n(n) : Jn(n);
}
function Q(n, r, t) {
  Z(n), t === void 0 && (t = 0), r === void 0 && (r = new Uint8Array(K(n)));
  let e = 0;
  return n < 253 ? (r.set([Number(n)], t), e = 1) : n <= 65535 ? (r.set([253], t), Tn(r, t + 1, Number(n), "LE"), e = 3) : n <= 4294967295 ? (r.set([254], t), Rn(r, t + 1, Number(n), "LE"), e = 5) : (r.set([255], t), pn(r, t + 1, BigInt(n), "LE"), e = 9), { buffer: r, bytes: e };
}
function W(n, r) {
  r === void 0 && (r = 0);
  const t = n.at(r);
  if (t === void 0)
    throw new Error("buffer too small");
  if (t < 253)
    return { numberValue: t, bigintValue: BigInt(t), bytes: 1 };
  if (t === 253) {
    const e = Pn(n, r + 1, "LE");
    return {
      numberValue: e,
      bigintValue: BigInt(e),
      bytes: 3
    };
  } else if (t === 254) {
    const e = Vn(n, r + 1, "LE");
    return {
      numberValue: e,
      bigintValue: BigInt(e),
      bytes: 5
    };
  } else {
    const e = jn(n, r + 1, "LE");
    return { numberValue: e <= Number.MAX_SAFE_INTEGER ? Number(e) : null, bigintValue: e, bytes: 9 };
  }
}
function K(n) {
  return Z(n), n < 253 ? 1 : n <= 65535 ? 3 : n <= 4294967295 ? 5 : 9;
}
const bn = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: W,
  encode: Q,
  encodingLength: K
}, Symbol.toStringTag, { value: "Module" })), { typeforce: nn } = Bn;
function rn(n, r) {
  if (typeof n != "number") throw new Error("cannot write a non-number as a number");
  if (n < 0) throw new Error("specified a negative value for writing an unsigned value");
  if (n > r) throw new Error("RangeError: value out of range");
  if (Math.floor(n) !== n) throw new Error("value has a fractional component");
}
function vn(n, r) {
  const t = n.readUInt32LE(r);
  let e = n.readUInt32LE(r + 4);
  return e *= 4294967296, rn(e + t, 9007199254740991), e + t;
}
function kn(n, r, t) {
  return rn(r, 9007199254740991), n.writeInt32LE(r & -1, t), n.writeUInt32LE(Math.floor(r / 4294967296), t + 4), t + 8;
}
function Xn(n) {
  if (n.length < 1) return n;
  let r = n.length - 1, t = 0;
  for (let e = 0; e < n.length / 2; e++)
    t = n[e], n[e] = n[r], n[r] = t, r--;
  return n;
}
function Gn(n) {
  const r = A.allocUnsafe(n.length);
  return n.copy(r), r;
}
class tn {
  constructor(r, t = 0) {
    this.buffer = r, this.offset = t, nn(v($, k), [r, t]);
  }
  static withCapacity(r) {
    return new tn(A.alloc(r));
  }
  writeUInt8(r) {
    this.offset = this.buffer.writeUInt8(r, this.offset);
  }
  writeInt32(r) {
    this.offset = this.buffer.writeInt32LE(r, this.offset);
  }
  writeUInt32(r) {
    this.offset = this.buffer.writeUInt32LE(r, this.offset);
  }
  writeUInt64(r) {
    this.offset = kn(this.buffer, r, this.offset);
  }
  writeVarInt(r) {
    const t = Q(r, this.buffer, this.offset);
    this.offset += t.bytes;
  }
  writeSlice(r) {
    if (this.buffer.length < this.offset + r.length)
      throw new Error("Cannot write slice out of bounds");
    this.offset += r.copy(this.buffer, this.offset);
  }
  writeVarSlice(r) {
    this.writeVarInt(r.length), this.writeSlice(r);
  }
  writeVector(r) {
    this.writeVarInt(r.length), r.forEach((t) => this.writeVarSlice(t));
  }
  end() {
    if (this.buffer.length === this.offset)
      return this.buffer;
    throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);
  }
}
class Yn {
  constructor(r, t = 0) {
    this.buffer = r, this.offset = t, nn(v($, k), [r, t]);
  }
  readUInt8() {
    const r = this.buffer.readUInt8(this.offset);
    return this.offset++, r;
  }
  readInt32() {
    const r = this.buffer.readInt32LE(this.offset);
    return this.offset += 4, r;
  }
  readUInt32() {
    const r = this.buffer.readUInt32LE(this.offset);
    return this.offset += 4, r;
  }
  readUInt64() {
    const r = vn(this.buffer, this.offset);
    return this.offset += 8, r;
  }
  readVarInt() {
    const r = W(this.buffer, this.offset);
    return this.offset += r.bytes, r.numberValue || 0;
  }
  readSlice(r) {
    if (this.buffer.length < this.offset + r)
      throw new Error("Cannot read slice out of bounds");
    const t = A.from(this.buffer.subarray(this.offset, this.offset + r));
    return this.offset += r, t;
  }
  readVarSlice() {
    return this.readSlice(this.readVarInt());
  }
  readVector() {
    const r = this.readVarInt(), t = [];
    for (let e = 0; e < r; e++) t.push(this.readVarSlice());
    return t;
  }
}
function Zn(n, r) {
  if (!Array.isArray(n)) throw TypeError("Expected values Array");
  if (typeof r != "function") throw TypeError("Expected digest Function");
  let t = n.length;
  const e = n.concat();
  for (; t > 1; ) {
    let a = 0;
    for (let d = 0; d < t; d += 2, ++a) {
      const N = e[d], l = d + 1 === t ? N : e[d + 1], E = A.concat([N, l]);
      e[a] = r(E);
    }
    t = a;
  }
  return e[0];
}
export {
  In as A,
  Yn as B,
  Dn as C,
  bn as D,
  vn as E,
  On as F,
  kn as G,
  dn as H,
  An as N,
  gn as S,
  b as T,
  _n as U,
  v as a,
  X as b,
  Gn as c,
  hn as d,
  K as e,
  Q as f,
  Bn as g,
  En as h,
  G as i,
  k as j,
  $ as k,
  mn as l,
  Un as m,
  tn as n,
  Zn as o,
  Cn as p,
  yn as q,
  Xn as r,
  an as s,
  w as t,
  Fn as u,
  fn as v,
  Mn as w,
  zn as x,
  xn as y,
  Nn as z
};
