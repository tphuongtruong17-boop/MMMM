import { B as _ } from "./crypto-BhCpKpek.js";
import { p as D, g as d, U as C, q as H, u as L, A as l, v as h, w as M, k as I, x as w, y as V, z as B, d as F, C as m, l as K } from "./utils-DNZi-T5W.js";
const o = {
  OP_FALSE: 0,
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_RESERVED: 80,
  OP_TRUE: 81,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,
  OP_NOP: 97,
  OP_VER: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_VERIF: 101,
  OP_VERNOTIF: 102,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,
  OP_CAT: 126,
  OP_SUBSTR: 127,
  OP_LEFT: 128,
  OP_RIGHT: 129,
  OP_SIZE: 130,
  OP_INVERT: 131,
  OP_AND: 132,
  OP_OR: 133,
  OP_XOR: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_RESERVED1: 137,
  OP_RESERVED2: 138,
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_2MUL: 141,
  OP_2DIV: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,
  OP_ADD: 147,
  OP_SUB: 148,
  OP_MUL: 149,
  OP_DIV: 150,
  OP_MOD: 151,
  OP_LSHIFT: 152,
  OP_RSHIFT: 153,
  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,
  OP_WITHIN: 165,
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,
  OP_NOP1: 176,
  OP_NOP2: 177,
  OP_CHECKLOCKTIMEVERIFY: 177,
  OP_NOP3: 178,
  OP_CHECKSEQUENCEVERIFY: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,
  OP_CHECKSIGADD: 186,
  OP_PUBKEYHASH: 253,
  OP_PUBKEY: 254,
  OP_INVALIDOPCODE: 255
}, T = {};
for (const t of Object.keys(o)) {
  const n = o[t];
  T[n] = t;
}
function G(t, n, e) {
  n = n || 4, e = e === void 0 ? !0 : e;
  const r = t.length;
  if (r === 0) return 0;
  if (r > n) throw new TypeError("Script number overflow");
  if (e && (t[r - 1] & 127) === 0 && (r <= 1 || (t[r - 2] & 128) === 0))
    throw new Error("Non-minimally encoded script number");
  if (r === 5) {
    const P = t.readUInt32LE(0), i = t.readUInt8(4);
    return i & 128 ? -((i & -129) * 4294967296 + P) : i * 4294967296 + P;
  }
  let O = 0;
  for (let P = 0; P < r; ++P)
    O |= t[P] << 8 * P;
  return t[r - 1] & 128 ? -(O & ~(128 << 8 * (r - 1))) : O;
}
function v(t) {
  return t > 2147483647 ? 5 : t > 8388607 ? 4 : t > 32767 ? 3 : t > 127 ? 2 : t > 0 ? 1 : 0;
}
function R(t) {
  let n = Math.abs(t);
  const e = v(n), r = _.allocUnsafe(e), O = t < 0;
  for (let P = 0; P < e; ++P)
    r.writeUInt8(n & 255, P), n >>= 8;
  return r[e - 1] & 128 ? r.writeUInt8(O ? 128 : 0, e - 1) : O && (r[e - 1] |= 128), r;
}
const b = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: G,
  encode: R
}, Symbol.toStringTag, { value: "Module" })), { typeforce: $ } = d, f = _.alloc(1, 0);
function a(t) {
  const n = t & -129;
  return n > 0 && n < 4;
}
function A(t) {
  let n = 0;
  for (; t[n] === 0; ) ++n;
  return n === t.length ? f : (t = t.subarray(n), t[0] & 128 ? _.concat([f, t], 1 + t.length) : t);
}
function S(t) {
  t[0] === 0 && (t = t.subarray(1));
  const n = _.alloc(32, 0), e = Math.max(0, 32 - t.length);
  return t.copy(n, e), n;
}
function Q(t) {
  const n = t.readUInt8(t.length - 1);
  if (!a(n))
    throw new Error(`Invalid hashType ${n}`);
  const e = D(t.subarray(0, -1)), r = S(e.r), O = S(e.s);
  return { signature: _.concat([r, O], 64), hashType: n };
}
function Y(t, n) {
  if ($(
    {
      signature: H(64),
      hashType: C
    },
    { signature: t, hashType: n }
  ), !a(n))
    throw new Error(`Invalid hashType ${n}`);
  const e = _.allocUnsafe(1);
  e.writeUInt8(n, 0);
  const r = A(t.subarray(0, 32)), O = A(t.subarray(32, 64));
  return _.concat([L(r, O), e]);
}
const j = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: Q,
  encode: Y,
  isDefinedHashType: a
}, Symbol.toStringTag, { value: "Module" })), { typeforce: s } = d, U = o.OP_RESERVED;
function z(t) {
  return K(t) && (t === o.OP_0 || t >= o.OP_1 && t <= o.OP_16 || t === o.OP_1NEGATE);
}
function N(t) {
  return I(t) || z(t);
}
function p(t) {
  return l(t) && t.every(N);
}
function W(t) {
  return t.length - t.filter(N).length;
}
function c(t) {
  if (t.length === 0) return o.OP_0;
  if (t.length === 1) {
    if (t[0] >= 1 && t[0] <= 16) return U + t[0];
    if (t[0] === 129) return o.OP_1NEGATE;
  }
}
function g(t) {
  return _.isBuffer(t);
}
function X(t) {
  return l(t);
}
function E(t) {
  return _.isBuffer(t);
}
function y(t) {
  if (g(t)) return t;
  s(l, t);
  const n = t.reduce((O, P) => E(P) ? P.length === 1 && c(P) !== void 0 ? O + 1 : O + h(P.length) + P.length : O + 1, 0), e = _.allocUnsafe(n);
  let r = 0;
  if (t.forEach((O) => {
    if (E(O)) {
      const P = c(O);
      if (P !== void 0) {
        e.writeUInt8(P, r), r += 1;
        return;
      }
      r += M(e, O.length, r), O.copy(e, r), r += O.length;
    } else
      e.writeUInt8(O, r), r += 1;
  }), r !== e.length) throw new Error("Could not decode chunks");
  return e;
}
function u(t) {
  if (X(t)) return t;
  s(I, t);
  const n = [];
  let e = 0;
  for (; e < t.length; ) {
    const r = t[e];
    if (r > o.OP_0 && r <= o.OP_PUSHDATA4) {
      const O = w(t, e);
      if (O === null || (e += O.size, e + O.number > t.length)) return null;
      const P = t.subarray(e, e + O.number);
      e += O.number;
      const i = c(P);
      i !== void 0 ? n.push(i) : n.push(P);
    } else
      n.push(r), e += 1;
  }
  return n;
}
function Z(t) {
  if (g(t) && (t = u(t)), !t)
    throw new Error("Could not convert invalid chunks to ASM");
  return t.map((n) => {
    if (E(n)) {
      const e = c(n);
      if (e === void 0) return n.toString("hex");
      n = e;
    }
    return T[n];
  }).join(" ");
}
function q(t) {
  return s(V, t), y(
    t.split(" ").map((n) => o[n] !== void 0 ? o[n] : (s(B, n), _.from(n, "hex")))
  );
}
function J(t) {
  return t = u(t), s(p, t), t.map((n) => E(n) ? n : n === o.OP_0 ? _.allocUnsafe(0) : R(n - U));
}
function x(t) {
  return F(t);
}
function k(t) {
  return !_.isBuffer(t) || !a(t[t.length - 1]) ? !1 : m(t.subarray(0, -1));
}
const tt = b, nt = j, Ot = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  compile: y,
  countNonPushOnlyOPs: W,
  decompile: u,
  fromASM: q,
  isCanonicalPubKey: x,
  isCanonicalScriptSignature: k,
  isPushOnly: p,
  number: tt,
  opcodes: o,
  signature: nt,
  toASM: Z,
  toStack: J
}, Symbol.toStringTag, { value: "Module" }));
export {
  x as a,
  W as b,
  y as c,
  u as d,
  p as e,
  J as f,
  Ot as g,
  k as i,
  o,
  nt as s,
  Z as t
};
