import { B as c, b as U, s as N, t as $ } from "./crypto-BhCpKpek.js";
import { B as z, g as K, h as D, a as C, j as b, m as P, k as _, N as Q, S as W, e as v, l as V, n as A, r as M, F as J, o as x, f as tt } from "./utils-DNZi-T5W.js";
import { d as et, c as st, o as it } from "./script-DyPItFEl.js";
const { typeforce: p } = K;
function I(l) {
  const t = l.length;
  return v(t) + t;
}
function rt(l) {
  const t = l.length;
  return v(t) + l.reduce((e, s) => e + I(s), 0);
}
const d = c.allocUnsafe(0), F = [], k = c.from(
  "0000000000000000000000000000000000000000000000000000000000000000",
  "hex"
), T = c.from(
  "0000000000000000000000000000000000000000000000000000000000000001",
  "hex"
), nt = c.from("ffffffffffffffff", "hex"), ot = {
  script: d,
  valueBuffer: nt
};
function ht(l) {
  return "value" in l;
}
class o {
  constructor() {
    this.version = 1, this.locktime = 0, this.ins = [], this.outs = [];
  }
  static {
    this.DEFAULT_SEQUENCE = 4294967295;
  }
  static {
    this.SIGHASH_DEFAULT = 0;
  }
  static {
    this.SIGHASH_ALL = 1;
  }
  static {
    this.SIGHASH_NONE = 2;
  }
  static {
    this.SIGHASH_SINGLE = 3;
  }
  static {
    this.SIGHASH_ANYONECANPAY = 128;
  }
  static {
    this.SIGHASH_OUTPUT_MASK = 3;
  }
  static {
    this.SIGHASH_INPUT_MASK = 128;
  }
  static {
    this.ADVANCED_TRANSACTION_MARKER = 0;
  }
  static {
    this.ADVANCED_TRANSACTION_FLAG = 1;
  }
  static {
    this.TRUC_VERSION = 3;
  }
  static {
    this.TRUC_MAX_VSIZE = 1e4;
  }
  static {
    this.TRUC_CHILD_MAX_VSIZE = 1e3;
  }
  static fromBuffer(t, e) {
    const s = new z(t), i = new o();
    i.version = s.readInt32();
    const n = s.readUInt8(), r = s.readUInt8();
    let f = !1;
    n === o.ADVANCED_TRANSACTION_MARKER && r === o.ADVANCED_TRANSACTION_FLAG ? f = !0 : s.offset -= 2;
    const u = s.readVarInt();
    for (let S = 0; S < u; ++S) {
      const m = s.readSlice(32), E = s.readUInt32(), y = s.readVarSlice(), L = s.readUInt32();
      i.ins.push({
        hash: m,
        index: E,
        script: y,
        sequence: L,
        witness: F
      });
    }
    const g = s.readVarInt();
    for (let S = 0; S < g; ++S)
      i.outs.push({
        value: s.readUInt64(),
        script: s.readVarSlice()
      });
    if (f) {
      for (let S = 0; S < u; ++S)
        i.ins[S].witness = s.readVector();
      if (!i.hasWitnesses()) throw new Error("Transaction has superfluous witness data");
    }
    if (i.locktime = s.readUInt32(), e) return i;
    if (s.offset !== t.length)
      throw new Error("Transaction has unexpected data");
    return i;
  }
  static fromHex(t) {
    return o.fromBuffer(c.from(t, "hex"), !1);
  }
  static isCoinbaseHash(t) {
    p(D, t);
    for (let e = 0; e < 32; ++e)
      if (t[e] !== 0) return !1;
    return !0;
  }
  isCoinbase() {
    return this.ins.length === 1 && o.isCoinbaseHash(this.ins[0].hash);
  }
  addInput(t, e, s, i) {
    return p(
      C(
        D,
        b,
        P(b),
        P(_)
      ),
      [t, e, s, i]
    ), Q(s) && (s = o.DEFAULT_SEQUENCE), this.ins.push({
      hash: t,
      index: e,
      script: i || d,
      sequence: s,
      witness: F
    }) - 1;
  }
  addOutput(t, e) {
    return p(C(_, W), [t, e]), this.outs.push({
      script: t,
      value: e
    }) - 1;
  }
  hasWitnesses() {
    return this.ins.some((t) => t.witness.length !== 0);
  }
  weight() {
    const t = this.byteLength(!1), e = this.byteLength(!0);
    return t * 3 + e;
  }
  virtualSize() {
    return Math.ceil(this.weight() / 4);
  }
  byteLength(t = !0) {
    const e = t && this.hasWitnesses();
    return (e ? 10 : 8) + v(this.ins.length) + v(this.outs.length) + this.ins.reduce((s, i) => s + 40 + I(i.script), 0) + this.outs.reduce((s, i) => s + 8 + I(i.script), 0) + (e ? this.ins.reduce((s, i) => s + rt(i.witness), 0) : 0);
  }
  clone() {
    const t = new o();
    return t.version = this.version, t.locktime = this.locktime, t.ins = this.ins.map((e) => ({
      hash: e.hash,
      index: e.index,
      script: e.script,
      sequence: e.sequence,
      witness: e.witness
    })), t.outs = this.outs.map((e) => ({
      script: e.script,
      value: e.value
    })), t;
  }
  /**
   * Hash transaction for signing a specific input.
   *
   * Bitcoin uses a different hash for each signed transaction input.
   * This method copies the transaction, makes the necessary changes based on the
   * hashType, and then hashes the result.
   * This hash can then be used to sign the provided transaction input.
   */
  hashForSignature(t, e, s) {
    if (p(C(
      b,
      _,
      /* types.UInt8 */
      V
    ), [
      t,
      e,
      s
    ]), t >= this.ins.length) return T;
    const i = et(e);
    if (!i) throw new Error("Could not decompile prevOutScript");
    const n = st(
      i.filter((u) => u !== it.OP_CODESEPARATOR)
    ), r = this.clone();
    if ((s & 31) === o.SIGHASH_NONE)
      r.outs = [], r.ins.forEach((u, g) => {
        g !== t && (u.sequence = 0);
      });
    else if ((s & 31) === o.SIGHASH_SINGLE) {
      if (t >= this.outs.length) return T;
      r.outs.length = t + 1;
      for (let u = 0; u < t; u++)
        r.outs[u] = ot;
      r.ins.forEach((u, g) => {
        g !== t && (u.sequence = 0);
      });
    }
    s & o.SIGHASH_ANYONECANPAY ? (r.ins = [r.ins[t]], r.ins[0].script = n) : (r.ins.forEach((u) => {
      u.script = d;
    }), r.ins[t].script = n);
    const f = c.allocUnsafe(r.byteLength(!1) + 4);
    return f.writeInt32LE(s, f.length - 4), r.__toBuffer(f, 0, !1), U(f);
  }
  hashForWitnessV1(t, e, s, i, n, r) {
    if (p(
      C(
        b,
        p.arrayOf(_),
        p.arrayOf(W),
        b
      ),
      [t, e, s, i]
    ), s.length !== this.ins.length || e.length !== this.ins.length)
      throw new Error("Must supply prevout script and value for all inputs");
    const f = i === o.SIGHASH_DEFAULT ? o.SIGHASH_ALL : i & o.SIGHASH_OUTPUT_MASK, g = (i & o.SIGHASH_INPUT_MASK) === o.SIGHASH_ANYONECANPAY, S = f === o.SIGHASH_NONE, m = f === o.SIGHASH_SINGLE;
    let E = d, y = d, L = d, O = d, G = d;
    if (!g) {
      let h = A.withCapacity(36 * this.ins.length);
      this.ins.forEach((w) => {
        h.writeSlice(w.hash), h.writeUInt32(w.index);
      }), E = N(h.end()), h = A.withCapacity(8 * this.ins.length), s.forEach((w) => h.writeUInt64(w)), y = N(h.end()), h = A.withCapacity(
        e.map(I).reduce((w, H) => w + H)
      ), e.forEach((w) => h.writeVarSlice(w)), L = N(h.end()), h = A.withCapacity(4 * this.ins.length), this.ins.forEach((w) => h.writeUInt32(w.sequence)), O = N(h.end());
    }
    if (S || m) {
      if (m && t < this.outs.length) {
        const h = this.outs[t], w = A.withCapacity(8 + I(h.script));
        w.writeUInt64(h.value), w.writeVarSlice(h.script), G = N(w.end());
      }
    } else {
      if (!this.outs.length)
        throw new Error("Add outputs to the transaction before signing.");
      const h = this.outs.map((H) => 8 + I(H.script)).reduce((H, Z) => H + Z), w = A.withCapacity(h);
      this.outs.forEach((H) => {
        w.writeUInt64(H.value), w.writeVarSlice(H.script);
      }), G = N(w.end());
    }
    const j = (n ? 2 : 0) + (r ? 1 : 0), X = 174 - (g ? 49 : 0) - (S ? 32 : 0) + (r ? 32 : 0) + (n ? 37 : 0), a = A.withCapacity(X);
    if (a.writeUInt8(i), a.writeInt32(this.version), a.writeUInt32(this.locktime), a.writeSlice(E), a.writeSlice(y), a.writeSlice(L), a.writeSlice(O), S || m || a.writeSlice(G), a.writeUInt8(j), g) {
      const h = this.ins[t];
      a.writeSlice(h.hash), a.writeUInt32(h.index), a.writeUInt64(s[t]), a.writeVarSlice(e[t]), a.writeUInt32(h.sequence);
    } else
      a.writeUInt32(t);
    if (r) {
      const h = A.withCapacity(I(r));
      h.writeVarSlice(r), a.writeSlice(N(h.end()));
    }
    return m && a.writeSlice(G), n && (a.writeSlice(n), a.writeUInt8(0), a.writeUInt32(4294967295)), $(
      "TapSighash",
      c.concat([c.from([0]), a.end()])
    );
  }
  hashForWitnessV0(t, e, s, i) {
    p(C(b, _, W, b), [
      t,
      e,
      s,
      i
    ]);
    let n = c.from([]), r, f = k, u = k, g = k;
    if (i & o.SIGHASH_ANYONECANPAY || (n = c.allocUnsafe(36 * this.ins.length), r = new A(n, 0), this.ins.forEach((m) => {
      r.writeSlice(m.hash), r.writeUInt32(m.index);
    }), u = U(n)), !(i & o.SIGHASH_ANYONECANPAY) && (i & 31) !== o.SIGHASH_SINGLE && (i & 31) !== o.SIGHASH_NONE && (n = c.allocUnsafe(4 * this.ins.length), r = new A(n, 0), this.ins.forEach((m) => {
      r.writeUInt32(m.sequence);
    }), g = U(n)), (i & 31) !== o.SIGHASH_SINGLE && (i & 31) !== o.SIGHASH_NONE) {
      const m = this.outs.reduce((E, y) => E + 8 + I(y.script), 0);
      n = c.allocUnsafe(m), r = new A(n, 0), this.outs.forEach((E) => {
        r.writeUInt64(E.value), r.writeVarSlice(E.script);
      }), f = U(n);
    } else if ((i & 31) === o.SIGHASH_SINGLE && t < this.outs.length) {
      const m = this.outs[t];
      n = c.allocUnsafe(8 + I(m.script)), r = new A(n, 0), r.writeUInt64(m.value), r.writeVarSlice(m.script), f = U(n);
    }
    n = c.allocUnsafe(156 + I(e)), r = new A(n, 0);
    const S = this.ins[t];
    return r.writeInt32(this.version), r.writeSlice(u), r.writeSlice(g), r.writeSlice(S.hash), r.writeUInt32(S.index), r.writeVarSlice(e), r.writeUInt64(s), r.writeUInt32(S.sequence), r.writeSlice(f), r.writeUInt32(this.locktime), r.writeUInt32(i), U(n);
  }
  getHash(t) {
    return t && this.isCoinbase() ? c.alloc(32, 0) : U(this.__toBuffer(void 0, void 0, t));
  }
  getId() {
    return M(this.getHash(!1)).toString("hex");
  }
  toBuffer(t, e) {
    return this.__toBuffer(t, e, !0);
  }
  toHex() {
    return this.toBuffer(void 0, void 0).toString("hex");
  }
  setInputScript(t, e) {
    p(C(V, _), [t, e]), this.ins[t].script = e;
  }
  setWitness(t, e) {
    p(C(V, [_]), [t, e]), this.ins[t].witness = e;
  }
  __toBuffer(t, e, s = !1) {
    t || (t = c.allocUnsafe(this.byteLength(s)));
    const i = new A(t, e || 0);
    i.writeInt32(this.version);
    const n = s && this.hasWitnesses();
    return n && (i.writeUInt8(o.ADVANCED_TRANSACTION_MARKER), i.writeUInt8(o.ADVANCED_TRANSACTION_FLAG)), i.writeVarInt(this.ins.length), this.ins.forEach((r) => {
      i.writeSlice(r.hash), i.writeUInt32(r.index), i.writeVarSlice(r.script), i.writeUInt32(r.sequence);
    }), i.writeVarInt(this.outs.length), this.outs.forEach((r) => {
      ht(r) ? i.writeUInt64(r.value) : i.writeSlice(r.valueBuffer), i.writeVarSlice(r.script);
    }), n && this.ins.forEach((r) => {
      i.writeVector(r.witness);
    }), i.writeUInt32(this.locktime), e !== void 0 ? t.subarray(e, i.offset) : t;
  }
}
const wt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Transaction: o
}, Symbol.toStringTag, { value: "Module" })), { typeforce: ct } = K, B = new TypeError("Cannot compute merkle root for zero transactions"), Y = new TypeError("Cannot compute witness commit for non-segwit block");
class R {
  constructor() {
    this.version = 1, this.prevHash = void 0, this.merkleRoot = void 0, this.timestamp = 0, this.witnessCommit = void 0, this.bits = 0, this.nonce = 0, this.transactions = void 0;
  }
  static fromBuffer(t) {
    if (t.length < 80) throw new Error("Buffer too small (< 80 bytes)");
    const e = new z(t), s = new R();
    if (s.version = e.readInt32(), s.prevHash = e.readSlice(32), s.merkleRoot = e.readSlice(32), s.timestamp = e.readUInt32(), s.bits = e.readUInt32(), s.nonce = e.readUInt32(), t.length === 80) return s;
    const i = () => {
      const f = o.fromBuffer(
        e.buffer.subarray(e.offset),
        !0
      );
      return e.offset += f.byteLength(), f;
    }, n = e.readVarInt();
    s.transactions = [];
    for (let f = 0; f < n; ++f) {
      const u = i();
      s.transactions.push(u);
    }
    const r = s.getWitnessCommit();
    return r && (s.witnessCommit = r), s;
  }
  static fromHex(t) {
    return R.fromBuffer(c.from(t, "hex"));
  }
  static calculateTarget(t) {
    const e = ((t & 4278190080) >> 24) - 3, s = t & 8388607, i = c.alloc(32, 0);
    return i.writeUIntBE(s, 29 - e, 3), i;
  }
  static calculateMerkleRoot(t, e) {
    if (ct([{ getHash: J }], t), t.length === 0) throw B;
    if (e && !q(t)) throw Y;
    const s = t.map((n) => n.getHash(e)), i = x(s, U);
    return e ? U(c.concat([i, t[0].ins[0].witness[0]])) : i;
  }
  getWitnessCommit() {
    if (!q(this.transactions)) return null;
    const t = this.transactions[0].outs.filter(
      (s) => s.script.subarray(0, 6).equals(c.from("6a24aa21a9ed", "hex"))
    ).map((s) => s.script.subarray(6, 38));
    if (t.length === 0) return null;
    const e = t[t.length - 1];
    return e instanceof c && e.length === 32 ? e : null;
  }
  hasWitnessCommit() {
    return this.witnessCommit instanceof c && this.witnessCommit.length === 32 || this.getWitnessCommit() !== null;
  }
  hasWitness() {
    return at(this.transactions);
  }
  weight() {
    const t = this.byteLength(!1, !1), e = this.byteLength(!1, !0);
    return t * 3 + e;
  }
  byteLength(t, e = !0) {
    return t || !this.transactions ? 80 : 80 + v(this.transactions.length) + this.transactions.reduce((s, i) => s + i.byteLength(e), 0);
  }
  getHash() {
    return U(this.toBuffer(!0));
  }
  getId() {
    return M(this.getHash()).toString("hex");
  }
  getUTCDate() {
    const t = /* @__PURE__ */ new Date(0);
    return t.setUTCSeconds(this.timestamp), t;
  }
  // TODO: buffer, offset compatibility
  toBuffer(t) {
    const e = c.allocUnsafe(this.byteLength(t)), s = new A(e);
    if (s.writeInt32(this.version), s.writeSlice(this.prevHash), s.writeSlice(this.merkleRoot), s.writeUInt32(this.timestamp), s.writeUInt32(this.bits), s.writeUInt32(this.nonce), t || !this.transactions) return e;
    const i = tt(this.transactions.length, e, s.offset);
    return s.offset += i.bytes, this.transactions.forEach((n) => {
      const r = n.byteLength();
      n.toBuffer(e, s.offset), s.offset += r;
    }), e;
  }
  toHex(t) {
    return this.toBuffer(t).toString("hex");
  }
  checkTxRoots() {
    const t = this.hasWitnessCommit();
    return !t && this.hasWitness() ? !1 : this.__checkMerkleRoot() && (t ? this.__checkWitnessCommit() : !0);
  }
  checkProofOfWork() {
    const t = M(this.getHash()), e = R.calculateTarget(this.bits);
    return t.compare(e) <= 0;
  }
  __checkMerkleRoot() {
    if (!this.transactions) throw B;
    const t = R.calculateMerkleRoot(this.transactions);
    return this.merkleRoot.compare(t) === 0;
  }
  __checkWitnessCommit() {
    if (!this.transactions) throw B;
    if (!this.hasWitnessCommit()) throw Y;
    const t = R.calculateMerkleRoot(this.transactions, !0);
    return this.witnessCommit.compare(t) === 0;
  }
}
function q(l) {
  return l instanceof Array && l[0] && l[0].ins && l[0].ins instanceof Array && l[0].ins[0] && l[0].ins[0].witness && l[0].ins[0].witness instanceof Array && l[0].ins[0].witness.length > 0;
}
function at(l) {
  return l instanceof Array && l.some(
    (t) => typeof t == "object" && t.ins instanceof Array && t.ins.some(
      (e) => typeof e == "object" && e.witness instanceof Array && e.witness.length > 0
    )
  );
}
export {
  R as B,
  o as T,
  wt as a
};
