import { b as v, d as g, f as ie, i as L, a as D } from "./psbt-BCNk7JUx.js";
import { o as _, c as l, i as H, d as m, b as oe, e as fe, f as me } from "./script-DyPItFEl.js";
import { t as r, d as P, s as j, b as we, e as le, f as ye, i as be, T as $ } from "./utils-DNZi-T5W.js";
import { a as k, B as c, h as T, t as X, s as Y } from "./crypto-BhCpKpek.js";
var E = /* @__PURE__ */ ((e) => (e.P2PK = "p2pk", e.P2PKH = "p2pkh", e.P2SH = "p2sh", e.P2MS = "p2ms", e.P2WPKH = "p2wpkh", e.P2WSH = "p2wsh", e.P2TR = "p2tr", e.P2OP = "p2op", e.Embed = "embed", e.ScriptRedeem = "scriptRedeem", e))(E || {});
function p(e, o, f) {
  Object.defineProperty(e, o, {
    configurable: !0,
    enumerable: !0,
    get() {
      const i = f.call(this);
      return this[o] = i, i;
    },
    set(i) {
      Object.defineProperty(this, o, {
        configurable: !0,
        enumerable: !0,
        value: i,
        writable: !0
      });
    }
  });
}
function y(e) {
  let o;
  return () => (o !== void 0 || (o = e()), o);
}
const Q = _, z = 16, Z = 2, J = 40;
function ge(e, o) {
  if (!e.address && !e.output && !e.program && (typeof e.deploymentVersion > "u" || !e.hash160))
    throw new TypeError("At least one of address, output or program must be provided");
  o = Object.assign({ validate: !0 }, o || {}), r(
    {
      address: r.maybe(r.String),
      output: r.maybe(r.Buffer),
      program: r.maybe(r.Buffer),
      network: r.maybe(r.Object),
      deploymentVersion: r.maybe(r.Number),
      hash160: r.maybe(r.BufferN(20))
    },
    e
  );
  const f = () => {
    if (typeof e.deploymentVersion < "u" && typeof e.hash160 < "u") {
      if (e.hash160.length !== 20) throw new TypeError("hash160 must be exactly 20 bytes");
      if (e.deploymentVersion < 0 || e.deploymentVersion > 255)
        throw new TypeError("deploymentVersion must fit in one byte");
      return c.concat([c.of(e.deploymentVersion), e.hash160]);
    }
  }, i = y(() => ie(e.address)), s = e.network || v, u = {
    name: E.P2OP,
    network: s,
    deploymentVersion: 0
  };
  if (p(u, "program", () => {
    if (e.program) return e.program;
    const n = f();
    if (n) return n;
    if (e.output) {
      if (e.output[0] !== Q.OP_16) throw new TypeError("Invalid P2OP script");
      let t = 1, h;
      if (e.output[1] < 76)
        h = e.output[1], t = 2;
      else if (e.output[1] === 76)
        h = e.output[2], t = 3;
      else
        throw new TypeError("Unsupported push opcode in P2OP script");
      return e.output.subarray(t, t + h);
    }
    if (e.address)
      return i().data;
  }), p(u, "deploymentVersion", () => {
    if (u.program)
      return u.program[0];
  }), p(u, "hash160", () => {
    if (u.program)
      return u.program.subarray(1);
  }), p(u, "output", () => {
    if (u.program)
      return l([Q.OP_16, u.program]);
  }), p(u, "address", () => {
    if (!u.program) return;
    if (!s.bech32Opnet)
      throw new TypeError("Network does not support opnet");
    const n = g.bech32m.toWords(u.program);
    return n.unshift(z), g.bech32m.encode(s.bech32Opnet, n);
  }), o.validate) {
    let n = k.alloc(0);
    if (e.address) {
      const t = i();
      if (s.bech32Opnet !== t.prefix)
        throw new TypeError("Invalid prefix or network mismatch");
      if (t.version !== z)
        throw new TypeError("Invalid witness version for p2op");
      if (t.data.length < Z || t.data.length > J)
        throw new TypeError("Invalid witness program length");
      n = t.data;
    }
    if (e.program) {
      if (n.length && !n.equals(e.program)) throw new TypeError("Program mismatch");
      n = e.program;
    }
    if (!n.length && e.deploymentVersion !== void 0 && e.hash160 && (n = f()), e.output) {
      const t = u.program;
      if (n.length && !n.equals(t))
        throw new TypeError("Program mismatch (output vs other source)");
      n = t;
    }
    if (n.length < Z || n.length > J)
      throw new TypeError(`Witness program must be 2â€“40 bytes. Was ${n.length} bytes`);
    if (e.deploymentVersion !== void 0 && e.deploymentVersion !== n[0])
      throw new TypeError("deploymentVersion mismatch");
    if (e.hash160 && !e.hash160.equals(n.subarray(1)))
      throw new TypeError("hash160 mismatch");
  }
  return Object.assign(u, e);
}
const S = _;
function ke(e, o) {
  if (!e.address && !e.hash && !e.output && !e.pubkey && !e.input)
    throw new TypeError("Not enough data");
  o = Object.assign({ validate: !0 }, o || {}), r(
    {
      network: r.maybe(r.Object),
      address: r.maybe(r.String),
      hash: r.maybe(r.BufferN(20)),
      output: r.maybe(r.BufferN(25)),
      pubkey: r.maybe(P),
      signature: r.maybe(H),
      input: r.maybe(r.Buffer)
    },
    e
  );
  const f = y(() => {
    const n = c.from(L.decode(e.address)), t = n.readUInt8(0), h = n.subarray(1);
    return { version: t, hash: h };
  }), i = y(() => m(e.input)), s = e.network || v, u = {
    name: E.P2PKH,
    network: s,
    hash: void 0
  };
  if (p(u, "address", () => {
    if (!u.hash) return;
    const n = c.allocUnsafe(21);
    return n.writeUInt8(s.pubKeyHash, 0), u.hash.copy(n, 1), L.encode(n);
  }), p(u, "hash", () => {
    if (e.output) return e.output.subarray(3, 23);
    if (e.address) return f().hash;
    if (e.pubkey || u.pubkey) return T(e.pubkey || u.pubkey);
  }), p(u, "output", () => {
    if (u.hash)
      return l([
        S.OP_DUP,
        S.OP_HASH160,
        u.hash,
        S.OP_EQUALVERIFY,
        S.OP_CHECKSIG
      ]);
  }), p(u, "pubkey", () => {
    if (e.input)
      return i()[1];
  }), p(u, "signature", () => {
    if (e.input)
      return i()[0];
  }), p(u, "input", () => {
    if (!e.pubkey || !e.signature) return;
    let n = e.pubkey;
    if (e.useHybrid || e.useUncompressed) {
      const t = D(e.pubkey);
      t && (e.useUncompressed ? n = t.uncompressed : n = t.hybrid);
    }
    return l([e.signature, n]);
  }), p(u, "witness", () => {
    if (u.input)
      return [];
  }), o.validate) {
    let n = c.from([]);
    if (e.address) {
      if (f().version !== s.pubKeyHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (f().hash.length !== 20)
        throw new TypeError("Invalid address");
      n = f().hash;
    }
    if (e.hash) {
      if (n.length > 0 && !n.equals(e.hash))
        throw new TypeError("Hash mismatch");
      n = e.hash;
    }
    if (e.output) {
      if (e.output.length !== 25 || e.output[0] !== S.OP_DUP || e.output[1] !== S.OP_HASH160 || e.output[2] !== 20 || e.output[23] !== S.OP_EQUALVERIFY || e.output[24] !== S.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      const t = e.output.subarray(3, 23);
      if (n.length > 0 && !n.equals(t)) throw new TypeError("Hash mismatch");
      n = t;
    }
    if (e.pubkey) {
      const t = T(e.pubkey);
      let h = n.length > 0 && !n.equals(t);
      if (h && (e.pubkey.length === 33 && (e.pubkey[0] === 2 || e.pubkey[0] === 3) || e.pubkey.length === 65 && e.pubkey[0] === 4)) {
        const d = D(e.pubkey);
        if (d) {
          const a = T(d.uncompressed);
          if (n.equals(a))
            h = !1, e.useUncompressed = !0;
          else {
            const w = T(d.hybrid);
            h = !n.equals(w), h || (e.useHybrid = !0);
          }
        }
      }
      if (h)
        throw new TypeError("Hash mismatch");
      n = t;
    }
    if (e.input) {
      const t = i();
      if (t.length !== 2) throw new TypeError("Input is invalid");
      if (!H(t[0]))
        throw new TypeError("Input has invalid signature");
      if (!P(t[1])) throw new TypeError("Input has invalid pubkey");
      if (e.signature && !e.signature.equals(t[0]))
        throw new TypeError("Signature mismatch");
      if (e.pubkey && !e.pubkey.equals(t[1]))
        throw new TypeError("Pubkey mismatch");
      const h = T(t[1]);
      if (n.length > 0 && !n.equals(h)) throw new TypeError("Hash mismatch (input)");
    }
  }
  return Object.assign(u, e);
}
const q = _;
function Ee(e, o) {
  if (!e.address && !e.hash && !e.output && !e.redeem && !e.input)
    throw new TypeError("Not enough data");
  o = Object.assign({ validate: !0 }, o || {}), r(
    {
      network: r.maybe(r.Object),
      address: r.maybe(r.String),
      hash: r.maybe(r.BufferN(20)),
      output: r.maybe(r.BufferN(23)),
      redeem: r.maybe({
        network: r.maybe(r.Object),
        output: r.maybe(r.Buffer),
        input: r.maybe(r.Buffer),
        witness: r.maybe(r.arrayOf(r.Buffer))
      }),
      input: r.maybe(r.Buffer),
      witness: r.maybe(r.arrayOf(r.Buffer))
    },
    e
  );
  let f = e.network;
  f || (f = e.redeem && e.redeem.network || v);
  const i = {
    network: f,
    name: E.P2SH
  }, s = y(() => {
    const t = c.from(L.decode(e.address)), h = t.readUInt8(0), d = t.subarray(1);
    return { version: h, hash: d };
  }), u = y(() => m(e.input)), n = y(() => {
    const t = u(), h = t[t.length - 1];
    return {
      network: f,
      output: h === q.OP_FALSE ? c.from([]) : h,
      input: l(t.slice(0, -1)),
      witness: e.witness || []
    };
  });
  if (p(i, "address", () => {
    if (!i.hash) return;
    const t = c.allocUnsafe(21);
    return t.writeUInt8(i.network.scriptHash, 0), i.hash.copy(t, 1), L.encode(t);
  }), p(i, "hash", () => {
    if (e.output) return e.output.subarray(2, 22);
    if (e.address) return s().hash;
    if (i.redeem && i.redeem.output) return T(i.redeem.output);
  }), p(i, "output", () => {
    if (i.hash)
      return l([q.OP_HASH160, i.hash, q.OP_EQUAL]);
  }), p(i, "redeem", () => {
    if (e.input)
      return n();
  }), p(i, "input", () => {
    if (!(!e.redeem || !e.redeem.input || !e.redeem.output))
      return l(
        [].concat(m(e.redeem.input), e.redeem.output)
      );
  }), p(i, "witness", () => {
    if (i.redeem && i.redeem.witness) return i.redeem.witness;
    if (i.input) return [];
  }), p(i, "name", () => {
    const t = ["p2sh"];
    return i.redeem !== void 0 && i.redeem.name !== void 0 && t.push(i.redeem.name), t.join("-");
  }), o.validate) {
    let t = c.from([]);
    if (e.address) {
      if (s().version !== f.scriptHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (s().hash.length !== 20) throw new TypeError("Invalid address");
      t = s().hash;
    }
    if (e.hash) {
      if (t.length > 0 && !t.equals(e.hash)) throw new TypeError("Hash mismatch");
      t = e.hash;
    }
    if (e.output) {
      if (e.output.length !== 23 || e.output[0] !== q.OP_HASH160 || e.output[1] !== 20 || e.output[22] !== q.OP_EQUAL)
        throw new TypeError("Output is invalid");
      const d = e.output.subarray(2, 22);
      if (t.length > 0 && !t.equals(d)) throw new TypeError("Hash mismatch");
      t = d;
    }
    const h = (d) => {
      if (d.output) {
        const a = m(d.output);
        if (!a || a.length < 1)
          throw new TypeError("Redeem.output too short");
        if (d.output.byteLength > 520)
          throw new TypeError("Redeem.output unspendable if larger than 520 bytes");
        if (oe(a) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const w = T(d.output);
        if (t.length > 0 && !t.equals(w)) throw new TypeError("Hash mismatch");
        t = w;
      }
      if (d.input) {
        const a = d.input.length > 0, w = d.witness && d.witness.length > 0;
        if (!a && !w) throw new TypeError("Empty input");
        if (a && w) throw new TypeError("Input and witness provided");
        if (a) {
          const I = m(d.input);
          if (!fe(I))
            throw new TypeError("Non push-only scriptSig");
        }
      }
    };
    if (e.input) {
      const d = u();
      if (!d || d.length < 1) throw new TypeError("Input too short");
      if (!c.isBuffer(n().output)) throw new TypeError("Input is invalid");
      h(n());
    }
    if (e.redeem) {
      if (e.redeem.network && e.redeem.network !== f)
        throw new TypeError("Network mismatch");
      if (e.input) {
        const d = n();
        if (e.redeem.output && !e.redeem.output.equals(d.output))
          throw new TypeError("Redeem.output mismatch");
        if (e.redeem.input && !e.redeem.input.equals(d.input))
          throw new TypeError("Redeem.input mismatch");
      }
      h(e.redeem);
    }
    if (e.witness && e.redeem && e.redeem.witness && !j(e.redeem.witness, e.witness))
      throw new TypeError("Witness and redeem.witness mismatch");
  }
  return Object.assign(i, e);
}
const R = {};
function We(e) {
  e ? e !== R.eccLib && (Te(e), R.eccLib = e) : R.eccLib = e;
}
function pe() {
  if (!R.eccLib)
    throw new Error(
      "No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance"
    );
  return R.eccLib;
}
const O = (e) => c.from(e, "hex");
function Te(e) {
  b(typeof e.isXOnlyPoint == "function"), b(e.isXOnlyPoint(O("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))), b(e.isXOnlyPoint(O("fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e"))), b(e.isXOnlyPoint(O("f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9"))), b(e.isXOnlyPoint(O("0000000000000000000000000000000000000000000000000000000000000001"))), b(
    !e.isXOnlyPoint(O("0000000000000000000000000000000000000000000000000000000000000000"))
  ), b(
    !e.isXOnlyPoint(O("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"))
  ), b(typeof e.xOnlyPointAddTweak == "function"), Pe.forEach((o) => {
    const f = e.xOnlyPointAddTweak(O(o.pubkey), O(o.tweak));
    o.result === null ? b(f === null) : (b(f !== null), b(f.parity === o.parity), b(c.from(f.xOnlyPubkey).equals(O(o.result))));
  });
}
function b(e) {
  if (!e) throw new Error("ecc library invalid");
}
const Pe = [
  {
    pubkey: "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
    tweak: "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140",
    parity: -1,
    result: null
  },
  {
    pubkey: "1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b",
    tweak: "a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac",
    parity: 1,
    result: "e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf"
  },
  {
    pubkey: "2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991",
    tweak: "823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47",
    parity: 0,
    result: "9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c"
  }
], G = 192, Oe = 128, ve = (e) => "left" in e && "right" in e;
function F(e, o) {
  if (e.length < 33)
    throw new TypeError(
      `The control-block length is too small. Got ${e.length}, expected min 33.`
    );
  const f = (e.length - 33) / 32;
  let i = o;
  for (let s = 0; s < f; s++) {
    const u = e.subarray(33 + 32 * s, 65 + 32 * s);
    i.compare(u) < 0 ? i = M(i, u) : i = M(u, i);
  }
  return i;
}
function W(e) {
  if (we(e)) return { hash: B(e) };
  const o = [W(e[0]), W(e[1])];
  o.sort((s, u) => s.hash.compare(u.hash));
  const [f, i] = o;
  return {
    hash: M(f.hash, i.hash),
    left: f,
    right: i
  };
}
function x(e, o) {
  if (ve(e)) {
    const f = x(e.left, o);
    if (f !== void 0) return [...f, e.right.hash];
    const i = x(e.right, o);
    if (i !== void 0) return [...i, e.left.hash];
  } else if (e.hash.equals(o))
    return [];
}
function B(e) {
  const o = e.version || G;
  return X(
    "TapLeaf",
    k.concat([k.from([o]), Se(e.output)])
  );
}
function _e(e, o) {
  return X("TapTweak", k.concat(o ? [e, o] : [e]));
}
function V(e, o) {
  if (!k.isBuffer(e) || e.length !== 32 || o && o.length !== 32) return null;
  const f = _e(e, o), i = pe().xOnlyPointAddTweak(e, f);
  return !i || i.xOnlyPubkey === null ? null : {
    parity: i.parity,
    x: k.from(i.xOnlyPubkey)
  };
}
function M(e, o) {
  return X("TapBranch", k.concat([e, o]));
}
function Se(e) {
  const o = le(e.length), f = k.allocUnsafe(o);
  return ye(e.length, f), k.concat([f, e]);
}
const ee = _, re = 1, Ie = 80;
function He(e, o) {
  if (!e.address && !e.output && !e.pubkey && !e.internalPubkey && !(e.witness && e.witness.length > 1))
    throw new TypeError("Not enough data");
  o = Object.assign({ validate: !0 }, o || {}), r(
    {
      address: r.maybe(r.String),
      input: r.maybe(r.BufferN(0)),
      network: r.maybe(r.Object),
      output: r.maybe(r.BufferN(34)),
      internalPubkey: r.maybe(r.BufferN(32)),
      hash: r.maybe(r.BufferN(32)),
      // merkle root hash, the tweak
      pubkey: r.maybe(r.BufferN(32)),
      // tweaked with `hash` from `internalPubkey`
      signature: r.maybe(r.anyOf(r.BufferN(64), r.BufferN(65))),
      witness: r.maybe(r.arrayOf(r.Buffer)),
      scriptTree: r.maybe(be),
      redeem: r.maybe({
        output: r.maybe(r.Buffer),
        // tapleaf script
        redeemVersion: r.maybe(r.Number),
        // tapleaf version
        witness: r.maybe(r.arrayOf(r.Buffer))
      }),
      redeemVersion: r.maybe(r.Number)
    },
    e
  );
  const f = y(() => ie(e.address)), i = y(() => {
    if (!(!e.witness || !e.witness.length))
      return e.witness.length >= 2 && e.witness[e.witness.length - 1][0] === Ie ? e.witness.slice(0, -1) : e.witness.slice();
  }), s = y(() => {
    if (e.scriptTree) return W(e.scriptTree);
    if (e.hash) return { hash: e.hash };
  }), u = e.network || v, n = {
    name: E.P2TR,
    network: u
  };
  if (p(n, "address", () => {
    if (!n.pubkey) return;
    const t = g.bech32m.toWords(n.pubkey);
    return t.unshift(re), g.bech32m.encode(u.bech32, t);
  }), p(n, "hash", () => {
    const t = s();
    if (t) return t.hash;
    const h = i();
    if (h && h.length > 1) {
      const d = h[h.length - 1], a = d[0] & $, w = h[h.length - 2], I = B({
        output: w,
        version: a
      });
      return F(d, I);
    }
  }), p(n, "output", () => {
    if (n.pubkey)
      return l([ee.OP_1, n.pubkey]);
  }), p(n, "redeemVersion", () => e.redeemVersion ? e.redeemVersion : e.redeem && e.redeem.redeemVersion !== void 0 && e.redeem.redeemVersion !== null ? e.redeem.redeemVersion : G), p(n, "redeem", () => {
    const t = i();
    if (!(!t || t.length < 2))
      return {
        output: t[t.length - 2],
        witness: t.slice(0, -2),
        redeemVersion: t[t.length - 1][0] & $
      };
  }), p(n, "pubkey", () => {
    if (e.pubkey) return e.pubkey;
    if (e.output) return e.output.subarray(2);
    if (e.address) return f().data;
    if (n.internalPubkey) {
      const t = V(n.internalPubkey, n.hash);
      if (t) return t.x;
    }
  }), p(n, "internalPubkey", () => {
    if (e.internalPubkey) return e.internalPubkey;
    const t = i();
    if (t && t.length > 1) return t[t.length - 1].subarray(1, 33);
  }), p(n, "signature", () => {
    if (e.signature) return e.signature;
    const t = i();
    if (!(!t || t.length !== 1))
      return t[0];
  }), p(n, "witness", () => {
    if (e.witness) return e.witness;
    const t = s();
    if (t && e.redeem && e.redeem.output && e.internalPubkey) {
      const h = B({
        output: e.redeem.output,
        version: n.redeemVersion
      }), d = x(t, h);
      if (!d) return;
      const a = V(e.internalPubkey, t.hash);
      if (!a) return;
      const w = k.concat(
        [k.from([n.redeemVersion | a.parity]), e.internalPubkey].concat(
          d
        )
      );
      return [e.redeem.output, w];
    }
    if (e.signature) return [e.signature];
  }), o.validate) {
    let t = k.from([]);
    if (e.address) {
      if (u && u.bech32 !== f().prefix)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (f().version !== re)
        throw new TypeError("Invalid address version");
      if (f().data.length !== 32) throw new TypeError("Invalid address data");
      t = f().data;
    }
    if (e.pubkey) {
      if (t.length > 0 && !t.equals(e.pubkey))
        throw new TypeError("Pubkey mismatch");
      t = e.pubkey;
    }
    if (e.output) {
      if (e.output.length !== 34 || e.output[0] !== ee.OP_1 || e.output[1] !== 32)
        throw new TypeError("Output is invalid");
      if (t.length > 0 && !t.equals(e.output.subarray(2)))
        throw new TypeError("Pubkey mismatch");
      t = e.output.subarray(2);
    }
    if (e.internalPubkey) {
      const a = V(e.internalPubkey, n.hash);
      if (t.length > 0 && !t.equals(a.x))
        throw new TypeError("Pubkey mismatch");
      t = a.x;
    }
    const h = s();
    if (e.hash && h && !e.hash.equals(h.hash))
      throw new TypeError("Hash mismatch");
    if (e.redeem && e.redeem.output && h) {
      const a = B({
        output: e.redeem.output,
        version: n.redeemVersion
      });
      if (!x(h, a))
        throw new TypeError("Redeem script not in tree");
    }
    const d = i();
    if (e.redeem && n.redeem) {
      if (e.redeem.redeemVersion && e.redeem.redeemVersion !== n.redeem.redeemVersion)
        throw new TypeError("Redeem.redeemVersion and witness mismatch");
      if (e.redeem.output) {
        if (m(e.redeem.output).length === 0)
          throw new TypeError("Redeem.output is invalid");
        if (n.redeem.output && !e.redeem.output.equals(n.redeem.output))
          throw new TypeError("Redeem.output and witness mismatch");
      }
      if (e.redeem.witness && n.redeem.witness && !j(e.redeem.witness, n.redeem.witness))
        throw new TypeError("Redeem.witness and witness mismatch");
    }
    if (d && d.length)
      if (d.length === 1) {
        if (e.signature && !e.signature.equals(d[0]))
          throw new TypeError("Signature mismatch");
      } else {
        const a = d[d.length - 1];
        if (a.length < 33)
          throw new TypeError(
            `The control-block length is too small. Got ${a.length}, expected min 33.`
          );
        if ((a.length - 33) % 32 !== 0)
          throw new TypeError(
            `The control-block length of ${a.length} is incorrect!`
          );
        const w = (a.length - 33) / 32;
        if (w > 128)
          throw new TypeError(`The script path is too long. Got ${w}, expected max 128.`);
        const I = a.subarray(1, 33);
        if (e.internalPubkey && !e.internalPubkey.equals(I))
          throw new TypeError("Internal pubkey mismatch");
        if (!pe().isXOnlyPoint(I))
          throw new TypeError("Invalid internalPubkey for p2tr witness");
        const he = a[0] & $, de = d[d.length - 2], ae = B({
          output: de,
          version: he
        }), ce = F(a, ae), C = V(I, ce);
        if (!C)
          throw new TypeError("Invalid outputKey for p2tr witness");
        if (t.length && !t.equals(C.x))
          throw new TypeError("Pubkey mismatch for p2tr witness");
        if (C.parity !== (a[0] & 1)) throw new Error("Incorrect parity");
      }
  }
  return Object.assign(n, e);
}
const te = _, Ne = c.alloc(0);
function Be(e, o) {
  if (!e.address && !e.hash && !e.output && !e.pubkey && !e.witness)
    throw new TypeError("Not enough data");
  o = Object.assign({ validate: !0 }, o || {}), r(
    {
      address: r.maybe(r.String),
      hash: r.maybe(r.BufferN(20)),
      input: r.maybe(r.BufferN(0)),
      network: r.maybe(r.Object),
      output: r.maybe(r.BufferN(22)),
      pubkey: r.maybe(P),
      signature: r.maybe(H),
      witness: r.maybe(r.arrayOf(r.Buffer))
    },
    e
  );
  const f = y(() => {
    const u = g.bech32.decode(e.address), n = u.words.shift(), t = g.bech32.fromWords(u.words);
    return {
      version: n,
      prefix: u.prefix,
      data: c.from(t)
    };
  }), i = e.network || v, s = {
    name: E.P2WPKH,
    network: i
  };
  if (p(s, "address", () => {
    if (!s.hash) return;
    const u = g.bech32.toWords(s.hash);
    return u.unshift(0), g.bech32.encode(i.bech32, u);
  }), p(s, "hash", () => {
    if (e.output) return e.output.subarray(2, 22);
    if (e.address) return f().data;
    if (e.pubkey || s.pubkey) return T(e.pubkey || s.pubkey);
  }), p(s, "output", () => {
    if (s.hash)
      return l([te.OP_0, s.hash]);
  }), p(s, "pubkey", () => {
    if (e.pubkey) return e.pubkey;
    if (e.witness)
      return e.witness[1];
  }), p(s, "signature", () => {
    if (e.witness)
      return e.witness[0];
  }), p(s, "input", () => {
    if (s.witness)
      return Ne;
  }), p(s, "witness", () => {
    if (e.pubkey && e.signature)
      return [e.signature, e.pubkey];
  }), o.validate) {
    let u = c.from([]);
    if (e.address) {
      if (i && i.bech32 !== f().prefix)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (f().version !== 0) throw new TypeError("Invalid address version");
      if (f().data.length !== 20) throw new TypeError("Invalid address data");
      u = f().data;
    }
    if (e.hash) {
      if (u.length > 0 && !u.equals(e.hash)) throw new TypeError("Hash mismatch");
      u = e.hash;
    }
    if (e.output) {
      if (e.output.length !== 22 || e.output[0] !== te.OP_0 || e.output[1] !== 20)
        throw new TypeError("Output is invalid");
      if (u.length > 0 && !u.equals(e.output.subarray(2)))
        throw new TypeError("Hash mismatch");
      u = e.output.subarray(2);
    }
    if (e.pubkey) {
      const n = T(e.pubkey);
      if (u.length > 0 && !u.equals(n)) throw new TypeError("Hash mismatch");
      if (u = n, !P(e.pubkey) || e.pubkey.length !== 33)
        throw new TypeError("Invalid pubkey for p2wpkh");
    }
    if (e.witness) {
      if (e.witness.length !== 2) throw new TypeError("Witness is invalid");
      if (!H(e.witness[0]))
        throw new TypeError("Witness has invalid signature");
      if (!P(e.witness[1]) || e.witness[1].length !== 33)
        throw new TypeError("Witness has invalid pubkey");
      if (e.signature && !e.signature.equals(e.witness[0]))
        throw new TypeError("Signature mismatch");
      if (e.pubkey && !e.pubkey.equals(e.witness[1])) throw new TypeError("Pubkey mismatch");
      const n = T(e.witness[1]);
      if (u.length > 0 && !u.equals(n)) throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(s, e);
}
const ne = _, K = c.alloc(0);
function A(e) {
  return !!(c.isBuffer(e) && e.length === 65 && e[0] === 4 && P(e));
}
function je(e, o) {
  if (!e.address && !e.hash && !e.output && !e.redeem && !e.witness)
    throw new TypeError("Not enough data");
  o = Object.assign({ validate: !0 }, o || {}), r(
    {
      network: r.maybe(r.Object),
      address: r.maybe(r.String),
      hash: r.maybe(r.BufferN(32)),
      output: r.maybe(r.BufferN(34)),
      redeem: r.maybe({
        input: r.maybe(r.Buffer),
        network: r.maybe(r.Object),
        output: r.maybe(r.Buffer),
        witness: r.maybe(r.arrayOf(r.Buffer))
      }),
      input: r.maybe(r.BufferN(0)),
      witness: r.maybe(r.arrayOf(r.Buffer))
    },
    e
  );
  const f = y(() => {
    const n = g.bech32.decode(e.address), t = n.words.shift(), h = g.bech32.fromWords(n.words);
    return {
      version: t,
      prefix: n.prefix,
      data: c.from(h)
    };
  }), i = y(() => m(e.redeem.input));
  let s = e.network;
  s || (s = e.redeem && e.redeem.network || v);
  const u = {
    network: s,
    name: E.P2WSH
  };
  if (p(u, "address", () => {
    if (!u.hash) return;
    const n = g.bech32.toWords(u.hash);
    return n.unshift(0), g.bech32.encode(s.bech32, n);
  }), p(u, "hash", () => {
    if (e.output) return e.output.subarray(2);
    if (e.address) return f().data;
    if (u.redeem && u.redeem.output) return Y(u.redeem.output);
  }), p(u, "output", () => {
    if (u.hash)
      return l([ne.OP_0, u.hash]);
  }), p(u, "redeem", () => {
    if (e.witness)
      return {
        output: e.witness[e.witness.length - 1],
        input: K,
        witness: e.witness.slice(0, -1)
      };
  }), p(u, "input", () => {
    if (u.witness)
      return K;
  }), p(u, "witness", () => {
    if (e.redeem && e.redeem.input && e.redeem.input.length > 0 && e.redeem.output && e.redeem.output.length > 0) {
      const n = me(i());
      return u.redeem = Object.assign({ witness: n }, e.redeem), u.redeem.input = K, [].concat(n, e.redeem.output);
    }
    if (e.redeem && e.redeem.output && e.redeem.witness)
      return [].concat(e.redeem.witness, e.redeem.output);
  }), p(u, "name", () => {
    const n = ["p2wsh"];
    return u.redeem !== void 0 && u.redeem.name !== void 0 && n.push(u.redeem.name), n.join("-");
  }), o.validate) {
    let n = c.from([]);
    if (e.address) {
      if (f().prefix !== s.bech32)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (f().version !== 0) throw new TypeError("Invalid address version");
      if (f().data.length !== 32) throw new TypeError("Invalid address data");
      n = f().data;
    }
    if (e.hash) {
      if (n.length > 0 && !n.equals(e.hash)) throw new TypeError("Hash mismatch");
      n = e.hash;
    }
    if (e.output) {
      if (e.output.length !== 34 || e.output[0] !== ne.OP_0 || e.output[1] !== 32)
        throw new TypeError("Output is invalid");
      const t = e.output.subarray(2);
      if (n.length > 0 && !n.equals(t)) throw new TypeError("Hash mismatch");
      n = t;
    }
    if (e.redeem) {
      if (e.redeem.network && e.redeem.network !== s)
        throw new TypeError("Network mismatch");
      if (e.redeem.input && e.redeem.input.length > 0 && e.redeem.witness && e.redeem.witness.length > 0)
        throw new TypeError("Ambiguous witness source");
      if (e.redeem.output) {
        const t = m(e.redeem.output);
        if (!t || t.length < 1)
          throw new TypeError("Redeem.output is invalid");
        if (e.redeem.output.byteLength > 3600)
          throw new TypeError("Redeem.output unspendable if larger than 3600 bytes");
        if (oe(t) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const h = Y(e.redeem.output);
        if (n.length > 0 && !n.equals(h)) throw new TypeError("Hash mismatch");
        n = h;
      }
      if (e.redeem.input && !fe(i()))
        throw new TypeError("Non push-only scriptSig");
      if (e.witness && e.redeem.witness && !j(e.witness, e.redeem.witness))
        throw new TypeError("Witness and redeem.witness mismatch");
      if (e.redeem.input && i().some(A) || e.redeem.output && (m(e.redeem.output) || []).some(A))
        throw new TypeError("redeem.input or redeem.output contains uncompressed pubkey");
    }
    if (e.witness && e.witness.length > 0) {
      const t = e.witness[e.witness.length - 1];
      if (e.redeem && e.redeem.output && !e.redeem.output.equals(t))
        throw new TypeError("Witness and redeem.output mismatch");
      if (e.witness.some(A) || (m(t) || []).some(A))
        throw new TypeError("Witness contains uncompressed pubkey");
    }
  }
  return Object.assign(u, e);
}
const se = _;
function qe(e, o) {
  if (!e.data && !e.output) throw new TypeError("Not enough data");
  o = Object.assign({ validate: !0 }, o || {}), r(
    {
      network: r.maybe(r.Object),
      output: r.maybe(r.Buffer),
      data: r.maybe(r.arrayOf(r.Buffer))
    },
    e
  );
  const f = e.network || v, i = { name: E.Embed, network: f, data: [] };
  if (p(i, "output", () => {
    if (e.data)
      return l([se.OP_RETURN].concat(e.data));
  }), p(i, "data", () => {
    if (!e.output) return;
    const s = m(e.output);
    if (s != null)
      return s.slice(1);
  }), o.validate && e.output) {
    const s = m(e.output);
    if (s[0] !== se.OP_RETURN) throw new TypeError("Output is invalid");
    if (!s.slice(1).every(r.Buffer)) throw new TypeError("Output is invalid");
    if (e.data && !j(e.data, i.data)) throw new TypeError("Data mismatch");
  }
  return Object.assign(i, e);
}
const N = _, U = N.OP_RESERVED;
function Ve(e, o) {
  if (!e.input && !e.output && !(e.pubkeys && e.m !== void 0) && !e.signatures)
    throw new TypeError("Not enough data");
  o = Object.assign({ validate: !0 }, o || {});
  function f(h) {
    return H(h) || (o.allowIncomplete && h === N.OP_0) !== void 0;
  }
  r(
    {
      network: r.maybe(r.Object),
      m: r.maybe(r.Number),
      n: r.maybe(r.Number),
      output: r.maybe(r.Buffer),
      pubkeys: r.maybe(r.arrayOf(P)),
      signatures: r.maybe(r.arrayOf(f)),
      input: r.maybe(r.Buffer)
    },
    e
  );
  const s = {
    network: e.network || v,
    name: E.P2MS
  };
  let u = [], n = !1;
  function t(h) {
    n || (n = !0, u = m(h), s.m = u[0] - U, s.n = u[u.length - 2] - U, s.pubkeys = u.slice(1, -2));
  }
  if (p(s, "output", () => {
    if (e.m && s.n && e.pubkeys)
      return l(
        [].concat(
          U + e.m,
          e.pubkeys,
          U + s.n,
          N.OP_CHECKMULTISIG
        )
      );
  }), p(s, "m", () => {
    if (s.output)
      return t(s.output), s.m;
  }), p(s, "n", () => {
    if (s.pubkeys)
      return s.pubkeys.length;
  }), p(s, "pubkeys", () => {
    if (e.output)
      return t(e.output), s.pubkeys;
  }), p(s, "signatures", () => {
    if (!e.input) return;
    const h = m(e.input);
    if (h != null)
      return h.slice(1);
  }), p(s, "input", () => {
    if (e.signatures)
      return l([N.OP_0].concat(e.signatures));
  }), p(s, "witness", () => {
    if (s.input)
      return [];
  }), p(s, "name", () => {
    if (!(!s.m || !s.n))
      return `p2ms(${s.m} of ${s.n})`;
  }), o.validate) {
    if (e.output) {
      if (t(e.output), !r.Number(u[0])) throw new TypeError("Output is invalid");
      if (!r.Number(u[u.length - 2])) throw new TypeError("Output is invalid");
      if (u[u.length - 1] !== N.OP_CHECKMULTISIG)
        throw new TypeError("Output is invalid");
      if (s.m <= 0 || s.n > 16 || s.m > s.n || s.n !== u.length - 3)
        throw new TypeError("Output is invalid");
      if (!s.pubkeys.every((h) => P(h))) throw new TypeError("Output is invalid");
      if (e.m !== void 0 && e.m !== s.m) throw new TypeError("m mismatch");
      if (e.n !== void 0 && e.n !== s.n) throw new TypeError("n mismatch");
      if (e.pubkeys && !j(e.pubkeys, s.pubkeys))
        throw new TypeError("Pubkeys mismatch");
    }
    if (e.pubkeys) {
      if (e.n !== void 0 && e.n !== e.pubkeys.length)
        throw new TypeError("Pubkey count mismatch");
      if (s.n = e.pubkeys.length, s.n < s.m) throw new TypeError("Pubkey count cannot be less than m");
    }
    if (e.signatures) {
      if (e.signatures.length < s.m) throw new TypeError("Not enough signatures provided");
      if (e.signatures.length > s.m) throw new TypeError("Too many signatures provided");
    }
    if (e.input) {
      if (e.input[0] !== N.OP_0) throw new TypeError("Input is invalid");
      if (s.signatures.length === 0 || !s.signatures.every(f))
        throw new TypeError("Input has invalid signature(s)");
      if (e.signatures && !j(e.signatures, s.signatures))
        throw new TypeError("Signature mismatch");
      if (e.m !== void 0 && e.m !== e.signatures.length)
        throw new TypeError("Signature count mismatch");
    }
  }
  return Object.assign(s, e);
}
const ue = _;
function Re(e, o) {
  if (!e.input && !e.output && !e.pubkey && !e.input && !e.signature)
    throw new TypeError("Not enough data");
  o = Object.assign({ validate: !0 }, o || {}), r(
    {
      network: r.maybe(r.Object),
      output: r.maybe(r.Buffer),
      pubkey: r.maybe(P),
      signature: r.maybe(H),
      input: r.maybe(r.Buffer)
    },
    e
  );
  const f = y(() => m(e.input)), i = e.network || v, s = {
    name: E.P2PK,
    network: i,
    pubkey: void 0
  };
  if (p(s, "output", () => {
    if (e.pubkey)
      return l([e.pubkey, ue.OP_CHECKSIG]);
  }), p(s, "pubkey", () => {
    if (e.output)
      return e.output.subarray(1, -1);
  }), p(s, "signature", () => {
    if (e.input)
      return f()[0];
  }), p(s, "input", () => {
    if (e.signature)
      return l([e.signature]);
  }), p(s, "witness", () => {
    if (s.input)
      return [];
  }), o.validate) {
    if (e.output) {
      if (e.output[e.output.length - 1] !== ue.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      if (!P(s.pubkey)) throw new TypeError("Output pubkey is invalid");
      if (e.pubkey && !e.pubkey.equals(s.pubkey)) throw new TypeError("Pubkey mismatch");
    }
    if (e.signature && e.input && !e.input.equals(s.input))
      throw new TypeError("Signature mismatch");
    if (e.input) {
      if (f().length !== 1) throw new TypeError("Input is invalid");
      if (!H(s.signature))
        throw new TypeError("Input has invalid signature");
    }
  }
  return Object.assign(s, e);
}
const Ce = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  LEAF_VERSION_TAPSCRIPT: G,
  MAX_TAPTREE_DEPTH: Oe,
  PaymentType: E,
  findScriptPath: x,
  p2data: qe,
  p2ms: Ve,
  p2op: ge,
  p2pk: Re,
  p2pkh: ke,
  p2sh: Ee,
  p2tr: He,
  p2wpkh: Be,
  p2wsh: je,
  prop: p,
  rootHashFromPath: F,
  tapleafHash: B,
  toHashTree: W,
  tweakKey: V,
  value: y
}, Symbol.toStringTag, { value: "Module" }));
export {
  G as L,
  Oe as M,
  E as P,
  Ee as a,
  Be as b,
  je as c,
  He as d,
  ge as e,
  Re as f,
  Ve as g,
  B as h,
  Ce as i,
  We as j,
  W as k,
  x as l,
  _e as m,
  ke as p,
  F as r,
  V as t
};
