var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ConfigurableDBManager_instances, _ConfigurableDBManager_getMongoCredentials;
import { MongoClient, ReadPreference, } from 'mongodb';
import { DataAccessError } from '../errors/DataAccessError.js';
import { DataAccessErrorType } from '../errors/enums/DataAccessErrorType.js';
import { Globals } from '../utils/Globals.js';
import { MongoCredentials } from './credentials/MongoCredentials.js';
import { InnerDBManager } from './interfaces/IDBManager.js';
Globals.register();
BigInt.prototype.toJSON = function () {
    return this.toString();
};
export class ConfigurableDBManager extends InnerDBManager {
    constructor(config, mongoOpts = {
        readPreference: ReadPreference.PRIMARY_PREFERRED,
        directConnection: true,
        connectTimeoutMS: 30000,
        socketTimeoutMS: 30000,
        appName: `OPNet`,
    }) {
        super(config);
        _ConfigurableDBManager_instances.add(this);
        this.mongoOpts = mongoOpts;
        this.isConnected = false;
        this.db = null;
        this.isConnecting = false;
        this.databaseName = '';
        this.connectionUri = '';
        this.isSetup = false;
        this.connectionPromise = null;
    }
    createNewMongoClient() {
        const mongoCredentials = __classPrivateFieldGet(this, _ConfigurableDBManager_instances, "m", _ConfigurableDBManager_getMongoCredentials).call(this);
        return [
            new MongoClient(mongoCredentials.connectionUri, this.mongoOpts),
            mongoCredentials.databaseName,
        ];
    }
    setup() {
        if (this.isSetup)
            return true;
        this.isSetup = true;
        const mongoProductionCredentials = __classPrivateFieldGet(this, _ConfigurableDBManager_instances, "m", _ConfigurableDBManager_getMongoCredentials).call(this);
        this.connectionUri = mongoProductionCredentials.connectionUri;
        this.databaseName = mongoProductionCredentials.databaseName;
        if (!this.mongo) {
            this.mongo = new MongoClient(this.connectionUri, this.mongoOpts);
        }
        return false;
    }
    async close() {
        await this.client?.close();
        this.db = null;
        delete this.client;
        this.connectionPromise = null;
        this.isConnected = false;
    }
    async connect(log = false) {
        if (this.connectionPromise) {
            return this.connectionPromise;
        }
        if (this.isConnecting)
            return;
        if (!this.mongo)
            return;
        this.isConnecting = true;
        this.connectionPromise = new Promise(async (resolve) => {
            this.info('Initializing MongoDB Remote Connection.');
            if (!this.mongo)
                return this.log('Mongo client is not initialized.');
            this.isConnected = false;
            const client = await this.mongo.connect().catch((err) => {
                this.error(`Something went wrong while connecting to the database -> ${err}`);
                setTimeout(async () => {
                    this.warn(`Attempting mongo auto reconnection.`);
                    await this.connect();
                    resolve();
                }, 2000);
            });
            if (!client) {
                return;
            }
            if (log)
                this.success('Connected to the database.');
            this.client = client;
            this.isConnected = true;
            this.db = this.client.db(this.databaseName);
            resolve();
        });
        return this.connectionPromise;
    }
    startSession() {
        if (!this.client) {
            throw new DataAccessError('Client not connected.', DataAccessErrorType.Unknown, '');
        }
        const sessionConfig = {
            defaultTransactionOptions: {
                maxCommitTimeMS: 29 * 60000,
                maxTimeMS: 29 * 60000,
            },
        };
        return this.client.startSession(sessionConfig);
    }
}
_ConfigurableDBManager_instances = new WeakSet(), _ConfigurableDBManager_getMongoCredentials = function _ConfigurableDBManager_getMongoCredentials() {
    return new MongoCredentials({
        databaseName: this.config.DATABASE.DATABASE_NAME,
        username: this.config.DATABASE.AUTH.USERNAME,
        password: this.config.DATABASE.AUTH.PASSWORD,
        host: this.config.DATABASE.HOST,
        port: this.config.DATABASE.PORT.toString(),
    });
};
