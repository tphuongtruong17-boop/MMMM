import { ObjectId, } from 'mongodb';
import { DataAccessError } from '../../errors/DataAccessError.js';
import { DataAccessErrorType } from '../../errors/enums/DataAccessErrorType.js';
import { DBConstants } from '../DBConstants.js';
import { BaseRepository } from './BaseRepository.js';
export class BaseRepositoryWithId extends BaseRepository {
    constructor(db) {
        super(db);
    }
    async deleteById(id, currentSession) {
        try {
            const collection = this.getCollection();
            const options = this.getOptions(currentSession);
            const filter = {
                _id: id,
            };
            const result = await collection.deleteOne(filter, options);
            return result.deletedCount === 1;
        }
        catch (error) {
            if (error instanceof Error) {
                throw new DataAccessError(error.message, DataAccessErrorType.Unknown, `id: ${id.toString()}`);
            }
            else {
                throw error;
            }
        }
    }
    async deleteDocumentById(document, session) {
        return await this.deleteById(document._id, session);
    }
    async getById(id, currentSession) {
        try {
            const collection = this.getCollection();
            const options = this.getOptions(currentSession);
            const filter = {
                _id: id,
            };
            return (await collection.findOne(filter, options));
        }
        catch (error) {
            if (error instanceof Error) {
                throw new DataAccessError(error.message, DataAccessErrorType.Unknown, `id: ${id.toString()}`);
            }
            else {
                throw error;
            }
        }
    }
    async saveById(document, currentSession) {
        try {
            const collection = this.getCollection();
            const currentVersion = document.version;
            document.version = document.version + 1;
            const filter = {
                _id: document._id,
                version: currentVersion,
            };
            const { _id, ...updateData } = document;
            if (_id.toString() !== DBConstants.NULL_OBJECT_ID) {
                const options = this.getOptions(currentSession);
                const result = await collection.updateOne(filter, { $set: updateData }, options);
                if (result.modifiedCount === 0) {
                    throw new DataAccessError('Concurency error while updating.', DataAccessErrorType.Concurency, `id ${document._id}, version: ${currentVersion}`);
                }
            }
            else {
                const options = this.getOptions(currentSession);
                document._id = new ObjectId();
                await collection.insertOne(document, options);
            }
        }
        catch (error) {
            if (error instanceof DataAccessError) {
                throw error;
            }
            else if (error instanceof Error) {
                throw new DataAccessError(error.message);
            }
            else {
                throw error;
            }
        }
    }
    async updatePartialById(id, version, document, currentSession) {
        try {
            const collection = this.getCollection();
            document.version = version + 1;
            const filter = {
                _id: id,
                version: version,
            };
            const options = this.getOptions(currentSession);
            const updateResult = await collection.updateOne(filter, { $set: document }, options);
            if (updateResult.modifiedCount !== 1) {
                throw new DataAccessError('Concurency error while updating.', DataAccessErrorType.Concurency, `id ${id}, version: ${version}`);
            }
        }
        catch (error) {
            if (error instanceof Error) {
                throw new DataAccessError(error.message, DataAccessErrorType.Unknown, `id: ${id.toString()}`);
            }
            else {
                throw error;
            }
        }
    }
}
