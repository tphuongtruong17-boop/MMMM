import { Logger } from '@btc-vision/logger';
import { DataAccessError } from '../../errors/DataAccessError.js';
import { DataAccessErrorType } from '../../errors/enums/DataAccessErrorType.js';
import { PagingQueryResult } from './PagingQuery.js';
export class BaseRepository extends Logger {
    constructor(db) {
        super();
        this._db = db;
    }
    async delete(criteria, currentSession) {
        try {
            const collection = this.getCollection();
            const options = this.getOptions(currentSession);
            const result = await collection.deleteMany(criteria, options);
            return result.deletedCount;
        }
        catch (error) {
            if (error instanceof Error) {
                const errorDescription = error.stack || error.message;
                throw new DataAccessError(errorDescription, DataAccessErrorType.Unknown, '');
            }
            else {
                throw error;
            }
        }
    }
    async getAll(criteria, currentSession, sort) {
        try {
            const collection = this.getCollection();
            const options = this.getOptions(currentSession);
            options.sort = sort;
            if (criteria) {
                return (await collection.find(criteria, options).toArray());
            }
            else {
                return (await collection.find({}, options).toArray());
            }
        }
        catch (error) {
            if (error instanceof Error) {
                const errorDescription = error.stack || error.message;
                throw new DataAccessError(errorDescription, DataAccessErrorType.Unknown, '');
            }
            else {
                throw error;
            }
        }
    }
    async getCount(criteria, currentSession) {
        try {
            const collection = this.getCollection();
            const options = this.getOptions(currentSession);
            if (criteria) {
                return await collection.countDocuments(criteria, options);
            }
            else {
                return await collection.countDocuments({}, options);
            }
        }
        catch (error) {
            if (error instanceof Error) {
                const errorDescription = error.stack || error.message;
                throw new DataAccessError(errorDescription, DataAccessErrorType.Unknown, '');
            }
            else {
                throw error;
            }
        }
    }
    async queryOne(criteria, currentSession, sort) {
        try {
            const collection = this.getCollection();
            const options = this.getOptions(currentSession);
            options.sort = sort;
            return (await collection.findOne(criteria, options));
        }
        catch (error) {
            if (error instanceof Error) {
                const errorDescription = error.stack || error.message;
                throw new DataAccessError(errorDescription, DataAccessErrorType.Unknown, '');
            }
            else {
                throw error;
            }
        }
    }
    async queryMany(criteria, currentSession, sort) {
        try {
            const collection = this.getCollection();
            const options = this.getOptions(currentSession);
            options.sort = sort;
            return (await collection.find(criteria, options).toArray());
        }
        catch (error) {
            if (error instanceof Error) {
                const errorDescription = error.stack || error.message;
                throw new DataAccessError(errorDescription, DataAccessErrorType.Unknown, '');
            }
            else {
                throw error;
            }
        }
    }
    async queryManyAndSortPaged(criteria, sort, pagingQueryInfo, currentSession) {
        try {
            const collection = this.getCollection();
            const skips = pagingQueryInfo.pageSize * (pagingQueryInfo.pageNumber - 1);
            const count = await this.getCount(criteria);
            const options = this.getOptions(currentSession);
            const documents = await collection
                .find(criteria, options)
                .sort(sort)
                .skip(skips)
                .limit(pagingQueryInfo.pageSize)
                .toArray();
            return new PagingQueryResult(pagingQueryInfo.pageSize, pagingQueryInfo.pageNumber, count, pagingQueryInfo.pageNumber * pagingQueryInfo.pageSize < count, documents);
        }
        catch (error) {
            if (error instanceof Error) {
                const errorDescription = error.stack || error.message;
                throw new DataAccessError(errorDescription, DataAccessErrorType.Unknown, '');
            }
            else {
                throw error;
            }
        }
    }
    async queryManyAndSort(criteria, sort, currentSession) {
        try {
            const collection = this.getCollection();
            const options = this.getOptions(currentSession);
            return (await collection.find(criteria, options).sort(sort).toArray());
        }
        catch (error) {
            if (error instanceof Error) {
                const errorDescription = error.stack || error.message;
                throw new DataAccessError(errorDescription, DataAccessErrorType.Unknown, '');
            }
            else {
                throw error;
            }
        }
    }
    async save(criteria, document, currentSession) {
        try {
            const collection = this.getCollection();
            const options = {
                ...this.getOptions(currentSession),
                upsert: true,
            };
            const result = await collection.updateOne(criteria, { $set: document }, options);
            if (!result.acknowledged) {
                throw new DataAccessError('Concurrency error while updating.', DataAccessErrorType.Concurency, '');
            }
        }
        catch (error) {
            if (error instanceof DataAccessError) {
                throw error;
            }
            else if (error instanceof Error) {
                const errorDescription = error.stack || error.message;
                throw new DataAccessError(errorDescription, DataAccessErrorType.Unknown, '');
            }
            else {
                throw error;
            }
        }
    }
    async updatePartial(criteria, document, currentSession) {
        try {
            const collection = this.getCollection();
            const options = {
                ...this.getOptions(currentSession),
                upsert: true,
            };
            const updateResult = await collection.updateOne(criteria, { $set: document }, options);
            if (!updateResult.acknowledged) {
                throw new DataAccessError('Concurrency error while updating.', DataAccessErrorType.Concurency, '');
            }
        }
        catch (error) {
            if (error instanceof Error) {
                const errorDescription = error.stack || error.message;
                throw new DataAccessError(errorDescription, DataAccessErrorType.Unknown, '');
            }
            else {
                throw error;
            }
        }
    }
    async bulkWrite(operations, currentSession) {
        try {
            const collection = this.getCollection();
            const options = this.getOptions(currentSession);
            options.ordered = false;
            const result = await collection.bulkWrite(operations, options);
            if (result.hasWriteErrors()) {
                result.getWriteErrors().forEach((error) => {
                    this.error(`Bulk write error: ${error}`);
                });
                throw new DataAccessError('Failed to bulk write.', DataAccessErrorType.Unknown, '');
            }
            if (!result.isOk()) {
                throw new DataAccessError('Failed to bulk write.', DataAccessErrorType.Unknown, '');
            }
        }
        catch (error) {
            if (error instanceof Error) {
                const errorDescription = error.stack || error.message;
                throw new DataAccessError(errorDescription, DataAccessErrorType.Unknown, '');
            }
            else {
                throw error;
            }
        }
    }
    async updatePartialWithFilter(criteria, document, currentSession) {
        try {
            const collection = this.getCollection();
            const options = {
                ...this.getOptions(currentSession),
                upsert: true,
            };
            const updateResult = await collection.updateOne(criteria, document, options);
            if (!updateResult.acknowledged) {
                throw new DataAccessError('Concurrency error while updating.', DataAccessErrorType.Concurency, '');
            }
        }
        catch (error) {
            if (error instanceof Error) {
                const errorDescription = error.stack || error.message;
                throw new DataAccessError(errorDescription, DataAccessErrorType.Unknown, '');
            }
            else {
                throw error;
            }
        }
    }
    getOptions(currentSession) {
        const options = {};
        if (currentSession) {
            options.session = currentSession;
            options.readPreference = 'primary';
        }
        return options;
    }
}
