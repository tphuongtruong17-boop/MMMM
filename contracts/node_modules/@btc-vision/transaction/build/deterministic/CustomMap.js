var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _CustomMap_keys, _CustomMap_values;
export class CustomMap {
    constructor() {
        _CustomMap_keys.set(this, void 0);
        _CustomMap_values.set(this, void 0);
        this._size = 0;
        this.capacity = CustomMap.INITIAL_CAPACITY;
        __classPrivateFieldSet(this, _CustomMap_keys, new Array(this.capacity), "f");
        __classPrivateFieldSet(this, _CustomMap_values, new Array(this.capacity), "f");
        this.deleted = new Array(this.capacity).fill(false);
    }
    get size() {
        return this._size;
    }
    set(key, value) {
        let exist = true;
        const index = this.findInsertIndex(key);
        if (__classPrivateFieldGet(this, _CustomMap_keys, "f")[index] === undefined || this.deleted[index]) {
            this._size++;
            exist = false;
        }
        __classPrivateFieldGet(this, _CustomMap_keys, "f")[index] = key;
        __classPrivateFieldGet(this, _CustomMap_values, "f")[index] = value;
        this.deleted[index] = false;
        if (this._size > this.capacity * CustomMap.LOAD_FACTOR) {
            this.resize();
        }
        return exist;
    }
    get(key) {
        const index = this.findIndex(key);
        return index === -1 ? undefined : __classPrivateFieldGet(this, _CustomMap_values, "f")[index];
    }
    has(key) {
        return this.findIndex(key) !== -1;
    }
    indexOf(key) {
        return this.findIndex(key);
    }
    delete(key) {
        const index = this.findIndex(key);
        if (index === -1) {
            return false;
        }
        __classPrivateFieldGet(this, _CustomMap_keys, "f")[index] = undefined;
        __classPrivateFieldGet(this, _CustomMap_values, "f")[index] = undefined;
        this.deleted[index] = true;
        this._size--;
        return true;
    }
    clear() {
        __classPrivateFieldSet(this, _CustomMap_keys, new Array(this.capacity), "f");
        __classPrivateFieldSet(this, _CustomMap_values, new Array(this.capacity), "f");
        this.deleted = new Array(this.capacity).fill(false);
        this._size = 0;
    }
    *entries() {
        for (let i = 0; i < this.capacity; i++) {
            if (__classPrivateFieldGet(this, _CustomMap_keys, "f")[i] !== undefined && !this.deleted[i]) {
                yield [__classPrivateFieldGet(this, _CustomMap_keys, "f")[i], __classPrivateFieldGet(this, _CustomMap_values, "f")[i]];
            }
        }
    }
    *keys() {
        for (let i = 0; i < this.capacity; i++) {
            if (__classPrivateFieldGet(this, _CustomMap_keys, "f")[i] !== undefined && !this.deleted[i]) {
                yield __classPrivateFieldGet(this, _CustomMap_keys, "f")[i];
            }
        }
    }
    *values() {
        for (let i = 0; i < this.capacity; i++) {
            if (__classPrivateFieldGet(this, _CustomMap_keys, "f")[i] !== undefined && !this.deleted[i]) {
                yield __classPrivateFieldGet(this, _CustomMap_values, "f")[i];
            }
        }
    }
    *[(_CustomMap_keys = new WeakMap(), _CustomMap_values = new WeakMap(), Symbol.iterator)]() {
        yield* this.entries();
    }
    hashBigInt(key) {
        if (key >= -2147483648n && key <= 2147483647n) {
            return Number(key) | 0;
        }
        let hash = 2166136261;
        let n = key < 0n ? -key : key;
        while (n > 0n) {
            const chunk = Number(n & 0xffffffffn);
            hash ^= chunk;
            hash = Math.imul(hash, 16777619);
            n = n >> 32n;
        }
        if (key < 0n) {
            hash ^= 0x80000000;
            hash = Math.imul(hash, 16777619);
        }
        return Math.abs(hash);
    }
    hash(key) {
        let hash = 0;
        switch (typeof key) {
            case 'number':
                if (key !== key)
                    return 0x7ff8000000000000;
                if (!isFinite(key))
                    return key > 0 ? 0x7ff0000000000000 : 0xfff0000000000000;
                hash = key | 0;
                break;
            case 'string':
                hash = 2166136261;
                for (let i = 0; i < key.length; i++) {
                    hash ^= key.charCodeAt(i);
                    hash = Math.imul(hash, 16777619);
                }
                break;
            case 'boolean':
                hash = key ? 1231 : 1237;
                break;
            case 'symbol': {
                const desc = key.description || '';
                hash = this.hash(desc);
                break;
            }
            case 'bigint':
                hash = this.hashBigInt(key);
                break;
            case 'undefined':
                hash = 0;
                break;
            case 'object':
                if (key === null) {
                    hash = 0;
                }
                else if (key instanceof Date) {
                    hash = key.getTime() | 0;
                }
                else if (ArrayBuffer.isView(key) || key instanceof ArrayBuffer) {
                    hash = this.hashBuffer(key);
                }
                else if (Array.isArray(key)) {
                    hash = 1;
                    for (const item of key) {
                        hash = Math.imul(hash, 31) + this.hash(item);
                    }
                }
                else {
                    throw new Error('Raw object not supported.');
                }
                break;
            case 'function':
                hash = this.hash(key.toString());
                break;
        }
        return Math.abs(hash) % this.capacity;
    }
    hashBuffer(buffer) {
        let bytes;
        if (buffer instanceof ArrayBuffer) {
            bytes = new Uint8Array(buffer);
        }
        else if (ArrayBuffer.isView(buffer)) {
            bytes = new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
        }
        else {
            return 0;
        }
        let hash = 2166136261;
        for (let i = 0; i < Math.min(bytes.length, 100); i++) {
            hash ^= bytes[i];
            hash = Math.imul(hash, 16777619);
        }
        return hash;
    }
    equals(a, b) {
        if (a === b)
            return true;
        if (typeof a === 'number' && typeof b === 'number' && a !== a && b !== b) {
            return true;
        }
        if ((ArrayBuffer.isView(a) || a instanceof ArrayBuffer) &&
            (ArrayBuffer.isView(b) || b instanceof ArrayBuffer)) {
            return this.buffersEqual(a, b);
        }
        return false;
    }
    buffersEqual(a, b) {
        const bytesA = this.getBytes(a);
        const bytesB = this.getBytes(b);
        if (bytesA.length !== bytesB.length)
            return false;
        for (let i = 0; i < bytesA.length; i++) {
            if (bytesA[i] !== bytesB[i])
                return false;
        }
        return true;
    }
    getBytes(buffer) {
        if (buffer instanceof ArrayBuffer) {
            return new Uint8Array(buffer);
        }
        else if (ArrayBuffer.isView(buffer)) {
            return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
        }
        return new Uint8Array(0);
    }
    findIndex(key) {
        let index = this.hash(key);
        while (__classPrivateFieldGet(this, _CustomMap_keys, "f")[index] !== undefined || this.deleted[index]) {
            if (__classPrivateFieldGet(this, _CustomMap_keys, "f")[index] !== undefined && this.equals(__classPrivateFieldGet(this, _CustomMap_keys, "f")[index], key)) {
                return index;
            }
            index = (index + 1) % this.capacity;
        }
        return -1;
    }
    findInsertIndex(key) {
        let index = this.hash(key);
        while (__classPrivateFieldGet(this, _CustomMap_keys, "f")[index] !== undefined && !this.deleted[index]) {
            if (this.equals(__classPrivateFieldGet(this, _CustomMap_keys, "f")[index], key)) {
                return index;
            }
            index = (index + 1) % this.capacity;
        }
        return index;
    }
    resize() {
        const oldKeys = __classPrivateFieldGet(this, _CustomMap_keys, "f");
        const oldValues = __classPrivateFieldGet(this, _CustomMap_values, "f");
        this.capacity *= 2;
        __classPrivateFieldSet(this, _CustomMap_keys, new Array(this.capacity), "f");
        __classPrivateFieldSet(this, _CustomMap_values, new Array(this.capacity), "f");
        this.deleted = new Array(this.capacity).fill(false);
        this._size = 0;
        for (let i = 0; i < oldKeys.length; i++) {
            if (oldKeys[i] !== undefined && !this.deleted[i]) {
                this.set(oldKeys[i], oldValues[i]);
            }
        }
    }
}
CustomMap.INITIAL_CAPACITY = 16;
CustomMap.LOAD_FACTOR = 0.75;
