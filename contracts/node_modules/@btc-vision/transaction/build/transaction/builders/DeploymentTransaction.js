import { TransactionType } from '../enums/TransactionType.js';
import { crypto as bitCrypto, PaymentType, toXOnly, } from '@btc-vision/bitcoin';
import { TransactionBuilder } from './TransactionBuilder.js';
import { DeploymentGenerator, versionBuffer, } from '../../generators/builders/DeploymentGenerator.js';
import { EcKeyPair } from '../../keypair/EcKeyPair.js';
import { BitcoinUtils } from '../../utils/BitcoinUtils.js';
import { Compressor } from '../../bytecode/Compressor.js';
import { SharedInteractionTransaction } from './SharedInteractionTransaction.js';
import { Address } from '../../keypair/Address.js';
import { TimeLockGenerator } from '../mineable/TimelockGenerator.js';
import { FeaturePriority, Features } from '../../generators/Features.js';
export class DeploymentTransaction extends TransactionBuilder {
    constructor(parameters) {
        super(parameters);
        this.type = TransactionType.DEPLOYMENT;
        this.tapLeafScript = null;
        this.deploymentVersion = 0x00;
        this.targetScriptRedeem = null;
        this.leftOverFundsScriptRedeem = null;
        this.customFinalizer = (_inputIndex, input) => {
            if (!this.tapLeafScript) {
                throw new Error('Tap leaf script is required');
            }
            if (!input.tapScriptSig) {
                throw new Error('Tap script signature is required');
            }
            const scriptSolution = [
                this.randomBytes,
                input.tapScriptSig[0].signature,
                input.tapScriptSig[1].signature,
            ];
            const witness = scriptSolution
                .concat(this.tapLeafScript.script)
                .concat(this.tapLeafScript.controlBlock);
            return {
                finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness(witness),
            };
        };
        if (!this.hashedPublicKey) {
            throw new Error('MLDSA signer must be defined to deploy a contract.');
        }
        this.bytecode = Compressor.compress(Buffer.concat([versionBuffer, parameters.bytecode]));
        this.verifyBytecode();
        if (parameters.calldata) {
            this.calldata = parameters.calldata;
            this.verifyCalldata();
        }
        if (!parameters.challenge)
            throw new Error('Challenge solution is required');
        this.randomBytes = parameters.randomBytes || BitcoinUtils.rndBytes();
        this.challenge = parameters.challenge;
        this.LOCK_LEAF_SCRIPT = this.defineLockScript();
        this.epochChallenge = TimeLockGenerator.generateTimeLockAddress(this.challenge.publicKey.originalPublicKeyBuffer(), this.network);
        this.contractSeed = this.getContractSeed();
        this.contractSigner = EcKeyPair.fromSeedKeyPair(this.contractSeed, this.network);
        this.deploymentGenerator = new DeploymentGenerator(Buffer.from(this.signer.publicKey), this.contractSignerXOnlyPubKey(), this.network);
        if (parameters.compiledTargetScript) {
            if (Buffer.isBuffer(parameters.compiledTargetScript)) {
                this.compiledTargetScript = parameters.compiledTargetScript;
            }
            else if (typeof parameters.compiledTargetScript === 'string') {
                this.compiledTargetScript = Buffer.from(parameters.compiledTargetScript, 'hex');
            }
            else {
                throw new Error('Invalid compiled target script format.');
            }
        }
        else {
            this.compiledTargetScript = this.deploymentGenerator.compile(this.bytecode, this.randomBytes, this.challenge, this.priorityFee, this.calldata, this.generateFeatures(parameters));
        }
        this.scriptTree = this.getScriptTree();
        this.internalInit();
        this._contractPubKey = '0x' + this.contractSeed.toString('hex');
        this._contractAddress = new Address(this.contractSeed);
    }
    get contractPubKey() {
        return this._contractPubKey;
    }
    get contractAddress() {
        return this._contractAddress;
    }
    get p2trAddress() {
        return this.to || this.getScriptAddress();
    }
    exportCompiledTargetScript() {
        return this.compiledTargetScript;
    }
    getRndBytes() {
        return this.randomBytes;
    }
    getChallenge() {
        return this.challenge;
    }
    getContractAddress() {
        if (this._computedAddress) {
            return this._computedAddress;
        }
        this._computedAddress = EcKeyPair.p2op(this.contractSeed, this.network, this.deploymentVersion);
        return this._computedAddress;
    }
    contractSignerXOnlyPubKey() {
        return toXOnly(Buffer.from(this.contractSigner.publicKey));
    }
    async buildTransaction() {
        if (!this.to) {
            this.to = this.getScriptAddress();
        }
        const selectedRedeem = this.contractSigner
            ? this.targetScriptRedeem
            : this.leftOverFundsScriptRedeem;
        if (!selectedRedeem) {
            throw new Error('Left over funds script redeem is required');
        }
        if (!selectedRedeem.redeemVersion) {
            throw new Error('Left over funds script redeem version is required');
        }
        if (!selectedRedeem.output) {
            throw new Error('Left over funds script redeem output is required');
        }
        this.tapLeafScript = {
            leafVersion: selectedRedeem.redeemVersion,
            script: selectedRedeem.output,
            controlBlock: this.getWitness(),
        };
        this.addInputsFromUTXO();
        const amountSpent = this.getTransactionOPNetFee();
        this.addFeeToOutput(amountSpent, this.getContractAddress(), this.epochChallenge, true);
        await this.addRefundOutput(amountSpent + this.addOptionalOutputsAndGetAmount());
    }
    async signInputsWalletBased(transaction) {
        const signer = this.signer;
        await this.signInput(transaction, transaction.data.inputs[0], 0, this.contractSigner);
        await signer.multiSignPsbt([transaction]);
        for (let i = 0; i < transaction.data.inputs.length; i++) {
            if (i === 0) {
                transaction.finalizeInput(i, this.customFinalizer.bind(this));
            }
            else {
                try {
                    transaction.finalizeInput(i, this.customFinalizerP2SH.bind(this));
                }
                catch (e) {
                    transaction.finalizeInput(i);
                }
            }
        }
    }
    async signInputs(transaction) {
        if (!this.contractSigner) {
            await super.signInputs(transaction);
            return;
        }
        if ('multiSignPsbt' in this.signer) {
            await this.signInputsWalletBased(transaction);
            return;
        }
        for (let i = 0; i < transaction.data.inputs.length; i++) {
            if (i === 0) {
                transaction.signInput(0, this.contractSigner);
                transaction.signInput(0, this.getSignerKey());
                transaction.finalizeInput(0, this.customFinalizer.bind(this));
            }
            else {
                transaction.signInput(i, this.getSignerKey());
                try {
                    transaction.finalizeInput(i, this.customFinalizerP2SH.bind(this));
                }
                catch (e) {
                    transaction.finalizeInput(i);
                }
            }
        }
    }
    generateScriptAddress() {
        return {
            name: PaymentType.P2TR,
            internalPubkey: this.internalPubKeyToXOnly(),
            network: this.network,
            scriptTree: this.scriptTree,
        };
    }
    generateTapData() {
        const selectedRedeem = this.contractSigner
            ? this.targetScriptRedeem
            : this.leftOverFundsScriptRedeem;
        if (!selectedRedeem) {
            throw new Error('Left over funds script redeem is required');
        }
        if (!this.scriptTree) {
            throw new Error('Script tree is required');
        }
        return {
            name: PaymentType.P2TR,
            internalPubkey: this.internalPubKeyToXOnly(),
            network: this.network,
            scriptTree: this.scriptTree,
            redeem: selectedRedeem,
        };
    }
    generateFeatures(parameters) {
        const features = [];
        const submission = parameters.challenge.getSubmission();
        if (submission) {
            features.push({
                priority: FeaturePriority.MLDSA_LINK_PUBKEY,
                opcode: Features.EPOCH_SUBMISSION,
                data: submission,
            });
        }
        if (parameters.revealMLDSAPublicKey && !parameters.linkMLDSAPublicKeyToAddress) {
            throw new Error('To reveal the MLDSA public key, you must set linkMLDSAPublicKeyToAddress to true.');
        }
        if (parameters.linkMLDSAPublicKeyToAddress) {
            this.generateMLDSALinkRequest(parameters, features);
        }
        return features;
    }
    verifyCalldata() {
        if (this.calldata &&
            this.calldata.length > SharedInteractionTransaction.MAXIMUM_CALLDATA_SIZE) {
            throw new Error('Calldata size overflow.');
        }
    }
    verifyBytecode() {
        if (!this.bytecode)
            throw new Error('Bytecode is required');
        if (this.bytecode.length > DeploymentTransaction.MAXIMUM_CONTRACT_SIZE) {
            throw new Error('Contract size overflow.');
        }
    }
    getContractSeed() {
        if (!this.bytecode) {
            throw new Error('Bytecode is required');
        }
        const deployerPubKey = this.internalPubKeyToXOnly();
        const salt = bitCrypto.hash256(this.randomBytes);
        const sha256OfBytecode = bitCrypto.hash256(this.bytecode);
        const buf = Buffer.concat([deployerPubKey, salt, sha256OfBytecode]);
        return bitCrypto.hash256(buf);
    }
    getPubKeys() {
        const pubkeys = [Buffer.from(this.signer.publicKey)];
        if (this.contractSigner) {
            pubkeys.push(Buffer.from(this.contractSigner.publicKey));
        }
        return pubkeys;
    }
    generateRedeemScripts() {
        this.targetScriptRedeem = {
            name: PaymentType.P2TR,
            output: this.compiledTargetScript,
            redeemVersion: 192,
        };
        this.leftOverFundsScriptRedeem = {
            name: PaymentType.P2TR,
            output: this.getLeafScript(),
            redeemVersion: 192,
        };
    }
    getLeafScript() {
        return this.LOCK_LEAF_SCRIPT;
    }
    getScriptTree() {
        if (!this.bytecode) {
            throw new Error('Contract bytecode is required');
        }
        this.generateRedeemScripts();
        return [
            {
                output: this.compiledTargetScript,
                version: 192,
            },
            {
                output: this.getLeafScript(),
                version: 192,
            },
        ];
    }
}
DeploymentTransaction.MAXIMUM_CONTRACT_SIZE = 128 * 1024;
