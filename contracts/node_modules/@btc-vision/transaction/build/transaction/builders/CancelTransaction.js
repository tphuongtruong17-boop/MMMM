import { TransactionType } from '../enums/TransactionType.js';
import { PaymentType } from '@btc-vision/bitcoin';
import { TransactionBuilder } from './TransactionBuilder.js';
export class CancelTransaction extends TransactionBuilder {
    constructor(parameters) {
        super({
            ...parameters,
            gasSatFee: 1n,
            isCancellation: true,
            priorityFee: 1n,
            calldata: Buffer.alloc(0),
        });
        this.type = TransactionType.CANCEL;
        this.tapLeafScript = null;
        this.leftOverFundsScriptRedeem = null;
        this.customFinalizer = (_inputIndex, input) => {
            if (!this.tapLeafScript) {
                throw new Error('Tap leaf script is required');
            }
            if (!input.tapScriptSig || input.tapScriptSig.length === 0) {
                throw new Error('Tap script signature is required');
            }
            const scriptSolution = [input.tapScriptSig[0].signature];
            const witness = scriptSolution
                .concat(this.tapLeafScript.script)
                .concat(this.tapLeafScript.controlBlock);
            return {
                finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness(witness),
            };
        };
        this.contractSecret = Buffer.alloc(0);
        if (Buffer.isBuffer(parameters.compiledTargetScript)) {
            this.compiledTargetScript = parameters.compiledTargetScript;
        }
        else {
            this.compiledTargetScript = Buffer.from(parameters.compiledTargetScript, 'hex');
        }
        this.scriptTree = this.getMinimalScriptTree();
        this.internalInit();
    }
    async buildTransaction() {
        if (!this.from) {
            throw new Error('From address is required');
        }
        if (!this.leftOverFundsScriptRedeem) {
            throw new Error('Left over funds script redeem is required');
        }
        if (!this.leftOverFundsScriptRedeem.redeemVersion) {
            throw new Error('Left over funds script redeem version is required');
        }
        if (!this.leftOverFundsScriptRedeem.output) {
            throw new Error('Left over funds script redeem output is required');
        }
        this.tapLeafScript = {
            leafVersion: this.leftOverFundsScriptRedeem.redeemVersion,
            script: this.leftOverFundsScriptRedeem.output,
            controlBlock: this.getWitness(),
        };
        this.addInputsFromUTXO();
        await this.addRefundOutput(0n, true);
        if (!this.feeOutput) {
            throw new Error('Must add extra UTXOs to cancel this transaction');
        }
    }
    generateScriptAddress() {
        return {
            internalPubkey: this.internalPubKeyToXOnly(),
            network: this.network,
            scriptTree: this.scriptTree,
            name: PaymentType.P2TR,
        };
    }
    generateTapData() {
        const selectedRedeem = this.leftOverFundsScriptRedeem;
        if (!selectedRedeem) {
            throw new Error('Left over funds script redeem is required');
        }
        if (!this.scriptTree) {
            throw new Error('Script tree is required');
        }
        return {
            internalPubkey: this.internalPubKeyToXOnly(),
            network: this.network,
            scriptTree: this.scriptTree,
            redeem: selectedRedeem,
            name: PaymentType.P2TR,
        };
    }
    async signInputs(transaction) {
        if ('multiSignPsbt' in this.signer) {
            await this.signInputsWalletBased(transaction);
        }
        else {
            await this.signInputsNonWalletBased(transaction);
        }
    }
    async signInputsWalletBased(transaction) {
        const signer = this.signer;
        await signer.multiSignPsbt([transaction]);
        for (let i = 0; i < transaction.data.inputs.length; i++) {
            if (i === 0) {
                transaction.finalizeInput(i, this.customFinalizer.bind(this));
            }
            else {
                try {
                    transaction.finalizeInput(i, this.customFinalizerP2SH.bind(this));
                }
                catch (e) {
                    transaction.finalizeInput(i);
                }
            }
        }
    }
    async signInputsNonWalletBased(transaction) {
        for (let i = 0; i < transaction.data.inputs.length; i++) {
            if (i === 0) {
                await this.signInput(transaction, transaction.data.inputs[i], i, this.getSignerKey());
                transaction.finalizeInput(0, this.customFinalizer.bind(this));
            }
            else {
                await this.signInput(transaction, transaction.data.inputs[i], i, this.signer);
                try {
                    transaction.finalizeInput(i, this.customFinalizerP2SH.bind(this));
                }
                catch (e) {
                    transaction.finalizeInput(i);
                }
            }
        }
    }
    getMinimalScriptTree() {
        this.generateLeftoverFundsRedeem();
        if (!this.leftOverFundsScriptRedeem || !this.leftOverFundsScriptRedeem.output) {
            throw new Error('Failed to generate leftover funds redeem script');
        }
        return [
            {
                output: this.compiledTargetScript,
                version: 192,
            },
            {
                output: this.leftOverFundsScriptRedeem.output,
                version: 192,
            },
        ];
    }
    generateLeftoverFundsRedeem() {
        this.leftOverFundsScriptRedeem = {
            name: PaymentType.P2TR,
            output: this.LOCK_LEAF_SCRIPT,
            redeemVersion: 192,
        };
    }
}
