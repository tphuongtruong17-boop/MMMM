import bitcoin, { getFinalScripts, initEccLib, opcodes, Psbt, script, toXOnly, Transaction, } from '@btc-vision/bitcoin';
import { witnessStackToScriptWitness } from '../utils/WitnessUtils.js';
import * as ecc from '@bitcoinerlab/secp256k1';
import { EcKeyPair } from '../../keypair/EcKeyPair.js';
import { AddressVerificator } from '../../keypair/AddressVerificator.js';
import { TweakedTransaction } from '../shared/TweakedTransaction.js';
import { P2WDADetector } from '../../p2wda/P2WDADetector.js';
import { FeaturePriority, Features } from '../../generators/Features.js';
import { BITCOIN_PROTOCOL_ID, getChainId } from '../../chain/ChainData.js';
import { BinaryWriter } from '../../buffer/BinaryWriter.js';
import { MLDSASecurityLevel } from '@btc-vision/bip32';
import { MessageSigner } from '../../keypair/MessageSigner.js';
import { getLevelFromPublicKeyLength } from '../../generators/MLDSAData.js';
initEccLib(ecc);
export const MINIMUM_AMOUNT_REWARD = 330n;
export const MINIMUM_AMOUNT_CA = 297n;
export const ANCHOR_SCRIPT = Buffer.from('51024e73', 'hex');
export class TransactionBuilder extends TweakedTransaction {
    constructor(parameters) {
        super(parameters);
        this.logColor = '#785def';
        this.debugFees = false;
        this.overflowFees = 0n;
        this.transactionFee = 0n;
        this.estimatedFees = 0n;
        this.updateInputs = [];
        this.outputs = [];
        this.feeOutput = null;
        this._maximumFeeRate = 100000000;
        this.optionalOutputsAdded = false;
        if (parameters.estimatedFees) {
            this.estimatedFees = parameters.estimatedFees;
        }
        this.signer = parameters.signer;
        this.network = parameters.network;
        this.feeRate = parameters.feeRate;
        this.priorityFee = parameters.priorityFee ?? 0n;
        this.gasSatFee = parameters.gasSatFee ?? 0n;
        this.utxos = parameters.utxos;
        this.optionalInputs = parameters.optionalInputs || [];
        this.to = parameters.to || undefined;
        this.debugFees = parameters.debugFees || false;
        this.LOCK_LEAF_SCRIPT = this.defineLockScript();
        if (parameters.note) {
            if (typeof parameters.note === 'string') {
                this.note = Buffer.from(parameters.note, 'utf8');
            }
            else {
                this.note = parameters.note;
            }
        }
        this.anchor = parameters.anchor ?? false;
        this.isPubKeyDestination = this.to
            ? AddressVerificator.isValidPublicKey(this.to, this.network)
            : false;
        this.optionalOutputs = parameters.optionalOutputs;
        this.from = TransactionBuilder.getFrom(parameters.from, this.signer, this.network);
        this.totalInputAmount = this.calculateTotalUTXOAmount();
        const totalVOut = this.calculateTotalVOutAmount();
        if (totalVOut < this.totalInputAmount) {
            throw new Error(`Vout value is less than the value to send`);
        }
        this.transaction = new Psbt({
            network: this.network,
            version: this.txVersion,
        });
    }
    static getFrom(from, keypair, network) {
        return from || EcKeyPair.getTaprootAddress(keypair, network);
    }
    static witnessStackToScriptWitness(witness) {
        return witnessStackToScriptWitness(witness);
    }
    addOPReturn(buffer) {
        const compileScript = script.compile([opcodes.OP_RETURN, buffer]);
        this.addOutput({
            value: 0,
            script: compileScript,
        });
    }
    addAnchor() {
        this.addOutput({
            value: 0,
            script: ANCHOR_SCRIPT,
        });
    }
    async getFundingTransactionParameters() {
        if (!this.estimatedFees) {
            this.estimatedFees = await this.estimateTransactionFees();
        }
        return {
            utxos: this.utxos,
            to: this.getScriptAddress(),
            signer: this.signer,
            network: this.network,
            feeRate: this.feeRate,
            priorityFee: this.priorityFee ?? 0n,
            gasSatFee: this.gasSatFee ?? 0n,
            from: this.from,
            amount: this.estimatedFees,
            optionalOutputs: this.optionalOutputs,
            optionalInputs: this.optionalInputs,
            mldsaSigner: null,
        };
    }
    setDestinationAddress(address) {
        this.to = address;
    }
    setMaximumFeeRate(feeRate) {
        this._maximumFeeRate = feeRate;
    }
    async signTransaction() {
        if (!this.utxos.length) {
            throw new Error('No UTXOs specified');
        }
        if (this.to &&
            !this.isPubKeyDestination &&
            !EcKeyPair.verifyContractAddress(this.to, this.network)) {
            throw new Error('Invalid contract address. The contract address must be a taproot address.');
        }
        if (this.signed)
            throw new Error('Transaction is already signed');
        this.signed = true;
        await this.buildTransaction();
        const builtTx = await this.internalBuildTransaction(this.transaction);
        if (builtTx) {
            if (this.regenerated) {
                throw new Error('Transaction was regenerated');
            }
            return this.transaction.extractTransaction(true, true);
        }
        throw new Error('Could not sign transaction');
    }
    async generateTransactionMinimalSignatures(checkPartialSigs = false) {
        if (this.to &&
            !this.isPubKeyDestination &&
            !EcKeyPair.verifyContractAddress(this.to, this.network)) {
            throw new Error('Invalid contract address. The contract address must be a taproot address.');
        }
        await this.buildTransaction();
        if (this.transaction.data.inputs.length === 0) {
            const inputs = this.getInputs();
            const outputs = this.getOutputs();
            this.transaction.setMaximumFeeRate(this._maximumFeeRate);
            this.transaction.addInputs(inputs, checkPartialSigs);
            for (let i = 0; i < this.updateInputs.length; i++) {
                this.transaction.updateInput(i, this.updateInputs[i]);
            }
            this.transaction.addOutputs(outputs);
        }
    }
    async signPSBT() {
        if (await this.signTransaction()) {
            return this.transaction;
        }
        throw new Error('Could not sign transaction');
    }
    addInput(input) {
        this.inputs.push(input);
    }
    addOutput(output, bypassMinCheck = false) {
        if (output.value === 0) {
            const script = output;
            if (!script.script || script.script.length === 0) {
                throw new Error('Output value is 0 and no script provided');
            }
            if (script.script.length < 2) {
                throw new Error('Output script is too short');
            }
            if (script.script[0] !== opcodes.OP_RETURN && !script.script.equals(ANCHOR_SCRIPT)) {
                throw new Error('Output script must start with OP_RETURN or be an ANCHOR when value is 0');
            }
        }
        else if (!bypassMinCheck && output.value < TransactionBuilder.MINIMUM_DUST) {
            throw new Error(`Output value is less than the minimum dust ${output.value} < ${TransactionBuilder.MINIMUM_DUST}`);
        }
        this.outputs.push(output);
    }
    getTotalOutputValue() {
        return this.outputs.reduce((total, output) => total + BigInt(output.value), 0n);
    }
    toAddress() {
        return this.to;
    }
    address() {
        return this.tapData?.address;
    }
    async estimateTransactionFees() {
        await Promise.resolve();
        const fakeTx = new Psbt({ network: this.network });
        const inputs = this.getInputs();
        const outputs = this.getOutputs();
        fakeTx.addInputs(inputs);
        fakeTx.addOutputs(outputs);
        const dummySchnorrSig = Buffer.alloc(64, 0);
        const dummyEcdsaSig = Buffer.alloc(72, 0);
        const dummyCompressedPubkey = Buffer.alloc(33, 2);
        const finalizer = (inputIndex, input) => {
            if (input.isPayToAnchor || this.anchorInputIndices.has(inputIndex)) {
                return {
                    finalScriptSig: undefined,
                    finalScriptWitness: Buffer.from([0]),
                };
            }
            if (input.witnessScript && P2WDADetector.isP2WDAWitnessScript(input.witnessScript)) {
                const dummyDataSlots = [];
                for (let i = 0; i < 10; i++) {
                    dummyDataSlots.push(Buffer.alloc(0));
                }
                const dummyEcdsaSig = Buffer.alloc(72, 0);
                return {
                    finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness([
                        ...dummyDataSlots,
                        dummyEcdsaSig,
                        input.witnessScript,
                    ]),
                };
            }
            if (inputIndex === 0 && this.tapLeafScript) {
                const dummySecret = Buffer.alloc(32, 0);
                const dummyScript = this.tapLeafScript.script;
                const dummyControlBlock = Buffer.alloc(1 + 32 + 32, 0);
                return {
                    finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness([
                        dummySecret,
                        dummySchnorrSig,
                        dummySchnorrSig,
                        dummyScript,
                        dummyControlBlock,
                    ]),
                };
            }
            if (input.witnessUtxo) {
                const script = input.witnessUtxo.script;
                const decompiled = bitcoin.script.decompile(script);
                if (decompiled &&
                    decompiled.length === 5 &&
                    decompiled[0] === opcodes.OP_DUP &&
                    decompiled[1] === opcodes.OP_HASH160 &&
                    decompiled[3] === opcodes.OP_EQUALVERIFY &&
                    decompiled[4] === opcodes.OP_CHECKSIG) {
                    return {
                        finalScriptSig: bitcoin.script.compile([
                            dummyEcdsaSig,
                            dummyCompressedPubkey,
                        ]),
                        finalScriptWitness: undefined,
                    };
                }
            }
            if (input.witnessScript) {
                if (this.csvInputIndices.has(inputIndex)) {
                    return {
                        finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness([
                            dummyEcdsaSig,
                            input.witnessScript,
                        ]),
                    };
                }
                if (input.redeemScript) {
                    const dummyWitness = [dummyEcdsaSig, input.witnessScript];
                    return {
                        finalScriptSig: input.redeemScript,
                        finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness(dummyWitness),
                    };
                }
                const decompiled = bitcoin.script.decompile(input.witnessScript);
                if (decompiled && decompiled.length >= 4) {
                    const firstOp = decompiled[0];
                    const lastOp = decompiled[decompiled.length - 1];
                    if (typeof firstOp === 'number' &&
                        firstOp >= opcodes.OP_1 &&
                        lastOp === opcodes.OP_CHECKMULTISIG) {
                        const m = firstOp - opcodes.OP_1 + 1;
                        const signatures = [];
                        for (let i = 0; i < m; i++) {
                            signatures.push(dummyEcdsaSig);
                        }
                        return {
                            finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness([
                                Buffer.alloc(0),
                                ...signatures,
                                input.witnessScript,
                            ]),
                        };
                    }
                }
                return {
                    finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness([
                        dummyEcdsaSig,
                        input.witnessScript,
                    ]),
                };
            }
            else if (input.redeemScript) {
                const decompiled = bitcoin.script.decompile(input.redeemScript);
                if (decompiled &&
                    decompiled.length === 2 &&
                    decompiled[0] === opcodes.OP_0 &&
                    Buffer.isBuffer(decompiled[1]) &&
                    decompiled[1].length === 20) {
                    return {
                        finalScriptSig: input.redeemScript,
                        finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness([
                            dummyEcdsaSig,
                            dummyCompressedPubkey,
                        ]),
                    };
                }
            }
            if (input.redeemScript && !input.witnessScript && !input.witnessUtxo) {
                return {
                    finalScriptSig: bitcoin.script.compile([dummyEcdsaSig, input.redeemScript]),
                    finalScriptWitness: undefined,
                };
            }
            const script = input.witnessUtxo?.script;
            if (!script)
                return { finalScriptSig: undefined, finalScriptWitness: undefined };
            if (input.tapInternalKey) {
                return {
                    finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness([
                        dummySchnorrSig,
                    ]),
                };
            }
            if (script.length === 22 && script[0] === opcodes.OP_0) {
                return {
                    finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness([
                        dummyEcdsaSig,
                        dummyCompressedPubkey,
                    ]),
                };
            }
            if (input.redeemScript?.length === 22 && input.redeemScript[0] === opcodes.OP_0) {
                return {
                    finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness([
                        dummyEcdsaSig,
                        dummyCompressedPubkey,
                    ]),
                };
            }
            return getFinalScripts(inputIndex, input, script, true, !!input.redeemScript, !!input.witnessScript);
        };
        try {
            for (let i = 0; i < fakeTx.data.inputs.length; i++) {
                const fullInput = inputs[i];
                if (fullInput) {
                    fakeTx.finalizeInput(i, (idx) => finalizer(idx, fullInput));
                }
            }
        }
        catch (e) {
            this.warn(`Could not finalize dummy tx: ${e.message}`);
        }
        const tx = fakeTx.extractTransaction(true, true);
        const size = tx.virtualSize();
        const fee = this.feeRate * size;
        const finalFee = BigInt(Math.ceil(fee));
        if (this.debugFees) {
            this.log(`Estimating fees: feeRate=${this.feeRate}, accurate_vSize=${size}, fee=${finalFee}n`);
        }
        return finalFee;
    }
    async rebuildFromBase64(base64) {
        this.transaction = Psbt.fromBase64(base64, {
            network: this.network,
            version: this.txVersion,
        });
        this.signed = false;
        this.sighashTypes = [Transaction.SIGHASH_ANYONECANPAY, Transaction.SIGHASH_ALL];
        return await this.signPSBT();
    }
    setPSBT(psbt) {
        this.transaction = psbt;
    }
    getInputs() {
        return this.inputs;
    }
    getOutputs() {
        const outputs = [...this.outputs];
        if (this.feeOutput)
            outputs.push(this.feeOutput);
        return outputs;
    }
    getOptionalOutputValue() {
        if (!this.optionalOutputs)
            return 0n;
        let total = 0n;
        for (let i = 0; i < this.optionalOutputs.length; i++) {
            total += BigInt(this.optionalOutputs[i].value);
        }
        return total;
    }
    async addRefundOutput(amountSpent, expectRefund = false) {
        if (this.note) {
            this.addOPReturn(this.note);
        }
        if (this.anchor) {
            this.addAnchor();
        }
        let previousFee = -1n;
        let estimatedFee = 0n;
        let iterations = 0;
        const maxIterations = 5;
        let sendBackAmount = 0n;
        while (iterations < maxIterations && estimatedFee !== previousFee) {
            previousFee = estimatedFee;
            estimatedFee = await this.estimateTransactionFees();
            const totalSpent = amountSpent + estimatedFee;
            sendBackAmount = this.totalInputAmount - totalSpent;
            if (this.debugFees) {
                this.log(`Iteration ${iterations + 1}: inputAmount=${this.totalInputAmount}, totalSpent=${totalSpent}, sendBackAmount=${sendBackAmount}`);
            }
            if (sendBackAmount >= TransactionBuilder.MINIMUM_DUST) {
                if (AddressVerificator.isValidP2TRAddress(this.from, this.network)) {
                    this.feeOutput = {
                        value: Number(sendBackAmount),
                        address: this.from,
                        tapInternalKey: this.internalPubKeyToXOnly(),
                    };
                }
                else if (AddressVerificator.isValidPublicKey(this.from, this.network)) {
                    const pubKeyScript = script.compile([
                        Buffer.from(this.from.replace('0x', ''), 'hex'),
                        opcodes.OP_CHECKSIG,
                    ]);
                    this.feeOutput = {
                        value: Number(sendBackAmount),
                        script: pubKeyScript,
                    };
                }
                else {
                    this.feeOutput = {
                        value: Number(sendBackAmount),
                        address: this.from,
                    };
                }
                this.overflowFees = sendBackAmount;
            }
            else {
                this.feeOutput = null;
                this.overflowFees = 0n;
                if (sendBackAmount < 0n && iterations === maxIterations) {
                    throw new Error(`Insufficient funds: need ${totalSpent} sats but only have ${this.totalInputAmount} sats`);
                }
                if (this.debugFees) {
                    this.warn(`Amount to send back (${sendBackAmount} sat) is less than minimum dust...`);
                }
            }
            iterations++;
        }
        if (expectRefund && sendBackAmount < 0n) {
            throw new Error(`Insufficient funds: need at least ${-sendBackAmount} more sats to cover fees.`);
        }
        if (iterations >= maxIterations) {
            this.warn(`Fee calculation did not stabilize after ${maxIterations} iterations`);
        }
        this.transactionFee = estimatedFee;
        if (this.debugFees) {
            this.log(`Final fee: ${estimatedFee} sats, Change output: ${this.feeOutput ? `${this.feeOutput.value} sats` : 'none'}`);
        }
    }
    defineLockScript() {
        return script.compile([toXOnly(Buffer.from(this.signer.publicKey)), opcodes.OP_CHECKSIG]);
    }
    addValueToToOutput(value) {
        if (value < TransactionBuilder.MINIMUM_DUST) {
            throw new Error(`Value to send is less than the minimum dust ${value} < ${TransactionBuilder.MINIMUM_DUST}`);
        }
        for (const output of this.outputs) {
            if ('address' in output && output.address === this.to) {
                output.value += Number(value);
                return;
            }
        }
        throw new Error('Output not found');
    }
    generateLegacySignature() {
        this.tweakSigner();
        if (!this.tweakedSigner) {
            throw new Error('Tweaked signer is not defined');
        }
        const tweakedKey = toXOnly(this.tweakedSigner.publicKey);
        const originalKey = this.signer.publicKey;
        if (originalKey.length !== 33) {
            throw new Error('Original public key must be compressed (33 bytes)');
        }
        const chainId = getChainId(this.network);
        const writer = new BinaryWriter();
        writer.writeU8(MLDSASecurityLevel.LEVEL2);
        writer.writeBytes(this.hashedPublicKey);
        writer.writeBytes(tweakedKey);
        writer.writeBytes(originalKey);
        writer.writeBytes(BITCOIN_PROTOCOL_ID);
        writer.writeBytes(chainId);
        const message = writer.getBuffer();
        const signature = MessageSigner.signMessage(this.tweakedSigner, message);
        const isValid = MessageSigner.verifySignature(tweakedKey, message, signature.signature);
        if (!isValid) {
            throw new Error('Could not verify generated legacy signature for MLDSA link request');
        }
        return Buffer.from(signature.signature);
    }
    generateMLDSASignature() {
        if (!this.mldsaSigner) {
            throw new Error('MLDSA signer is not defined');
        }
        this.tweakSigner();
        if (!this.tweakedSigner) {
            throw new Error('Tweaked signer is not defined');
        }
        const tweakedKey = toXOnly(this.tweakedSigner.publicKey);
        const originalKey = this.signer.publicKey;
        if (originalKey.length !== 33) {
            throw new Error('Original public key must be compressed (33 bytes)');
        }
        const chainId = getChainId(this.network);
        const level = getLevelFromPublicKeyLength(this.mldsaSigner.publicKey.length);
        if (level !== MLDSASecurityLevel.LEVEL2) {
            throw new Error('Only MLDSA level 2 is supported for link requests');
        }
        const writer = new BinaryWriter();
        writer.writeU8(level);
        writer.writeBytes(this.hashedPublicKey);
        writer.writeBytes(this.mldsaSigner.publicKey);
        writer.writeBytes(tweakedKey);
        writer.writeBytes(originalKey);
        writer.writeBytes(BITCOIN_PROTOCOL_ID);
        writer.writeBytes(chainId);
        const message = writer.getBuffer();
        const signature = MessageSigner.signMLDSAMessage(this.mldsaSigner, message);
        const isValid = MessageSigner.verifyMLDSASignature(this.mldsaSigner, message, signature.signature);
        if (!isValid) {
            throw new Error('Could not verify generated MLDSA signature for link request');
        }
        return Buffer.from(signature.signature);
    }
    generateMLDSALinkRequest(parameters, features) {
        const mldsaSigner = this.mldsaSigner;
        const legacySignature = this.generateLegacySignature();
        let mldsaSignature = null;
        if (parameters.revealMLDSAPublicKey) {
            mldsaSignature = this.generateMLDSASignature();
        }
        const mldsaRequest = {
            priority: FeaturePriority.MLDSA_LINK_PUBKEY,
            opcode: Features.MLDSA_LINK_PUBKEY,
            data: {
                verifyRequest: !!parameters.revealMLDSAPublicKey,
                publicKey: mldsaSigner.publicKey,
                hashedPublicKey: this.hashedPublicKey,
                level: getLevelFromPublicKeyLength(mldsaSigner.publicKey.length),
                legacySignature: legacySignature,
                mldsaSignature: mldsaSignature,
            },
        };
        features.push(mldsaRequest);
    }
    getTransactionOPNetFee() {
        const totalFee = this.priorityFee + this.gasSatFee;
        if (totalFee > TransactionBuilder.MINIMUM_DUST) {
            return totalFee;
        }
        return TransactionBuilder.MINIMUM_DUST;
    }
    calculateTotalUTXOAmount() {
        let total = 0n;
        for (const utxo of this.utxos) {
            total += utxo.value;
        }
        for (const utxo of this.optionalInputs) {
            total += utxo.value;
        }
        return total;
    }
    calculateTotalVOutAmount() {
        let total = 0n;
        for (const utxo of this.utxos) {
            total += utxo.value;
        }
        for (const utxo of this.optionalInputs) {
            total += utxo.value;
        }
        return total;
    }
    addOptionalOutputsAndGetAmount() {
        if (!this.optionalOutputs || this.optionalOutputsAdded)
            return 0n;
        let refundedFromOptionalOutputs = 0n;
        for (let i = 0; i < this.optionalOutputs.length; i++) {
            this.addOutput(this.optionalOutputs[i]);
            refundedFromOptionalOutputs += BigInt(this.optionalOutputs[i].value);
        }
        this.optionalOutputsAdded = true;
        return refundedFromOptionalOutputs;
    }
    addInputsFromUTXO() {
        if (this.utxos.length) {
            if (this.totalInputAmount < TransactionBuilder.MINIMUM_DUST) {
                throw new Error(`Total input amount is ${this.totalInputAmount} sat which is less than the minimum dust ${TransactionBuilder.MINIMUM_DUST} sat.`);
            }
            for (let i = 0; i < this.utxos.length; i++) {
                const utxo = this.utxos[i];
                this.registerInputSigner(i, utxo);
                const input = this.generatePsbtInputExtended(utxo, i);
                this.addInput(input);
            }
        }
        if (this.optionalInputs) {
            for (let i = this.utxos.length; i < this.optionalInputs.length + this.utxos.length; i++) {
                const utxo = this.optionalInputs[i - this.utxos.length];
                this.registerInputSigner(i, utxo);
                const input = this.generatePsbtInputExtended(utxo, i, true);
                this.addInput(input);
            }
        }
    }
    internalInit() {
        this.verifyUTXOValidity();
        super.internalInit();
    }
    updateInput(input) {
        this.updateInputs.push(input);
    }
    addFeeToOutput(amountSpent, contractAddress, epochChallenge, addContractOutput) {
        if (addContractOutput) {
            let amountToCA;
            if (amountSpent > MINIMUM_AMOUNT_REWARD + MINIMUM_AMOUNT_CA) {
                amountToCA = MINIMUM_AMOUNT_CA;
            }
            else {
                amountToCA = amountSpent;
            }
            this.addOutput({
                value: Number(amountToCA),
                address: contractAddress,
            }, true);
            if (amountToCA === MINIMUM_AMOUNT_CA &&
                amountSpent - MINIMUM_AMOUNT_CA > MINIMUM_AMOUNT_REWARD) {
                this.addOutput({
                    value: Number(amountSpent - amountToCA),
                    address: epochChallenge.address,
                }, true);
            }
        }
        else {
            const amountToEpoch = amountSpent < MINIMUM_AMOUNT_REWARD ? MINIMUM_AMOUNT_REWARD : amountSpent;
            this.addOutput({
                value: Number(amountToEpoch),
                address: epochChallenge.address,
            }, true);
        }
    }
    getWitness() {
        if (!this.tapData || !this.tapData.witness) {
            throw new Error('Witness is required');
        }
        if (this.tapData.witness.length === 0) {
            throw new Error('Witness is empty');
        }
        return this.tapData.witness[this.tapData.witness.length - 1];
    }
    getTapOutput() {
        if (!this.tapData || !this.tapData.output) {
            throw new Error('Tap data is required');
        }
        return this.tapData.output;
    }
    verifyUTXOValidity() {
        for (const utxo of this.utxos) {
            if (!utxo.scriptPubKey) {
                throw new Error('Address is required');
            }
        }
        for (const utxo of this.optionalInputs) {
            if (!utxo.scriptPubKey) {
                throw new Error('Address is required');
            }
        }
    }
    async setFeeOutput(output) {
        const initialValue = output.value;
        this.feeOutput = null;
        let estimatedFee = 0n;
        let lastFee = -1n;
        this.log(`setFeeOutput: Starting fee calculation for change. Initial available value: ${initialValue} sats.`);
        for (let i = 0; i < 3 && estimatedFee !== lastFee; i++) {
            lastFee = estimatedFee;
            estimatedFee = await this.estimateTransactionFees();
            const valueLeft = BigInt(initialValue) - estimatedFee;
            if (this.debugFees) {
                this.log(` -> Iteration ${i + 1}: Estimated fee is ${estimatedFee} sats. Value left for change: ${valueLeft} sats.`);
            }
            if (valueLeft >= TransactionBuilder.MINIMUM_DUST) {
                this.feeOutput = { ...output, value: Number(valueLeft) };
                this.overflowFees = valueLeft;
            }
            else {
                this.feeOutput = null;
                this.overflowFees = 0n;
                estimatedFee = await this.estimateTransactionFees();
                if (this.debugFees) {
                    this.log(` -> Change is less than dust. Final fee without change output: ${estimatedFee} sats.`);
                }
            }
        }
        const finalValueLeft = BigInt(initialValue) - estimatedFee;
        if (finalValueLeft < 0) {
            throw new Error(`setFeeOutput: Insufficient funds to pay the fees. Required fee: ${estimatedFee}, Available: ${initialValue}. Total input: ${this.totalInputAmount} sat`);
        }
        if (finalValueLeft >= TransactionBuilder.MINIMUM_DUST) {
            this.feeOutput = { ...output, value: Number(finalValueLeft) };
            this.overflowFees = finalValueLeft;
            if (this.debugFees) {
                this.log(`setFeeOutput: Final change output set to ${finalValueLeft} sats. Final fee: ${estimatedFee} sats.`);
            }
        }
        else {
            this.warn(`Amount to send back (${finalValueLeft} sat) is less than the minimum dust (${TransactionBuilder.MINIMUM_DUST} sat), it will be consumed in fees instead.`);
            this.feeOutput = null;
            this.overflowFees = 0n;
        }
    }
    async internalBuildTransaction(transaction, checkPartialSigs = false) {
        if (transaction.data.inputs.length === 0) {
            const inputs = this.getInputs();
            const outputs = this.getOutputs();
            transaction.setMaximumFeeRate(this._maximumFeeRate);
            transaction.addInputs(inputs, checkPartialSigs);
            for (let i = 0; i < this.updateInputs.length; i++) {
                transaction.updateInput(i, this.updateInputs[i]);
            }
            transaction.addOutputs(outputs);
        }
        try {
            await this.signInputs(transaction);
            if (this.finalized) {
                this.transactionFee = BigInt(transaction.getFee());
            }
            return true;
        }
        catch (e) {
            const err = e;
            this.error(`[internalBuildTransaction] Something went wrong while getting building the transaction: ${err.stack}`);
        }
        return false;
    }
}
TransactionBuilder.MINIMUM_DUST = 330n;
