import { Buffer } from 'buffer';
import { Psbt, toXOnly } from '@btc-vision/bitcoin';
import { TransactionType } from '../enums/TransactionType.js';
import { MINIMUM_AMOUNT_REWARD, TransactionBuilder } from './TransactionBuilder.js';
import { HashCommitmentGenerator } from '../../generators/builders/HashCommitmentGenerator.js';
import { CalldataGenerator } from '../../generators/builders/CalldataGenerator.js';
import { TimeLockGenerator } from '../mineable/TimelockGenerator.js';
import { EcKeyPair } from '../../keypair/EcKeyPair.js';
import { BitcoinUtils } from '../../utils/BitcoinUtils.js';
import { Compressor } from '../../bytecode/Compressor.js';
import { FeaturePriority, Features } from '../../generators/Features.js';
import { AddressGenerator } from '../../generators/AddressGenerator.js';
export class ConsolidatedInteractionTransaction extends TransactionBuilder {
    constructor(parameters) {
        super(parameters);
        this.type = TransactionType.INTERACTION;
        this.cachedValuePerOutput = null;
        if (!parameters.to) {
            throw new Error('Contract address (to) is required');
        }
        if (!parameters.contract) {
            throw new Error('Contract secret (contract) is required');
        }
        if (!parameters.calldata) {
            throw new Error('Calldata is required');
        }
        if (!parameters.challenge) {
            throw new Error('Challenge solution is required');
        }
        this.contractAddress = parameters.to;
        this.contractSecret = Buffer.from(parameters.contract.replace('0x', ''), 'hex');
        this.disableAutoRefund = parameters.disableAutoRefund || false;
        this.maxChunkSize = parameters.maxChunkSize ?? HashCommitmentGenerator.MAX_CHUNK_SIZE;
        if (this.contractSecret.length !== 32) {
            throw new Error('Invalid contract secret length. Expected 32 bytes.');
        }
        this.calldata = Compressor.compress(parameters.calldata);
        this.randomBytes = parameters.randomBytes || BitcoinUtils.rndBytes();
        this.scriptSigner = EcKeyPair.fromSeedKeyPair(this.randomBytes, this.network);
        this.challenge = parameters.challenge;
        this.epochChallenge = TimeLockGenerator.generateTimeLockAddress(this.challenge.publicKey.originalPublicKeyBuffer(), this.network);
        this.calldataGenerator = new CalldataGenerator(Buffer.from(this.signer.publicKey), toXOnly(Buffer.from(this.scriptSigner.publicKey)), this.network);
        if (parameters.compiledTargetScript) {
            if (Buffer.isBuffer(parameters.compiledTargetScript)) {
                this.compiledTargetScript = parameters.compiledTargetScript;
            }
            else if (typeof parameters.compiledTargetScript === 'string') {
                this.compiledTargetScript = Buffer.from(parameters.compiledTargetScript, 'hex');
            }
            else {
                throw new Error('Invalid compiled target script format.');
            }
        }
        else {
            this.compiledTargetScript = this.calldataGenerator.compile(this.calldata, this.contractSecret, this.challenge, this.priorityFee, this.generateFeatures(parameters));
        }
        this.hashCommitmentGenerator = new HashCommitmentGenerator(Buffer.from(this.signer.publicKey), this.network);
        this.commitmentOutputs = this.hashCommitmentGenerator.prepareChunks(this.compiledTargetScript, this.maxChunkSize);
        this.validateOutputCount();
        const totalChunks = this.commitmentOutputs.reduce((sum, output) => sum + output.dataChunks.length, 0);
        this.log(`ConsolidatedInteractionTransaction: ${this.commitmentOutputs.length} outputs, ` +
            `${totalChunks} chunks from ${this.compiledTargetScript.length} bytes compiled data`);
        this.internalInit();
    }
    exportCompiledTargetScript() {
        return this.compiledTargetScript;
    }
    getContractSecret() {
        return this.contractSecret;
    }
    getRndBytes() {
        return this.randomBytes;
    }
    getChallenge() {
        return this.challenge;
    }
    getCommitmentOutputs() {
        return this.commitmentOutputs;
    }
    getOutputCount() {
        return this.commitmentOutputs.length;
    }
    getTotalChunkCount() {
        return this.commitmentOutputs.reduce((sum, output) => sum + output.dataChunks.length, 0);
    }
    async build() {
        const setupTx = await this.signTransaction();
        const setupTxId = setupTx.getId();
        const setup = {
            txHex: setupTx.toHex(),
            txId: setupTxId,
            outputs: this.commitmentOutputs,
            feesPaid: this.transactionFee,
            chunkCount: this.getTotalChunkCount(),
            totalDataSize: this.compiledTargetScript.length,
        };
        this.log(`Setup transaction: ${setup.txId}`);
        const reveal = this.buildRevealTransaction(setupTxId);
        return {
            setup,
            reveal,
            totalFees: setup.feesPaid + reveal.feesPaid,
        };
    }
    buildRevealTransaction(setupTxId) {
        const revealPsbt = new Psbt({ network: this.network });
        const valuePerOutput = this.calculateValuePerOutput();
        for (let i = 0; i < this.commitmentOutputs.length; i++) {
            const commitment = this.commitmentOutputs[i];
            revealPsbt.addInput({
                hash: setupTxId,
                index: i,
                witnessUtxo: {
                    script: commitment.scriptPubKey,
                    value: Number(valuePerOutput),
                },
                witnessScript: commitment.witnessScript,
            });
        }
        const inputValue = BigInt(this.commitmentOutputs.length) * valuePerOutput;
        const opnetFee = this.getTransactionOPNetFee();
        const feeAmount = opnetFee < MINIMUM_AMOUNT_REWARD ? MINIMUM_AMOUNT_REWARD : opnetFee;
        revealPsbt.addOutput({
            address: this.epochChallenge.address,
            value: Number(feeAmount),
        });
        const estimatedVBytes = this.estimateRevealVBytes();
        const revealFee = BigInt(Math.ceil(estimatedVBytes * this.feeRate));
        const changeValue = inputValue - feeAmount - revealFee;
        if (changeValue > TransactionBuilder.MINIMUM_DUST) {
            const refundAddress = this.getRefundAddress();
            revealPsbt.addOutput({
                address: refundAddress,
                value: Number(changeValue),
            });
        }
        for (let i = 0; i < this.commitmentOutputs.length; i++) {
            revealPsbt.signInput(i, this.signer);
        }
        for (let i = 0; i < this.commitmentOutputs.length; i++) {
            const commitment = this.commitmentOutputs[i];
            revealPsbt.finalizeInput(i, (_inputIndex, input) => {
                return this.finalizeCommitmentInput(input, commitment);
            });
        }
        const revealTx = revealPsbt.extractTransaction();
        const result = {
            txHex: revealTx.toHex(),
            txId: revealTx.getId(),
            dataSize: this.compiledTargetScript.length,
            feesPaid: revealFee,
            inputCount: this.commitmentOutputs.length,
        };
        this.log(`Reveal transaction: ${result.txId}`);
        return result;
    }
    getValuePerOutput() {
        return this.calculateValuePerOutput();
    }
    async buildTransaction() {
        this.addInputsFromUTXO();
        const valuePerOutput = this.calculateValuePerOutput();
        for (const commitment of this.commitmentOutputs) {
            this.addOutput({
                value: Number(valuePerOutput),
                address: commitment.address,
            });
        }
        const totalCommitmentValue = BigInt(this.commitmentOutputs.length) * valuePerOutput;
        const optionalAmount = this.addOptionalOutputsAndGetAmount();
        await this.addRefundOutput(totalCommitmentValue + optionalAmount);
    }
    finalizeCommitmentInput(input, commitment) {
        if (!input.partialSig || input.partialSig.length === 0) {
            throw new Error('No signature for commitment input');
        }
        if (!input.witnessScript) {
            throw new Error('No witness script for commitment input');
        }
        const witnessStack = [
            input.partialSig[0].signature,
            ...commitment.dataChunks,
            input.witnessScript,
        ];
        return {
            finalScriptSig: undefined,
            finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness(witnessStack),
        };
    }
    estimateRevealVBytes() {
        const inputCount = this.commitmentOutputs.length;
        let witnessWeight = 0;
        for (const commitment of this.commitmentOutputs) {
            const numChunks = commitment.dataChunks.length;
            const chunkDataWeight = numChunks * 80;
            const scriptWeight = numChunks * 23 + 35;
            const sigWeight = 72;
            const overheadWeight = 20;
            witnessWeight += 164 + chunkDataWeight + scriptWeight + sigWeight + overheadWeight;
        }
        const weight = 40 + witnessWeight + 200;
        return Math.ceil(weight / 4);
    }
    calculateValuePerOutput() {
        if (this.cachedValuePerOutput !== null) {
            return this.cachedValuePerOutput;
        }
        const numOutputs = this.commitmentOutputs.length;
        const opnetFee = this.getTransactionOPNetFee();
        const feeAmount = opnetFee < MINIMUM_AMOUNT_REWARD ? MINIMUM_AMOUNT_REWARD : opnetFee;
        const estimatedVBytes = this.estimateRevealVBytes();
        const revealFee = BigInt(Math.ceil(estimatedVBytes * this.feeRate));
        const totalNeeded = feeAmount + revealFee + TransactionBuilder.MINIMUM_DUST;
        const valuePerOutput = BigInt(Math.ceil(Number(totalNeeded) / numOutputs));
        const minValue = HashCommitmentGenerator.MIN_OUTPUT_VALUE;
        this.cachedValuePerOutput = valuePerOutput > minValue ? valuePerOutput : minValue;
        return this.cachedValuePerOutput;
    }
    getRefundAddress() {
        if (this.from) {
            return this.from;
        }
        return AddressGenerator.generatePKSH(this.signer.publicKey, this.network);
    }
    generateFeatures(parameters) {
        const features = [];
        if (parameters.loadedStorage) {
            features.push({
                priority: FeaturePriority.ACCESS_LIST,
                opcode: Features.ACCESS_LIST,
                data: parameters.loadedStorage,
            });
        }
        const submission = parameters.challenge.getSubmission();
        if (submission) {
            features.push({
                priority: FeaturePriority.EPOCH_SUBMISSION,
                opcode: Features.EPOCH_SUBMISSION,
                data: submission,
            });
        }
        if (parameters.revealMLDSAPublicKey && !parameters.linkMLDSAPublicKeyToAddress) {
            throw new Error('To reveal the MLDSA public key, you must set linkMLDSAPublicKeyToAddress to true.');
        }
        if (parameters.linkMLDSAPublicKeyToAddress) {
            this.generateMLDSALinkRequest(parameters, features);
        }
        return features;
    }
    validateOutputCount() {
        const maxInputs = HashCommitmentGenerator.calculateMaxInputsPerTx();
        if (this.commitmentOutputs.length > maxInputs) {
            const maxData = HashCommitmentGenerator.calculateMaxDataPerTx();
            throw new Error(`Data too large: ${this.commitmentOutputs.length} P2WSH outputs needed, ` +
                `max ${maxInputs} per standard transaction (~${Math.floor(maxData / 1024)}KB). ` +
                `Compiled data: ${this.compiledTargetScript.length} bytes.`);
        }
    }
}
