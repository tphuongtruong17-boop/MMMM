import { Transaction } from '@btc-vision/bitcoin';
import { currentConsensus } from '../consensus/ConsensusConfig.js';
import { CustomScriptTransaction } from './builders/CustomScriptTransaction.js';
import { DeploymentTransaction } from './builders/DeploymentTransaction.js';
import { FundingTransaction } from './builders/FundingTransaction.js';
import { InteractionTransaction } from './builders/InteractionTransaction.js';
import { TransactionBuilder } from './builders/TransactionBuilder.js';
import { P2WDADetector } from '../p2wda/P2WDADetector.js';
import { InteractionTransactionP2WDA } from './builders/InteractionTransactionP2WDA.js';
import { Address } from '../keypair/Address.js';
import { BitcoinUtils } from '../utils/BitcoinUtils.js';
import { CancelTransaction } from './builders/CancelTransaction.js';
import { ConsolidatedInteractionTransaction } from './builders/ConsolidatedInteractionTransaction.js';
export class TransactionFactory {
    constructor() {
        this.debug = false;
        this.DUMMY_PUBKEY = Buffer.alloc(32, 1);
        this.P2TR_SCRIPT = Buffer.concat([Buffer.from([0x51, 0x20]), this.DUMMY_PUBKEY]);
        this.INITIAL_FUNDING_ESTIMATE = 2000n;
        this.MAX_ITERATIONS = 10;
    }
    async createCancellableTransaction(params) {
        if (!params.to) {
            throw new Error('Field "to" not provided.');
        }
        if (!params.from) {
            throw new Error('Field "from" not provided.');
        }
        if (!params.utxos[0]) {
            throw new Error('Missing at least one UTXO.');
        }
        const opWalletCancel = await this.detectCancelOPWallet(params);
        if (opWalletCancel) {
            return opWalletCancel;
        }
        if (!('signer' in params)) {
            throw new Error('Field "signer" not provided, OP_WALLET not detected.');
        }
        const cancel = new CancelTransaction(params);
        const signed = await cancel.signTransaction();
        const rawTx = signed.toHex();
        return {
            transaction: rawTx,
            nextUTXOs: this.getUTXOAsTransaction(signed, params.from, 0),
            inputUtxos: params.utxos,
        };
    }
    async createCustomScriptTransaction(interactionParameters) {
        if (!interactionParameters.to) {
            throw new Error('Field "to" not provided.');
        }
        if (!interactionParameters.from) {
            throw new Error('Field "from" not provided.');
        }
        if (!interactionParameters.utxos[0]) {
            throw new Error('Missing at least one UTXO.');
        }
        if (!('signer' in interactionParameters)) {
            throw new Error('Field "signer" not provided, OP_WALLET not detected.');
        }
        const inputs = this.parseOptionalInputs(interactionParameters.optionalInputs);
        const { finalTransaction, estimatedAmount, challenge } = await this.iterateFundingAmount({ ...interactionParameters, optionalInputs: inputs }, CustomScriptTransaction, async (tx) => {
            const fee = await tx.estimateTransactionFees();
            const priorityFee = this.getPriorityFee(interactionParameters);
            const optionalValue = tx.getOptionalOutputValue();
            return fee + priorityFee + optionalValue;
        }, 'CustomScript');
        const parameters = await finalTransaction.getFundingTransactionParameters();
        parameters.utxos = interactionParameters.utxos;
        parameters.amount = estimatedAmount;
        const feeEstimationFunding = await this.createFundTransaction({
            ...parameters,
            optionalOutputs: [],
            optionalInputs: [],
        });
        if (!feeEstimationFunding) {
            throw new Error('Could not sign funding transaction.');
        }
        parameters.estimatedFees = feeEstimationFunding.estimatedFees;
        const signedTransaction = await this.createFundTransaction({
            ...parameters,
            optionalOutputs: [],
            optionalInputs: [],
        });
        if (!signedTransaction) {
            throw new Error('Could not sign funding transaction.');
        }
        const newParams = {
            ...interactionParameters,
            utxos: this.getUTXOAsTransaction(signedTransaction.tx, interactionParameters.to, 0),
            randomBytes: finalTransaction.getRndBytes(),
            nonWitnessUtxo: signedTransaction.tx.toBuffer(),
            estimatedFees: finalTransaction.estimatedFees,
            compiledTargetScript: finalTransaction.exportCompiledTargetScript(),
            optionalInputs: inputs,
        };
        const customTransaction = new CustomScriptTransaction(newParams);
        const outTx = await customTransaction.signTransaction();
        return [
            signedTransaction.tx.toHex(),
            outTx.toHex(),
            this.getUTXOAsTransaction(signedTransaction.tx, interactionParameters.from, 1),
            interactionParameters.utxos,
        ];
    }
    async signInteraction(interactionParameters) {
        if (!interactionParameters.to) {
            throw new Error('Field "to" not provided.');
        }
        if (!interactionParameters.from) {
            throw new Error('Field "from" not provided.');
        }
        if (!interactionParameters.utxos[0]) {
            throw new Error('Missing at least one UTXO.');
        }
        const opWalletInteraction = await this.detectInteractionOPWallet(interactionParameters);
        if (opWalletInteraction) {
            return opWalletInteraction;
        }
        if (!('signer' in interactionParameters)) {
            throw new Error('Field "signer" not provided, OP_WALLET not detected.');
        }
        const useP2WDA = this.hasP2WDAInputs(interactionParameters.utxos);
        if (useP2WDA) {
            return this.signP2WDAInteraction(interactionParameters);
        }
        const inputs = this.parseOptionalInputs(interactionParameters.optionalInputs);
        const { finalTransaction, estimatedAmount, challenge } = await this.iterateFundingAmount({ ...interactionParameters, optionalInputs: inputs }, InteractionTransaction, async (tx) => {
            const fee = await tx.estimateTransactionFees();
            const outputsValue = tx.getTotalOutputValue();
            return fee + outputsValue;
        }, 'Interaction');
        if (!challenge) {
            throw new Error('Failed to get challenge from interaction transaction');
        }
        const parameters = await finalTransaction.getFundingTransactionParameters();
        parameters.utxos = interactionParameters.utxos;
        parameters.amount = estimatedAmount;
        const feeEstimationFunding = await this.createFundTransaction({
            ...parameters,
            optionalOutputs: [],
            optionalInputs: [],
        });
        if (!feeEstimationFunding) {
            throw new Error('Could not sign funding transaction.');
        }
        parameters.estimatedFees = feeEstimationFunding.estimatedFees;
        const signedTransaction = await this.createFundTransaction({
            ...parameters,
            optionalOutputs: [],
            optionalInputs: [],
        });
        if (!signedTransaction) {
            throw new Error('Could not sign funding transaction.');
        }
        const fundingUTXO = this.getUTXOAsTransaction(signedTransaction.tx, finalTransaction.getScriptAddress(), 0);
        const newParams = {
            ...interactionParameters,
            utxos: fundingUTXO,
            randomBytes: finalTransaction.getRndBytes(),
            challenge: challenge,
            compiledTargetScript: finalTransaction.exportCompiledTargetScript(),
            nonWitnessUtxo: signedTransaction.tx.toBuffer(),
            estimatedFees: finalTransaction.estimatedFees,
            optionalInputs: inputs,
        };
        const interactionTx = new InteractionTransaction(newParams);
        const outTx = await interactionTx.signTransaction();
        return {
            interactionAddress: finalTransaction.getScriptAddress(),
            fundingTransaction: signedTransaction.tx.toHex(),
            interactionTransaction: outTx.toHex(),
            estimatedFees: interactionTx.transactionFee,
            nextUTXOs: this.getUTXOAsTransaction(signedTransaction.tx, interactionParameters.from, 1),
            challenge: challenge.toRaw(),
            fundingUTXOs: fundingUTXO,
            fundingInputUtxos: interactionParameters.utxos,
            compiledTargetScript: interactionTx.exportCompiledTargetScript().toString('hex'),
        };
    }
    async signConsolidatedInteraction(interactionParameters) {
        if (!interactionParameters.to) {
            throw new Error('Field "to" not provided.');
        }
        if (!interactionParameters.from) {
            throw new Error('Field "from" not provided.');
        }
        if (!interactionParameters.utxos[0]) {
            throw new Error('Missing at least one UTXO.');
        }
        if (!('signer' in interactionParameters)) {
            throw new Error('Field "signer" not provided.');
        }
        if (!interactionParameters.challenge) {
            throw new Error('Field "challenge" not provided.');
        }
        const inputs = this.parseOptionalInputs(interactionParameters.optionalInputs);
        const consolidatedTx = new ConsolidatedInteractionTransaction({
            ...interactionParameters,
            optionalInputs: inputs,
        });
        const result = await consolidatedTx.build();
        return {
            setupTransaction: result.setup.txHex,
            revealTransaction: result.reveal.txHex,
            setupTxId: result.setup.txId,
            revealTxId: result.reveal.txId,
            totalFees: result.totalFees,
            chunkCount: result.setup.chunkCount,
            dataSize: result.setup.totalDataSize,
            challenge: consolidatedTx.getChallenge().toRaw(),
            inputUtxos: interactionParameters.utxos,
            compiledTargetScript: consolidatedTx.exportCompiledTargetScript().toString('hex'),
        };
    }
    async signDeployment(deploymentParameters) {
        const opWalletDeployment = await this.detectDeploymentOPWallet(deploymentParameters);
        if (opWalletDeployment) {
            return opWalletDeployment;
        }
        if (!('signer' in deploymentParameters)) {
            throw new Error('Field "signer" not provided, OP_WALLET not detected.');
        }
        const inputs = this.parseOptionalInputs(deploymentParameters.optionalInputs);
        const { finalTransaction, estimatedAmount, challenge } = await this.iterateFundingAmount({ ...deploymentParameters, optionalInputs: inputs }, DeploymentTransaction, async (tx) => {
            const fee = await tx.estimateTransactionFees();
            const priorityFee = this.getPriorityFee(deploymentParameters);
            const optionalValue = tx.getOptionalOutputValue();
            return fee + priorityFee + optionalValue;
        }, 'Deployment');
        if (!challenge) {
            throw new Error('Failed to get challenge from deployment transaction');
        }
        const parameters = await finalTransaction.getFundingTransactionParameters();
        parameters.utxos = deploymentParameters.utxos;
        parameters.amount = estimatedAmount;
        const feeEstimationFunding = await this.createFundTransaction({
            ...parameters,
            optionalOutputs: [],
            optionalInputs: [],
        });
        if (!feeEstimationFunding) {
            throw new Error('Could not sign funding transaction.');
        }
        parameters.estimatedFees = feeEstimationFunding.estimatedFees;
        const fundingTransaction = new FundingTransaction({
            ...parameters,
            optionalInputs: [],
            optionalOutputs: [],
        });
        const signedTransaction = await fundingTransaction.signTransaction();
        if (!signedTransaction) {
            throw new Error('Could not sign funding transaction.');
        }
        const out = signedTransaction.outs[0];
        const newUtxo = {
            transactionId: signedTransaction.getId(),
            outputIndex: 0,
            scriptPubKey: {
                hex: out.script.toString('hex'),
                address: finalTransaction.getScriptAddress(),
            },
            value: BigInt(out.value),
        };
        const newParams = {
            ...deploymentParameters,
            utxos: [newUtxo],
            randomBytes: finalTransaction.getRndBytes(),
            compiledTargetScript: finalTransaction.exportCompiledTargetScript(),
            challenge: challenge,
            nonWitnessUtxo: signedTransaction.toBuffer(),
            estimatedFees: finalTransaction.estimatedFees,
            optionalInputs: inputs,
        };
        const deploymentTx = new DeploymentTransaction(newParams);
        const outTx = await deploymentTx.signTransaction();
        const out2 = signedTransaction.outs[1];
        const refundUTXO = {
            transactionId: signedTransaction.getId(),
            outputIndex: 1,
            scriptPubKey: {
                hex: out2.script.toString('hex'),
                address: deploymentParameters.from,
            },
            value: BigInt(out2.value),
        };
        return {
            transaction: [signedTransaction.toHex(), outTx.toHex()],
            contractAddress: deploymentTx.getContractAddress(),
            contractPubKey: deploymentTx.contractPubKey,
            utxos: [refundUTXO],
            challenge: challenge.toRaw(),
            inputUtxos: deploymentParameters.utxos,
        };
    }
    async createBTCTransfer(parameters) {
        if (!parameters.from) {
            throw new Error('Field "from" not provided.');
        }
        const resp = await this.createFundTransaction(parameters);
        return {
            estimatedFees: resp.estimatedFees,
            original: resp.original,
            tx: resp.tx.toHex(),
            nextUTXOs: this.getAllNewUTXOs(resp.original, resp.tx, parameters.from),
            inputUtxos: parameters.utxos,
        };
    }
    getAllNewUTXOs(original, tx, to) {
        const outputs = original.getOutputs();
        const utxos = [];
        for (let i = 0; i < tx.outs.length; i++) {
            const output = outputs[i];
            if ('address' in output) {
                if (output.address !== to)
                    continue;
            }
            else {
                continue;
            }
            utxos.push(...this.getUTXOAsTransaction(tx, to, i));
        }
        return utxos;
    }
    parseOptionalInputs(optionalInputs) {
        return (optionalInputs || []).map((input) => {
            let nonWitness = input.nonWitnessUtxo;
            if (nonWitness &&
                !(nonWitness instanceof Uint8Array) &&
                typeof nonWitness === 'object') {
                nonWitness = Buffer.from(Uint8Array.from(Object.values(input.nonWitnessUtxo)));
            }
            return {
                ...input,
                nonWitnessUtxo: nonWitness,
            };
        });
    }
    async detectCancelOPWallet(interactionParameters) {
        if (typeof window === 'undefined') {
            return null;
        }
        const _window = window;
        if (!_window || !_window.opnet || !_window.opnet.web3) {
            return null;
        }
        const opnet = _window.opnet.web3;
        const interaction = await opnet.cancelTransaction({
            ...interactionParameters,
            signer: undefined,
        });
        if (!interaction) {
            throw new Error('Could not sign interaction transaction.');
        }
        return {
            ...interaction,
            inputUtxos: interaction.inputUtxos ?? interactionParameters.utxos,
        };
    }
    async detectInteractionOPWallet(interactionParameters) {
        if (typeof window === 'undefined') {
            return null;
        }
        const _window = window;
        if (!_window || !_window.opnet || !_window.opnet.web3) {
            return null;
        }
        const opnet = _window.opnet.web3;
        const interaction = await opnet.signInteraction({
            ...interactionParameters,
            signer: undefined,
        });
        if (!interaction) {
            throw new Error('Could not sign interaction transaction.');
        }
        return {
            ...interaction,
            fundingInputUtxos: interaction.fundingInputUtxos ?? interactionParameters.utxos,
        };
    }
    async detectDeploymentOPWallet(deploymentParameters) {
        if (typeof window === 'undefined') {
            return null;
        }
        const _window = window;
        if (!_window || !_window.opnet || !_window.opnet.web3) {
            return null;
        }
        const opnet = _window.opnet.web3;
        const deployment = await opnet.deployContract({
            ...deploymentParameters,
            signer: undefined,
        });
        if (!deployment) {
            throw new Error('Could not sign interaction transaction.');
        }
        return {
            ...deployment,
            inputUtxos: deployment.inputUtxos ?? deploymentParameters.utxos,
        };
    }
    async createFundTransaction(parameters) {
        if (!parameters.to)
            throw new Error('Field "to" not provided.');
        const fundingTransaction = new FundingTransaction(parameters);
        const signedTransaction = await fundingTransaction.signTransaction();
        if (!signedTransaction) {
            throw new Error('Could not sign funding transaction.');
        }
        return {
            tx: signedTransaction,
            original: fundingTransaction,
            estimatedFees: fundingTransaction.estimatedFees,
            nextUTXOs: this.getUTXOAsTransaction(signedTransaction, parameters.to, 0),
            inputUtxos: parameters.utxos,
        };
    }
    hasP2WDAInputs(utxos) {
        return utxos.some((utxo) => P2WDADetector.isP2WDAUTXO(utxo));
    }
    writePSBTHeader(type, psbt) {
        const buf = Buffer.from(psbt, 'base64');
        const header = Buffer.alloc(2);
        header.writeUInt8(type, 0);
        header.writeUInt8(currentConsensus, 1);
        return Buffer.concat([header, buf]).toString('hex');
    }
    async signP2WDAInteraction(interactionParameters) {
        if (!interactionParameters.from) {
            throw new Error('Field "from" not provided.');
        }
        if (!('signer' in interactionParameters)) {
            throw new Error('P2WDA interactions require a signer. OP_WALLET is not supported for P2WDA.');
        }
        const inputs = this.parseOptionalInputs(interactionParameters.optionalInputs);
        const p2wdaTransaction = new InteractionTransactionP2WDA({
            ...interactionParameters,
            optionalInputs: inputs,
        });
        const signedTx = await p2wdaTransaction.signTransaction();
        const txHex = signedTx.toHex();
        return {
            interactionAddress: null,
            fundingTransaction: null,
            interactionTransaction: txHex,
            estimatedFees: p2wdaTransaction.estimatedFees,
            nextUTXOs: this.getUTXOAsTransaction(signedTx, interactionParameters.from, signedTx.outs.length - 1),
            fundingUTXOs: [...interactionParameters.utxos, ...inputs],
            fundingInputUtxos: interactionParameters.utxos,
            challenge: interactionParameters.challenge.toRaw(),
            compiledTargetScript: null,
        };
    }
    getPriorityFee(params) {
        const totalFee = params.priorityFee + params.gasSatFee;
        if (totalFee < TransactionBuilder.MINIMUM_DUST) {
            return TransactionBuilder.MINIMUM_DUST;
        }
        return totalFee;
    }
    async iterateFundingAmount(params, TransactionClass, calculateAmount, debugPrefix) {
        const randomBytes = 'randomBytes' in params
            ? (params.randomBytes ?? BitcoinUtils.rndBytes())
            : BitcoinUtils.rndBytes();
        const dummyAddress = Address.dead().p2tr(params.network);
        let estimatedFundingAmount = this.INITIAL_FUNDING_ESTIMATE;
        let previousAmount = 0n;
        let iterations = 0;
        let finalPreTransaction = null;
        let challenge = null;
        while (iterations < this.MAX_ITERATIONS && estimatedFundingAmount !== previousAmount) {
            previousAmount = estimatedFundingAmount;
            const dummyTx = new Transaction();
            dummyTx.addOutput(this.P2TR_SCRIPT, Number(estimatedFundingAmount));
            const simulatedFundedUtxo = {
                transactionId: Buffer.alloc(32, 0).toString('hex'),
                outputIndex: 0,
                scriptPubKey: {
                    hex: this.P2TR_SCRIPT.toString('hex'),
                    address: dummyAddress,
                },
                value: estimatedFundingAmount,
                nonWitnessUtxo: dummyTx.toBuffer(),
            };
            let txParams;
            if ('challenge' in params && params.challenge) {
                const withChallenge = {
                    ...params,
                    utxos: [simulatedFundedUtxo],
                    randomBytes: randomBytes,
                    challenge: challenge ?? params.challenge,
                };
                txParams = withChallenge;
            }
            else {
                const withoutChallenge = {
                    ...params,
                    utxos: [simulatedFundedUtxo],
                    randomBytes: randomBytes,
                };
                txParams = withoutChallenge;
            }
            const preTransaction = new TransactionClass(txParams);
            try {
                await preTransaction.generateTransactionMinimalSignatures();
                estimatedFundingAmount = await calculateAmount(preTransaction);
            }
            catch (error) {
                if (error instanceof Error) {
                    const match = error.message.match(/need (\d+) sats but only have (\d+) sats/);
                    if (match) {
                        estimatedFundingAmount = BigInt(match[1]);
                        if (this.debug) {
                            console.log(`${debugPrefix}: Caught insufficient funds, updating to ${estimatedFundingAmount}`);
                        }
                    }
                    else {
                        throw error;
                    }
                }
                else {
                    throw new Error('Unknown error during fee estimation');
                }
            }
            finalPreTransaction = preTransaction;
            if ('getChallenge' in preTransaction &&
                typeof preTransaction.getChallenge === 'function') {
                challenge = preTransaction.getChallenge();
            }
            iterations++;
            if (this.debug) {
                console.log(`${debugPrefix} Iteration ${iterations}: Previous=${previousAmount}, New=${estimatedFundingAmount}`);
            }
        }
        if (!finalPreTransaction) {
            throw new Error(`Failed to converge on ${debugPrefix} funding amount`);
        }
        return {
            finalTransaction: finalPreTransaction,
            estimatedAmount: estimatedFundingAmount,
            challenge,
        };
    }
    getUTXOAsTransaction(tx, to, index) {
        if (!tx.outs[index])
            return [];
        const out = tx.outs[index];
        const newUtxo = {
            transactionId: tx.getId(),
            outputIndex: index,
            scriptPubKey: {
                hex: out.script.toString('hex'),
                address: to,
            },
            value: BigInt(out.value),
        };
        return [newUtxo];
    }
}
