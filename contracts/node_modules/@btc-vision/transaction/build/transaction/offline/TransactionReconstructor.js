import { networks } from '@btc-vision/bitcoin';
import { ChallengeSolution } from '../../epoch/ChallengeSolution.js';
import { FundingTransaction } from '../builders/FundingTransaction.js';
import { DeploymentTransaction } from '../builders/DeploymentTransaction.js';
import { InteractionTransaction } from '../builders/InteractionTransaction.js';
import { MultiSignTransaction } from '../builders/MultiSignTransaction.js';
import { CustomScriptTransaction } from '../builders/CustomScriptTransaction.js';
import { CancelTransaction } from '../builders/CancelTransaction.js';
import { isCancelSpecificData, isCustomScriptSpecificData, isDeploymentSpecificData, isFundingSpecificData, isInteractionSpecificData, isMultiSigSpecificData, } from './interfaces/ITypeSpecificData.js';
export class TransactionReconstructor {
    static reconstruct(state, options) {
        const network = this.nameToNetwork(state.baseParams.networkName);
        const utxos = this.deserializeUTXOs(state.utxos);
        const optionalInputs = this.deserializeUTXOs(state.optionalInputs);
        const optionalOutputs = this.deserializeOutputs(state.optionalOutputs);
        const addressRotation = this.buildAddressRotationConfig(state.addressRotationEnabled, options.signerMap);
        const feeRate = options.newFeeRate ?? state.baseParams.feeRate;
        const priorityFee = options.newPriorityFee ?? BigInt(state.baseParams.priorityFee);
        const gasSatFee = options.newGasSatFee ?? BigInt(state.baseParams.gasSatFee);
        const baseParams = {
            signer: options.signer,
            mldsaSigner: options.mldsaSigner ?? null,
            network,
            chainId: state.header.chainId,
            utxos,
            optionalInputs,
            optionalOutputs,
            from: state.baseParams.from,
            to: state.baseParams.to,
            feeRate,
            priorityFee,
            gasSatFee,
            txVersion: state.baseParams.txVersion,
            note: state.baseParams.note ? Buffer.from(state.baseParams.note, 'hex') : undefined,
            anchor: state.baseParams.anchor,
            debugFees: state.baseParams.debugFees,
            addressRotation,
            estimatedFees: state.precomputedData.estimatedFees
                ? BigInt(state.precomputedData.estimatedFees)
                : undefined,
            compiledTargetScript: state.precomputedData.compiledTargetScript
                ? Buffer.from(state.precomputedData.compiledTargetScript, 'hex')
                : undefined,
        };
        const typeData = state.typeSpecificData;
        if (isFundingSpecificData(typeData)) {
            return this.reconstructFunding(baseParams, typeData);
        }
        else if (isDeploymentSpecificData(typeData)) {
            return this.reconstructDeployment(baseParams, typeData, state);
        }
        else if (isInteractionSpecificData(typeData)) {
            return this.reconstructInteraction(baseParams, typeData, state);
        }
        else if (isMultiSigSpecificData(typeData)) {
            return this.reconstructMultiSig(baseParams, typeData);
        }
        else if (isCustomScriptSpecificData(typeData)) {
            return this.reconstructCustomScript(baseParams, typeData, state);
        }
        else if (isCancelSpecificData(typeData)) {
            return this.reconstructCancel(baseParams, typeData);
        }
        throw new Error(`Unsupported transaction type: ${state.header.transactionType}`);
    }
    static reconstructFunding(baseParams, data) {
        const params = {
            ...baseParams,
            amount: BigInt(data.amount),
            splitInputsInto: data.splitInputsInto,
        };
        return new FundingTransaction(params);
    }
    static reconstructDeployment(baseParams, data, state) {
        const challenge = new ChallengeSolution(data.challenge);
        const params = {
            ...baseParams,
            bytecode: Buffer.from(data.bytecode, 'hex'),
            calldata: data.calldata ? Buffer.from(data.calldata, 'hex') : undefined,
            challenge,
            randomBytes: state.precomputedData.randomBytes
                ? Buffer.from(state.precomputedData.randomBytes, 'hex')
                : undefined,
            revealMLDSAPublicKey: data.revealMLDSAPublicKey,
            linkMLDSAPublicKeyToAddress: data.linkMLDSAPublicKeyToAddress,
        };
        return new DeploymentTransaction(params);
    }
    static reconstructInteraction(baseParams, data, state) {
        const challenge = new ChallengeSolution(data.challenge);
        if (!baseParams.to) {
            throw new Error('InteractionTransaction requires a "to" address');
        }
        const params = {
            ...baseParams,
            to: baseParams.to,
            calldata: Buffer.from(data.calldata, 'hex'),
            contract: data.contract,
            challenge,
            randomBytes: state.precomputedData.randomBytes
                ? Buffer.from(state.precomputedData.randomBytes, 'hex')
                : undefined,
            loadedStorage: data.loadedStorage,
            isCancellation: data.isCancellation,
            disableAutoRefund: data.disableAutoRefund,
            revealMLDSAPublicKey: data.revealMLDSAPublicKey,
            linkMLDSAPublicKeyToAddress: data.linkMLDSAPublicKeyToAddress,
        };
        return new InteractionTransaction(params);
    }
    static reconstructMultiSig(baseParams, data) {
        const pubkeys = data.pubkeys.map((pk) => Buffer.from(pk, 'hex'));
        if (data.existingPsbtBase64) {
            return MultiSignTransaction.fromBase64({
                mldsaSigner: baseParams.mldsaSigner,
                network: baseParams.network,
                chainId: baseParams.chainId,
                utxos: baseParams.utxos,
                optionalInputs: baseParams.optionalInputs,
                optionalOutputs: baseParams.optionalOutputs,
                feeRate: baseParams.feeRate,
                pubkeys,
                minimumSignatures: data.minimumSignatures,
                receiver: data.receiver,
                requestedAmount: BigInt(data.requestedAmount),
                refundVault: data.refundVault,
                psbt: data.existingPsbtBase64,
            });
        }
        const params = {
            mldsaSigner: baseParams.mldsaSigner,
            network: baseParams.network,
            chainId: baseParams.chainId,
            utxos: baseParams.utxos,
            optionalInputs: baseParams.optionalInputs,
            optionalOutputs: baseParams.optionalOutputs,
            feeRate: baseParams.feeRate,
            pubkeys,
            minimumSignatures: data.minimumSignatures,
            receiver: data.receiver,
            requestedAmount: BigInt(data.requestedAmount),
            refundVault: data.refundVault,
        };
        return new MultiSignTransaction(params);
    }
    static reconstructCustomScript(baseParams, data, state) {
        const scriptElements = data.scriptElements.map((el) => {
            if (el.elementType === 'buffer') {
                return Buffer.from(el.value, 'hex');
            }
            return [el.value];
        });
        const witnesses = data.witnesses.map((w) => Buffer.from(w, 'hex'));
        const annex = data.annex ? Buffer.from(data.annex, 'hex') : undefined;
        if (!baseParams.to) {
            throw new Error('CustomScriptTransaction requires a "to" address');
        }
        const params = {
            ...baseParams,
            to: baseParams.to,
            script: scriptElements,
            witnesses,
            annex,
            randomBytes: state.precomputedData.randomBytes
                ? Buffer.from(state.precomputedData.randomBytes, 'hex')
                : undefined,
        };
        return new CustomScriptTransaction(params);
    }
    static reconstructCancel(baseParams, data) {
        const params = {
            ...baseParams,
            compiledTargetScript: Buffer.from(data.compiledTargetScript, 'hex'),
        };
        return new CancelTransaction(params);
    }
    static buildAddressRotationConfig(enabled, signerMap) {
        if (!enabled) {
            return undefined;
        }
        if (!signerMap || signerMap.size === 0) {
            throw new Error('Address rotation enabled but no signerMap provided in reconstruction options');
        }
        return {
            enabled: true,
            signerMap,
        };
    }
    static deserializeUTXOs(serialized) {
        return serialized.map((s) => ({
            transactionId: s.transactionId,
            outputIndex: s.outputIndex,
            value: BigInt(s.value),
            scriptPubKey: {
                hex: s.scriptPubKeyHex,
                address: s.scriptPubKeyAddress,
            },
            redeemScript: s.redeemScript ? Buffer.from(s.redeemScript, 'hex') : undefined,
            witnessScript: s.witnessScript ? Buffer.from(s.witnessScript, 'hex') : undefined,
            nonWitnessUtxo: s.nonWitnessUtxo ? Buffer.from(s.nonWitnessUtxo, 'hex') : undefined,
        }));
    }
    static deserializeOutputs(serialized) {
        return serialized.map((s) => {
            const tapInternalKey = s.tapInternalKey
                ? Buffer.from(s.tapInternalKey, 'hex')
                : undefined;
            if (s.address) {
                return {
                    value: s.value,
                    address: s.address,
                    tapInternalKey,
                };
            }
            else if (s.script) {
                return {
                    value: s.value,
                    script: Buffer.from(s.script, 'hex'),
                    tapInternalKey,
                };
            }
            else {
                return {
                    value: s.value,
                    address: '',
                    tapInternalKey,
                };
            }
        });
    }
    static nameToNetwork(name) {
        switch (name) {
            case 'mainnet':
                return networks.bitcoin;
            case 'testnet':
                return networks.testnet;
            case 'regtest':
                return networks.regtest;
            default:
                throw new Error(`Unknown network: ${name}`);
        }
    }
}
