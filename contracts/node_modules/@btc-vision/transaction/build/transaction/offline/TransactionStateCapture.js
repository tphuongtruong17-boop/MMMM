import { ChainId } from '../../network/ChainId.js';
import { currentConsensus } from '../../consensus/ConsensusConfig.js';
import { TransactionType } from '../enums/TransactionType.js';
import { SERIALIZATION_FORMAT_VERSION, } from './interfaces/ISerializableState.js';
export class TransactionStateCapture {
    static fromFunding(params, precomputed) {
        return this.captureState({
            params,
            type: TransactionType.FUNDING,
            precomputed,
        });
    }
    static fromDeployment(params, precomputed) {
        return this.captureState({
            params: params,
            type: TransactionType.DEPLOYMENT,
            precomputed,
        });
    }
    static fromInteraction(params, precomputed) {
        return this.captureState({
            params,
            type: TransactionType.INTERACTION,
            precomputed,
        });
    }
    static fromMultiSig(params, precomputed) {
        return this.captureState({
            params,
            type: TransactionType.MULTI_SIG,
            precomputed,
        });
    }
    static fromCustomScript(params, precomputed) {
        return this.captureState({
            params,
            type: TransactionType.CUSTOM_CODE,
            precomputed,
        });
    }
    static fromCancel(params, precomputed) {
        return this.captureState({
            params,
            type: TransactionType.CANCEL,
            precomputed,
        });
    }
    static captureState(capture) {
        const { params, type, precomputed } = capture;
        return {
            header: this.createHeader(type, params.network, params.chainId),
            baseParams: this.extractBaseParams(params),
            utxos: this.serializeUTXOs(params.utxos),
            optionalInputs: this.serializeUTXOs(params.optionalInputs || []),
            optionalOutputs: this.serializeOutputs(params.optionalOutputs || []),
            addressRotationEnabled: params.addressRotation?.enabled ?? false,
            signerMappings: this.extractSignerMappings(params),
            typeSpecificData: this.extractTypeSpecificData(type, params),
            precomputedData: this.buildPrecomputedData(precomputed),
        };
    }
    static createHeader(type, network, chainId) {
        return {
            formatVersion: SERIALIZATION_FORMAT_VERSION,
            consensusVersion: currentConsensus,
            transactionType: type,
            chainId: chainId ?? this.networkToChainId(network),
            timestamp: Date.now(),
        };
    }
    static extractBaseParams(params) {
        const note = params.note
            ? Buffer.isBuffer(params.note)
                ? params.note.toString('hex')
                : Buffer.from(params.note).toString('hex')
            : undefined;
        const priorityFee = params.priorityFee ?? 0n;
        const gasSatFee = params.gasSatFee ?? 0n;
        return {
            from: params.from || '',
            to: params.to,
            feeRate: params.feeRate,
            priorityFee: priorityFee.toString(),
            gasSatFee: gasSatFee.toString(),
            networkName: this.networkToName(params.network),
            txVersion: params.txVersion ?? 2,
            note,
            anchor: params.anchor ?? false,
            debugFees: params.debugFees,
        };
    }
    static extractSignerMappings(params) {
        if (!params.addressRotation?.enabled) {
            return [];
        }
        const mappings = [];
        const addressToIndices = new Map();
        params.utxos.forEach((utxo, index) => {
            const address = utxo.scriptPubKey?.address;
            if (address) {
                const existing = addressToIndices.get(address);
                if (existing) {
                    existing.push(index);
                }
                else {
                    addressToIndices.set(address, [index]);
                }
            }
        });
        const utxoCount = params.utxos.length;
        (params.optionalInputs || []).forEach((utxo, index) => {
            const address = utxo.scriptPubKey?.address;
            if (address) {
                const existing = addressToIndices.get(address);
                if (existing) {
                    existing.push(utxoCount + index);
                }
                else {
                    addressToIndices.set(address, [utxoCount + index]);
                }
            }
        });
        addressToIndices.forEach((indices, address) => {
            mappings.push({ address, inputIndices: indices });
        });
        return mappings;
    }
    static extractTypeSpecificData(type, params) {
        switch (type) {
            case TransactionType.FUNDING:
                return this.extractFundingData(params);
            case TransactionType.DEPLOYMENT:
                return this.extractDeploymentData(params);
            case TransactionType.INTERACTION:
                return this.extractInteractionData(params);
            case TransactionType.MULTI_SIG:
                return this.extractMultiSigData(params);
            case TransactionType.CUSTOM_CODE:
                return this.extractCustomScriptData(params);
            case TransactionType.CANCEL:
                return this.extractCancelData(params);
            default:
                throw new Error(`Unsupported transaction type: ${type}`);
        }
    }
    static extractFundingData(params) {
        return {
            type: TransactionType.FUNDING,
            amount: params.amount.toString(),
            splitInputsInto: params.splitInputsInto ?? 1,
        };
    }
    static extractDeploymentData(params) {
        return {
            type: TransactionType.DEPLOYMENT,
            bytecode: params.bytecode.toString('hex'),
            calldata: params.calldata?.toString('hex'),
            challenge: params.challenge.toRaw(),
            revealMLDSAPublicKey: params.revealMLDSAPublicKey,
            linkMLDSAPublicKeyToAddress: params.linkMLDSAPublicKeyToAddress,
        };
    }
    static extractInteractionData(params) {
        return {
            type: TransactionType.INTERACTION,
            calldata: params.calldata.toString('hex'),
            contract: params.contract,
            challenge: params.challenge.toRaw(),
            loadedStorage: params.loadedStorage,
            isCancellation: params.isCancellation,
            disableAutoRefund: params.disableAutoRefund,
            revealMLDSAPublicKey: params.revealMLDSAPublicKey,
            linkMLDSAPublicKeyToAddress: params.linkMLDSAPublicKeyToAddress,
        };
    }
    static extractMultiSigData(params) {
        return {
            type: TransactionType.MULTI_SIG,
            pubkeys: (params.pubkeys || []).map((pk) => pk.toString('hex')),
            minimumSignatures: params.minimumSignatures || 0,
            receiver: params.receiver || '',
            requestedAmount: (params.requestedAmount || 0n).toString(),
            refundVault: params.refundVault || '',
            originalInputCount: params.originalInputCount || params.utxos.length,
            existingPsbtBase64: params.existingPsbtBase64,
        };
    }
    static extractCustomScriptData(params) {
        const scriptElements = (params.scriptElements || []).map((element) => {
            if (Buffer.isBuffer(element)) {
                return {
                    elementType: 'buffer',
                    value: element.toString('hex'),
                };
            }
            else {
                return {
                    elementType: 'opcode',
                    value: element,
                };
            }
        });
        return {
            type: TransactionType.CUSTOM_CODE,
            scriptElements,
            witnesses: (params.witnesses || []).map((w) => w.toString('hex')),
            annex: params.annex?.toString('hex'),
        };
    }
    static extractCancelData(params) {
        const script = params.compiledTargetScript;
        const scriptHex = script ? (Buffer.isBuffer(script) ? script.toString('hex') : script) : '';
        return {
            type: TransactionType.CANCEL,
            compiledTargetScript: scriptHex,
        };
    }
    static buildPrecomputedData(precomputed) {
        return {
            compiledTargetScript: precomputed?.compiledTargetScript,
            randomBytes: precomputed?.randomBytes,
            estimatedFees: precomputed?.estimatedFees,
            contractSeed: precomputed?.contractSeed,
            contractAddress: precomputed?.contractAddress,
        };
    }
    static serializeUTXOs(utxos) {
        return utxos.map((utxo) => ({
            transactionId: utxo.transactionId,
            outputIndex: utxo.outputIndex,
            value: utxo.value.toString(),
            scriptPubKeyHex: utxo.scriptPubKey.hex,
            scriptPubKeyAddress: utxo.scriptPubKey.address,
            redeemScript: utxo.redeemScript
                ? Buffer.isBuffer(utxo.redeemScript)
                    ? utxo.redeemScript.toString('hex')
                    : utxo.redeemScript
                : undefined,
            witnessScript: utxo.witnessScript
                ? Buffer.isBuffer(utxo.witnessScript)
                    ? utxo.witnessScript.toString('hex')
                    : utxo.witnessScript
                : undefined,
            nonWitnessUtxo: utxo.nonWitnessUtxo
                ? Buffer.isBuffer(utxo.nonWitnessUtxo)
                    ? utxo.nonWitnessUtxo.toString('hex')
                    : utxo.nonWitnessUtxo
                : undefined,
        }));
    }
    static serializeOutputs(outputs) {
        return outputs.map((output) => {
            const address = 'address' in output ? output.address : undefined;
            const script = 'script' in output ? output.script : undefined;
            return {
                value: output.value,
                address,
                script: script ? script.toString('hex') : undefined,
                tapInternalKey: output.tapInternalKey
                    ? output.tapInternalKey.toString('hex')
                    : undefined,
            };
        });
    }
    static networkToName(network) {
        if (network.bech32 === 'bc')
            return 'mainnet';
        if (network.bech32 === 'tb')
            return 'testnet';
        return 'regtest';
    }
    static networkToChainId(network) {
        return ChainId.Bitcoin;
    }
}
