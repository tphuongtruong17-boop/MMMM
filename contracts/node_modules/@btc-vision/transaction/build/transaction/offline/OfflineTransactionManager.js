import { Psbt } from '@btc-vision/bitcoin';
import { TransactionType } from '../enums/TransactionType.js';
import { TransactionBuilder } from '../builders/TransactionBuilder.js';
import { MultiSignTransaction } from '../builders/MultiSignTransaction.js';
import { TransactionSerializer } from './TransactionSerializer.js';
import { TransactionReconstructor } from './TransactionReconstructor.js';
import { TransactionStateCapture } from './TransactionStateCapture.js';
import { isMultiSigSpecificData } from './interfaces/ITypeSpecificData.js';
export class OfflineTransactionManager {
    static exportFunding(params, precomputed) {
        const state = TransactionStateCapture.fromFunding(params, precomputed);
        return TransactionSerializer.toBase64(state);
    }
    static exportDeployment(params, precomputed) {
        const state = TransactionStateCapture.fromDeployment(params, precomputed);
        return TransactionSerializer.toBase64(state);
    }
    static exportInteraction(params, precomputed) {
        const state = TransactionStateCapture.fromInteraction(params, precomputed);
        return TransactionSerializer.toBase64(state);
    }
    static exportMultiSig(params, precomputed) {
        const state = TransactionStateCapture.fromMultiSig(params, precomputed);
        return TransactionSerializer.toBase64(state);
    }
    static exportCustomScript(params, precomputed) {
        const state = TransactionStateCapture.fromCustomScript(params, precomputed);
        return TransactionSerializer.toBase64(state);
    }
    static exportCancel(params, precomputed) {
        const state = TransactionStateCapture.fromCancel(params, precomputed);
        return TransactionSerializer.toBase64(state);
    }
    static exportFromBuilder(builder, params, precomputed) {
        const type = builder.type;
        let state;
        switch (type) {
            case TransactionType.FUNDING:
                state = TransactionStateCapture.fromFunding(params, precomputed);
                break;
            case TransactionType.DEPLOYMENT:
                state = TransactionStateCapture.fromDeployment(params, precomputed);
                break;
            case TransactionType.INTERACTION:
                state = TransactionStateCapture.fromInteraction(params, precomputed);
                break;
            default:
                throw new Error(`Unsupported transaction type for export: ${type}`);
        }
        return TransactionSerializer.toBase64(state);
    }
    static importForSigning(serializedState, options) {
        const state = TransactionSerializer.fromBase64(serializedState);
        return TransactionReconstructor.reconstruct(state, options);
    }
    static async signAndExport(builder) {
        const tx = await builder.signTransaction();
        return tx.toHex();
    }
    static async importSignAndExport(serializedState, options) {
        const builder = this.importForSigning(serializedState, options);
        return this.signAndExport(builder);
    }
    static rebuildWithNewFees(serializedState, newFeeRate) {
        const state = TransactionSerializer.fromBase64(serializedState);
        const newState = {
            ...state,
            baseParams: {
                ...state.baseParams,
                feeRate: newFeeRate,
            },
        };
        return TransactionSerializer.toBase64(newState);
    }
    static async rebuildSignAndExport(serializedState, newFeeRate, options) {
        const builder = this.importForSigning(serializedState, {
            ...options,
            newFeeRate,
        });
        return this.signAndExport(builder);
    }
    static inspect(serializedState) {
        return TransactionSerializer.fromBase64(serializedState);
    }
    static validate(serializedState) {
        try {
            TransactionSerializer.fromBase64(serializedState);
            return true;
        }
        catch {
            return false;
        }
    }
    static getType(serializedState) {
        const state = TransactionSerializer.fromBase64(serializedState);
        return state.header.transactionType;
    }
    static fromBase64(base64State) {
        return TransactionSerializer.fromBase64(base64State);
    }
    static toBase64(state) {
        return TransactionSerializer.toBase64(state);
    }
    static toHex(serializedState) {
        const state = TransactionSerializer.fromBase64(serializedState);
        return TransactionSerializer.toHex(state);
    }
    static fromHex(hexState) {
        const state = TransactionSerializer.fromHex(hexState);
        return TransactionSerializer.toBase64(state);
    }
    static async multiSigAddSignature(serializedState, signer) {
        const state = TransactionSerializer.fromBase64(serializedState);
        if (!isMultiSigSpecificData(state.typeSpecificData)) {
            throw new Error('State is not a multisig transaction');
        }
        const typeData = state.typeSpecificData;
        const pubkeys = typeData.pubkeys.map((pk) => Buffer.from(pk, 'hex'));
        let psbt;
        const network = TransactionReconstructor['nameToNetwork'](state.baseParams.networkName);
        if (typeData.existingPsbtBase64) {
            psbt = Psbt.fromBase64(typeData.existingPsbtBase64, { network });
        }
        else {
            const builder = this.importForSigning(serializedState, {
                signer,
            });
            psbt = await builder.signPSBT();
        }
        const minimums = [];
        for (let i = typeData.originalInputCount; i < psbt.data.inputs.length; i++) {
            minimums.push(typeData.minimumSignatures);
        }
        const result = MultiSignTransaction.signPartial(psbt, signer, typeData.originalInputCount, minimums);
        const orderedPubKeys = [];
        for (let i = typeData.originalInputCount; i < psbt.data.inputs.length; i++) {
            orderedPubKeys.push(pubkeys);
        }
        MultiSignTransaction.attemptFinalizeInputs(psbt, typeData.originalInputCount, orderedPubKeys, result.final);
        const newPsbtBase64 = psbt.toBase64();
        const newState = {
            ...state,
            typeSpecificData: {
                ...typeData,
                existingPsbtBase64: newPsbtBase64,
            },
        };
        return {
            state: TransactionSerializer.toBase64(newState),
            signed: result.signed,
            final: result.final,
            psbtBase64: newPsbtBase64,
        };
    }
    static multiSigHasSigned(serializedState, signerPubKey) {
        const state = TransactionSerializer.fromBase64(serializedState);
        if (!isMultiSigSpecificData(state.typeSpecificData)) {
            throw new Error('State is not a multisig transaction');
        }
        const typeData = state.typeSpecificData;
        if (!typeData.existingPsbtBase64) {
            return false;
        }
        const network = TransactionReconstructor['nameToNetwork'](state.baseParams.networkName);
        const psbt = Psbt.fromBase64(typeData.existingPsbtBase64, { network });
        const pubKeyBuffer = Buffer.isBuffer(signerPubKey)
            ? signerPubKey
            : Buffer.from(signerPubKey, 'hex');
        return MultiSignTransaction.verifyIfSigned(psbt, pubKeyBuffer);
    }
    static multiSigGetSignatureStatus(serializedState) {
        const state = TransactionSerializer.fromBase64(serializedState);
        if (!isMultiSigSpecificData(state.typeSpecificData)) {
            throw new Error('State is not a multisig transaction');
        }
        const typeData = state.typeSpecificData;
        const required = typeData.minimumSignatures;
        if (!typeData.existingPsbtBase64) {
            return {
                required,
                collected: 0,
                isComplete: false,
                signers: [],
            };
        }
        const network = TransactionReconstructor['nameToNetwork'](state.baseParams.networkName);
        const psbt = Psbt.fromBase64(typeData.existingPsbtBase64, { network });
        const signerSet = new Set();
        for (let i = typeData.originalInputCount; i < psbt.data.inputs.length; i++) {
            const input = psbt.data.inputs[i];
            if (input.tapScriptSig) {
                for (const sig of input.tapScriptSig) {
                    signerSet.add(sig.pubkey.toString('hex'));
                }
            }
            if (input.finalScriptWitness) {
                const decoded = TransactionBuilder.readScriptWitnessToWitnessStack(input.finalScriptWitness);
                for (let j = 0; j < decoded.length - 2; j += 3) {
                    const pubKey = decoded[j + 2];
                    signerSet.add(pubKey.toString('hex'));
                }
            }
        }
        const signers = Array.from(signerSet);
        return {
            required,
            collected: signers.length,
            isComplete: signers.length >= required,
            signers,
        };
    }
    static multiSigFinalize(serializedState) {
        const state = TransactionSerializer.fromBase64(serializedState);
        if (!isMultiSigSpecificData(state.typeSpecificData)) {
            throw new Error('State is not a multisig transaction');
        }
        const typeData = state.typeSpecificData;
        if (!typeData.existingPsbtBase64) {
            throw new Error('No PSBT found in state - transaction has not been signed');
        }
        const network = TransactionReconstructor['nameToNetwork'](state.baseParams.networkName);
        const psbt = Psbt.fromBase64(typeData.existingPsbtBase64, { network });
        const pubkeys = typeData.pubkeys.map((pk) => Buffer.from(pk, 'hex'));
        const orderedPubKeys = [];
        for (let i = typeData.originalInputCount; i < psbt.data.inputs.length; i++) {
            orderedPubKeys.push(pubkeys);
        }
        const success = MultiSignTransaction.attemptFinalizeInputs(psbt, typeData.originalInputCount, orderedPubKeys, true);
        if (!success) {
            throw new Error('Failed to finalize multisig transaction - not enough signatures');
        }
        return psbt.extractTransaction(true, true).toHex();
    }
    static multiSigGetPsbt(serializedState) {
        const state = TransactionSerializer.fromBase64(serializedState);
        if (!isMultiSigSpecificData(state.typeSpecificData)) {
            throw new Error('State is not a multisig transaction');
        }
        return state.typeSpecificData.existingPsbtBase64 || null;
    }
    static multiSigUpdatePsbt(serializedState, psbtBase64) {
        const state = TransactionSerializer.fromBase64(serializedState);
        if (!isMultiSigSpecificData(state.typeSpecificData)) {
            throw new Error('State is not a multisig transaction');
        }
        const newState = {
            ...state,
            typeSpecificData: {
                ...state.typeSpecificData,
                existingPsbtBase64: psbtBase64,
            },
        };
        return TransactionSerializer.toBase64(newState);
    }
}
