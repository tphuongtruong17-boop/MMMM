import { Signer } from '@btc-vision/bitcoin';
import { ECPairInterface } from 'ecpair';
import { TransactionType } from '../enums/TransactionType.js';
import { TransactionBuilder } from '../builders/TransactionBuilder.js';
import { ISerializableTransactionState, PrecomputedData } from './interfaces/ISerializableState.js';
import { ReconstructionOptions } from './TransactionReconstructor.js';
import { IDeploymentParameters, IFundingTransactionParameters, IInteractionParameters, ITransactionParameters } from '../interfaces/ITransactionParameters.js';
export interface ExportOptions {
    params: ITransactionParameters;
    type: TransactionType;
    precomputed?: Partial<PrecomputedData>;
}
export declare class OfflineTransactionManager {
    static exportFunding(params: IFundingTransactionParameters, precomputed?: Partial<PrecomputedData>): string;
    static exportDeployment(params: IDeploymentParameters, precomputed: Partial<PrecomputedData> & {
        compiledTargetScript: string;
        randomBytes: string;
    }): string;
    static exportInteraction(params: IInteractionParameters, precomputed: Partial<PrecomputedData> & {
        compiledTargetScript: string;
        randomBytes: string;
    }): string;
    static exportMultiSig(params: ITransactionParameters & {
        pubkeys: Buffer[];
        minimumSignatures: number;
        receiver: string;
        requestedAmount: bigint;
        refundVault: string;
        originalInputCount?: number;
        existingPsbtBase64?: string;
    }, precomputed?: Partial<PrecomputedData>): string;
    static exportCustomScript(params: ITransactionParameters & {
        scriptElements: (Buffer | number)[];
        witnesses: Buffer[];
        annex?: Buffer;
    }, precomputed?: Partial<PrecomputedData>): string;
    static exportCancel(params: ITransactionParameters & {
        compiledTargetScript: Buffer | string;
    }, precomputed?: Partial<PrecomputedData>): string;
    static exportFromBuilder<T extends TransactionType>(builder: TransactionBuilder<T>, params: ITransactionParameters, precomputed?: Partial<PrecomputedData>): string;
    static importForSigning(serializedState: string, options: ReconstructionOptions): TransactionBuilder<TransactionType>;
    static signAndExport(builder: TransactionBuilder<TransactionType>): Promise<string>;
    static importSignAndExport(serializedState: string, options: ReconstructionOptions): Promise<string>;
    static rebuildWithNewFees(serializedState: string, newFeeRate: number): string;
    static rebuildSignAndExport(serializedState: string, newFeeRate: number, options: ReconstructionOptions): Promise<string>;
    static inspect(serializedState: string): ISerializableTransactionState;
    static validate(serializedState: string): boolean;
    static getType(serializedState: string): TransactionType;
    static fromBase64(base64State: string): ISerializableTransactionState;
    static toBase64(state: ISerializableTransactionState): string;
    static toHex(serializedState: string): string;
    static fromHex(hexState: string): string;
    static multiSigAddSignature(serializedState: string, signer: Signer | ECPairInterface): Promise<{
        state: string;
        signed: boolean;
        final: boolean;
        psbtBase64: string;
    }>;
    static multiSigHasSigned(serializedState: string, signerPubKey: Buffer | string): boolean;
    static multiSigGetSignatureStatus(serializedState: string): {
        required: number;
        collected: number;
        isComplete: boolean;
        signers: string[];
    };
    static multiSigFinalize(serializedState: string): string;
    static multiSigGetPsbt(serializedState: string): string | null;
    static multiSigUpdatePsbt(serializedState: string, psbtBase64: string): string;
}
