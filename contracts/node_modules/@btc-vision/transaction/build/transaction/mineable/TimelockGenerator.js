import bitcoin, { networks, opcodes, script } from '@btc-vision/bitcoin';
export class TimeLockGenerator {
    static generateTimeLockAddress(publicKey, network = networks.bitcoin, csvBlocks = TimeLockGenerator.CSV_BLOCKS) {
        const witnessScript = this.generateTimeLockScript(publicKey, csvBlocks);
        const p2wsh = bitcoin.payments.p2wsh({
            redeem: { output: witnessScript },
            network,
        });
        if (!p2wsh.address) {
            throw new Error('Failed to generate P2WSH address');
        }
        return {
            address: p2wsh.address,
            witnessScript: witnessScript,
        };
    }
    static generateTimeLockAddressP2TR(publicKey, network = networks.bitcoin, csvBlocks = TimeLockGenerator.CSV_BLOCKS) {
        if (publicKey.length !== 32) {
            throw new Error('Public key must be 32 bytes for Taproot');
        }
        const witnessScript = this.generateTimeLockScript(publicKey, csvBlocks);
        const taproot = bitcoin.payments.p2tr({
            redeem: { output: witnessScript },
            network,
            internalPubkey: TimeLockGenerator.UNSPENDABLE_INTERNAL_KEY,
        });
        if (!taproot.address) {
            throw new Error('Failed to generate P2TR address');
        }
        return taproot.address;
    }
    static generateTimeLockScript(publicKey, csvBlocks = TimeLockGenerator.CSV_BLOCKS) {
        return script.compile([
            script.number.encode(csvBlocks),
            opcodes.OP_CHECKSEQUENCEVERIFY,
            opcodes.OP_DROP,
            publicKey,
            opcodes.OP_CHECKSIG,
        ]);
    }
}
TimeLockGenerator.UNSPENDABLE_INTERNAL_KEY = Buffer.from('50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0', 'hex');
TimeLockGenerator.CSV_BLOCKS = 75;
