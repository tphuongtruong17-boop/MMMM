var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Address_p2tr, _Address_p2op, _Address_network, _Address_originalPublicKey, _Address_keyPair, _Address_uncompressed, _Address_tweakedUncompressed, _Address_p2wda, _Address_mldsaPublicKey, _Address_cachedBigInt, _Address_cachedUint64Array, _Address_originalMDLSAPublicKey, _Address_mldsaLevel, _Address_pendingLegacyKey, _Address_legacyProcessed, _Address_legacyPublicKey;
import { decompressPublicKey, toXOnly } from '@btc-vision/bitcoin';
import { ADDRESS_BYTE_LENGTH } from '../utils/lengths.js';
import { AddressVerificator } from './AddressVerificator.js';
import { EcKeyPair } from './EcKeyPair.js';
import { ContractAddress } from '../transaction/ContractAddress.js';
import { BitcoinUtils } from '../utils/BitcoinUtils.js';
import { TimeLockGenerator } from '../transaction/mineable/TimelockGenerator.js';
import { P2WDADetector } from '../p2wda/P2WDADetector.js';
import { sha256 } from '@noble/hashes/sha2';
export class Address extends Uint8Array {
    constructor(mldsaPublicKey, publicKeyOrTweak) {
        super(ADDRESS_BYTE_LENGTH);
        _Address_p2tr.set(this, void 0);
        _Address_p2op.set(this, void 0);
        _Address_network.set(this, void 0);
        _Address_originalPublicKey.set(this, void 0);
        _Address_keyPair.set(this, void 0);
        _Address_uncompressed.set(this, void 0);
        _Address_tweakedUncompressed.set(this, void 0);
        _Address_p2wda.set(this, void 0);
        _Address_mldsaPublicKey.set(this, void 0);
        _Address_cachedBigInt.set(this, void 0);
        _Address_cachedUint64Array.set(this, void 0);
        _Address_originalMDLSAPublicKey.set(this, void 0);
        _Address_mldsaLevel.set(this, void 0);
        _Address_pendingLegacyKey.set(this, void 0);
        _Address_legacyProcessed.set(this, false);
        _Address_legacyPublicKey.set(this, void 0);
        if (!mldsaPublicKey) {
            return;
        }
        if (publicKeyOrTweak) {
            const validLengths = [ADDRESS_BYTE_LENGTH, 33, 65];
            if (!validLengths.includes(publicKeyOrTweak.length)) {
                throw new Error(`Invalid public key length ${publicKeyOrTweak.length}`);
            }
            __classPrivateFieldSet(this, _Address_pendingLegacyKey, new Uint8Array(publicKeyOrTweak.length), "f");
            __classPrivateFieldGet(this, _Address_pendingLegacyKey, "f").set(publicKeyOrTweak);
        }
        this.setMldsaKey(mldsaPublicKey);
    }
    get mldsaLevel() {
        return __classPrivateFieldGet(this, _Address_mldsaLevel, "f");
    }
    set mldsaLevel(level) {
        __classPrivateFieldSet(this, _Address_mldsaLevel, level, "f");
    }
    get originalMDLSAPublicKey() {
        return __classPrivateFieldGet(this, _Address_originalMDLSAPublicKey, "f");
    }
    set originalMDLSAPublicKey(key) {
        __classPrivateFieldSet(this, _Address_originalMDLSAPublicKey, new Uint8Array(key), "f");
    }
    get originalPublicKey() {
        this.ensureLegacyProcessed();
        return __classPrivateFieldGet(this, _Address_originalPublicKey, "f");
    }
    get mldsaPublicKey() {
        return __classPrivateFieldGet(this, _Address_mldsaPublicKey, "f");
    }
    get legacyPublicKey() {
        this.ensureLegacyProcessed();
        return __classPrivateFieldGet(this, _Address_legacyPublicKey, "f");
    }
    get keyPair() {
        this.ensureLegacyProcessed();
        if (!__classPrivateFieldGet(this, _Address_keyPair, "f")) {
            throw new Error('Legacy public key not set for address');
        }
        return __classPrivateFieldGet(this, _Address_keyPair, "f");
    }
    static dead() {
        return Address.fromString('0x0000000000000000000000000000000000000000000000000000000000000000', '0x04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f');
    }
    static fromString(mldsaPublicKey, legacyPublicKey) {
        if (!mldsaPublicKey) {
            throw new Error('Invalid public key');
        }
        if (mldsaPublicKey.startsWith('0x')) {
            mldsaPublicKey = mldsaPublicKey.slice(2);
        }
        if (!BitcoinUtils.isValidHex(mldsaPublicKey)) {
            throw new Error('You must only pass public keys in hexadecimal format. If you have an address such as bc1q... you must convert it to a public key first. Please refer to await provider.getPublicKeyInfo("bc1q..."). If the public key associated with the address is not found, you must force the user to enter the destination public key. It looks like: 0x020373626d317ae8788ce3280b491068610d840c23ecb64c14075bbb9f670af52c.');
        }
        let classicBuffer;
        if (legacyPublicKey) {
            if (legacyPublicKey.startsWith('0x')) {
                legacyPublicKey = legacyPublicKey.slice(2);
            }
            if (!BitcoinUtils.isValidHex(legacyPublicKey)) {
                throw new Error('You must only pass classical public keys in hexadecimal format. If you have an address such as bc1q... you must convert it to a public key first. Please refer to await provider.getPublicKeyInfo("bc1q..."). If the public key associated with the address is not found, you must force the user to enter the destination public key. It looks like: 0x020373626d317ae8788ce3280b491068610d840c23ecb64c14075bbb9f670af52c.');
            }
            classicBuffer = Buffer.from(legacyPublicKey, 'hex');
        }
        return new Address(Buffer.from(mldsaPublicKey, 'hex'), classicBuffer);
    }
    static wrap(bytes) {
        return new Address(bytes);
    }
    static uncompressedToCompressed(publicKey) {
        const buffer = Uint8Array.from(publicKey);
        const x = buffer.slice(1, 33);
        const y = buffer.slice(33);
        const compressed = Buffer.alloc(33);
        compressed[0] = 0x02 + (y[y.length - 1] & 0x01);
        compressed.set(x, 1);
        return compressed;
    }
    static fromBigInt(value) {
        const buffer = new Uint8Array(32);
        const view = new DataView(buffer.buffer);
        view.setBigUint64(0, (value >> 192n) & 0xffffffffffffffffn, false);
        view.setBigUint64(8, (value >> 128n) & 0xffffffffffffffffn, false);
        view.setBigUint64(16, (value >> 64n) & 0xffffffffffffffffn, false);
        view.setBigUint64(24, value & 0xffffffffffffffffn, false);
        return new Address(buffer);
    }
    static fromUint64Array(w0, w1, w2, w3) {
        const buffer = new Uint8Array(32);
        const view = new DataView(buffer.buffer);
        view.setBigUint64(0, w0, false);
        view.setBigUint64(8, w1, false);
        view.setBigUint64(16, w2, false);
        view.setBigUint64(24, w3, false);
        return new Address(buffer);
    }
    toUint64Array() {
        if (__classPrivateFieldGet(this, _Address_cachedUint64Array, "f") !== undefined) {
            return __classPrivateFieldGet(this, _Address_cachedUint64Array, "f");
        }
        const view = new DataView(this.buffer, this.byteOffset, 32);
        __classPrivateFieldSet(this, _Address_cachedUint64Array, [
            view.getBigUint64(0, false),
            view.getBigUint64(8, false),
            view.getBigUint64(16, false),
            view.getBigUint64(24, false),
        ], "f");
        return __classPrivateFieldGet(this, _Address_cachedUint64Array, "f");
    }
    isDead() {
        for (let i = 0; i < ADDRESS_BYTE_LENGTH; i++) {
            if (this[i] !== 0) {
                return false;
            }
        }
        return true;
    }
    toHex() {
        return '0x' + Buffer.from(this).toString('hex');
    }
    tweakedToHex() {
        const key = this.legacyPublicKey;
        if (!key) {
            throw new Error('Legacy public key not set');
        }
        return '0x' + Buffer.from(key).toString('hex');
    }
    toBuffer() {
        return Buffer.from(this);
    }
    tweakedPublicKeyToBuffer() {
        const key = this.legacyPublicKey;
        if (!key) {
            throw new Error('Legacy public key not set');
        }
        return Buffer.from(key);
    }
    toUncompressedHex() {
        this.ensureLegacyProcessed();
        if (!__classPrivateFieldGet(this, _Address_uncompressed, "f")) {
            throw new Error('Legacy public key not set');
        }
        return '0x' + __classPrivateFieldGet(this, _Address_uncompressed, "f").uncompressed.toString('hex');
    }
    toUncompressedBuffer() {
        this.ensureLegacyProcessed();
        if (!__classPrivateFieldGet(this, _Address_uncompressed, "f")) {
            throw new Error('Legacy public key not set');
        }
        return __classPrivateFieldGet(this, _Address_uncompressed, "f").uncompressed;
    }
    toHybridPublicKeyHex() {
        this.ensureLegacyProcessed();
        if (!__classPrivateFieldGet(this, _Address_uncompressed, "f")) {
            throw new Error('Legacy public key not set');
        }
        return '0x' + __classPrivateFieldGet(this, _Address_uncompressed, "f").hybrid.toString('hex');
    }
    toHybridPublicKeyBuffer() {
        this.ensureLegacyProcessed();
        if (!__classPrivateFieldGet(this, _Address_uncompressed, "f")) {
            throw new Error('Legacy public key not set');
        }
        return __classPrivateFieldGet(this, _Address_uncompressed, "f").hybrid;
    }
    originalPublicKeyBuffer() {
        this.ensureLegacyProcessed();
        if (!__classPrivateFieldGet(this, _Address_originalPublicKey, "f")) {
            throw new Error('Legacy public key not set');
        }
        return Buffer.from(__classPrivateFieldGet(this, _Address_originalPublicKey, "f"));
    }
    toBigInt() {
        if (__classPrivateFieldGet(this, _Address_cachedBigInt, "f") !== undefined) {
            return __classPrivateFieldGet(this, _Address_cachedBigInt, "f");
        }
        const view = new DataView(this.buffer, this.byteOffset, 32);
        __classPrivateFieldSet(this, _Address_cachedBigInt, (view.getBigUint64(0, false) << 192n) |
            (view.getBigUint64(8, false) << 128n) |
            (view.getBigUint64(16, false) << 64n) |
            view.getBigUint64(24, false), "f");
        return __classPrivateFieldGet(this, _Address_cachedBigInt, "f");
    }
    equals(a) {
        const b = this;
        if (a.length !== b.length) {
            return false;
        }
        for (let i = 0; i < b.length; i++) {
            if (b[i] !== a[i]) {
                return false;
            }
        }
        return true;
    }
    lessThan(a) {
        const b = this;
        for (let i = 0; i < ADDRESS_BYTE_LENGTH; i++) {
            const thisByte = b[i];
            const aByte = a[i];
            if (thisByte < aByte) {
                return true;
            }
            else if (thisByte > aByte) {
                return false;
            }
        }
        return false;
    }
    greaterThan(a) {
        const b = this;
        for (let i = 0; i < ADDRESS_BYTE_LENGTH; i++) {
            const thisByte = b[i];
            const aByte = a[i];
            if (thisByte > aByte) {
                return true;
            }
            else if (thisByte < aByte) {
                return false;
            }
        }
        return false;
    }
    set(mldsaPublicKey) {
        this.setMldsaKey(mldsaPublicKey);
    }
    isValidLegacyPublicKey(network) {
        const key = this.legacyPublicKey;
        if (!key) {
            throw new Error(`Legacy key not set.`);
        }
        return AddressVerificator.isValidPublicKey(Buffer.from(key).toString('hex'), network);
    }
    p2pk() {
        return this.toHex();
    }
    p2wpkh(network) {
        return EcKeyPair.getP2WPKHAddress(this.keyPair, network);
    }
    p2pkh(network) {
        return EcKeyPair.getLegacyAddress(this.keyPair, network);
    }
    p2shp2wpkh(network) {
        return EcKeyPair.getLegacySegwitAddress(this.keyPair, network);
    }
    toString() {
        return this.toHex();
    }
    toJSON() {
        return this.toHex();
    }
    p2tr(network) {
        if (__classPrivateFieldGet(this, _Address_p2tr, "f") && __classPrivateFieldGet(this, _Address_network, "f") === network) {
            return __classPrivateFieldGet(this, _Address_p2tr, "f");
        }
        const key = this.legacyPublicKey;
        if (!key) {
            throw new Error('Legacy public key not set');
        }
        const p2trAddy = EcKeyPair.tweakedPubKeyBufferToAddress(key, network);
        if (p2trAddy) {
            __classPrivateFieldSet(this, _Address_network, network, "f");
            __classPrivateFieldSet(this, _Address_p2tr, p2trAddy, "f");
            return p2trAddy;
        }
        throw new Error('Legacy public key not set');
    }
    p2wda(network) {
        if (__classPrivateFieldGet(this, _Address_p2wda, "f") && __classPrivateFieldGet(this, _Address_network, "f") === network) {
            return __classPrivateFieldGet(this, _Address_p2wda, "f");
        }
        this.ensureLegacyProcessed();
        if (!__classPrivateFieldGet(this, _Address_originalPublicKey, "f")) {
            throw new Error('Cannot create P2WDA address: public key not set');
        }
        const publicKeyBuffer = Buffer.from(__classPrivateFieldGet(this, _Address_originalPublicKey, "f"));
        if (publicKeyBuffer.length !== 33) {
            throw new Error('P2WDA requires a compressed public key (33 bytes)');
        }
        try {
            const p2wdaInfo = P2WDADetector.generateP2WDAAddress(publicKeyBuffer, network);
            __classPrivateFieldSet(this, _Address_network, network, "f");
            __classPrivateFieldSet(this, _Address_p2wda, p2wdaInfo, "f");
            return {
                address: p2wdaInfo.address,
                witnessScript: p2wdaInfo.witnessScript,
            };
        }
        catch (error) {
            throw new Error(`Failed to generate P2WDA address: ${error.message}`);
        }
    }
    toCSV(duration, network) {
        const n = Number(duration);
        if (n < 1 || n > 65535) {
            throw new Error('CSV block number must be between 1 and 65535');
        }
        this.ensureLegacyProcessed();
        if (!__classPrivateFieldGet(this, _Address_originalPublicKey, "f")) {
            throw new Error('Cannot create CSV address: public key not set');
        }
        const publicKeyBuffer = Buffer.from(__classPrivateFieldGet(this, _Address_originalPublicKey, "f"));
        return TimeLockGenerator.generateTimeLockAddress(publicKeyBuffer, network, n);
    }
    toCSVTweaked(duration, network) {
        const n = Number(duration);
        if (n < 1 || n > 65535) {
            throw new Error('CSV block number must be between 1 and 65535');
        }
        this.ensureLegacyProcessed();
        if (!__classPrivateFieldGet(this, _Address_originalPublicKey, "f")) {
            throw new Error('Cannot create CSV address: public key not set');
        }
        return TimeLockGenerator.generateTimeLockAddressP2TR(this.tweakedPublicKeyToBuffer(), network, n);
    }
    p2op(network) {
        if (__classPrivateFieldGet(this, _Address_p2op, "f") && __classPrivateFieldGet(this, _Address_network, "f") === network) {
            return __classPrivateFieldGet(this, _Address_p2op, "f");
        }
        const p2opAddy = EcKeyPair.p2op(this, network);
        if (p2opAddy) {
            __classPrivateFieldSet(this, _Address_network, network, "f");
            __classPrivateFieldSet(this, _Address_p2op, p2opAddy, "f");
            return p2opAddy;
        }
        throw new Error('ML-DSA public key not set');
    }
    toTweakedHybridPublicKeyHex() {
        this.ensureLegacyProcessed();
        if (!__classPrivateFieldGet(this, _Address_tweakedUncompressed, "f")) {
            throw new Error('Legacy public key not set');
        }
        return '0x' + __classPrivateFieldGet(this, _Address_tweakedUncompressed, "f").toString('hex');
    }
    toTweakedHybridPublicKeyBuffer() {
        this.ensureLegacyProcessed();
        if (!__classPrivateFieldGet(this, _Address_tweakedUncompressed, "f")) {
            throw new Error('Legacy public key not set');
        }
        return __classPrivateFieldGet(this, _Address_tweakedUncompressed, "f");
    }
    setMldsaKey(mldsaPublicKey) {
        if (mldsaPublicKey.length === ADDRESS_BYTE_LENGTH) {
            const buf = new Uint8Array(ADDRESS_BYTE_LENGTH);
            buf.set(mldsaPublicKey);
            super.set(buf);
        }
        else {
            const validMLDSALengths = [1312, 1952, 2592];
            if (!validMLDSALengths.includes(mldsaPublicKey.length)) {
                throw new Error(`Invalid ML-DSA public key length: ${mldsaPublicKey.length}. ` +
                    `Expected 1312 (ML-DSA-44/LEVEL2), 1952 (ML-DSA-65/LEVEL3), or 2592 (ML-DSA-87/LEVEL5) bytes.`);
            }
            __classPrivateFieldSet(this, _Address_mldsaPublicKey, new Uint8Array(mldsaPublicKey.length), "f");
            __classPrivateFieldGet(this, _Address_mldsaPublicKey, "f").set(mldsaPublicKey);
            const hashedPublicKey = sha256(new Uint8Array(mldsaPublicKey));
            const buf = new Uint8Array(ADDRESS_BYTE_LENGTH);
            buf.set(hashedPublicKey);
            super.set(buf);
        }
    }
    ensureLegacyProcessed() {
        if (__classPrivateFieldGet(this, _Address_legacyProcessed, "f"))
            return;
        __classPrivateFieldSet(this, _Address_legacyProcessed, true, "f");
        const pending = __classPrivateFieldGet(this, _Address_pendingLegacyKey, "f");
        if (!pending)
            return;
        if (pending.length === ADDRESS_BYTE_LENGTH) {
            const buf = Buffer.alloc(ADDRESS_BYTE_LENGTH);
            buf.set(pending);
            __classPrivateFieldSet(this, _Address_tweakedUncompressed, ContractAddress.generateHybridKeyFromHash(buf), "f");
            __classPrivateFieldSet(this, _Address_legacyPublicKey, pending, "f");
        }
        else {
            this.autoFormat(pending);
        }
    }
    autoFormat(publicKey) {
        const firstByte = publicKey[0];
        if (firstByte === 0x03 || firstByte === 0x02) {
        }
        else if (firstByte === 0x04 || firstByte === 0x06 || firstByte === 0x07) {
            publicKey = Address.uncompressedToCompressed(publicKey);
        }
        __classPrivateFieldSet(this, _Address_originalPublicKey, Uint8Array.from(publicKey), "f");
        __classPrivateFieldSet(this, _Address_keyPair, EcKeyPair.fromPublicKey(__classPrivateFieldGet(this, _Address_originalPublicKey, "f")), "f");
        __classPrivateFieldSet(this, _Address_uncompressed, decompressPublicKey(__classPrivateFieldGet(this, _Address_originalPublicKey, "f")), "f");
        const tweakedBytes = toXOnly(EcKeyPair.tweakPublicKey(Buffer.from(__classPrivateFieldGet(this, _Address_originalPublicKey, "f"))));
        __classPrivateFieldSet(this, _Address_tweakedUncompressed, ContractAddress.generateHybridKeyFromHash(tweakedBytes), "f");
        __classPrivateFieldSet(this, _Address_legacyPublicKey, new Uint8Array(ADDRESS_BYTE_LENGTH), "f");
        __classPrivateFieldGet(this, _Address_legacyPublicKey, "f").set(tweakedBytes);
    }
}
_Address_p2tr = new WeakMap(), _Address_p2op = new WeakMap(), _Address_network = new WeakMap(), _Address_originalPublicKey = new WeakMap(), _Address_keyPair = new WeakMap(), _Address_uncompressed = new WeakMap(), _Address_tweakedUncompressed = new WeakMap(), _Address_p2wda = new WeakMap(), _Address_mldsaPublicKey = new WeakMap(), _Address_cachedBigInt = new WeakMap(), _Address_cachedUint64Array = new WeakMap(), _Address_originalMDLSAPublicKey = new WeakMap(), _Address_mldsaLevel = new WeakMap(), _Address_pendingLegacyKey = new WeakMap(), _Address_legacyProcessed = new WeakMap(), _Address_legacyPublicKey = new WeakMap();
