import * as ecc from '@bitcoinerlab/secp256k1';
import { crypto, toXOnly } from '@btc-vision/bitcoin';
import { TweakedSigner } from '../signer/TweakedSigner.js';
import { EcKeyPair } from './EcKeyPair.js';
import { isOPWallet } from '../transaction/browser/types/OPWallet.js';
class MessageSignerBase {
    sha256(message) {
        return crypto.sha256(Buffer.from(message));
    }
    async trySignSchnorrWithOPWallet(message) {
        const wallet = this.getOPWallet();
        if (!wallet) {
            return null;
        }
        const messageBuffer = typeof message === 'string' ? Buffer.from(message, 'utf-8') : Buffer.from(message);
        const hashedMessage = this.sha256(messageBuffer);
        const messageHex = hashedMessage.toString('hex');
        const signatureHex = await wallet.web3.signSchnorr(messageHex);
        return {
            signature: Buffer.from(signatureHex, 'hex'),
            message: hashedMessage,
        };
    }
    async trySignMLDSAWithOPWallet(message) {
        const wallet = this.getOPWallet();
        if (!wallet) {
            return null;
        }
        const messageBuffer = typeof message === 'string' ? Buffer.from(message, 'utf-8') : Buffer.from(message);
        const hashedMessage = this.sha256(messageBuffer);
        const messageHex = hashedMessage.toString('hex');
        const result = await wallet.web3.signMLDSAMessage(messageHex);
        return {
            signature: Buffer.from(result.signature, 'hex'),
            message: hashedMessage,
            publicKey: Buffer.from(result.publicKey, 'hex'),
            securityLevel: result.securityLevel,
        };
    }
    async signMessageAuto(message, keypair) {
        if (!keypair) {
            const walletResult = await this.trySignSchnorrWithOPWallet(message);
            if (walletResult) {
                return walletResult;
            }
            throw new Error('No keypair provided and OP_WALLET is not available.');
        }
        return this.signMessage(keypair, message);
    }
    async tweakAndSignMessageAuto(message, keypair, network) {
        if (!keypair) {
            const walletResult = await this.trySignSchnorrWithOPWallet(message);
            if (walletResult) {
                return walletResult;
            }
            throw new Error('No keypair provided and OP_WALLET is not available.');
        }
        if (!network) {
            throw new Error('Network is required when signing with a local keypair.');
        }
        return this.tweakAndSignMessage(keypair, message, network);
    }
    async signMLDSAMessageAuto(message, mldsaKeypair) {
        if (!mldsaKeypair) {
            const walletResult = await this.trySignMLDSAWithOPWallet(message);
            if (walletResult) {
                return walletResult;
            }
            throw new Error('No ML-DSA keypair provided and OP_WALLET is not available.');
        }
        return this.signMLDSAMessage(mldsaKeypair, message);
    }
    async verifyMLDSAWithOPWallet(message, signature) {
        const wallet = this.getOPWallet();
        if (!wallet) {
            return null;
        }
        const messageBuffer = typeof message === 'string' ? Buffer.from(message, 'utf-8') : Buffer.from(message);
        const hashedMessage = this.sha256(messageBuffer);
        const mldsaSignature = {
            signature: Buffer.from(signature.signature).toString('hex'),
            publicKey: Buffer.from(signature.publicKey).toString('hex'),
            securityLevel: signature.securityLevel,
            messageHash: hashedMessage.toString('hex'),
        };
        return wallet.web3.verifyMLDSASignature(hashedMessage.toString('hex'), mldsaSignature);
    }
    async getMLDSAPublicKeyFromOPWallet() {
        const wallet = this.getOPWallet();
        if (!wallet) {
            return null;
        }
        const publicKeyHex = await wallet.web3.getMLDSAPublicKey();
        return Buffer.from(publicKeyHex, 'hex');
    }
    tweakAndSignMessage(keypair, message, network) {
        const tweaked = TweakedSigner.tweakSigner(keypair, { network });
        return this.signMessage(tweaked, message);
    }
    signMessage(keypair, message) {
        if (typeof message === 'string') {
            message = Buffer.from(message, 'utf-8');
        }
        if (!keypair.privateKey) {
            throw new Error('Private key not found in keypair.');
        }
        const hashedMessage = this.sha256(message);
        return {
            signature: ecc.signSchnorr(hashedMessage, keypair.privateKey),
            message: hashedMessage,
        };
    }
    verifySignature(publicKey, message, signature) {
        if (typeof message === 'string') {
            message = Buffer.from(message, 'utf-8');
        }
        if (signature.length !== 64) {
            throw new Error('Invalid signature length.');
        }
        const hashedMessage = this.sha256(message);
        return ecc.verifySchnorr(hashedMessage, toXOnly(Buffer.from(publicKey)), signature);
    }
    tweakAndVerifySignature(publicKey, message, signature) {
        const tweakedPublicKey = EcKeyPair.tweakPublicKey(Buffer.from(publicKey));
        return this.verifySignature(tweakedPublicKey, message, signature);
    }
    signMLDSAMessage(mldsaKeypair, message) {
        if (typeof message === 'string') {
            message = Buffer.from(message, 'utf-8');
        }
        if (!mldsaKeypair.privateKey) {
            throw new Error('ML-DSA private key not found in keypair.');
        }
        const hashedMessage = this.sha256(message);
        const signature = mldsaKeypair.sign(hashedMessage);
        return {
            signature: Buffer.from(signature),
            message: hashedMessage,
            publicKey: Buffer.from(mldsaKeypair.publicKey),
            securityLevel: mldsaKeypair.securityLevel,
        };
    }
    verifyMLDSASignature(mldsaKeypair, message, signature) {
        if (typeof message === 'string') {
            message = Buffer.from(message, 'utf-8');
        }
        const hashedMessage = this.sha256(message);
        return mldsaKeypair.verify(hashedMessage, signature);
    }
    isOPWalletAvailable() {
        return this.getOPWallet() !== null;
    }
    getOPWallet() {
        if (typeof window === 'undefined') {
            return null;
        }
        const _window = window;
        if (!_window.opnet || !isOPWallet(_window.opnet)) {
            return null;
        }
        return _window.opnet;
    }
}
export const MessageSigner = new MessageSignerBase();
