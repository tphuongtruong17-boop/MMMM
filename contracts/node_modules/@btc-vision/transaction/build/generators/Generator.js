import { networks, toXOnly } from '@btc-vision/bitcoin';
import { BinaryWriter } from '../buffer/BinaryWriter.js';
import { Features, } from './Features.js';
import { Address } from '../keypair/Address.js';
import { Compressor } from '../bytecode/Compressor.js';
export class Generator {
    constructor(senderPubKey, contractSaltPubKey, network = networks.bitcoin) {
        this.network = networks.bitcoin;
        this.senderPubKey = senderPubKey;
        this.contractSaltPubKey = contractSaltPubKey;
        this.network = network;
        this.xSenderPubKey = toXOnly(senderPubKey);
    }
    buildHeader(features) {
        let flags = 0;
        for (const feature of features) {
            flags |= feature;
        }
        const bytesU24 = Buffer.alloc(3);
        bytesU24.writeUIntBE(flags, 0, 3);
        return Buffer.from([this.senderPubKey[0], ...bytesU24]);
    }
    getHeader(maxPriority, features = []) {
        const writer = new BinaryWriter(12);
        writer.writeBytes(this.buildHeader(features));
        writer.writeU64(maxPriority);
        return Buffer.from(writer.getBuffer());
    }
    splitBufferIntoChunks(buffer, chunkSize = Generator.DATA_CHUNK_SIZE) {
        const chunks = [];
        for (let i = 0; i < buffer.length; i += chunkSize) {
            const dataLength = Math.min(chunkSize, buffer.length - i);
            const buf2 = Buffer.alloc(dataLength);
            for (let j = 0; j < dataLength; j++) {
                buf2.writeUInt8(buffer[i + j], j);
            }
            chunks.push([buf2]);
        }
        return chunks;
    }
    encodeFeature(feature, finalBuffer) {
        switch (feature.opcode) {
            case Features.ACCESS_LIST: {
                return this.encodeAccessListFeature(feature, finalBuffer);
            }
            case Features.EPOCH_SUBMISSION: {
                return this.encodeChallengeSubmission(feature, finalBuffer);
            }
            case Features.MLDSA_LINK_PUBKEY: {
                return this.encodeLinkRequest(feature, finalBuffer);
            }
            default:
                throw new Error(`Unknown feature type: ${feature.opcode}`);
        }
    }
    encodeAccessListFeature(feature, finalBuffer) {
        const writer = new BinaryWriter();
        writer.writeU16(Object.keys(feature.data).length);
        for (const contract in feature.data) {
            const parsedContract = Address.fromString(contract);
            const data = feature.data[contract];
            writer.writeAddress(parsedContract);
            writer.writeU32(data.length);
            for (const pointer of data) {
                const pointerBuffer = Buffer.from(pointer, 'base64');
                if (pointerBuffer.length !== 32) {
                    throw new Error(`Invalid pointer length: ${pointerBuffer.length}`);
                }
                writer.writeBytes(pointerBuffer);
            }
        }
        finalBuffer.writeBytesWithLength(Compressor.compress(Buffer.from(writer.getBuffer())));
    }
    encodeChallengeSubmission(feature, finalBuffer) {
        if ('verifySignature' in feature.data && !feature.data.verifySignature()) {
            throw new Error('Invalid signature in challenge submission feature');
        }
        const writer = new BinaryWriter();
        writer.writeBytes(feature.data.publicKey.toBuffer());
        writer.writeBytes(feature.data.solution);
        if (feature.data.graffiti) {
            writer.writeBytesWithLength(feature.data.graffiti);
        }
        finalBuffer.writeBytesWithLength(writer.getBuffer());
    }
    encodeLinkRequest(feature, finalBuffer) {
        const data = feature.data;
        const writer = new BinaryWriter();
        writer.writeU8(data.level);
        writer.writeBytes(data.hashedPublicKey);
        writer.writeBoolean(data.verifyRequest);
        if (data.verifyRequest) {
            if (!data.publicKey || !data.mldsaSignature) {
                throw new Error('MLDSA public key and signature required when verifyRequest is true');
            }
            writer.writeBytes(data.publicKey);
            writer.writeBytes(data.mldsaSignature);
        }
        if (!data.legacySignature || data.legacySignature.length !== 64) {
            throw new Error('Legacy signature must be exactly 64 bytes');
        }
        writer.writeBytes(data.legacySignature);
        finalBuffer.writeBytesWithLength(writer.getBuffer());
    }
}
Generator.DATA_CHUNK_SIZE = 512;
Generator.MAGIC = Buffer.from('op', 'utf-8');
