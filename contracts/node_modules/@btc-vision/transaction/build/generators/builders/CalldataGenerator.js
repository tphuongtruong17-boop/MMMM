import { crypto, networks, opcodes, script } from '@btc-vision/bitcoin';
import { Compressor } from '../../bytecode/Compressor.js';
import { EcKeyPair } from '../../keypair/EcKeyPair.js';
import { Generator } from '../Generator.js';
import { BinaryWriter } from '../../buffer/BinaryWriter.js';
export class CalldataGenerator extends Generator {
    constructor(senderPubKey, contractSaltPubKey, network = networks.bitcoin) {
        super(senderPubKey, contractSaltPubKey, network);
    }
    static getPubKeyAsBuffer(witnessKeys, network) {
        let finalBuffer = Buffer.alloc(0);
        for (const pubKey of witnessKeys) {
            const key = EcKeyPair.fromPublicKey(pubKey, network);
            if (!key.compressed) {
                throw new Error('Public key must be compressed');
            }
            if (pubKey.byteLength !== 33) {
                throw new Error(`Public key must be 33 bytes, got ${pubKey.byteLength} bytes.`);
            }
            finalBuffer = Buffer.concat([finalBuffer, pubKey]);
        }
        const compressed = Compressor.compress(finalBuffer);
        if (compressed.byteLength >= finalBuffer.byteLength) {
            return finalBuffer;
        }
        return compressed;
    }
    compile(calldata, contractSecret, challenge, maxPriority, featuresRaw = []) {
        if (!this.contractSaltPubKey)
            throw new Error('Contract salt public key not set');
        const dataChunks = this.splitBufferIntoChunks(calldata);
        if (!dataChunks.length)
            throw new Error('No data chunks found');
        const featuresList = [];
        const featureData = [];
        if (featuresRaw && featuresRaw.length) {
            const features = featuresRaw.sort((a, b) => a.priority - b.priority);
            const finalBuffer = new BinaryWriter();
            for (let i = 0; i < features.length; i++) {
                const feature = features[i];
                featuresList.push(feature.opcode);
                this.encodeFeature(feature, finalBuffer);
            }
            featureData.push(...this.splitBufferIntoChunks(Buffer.from(finalBuffer.getBuffer())));
        }
        let compiledData = [
            this.getHeader(maxPriority, featuresList),
            opcodes.OP_TOALTSTACK,
            challenge.publicKey.toBuffer(),
            opcodes.OP_TOALTSTACK,
            challenge.solution,
            opcodes.OP_TOALTSTACK,
            this.xSenderPubKey,
            opcodes.OP_DUP,
            opcodes.OP_HASH256,
            crypto.hash256(this.xSenderPubKey),
            opcodes.OP_EQUALVERIFY,
            opcodes.OP_CHECKSIGVERIFY,
            this.contractSaltPubKey,
            opcodes.OP_CHECKSIGVERIFY,
            opcodes.OP_HASH160,
            crypto.hash160(contractSecret),
            opcodes.OP_EQUALVERIFY,
            opcodes.OP_DEPTH,
            opcodes.OP_1,
            opcodes.OP_NUMEQUAL,
            opcodes.OP_IF,
            Generator.MAGIC,
        ];
        compiledData = compiledData.concat(...featureData, ...[opcodes.OP_1NEGATE, ...dataChunks, opcodes.OP_ELSE, opcodes.OP_1, opcodes.OP_ENDIF]);
        const asm = compiledData.flat();
        const compiled = script.compile(asm);
        const decompiled = script.decompile(compiled);
        if (!decompiled) {
            throw new Error('Failed to decompile script??');
        }
        return compiled;
    }
}
