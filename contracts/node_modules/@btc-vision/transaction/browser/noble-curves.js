import { r as We, a as ln, b as dn, c as Me, i as yt, h as Qe, d as hn, e as Ae, f as yn, g as mn, j as kt, k as bn, s as wn } from "./noble-hashes.js";
function er(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function tr(e) {
  if (Object.prototype.hasOwnProperty.call(e, "__esModule")) return e;
  var n = e.default;
  if (typeof n == "function") {
    var c = function t() {
      var u = !1;
      try {
        u = this instanceof t;
      } catch {
      }
      return u ? Reflect.construct(n, arguments, this.constructor) : n.apply(this, arguments);
    };
    c.prototype = n.prototype;
  } else c = {};
  return Object.defineProperty(c, "__esModule", { value: !0 }), Object.keys(e).forEach(function(t) {
    var u = Object.getOwnPropertyDescriptor(e, t);
    Object.defineProperty(c, t, u.get ? u : {
      enumerable: !0,
      get: function() {
        return e[t];
      }
    });
  }), c;
}
var tt = {}, Ke = {}, nt = {}, rt = {}, _t;
function Ce() {
  return _t || (_t = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.notImplemented = e.bitMask = e.utf8ToBytes = e.randomBytes = e.isBytes = e.hexToBytes = e.concatBytes = e.bytesToUtf8 = e.bytesToHex = e.anumber = e.abytes = void 0, e.abool = m, e._abool2 = g, e._abytes2 = p, e.numberToHexUnpadded = v, e.hexToNumber = U, e.bytesToNumberBE = H, e.bytesToNumberLE = V, e.numberToBytesBE = E, e.numberToBytesLE = b, e.numberToVarBytesBE = S, e.ensureBytes = A, e.equalBytes = M, e.copyBytes = Q, e.asciiToBytes = F, e.inRange = se, e.aInRange = ie, e.bitLen = j, e.bitGet = R, e.bitSet = L, e.createHmacDrbg = K, e.validateObject = D, e.isHash = d, e._validateObject = l, e.memoized = a;
    const n = /* @__PURE__ */ We();
    var c = /* @__PURE__ */ We();
    Object.defineProperty(e, "abytes", { enumerable: !0, get: function() {
      return c.abytes;
    } }), Object.defineProperty(e, "anumber", { enumerable: !0, get: function() {
      return c.anumber;
    } }), Object.defineProperty(e, "bytesToHex", { enumerable: !0, get: function() {
      return c.bytesToHex;
    } }), Object.defineProperty(e, "bytesToUtf8", { enumerable: !0, get: function() {
      return c.bytesToUtf8;
    } }), Object.defineProperty(e, "concatBytes", { enumerable: !0, get: function() {
      return c.concatBytes;
    } }), Object.defineProperty(e, "hexToBytes", { enumerable: !0, get: function() {
      return c.hexToBytes;
    } }), Object.defineProperty(e, "isBytes", { enumerable: !0, get: function() {
      return c.isBytes;
    } }), Object.defineProperty(e, "randomBytes", { enumerable: !0, get: function() {
      return c.randomBytes;
    } }), Object.defineProperty(e, "utf8ToBytes", { enumerable: !0, get: function() {
      return c.utf8ToBytes;
    } });
    const t = /* @__PURE__ */ BigInt(0), u = /* @__PURE__ */ BigInt(1);
    function m(i, o) {
      if (typeof o != "boolean")
        throw new Error(i + " boolean expected, got " + o);
    }
    function g(i, o = "") {
      if (typeof i != "boolean") {
        const h = o && `"${o}"`;
        throw new Error(h + "expected boolean, got type=" + typeof i);
      }
      return i;
    }
    function p(i, o, h = "") {
      const w = (0, n.isBytes)(i), s = i?.length, f = o !== void 0;
      if (!w || f && s !== o) {
        const y = h && `"${h}" `, B = f ? ` of length ${o}` : "", O = w ? `length=${s}` : `type=${typeof i}`;
        throw new Error(y + "expected Uint8Array" + B + ", got " + O);
      }
      return i;
    }
    function v(i) {
      const o = i.toString(16);
      return o.length & 1 ? "0" + o : o;
    }
    function U(i) {
      if (typeof i != "string")
        throw new Error("hex string expected, got " + typeof i);
      return i === "" ? t : BigInt("0x" + i);
    }
    function H(i) {
      return U((0, n.bytesToHex)(i));
    }
    function V(i) {
      return (0, n.abytes)(i), U((0, n.bytesToHex)(Uint8Array.from(i).reverse()));
    }
    function E(i, o) {
      return (0, n.hexToBytes)(i.toString(16).padStart(o * 2, "0"));
    }
    function b(i, o) {
      return E(i, o).reverse();
    }
    function S(i) {
      return (0, n.hexToBytes)(v(i));
    }
    function A(i, o, h) {
      let w;
      if (typeof o == "string")
        try {
          w = (0, n.hexToBytes)(o);
        } catch (f) {
          throw new Error(i + " must be hex string or Uint8Array, cause: " + f);
        }
      else if ((0, n.isBytes)(o))
        w = Uint8Array.from(o);
      else
        throw new Error(i + " must be hex string or Uint8Array");
      const s = w.length;
      if (typeof h == "number" && s !== h)
        throw new Error(i + " of length " + h + " expected, got " + s);
      return w;
    }
    function M(i, o) {
      if (i.length !== o.length)
        return !1;
      let h = 0;
      for (let w = 0; w < i.length; w++)
        h |= i[w] ^ o[w];
      return h === 0;
    }
    function Q(i) {
      return Uint8Array.from(i);
    }
    function F(i) {
      return Uint8Array.from(i, (o, h) => {
        const w = o.charCodeAt(0);
        if (o.length !== 1 || w > 127)
          throw new Error(`string contains non-ASCII character "${i[h]}" with code ${w} at position ${h}`);
        return w;
      });
    }
    const G = (i) => typeof i == "bigint" && t <= i;
    function se(i, o, h) {
      return G(i) && G(o) && G(h) && o <= i && i < h;
    }
    function ie(i, o, h, w) {
      if (!se(o, h, w))
        throw new Error("expected valid " + i + ": " + h + " <= n < " + w + ", got " + o);
    }
    function j(i) {
      let o;
      for (o = 0; i > t; i >>= u, o += 1)
        ;
      return o;
    }
    function R(i, o) {
      return i >> BigInt(o) & u;
    }
    function L(i, o, h) {
      return i | (h ? u : t) << BigInt(o);
    }
    const _ = (i) => (u << BigInt(i)) - u;
    e.bitMask = _;
    function K(i, o, h) {
      if (typeof i != "number" || i < 2)
        throw new Error("hashLen must be a number");
      if (typeof o != "number" || o < 2)
        throw new Error("qByteLen must be a number");
      if (typeof h != "function")
        throw new Error("hmacFn must be a function");
      const w = (C) => new Uint8Array(C), s = (C) => Uint8Array.of(C);
      let f = w(i), y = w(i), B = 0;
      const O = () => {
        f.fill(1), y.fill(0), B = 0;
      }, k = (...C) => h(y, f, ...C), Y = (C = w(0)) => {
        y = k(s(0), C), f = k(), C.length !== 0 && (y = k(s(1), C), f = k());
      }, I = () => {
        if (B++ >= 1e3)
          throw new Error("drbg: tried 1000 values");
        let C = 0;
        const te = [];
        for (; C < o; ) {
          f = k();
          const $ = f.slice();
          te.push($), C += f.length;
        }
        return (0, n.concatBytes)(...te);
      };
      return (C, te) => {
        O(), Y(C);
        let $;
        for (; !($ = te(I())); )
          Y();
        return O(), $;
      };
    }
    const W = {
      bigint: (i) => typeof i == "bigint",
      function: (i) => typeof i == "function",
      boolean: (i) => typeof i == "boolean",
      string: (i) => typeof i == "string",
      stringOrUint8Array: (i) => typeof i == "string" || (0, n.isBytes)(i),
      isSafeInteger: (i) => Number.isSafeInteger(i),
      array: (i) => Array.isArray(i),
      field: (i, o) => o.Fp.isValid(i),
      hash: (i) => typeof i == "function" && Number.isSafeInteger(i.outputLen)
    };
    function D(i, o, h = {}) {
      const w = (s, f, y) => {
        const B = W[f];
        if (typeof B != "function")
          throw new Error("invalid validator function");
        const O = i[s];
        if (!(y && O === void 0) && !B(O, i))
          throw new Error("param " + String(s) + " is invalid. Expected " + f + ", got " + O);
      };
      for (const [s, f] of Object.entries(o))
        w(s, f, !1);
      for (const [s, f] of Object.entries(h))
        w(s, f, !0);
      return i;
    }
    function d(i) {
      return typeof i == "function" && Number.isSafeInteger(i.outputLen);
    }
    function l(i, o, h = {}) {
      if (!i || typeof i != "object")
        throw new Error("expected valid options object");
      function w(s, f, y) {
        const B = i[s];
        if (y && B === void 0)
          return;
        const O = typeof B;
        if (O !== f || B === null)
          throw new Error(`param "${s}" is invalid: expected ${f}, got ${O}`);
      }
      Object.entries(o).forEach(([s, f]) => w(s, f, !1)), Object.entries(h).forEach(([s, f]) => w(s, f, !0));
    }
    const r = () => {
      throw new Error("not implemented");
    };
    e.notImplemented = r;
    function a(i) {
      const o = /* @__PURE__ */ new WeakMap();
      return (h, ...w) => {
        const s = o.get(h);
        if (s !== void 0)
          return s;
        const f = i(h, ...w);
        return o.set(h, f), f;
      };
    }
  })(rt)), rt;
}
var Re = {}, he = {}, St;
function $e() {
  if (St) return he;
  St = 1, Object.defineProperty(he, "__esModule", { value: !0 }), he.isNegativeLE = void 0, he.mod = V, he.pow = E, he.pow2 = b, he.invert = S, he.tonelliShanks = G, he.FpSqrt = se, he.validateField = R, he.FpPow = L, he.FpInvertBatch = _, he.FpDiv = K, he.FpLegendre = W, he.FpIsSquare = D, he.nLength = d, he.Field = l, he.FpSqrtOdd = r, he.FpSqrtEven = a, he.hashToPrivateScalar = i, he.getFieldBytesLength = o, he.getMinHashLength = h, he.mapHashToField = w;
  const e = /* @__PURE__ */ Ce(), n = BigInt(0), c = BigInt(1), t = /* @__PURE__ */ BigInt(2), u = /* @__PURE__ */ BigInt(3), m = /* @__PURE__ */ BigInt(4), g = /* @__PURE__ */ BigInt(5), p = /* @__PURE__ */ BigInt(7), v = /* @__PURE__ */ BigInt(8), U = /* @__PURE__ */ BigInt(9), H = /* @__PURE__ */ BigInt(16);
  function V(s, f) {
    const y = s % f;
    return y >= n ? y : f + y;
  }
  function E(s, f, y) {
    return L(l(y), s, f);
  }
  function b(s, f, y) {
    let B = s;
    for (; f-- > n; )
      B *= B, B %= y;
    return B;
  }
  function S(s, f) {
    if (s === n)
      throw new Error("invert: expected non-zero number");
    if (f <= n)
      throw new Error("invert: expected positive modulus, got " + f);
    let y = V(s, f), B = f, O = n, k = c;
    for (; y !== n; ) {
      const I = B / y, q = B % y, C = O - k * I;
      B = y, y = q, O = k, k = C;
    }
    if (B !== c)
      throw new Error("invert: does not exist");
    return V(O, f);
  }
  function A(s, f, y) {
    if (!s.eql(s.sqr(f), y))
      throw new Error("Cannot find square root");
  }
  function M(s, f) {
    const y = (s.ORDER + c) / m, B = s.pow(f, y);
    return A(s, B, f), B;
  }
  function Q(s, f) {
    const y = (s.ORDER - g) / v, B = s.mul(f, t), O = s.pow(B, y), k = s.mul(f, O), Y = s.mul(s.mul(k, t), O), I = s.mul(k, s.sub(Y, s.ONE));
    return A(s, I, f), I;
  }
  function F(s) {
    const f = l(s), y = G(s), B = y(f, f.neg(f.ONE)), O = y(f, B), k = y(f, f.neg(B)), Y = (s + p) / H;
    return (I, q) => {
      let C = I.pow(q, Y), te = I.mul(C, B);
      const $ = I.mul(C, O), T = I.mul(C, k), X = I.eql(I.sqr(te), q), ae = I.eql(I.sqr($), q);
      C = I.cmov(C, te, X), te = I.cmov(T, $, ae);
      const ye = I.eql(I.sqr(te), q), pe = I.cmov(C, te, ye);
      return A(I, pe, q), pe;
    };
  }
  function G(s) {
    if (s < u)
      throw new Error("sqrt is not defined for small field");
    let f = s - c, y = 0;
    for (; f % t === n; )
      f /= t, y++;
    let B = t;
    const O = l(s);
    for (; W(O, B) === 1; )
      if (B++ > 1e3)
        throw new Error("Cannot find square root: probably non-prime P");
    if (y === 1)
      return M;
    let k = O.pow(B, f);
    const Y = (f + c) / t;
    return function(q, C) {
      if (q.is0(C))
        return C;
      if (W(q, C) !== 1)
        throw new Error("Cannot find square root");
      let te = y, $ = q.mul(q.ONE, k), T = q.pow(C, f), X = q.pow(C, Y);
      for (; !q.eql(T, q.ONE); ) {
        if (q.is0(T))
          return q.ZERO;
        let ae = 1, ye = q.sqr(T);
        for (; !q.eql(ye, q.ONE); )
          if (ae++, ye = q.sqr(ye), ae === te)
            throw new Error("Cannot find square root");
        const pe = c << BigInt(te - ae - 1), ve = q.pow($, pe);
        te = ae, $ = q.sqr(ve), T = q.mul(T, $), X = q.mul(X, ve);
      }
      return X;
    };
  }
  function se(s) {
    return s % m === u ? M : s % v === g ? Q : s % H === U ? F(s) : G(s);
  }
  const ie = (s, f) => (V(s, f) & c) === c;
  he.isNegativeLE = ie;
  const j = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
  ];
  function R(s) {
    const f = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "number",
      BITS: "number"
    }, y = j.reduce((B, O) => (B[O] = "function", B), f);
    return (0, e._validateObject)(s, y), s;
  }
  function L(s, f, y) {
    if (y < n)
      throw new Error("invalid exponent, negatives unsupported");
    if (y === n)
      return s.ONE;
    if (y === c)
      return f;
    let B = s.ONE, O = f;
    for (; y > n; )
      y & c && (B = s.mul(B, O)), O = s.sqr(O), y >>= c;
    return B;
  }
  function _(s, f, y = !1) {
    const B = new Array(f.length).fill(y ? s.ZERO : void 0), O = f.reduce((Y, I, q) => s.is0(I) ? Y : (B[q] = Y, s.mul(Y, I)), s.ONE), k = s.inv(O);
    return f.reduceRight((Y, I, q) => s.is0(I) ? Y : (B[q] = s.mul(Y, B[q]), s.mul(Y, I)), k), B;
  }
  function K(s, f, y) {
    return s.mul(f, typeof y == "bigint" ? S(y, s.ORDER) : s.inv(y));
  }
  function W(s, f) {
    const y = (s.ORDER - c) / t, B = s.pow(f, y), O = s.eql(B, s.ONE), k = s.eql(B, s.ZERO), Y = s.eql(B, s.neg(s.ONE));
    if (!O && !k && !Y)
      throw new Error("invalid Legendre symbol result");
    return O ? 1 : k ? 0 : -1;
  }
  function D(s, f) {
    return W(s, f) === 1;
  }
  function d(s, f) {
    f !== void 0 && (0, e.anumber)(f);
    const y = f !== void 0 ? f : s.toString(2).length, B = Math.ceil(y / 8);
    return { nBitLength: y, nByteLength: B };
  }
  function l(s, f, y = !1, B = {}) {
    if (s <= n)
      throw new Error("invalid field: expected ORDER > 0, got " + s);
    let O, k, Y = !1, I;
    if (typeof f == "object" && f != null) {
      if (B.sqrt || y)
        throw new Error("cannot specify opts in two arguments");
      const T = f;
      T.BITS && (O = T.BITS), T.sqrt && (k = T.sqrt), typeof T.isLE == "boolean" && (y = T.isLE), typeof T.modFromBytes == "boolean" && (Y = T.modFromBytes), I = T.allowedLengths;
    } else
      typeof f == "number" && (O = f), B.sqrt && (k = B.sqrt);
    const { nBitLength: q, nByteLength: C } = d(s, O);
    if (C > 2048)
      throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let te;
    const $ = Object.freeze({
      ORDER: s,
      isLE: y,
      BITS: q,
      BYTES: C,
      MASK: (0, e.bitMask)(q),
      ZERO: n,
      ONE: c,
      allowedLengths: I,
      create: (T) => V(T, s),
      isValid: (T) => {
        if (typeof T != "bigint")
          throw new Error("invalid field element: expected bigint, got " + typeof T);
        return n <= T && T < s;
      },
      is0: (T) => T === n,
      // is valid and invertible
      isValidNot0: (T) => !$.is0(T) && $.isValid(T),
      isOdd: (T) => (T & c) === c,
      neg: (T) => V(-T, s),
      eql: (T, X) => T === X,
      sqr: (T) => V(T * T, s),
      add: (T, X) => V(T + X, s),
      sub: (T, X) => V(T - X, s),
      mul: (T, X) => V(T * X, s),
      pow: (T, X) => L($, T, X),
      div: (T, X) => V(T * S(X, s), s),
      // Same as above, but doesn't normalize
      sqrN: (T) => T * T,
      addN: (T, X) => T + X,
      subN: (T, X) => T - X,
      mulN: (T, X) => T * X,
      inv: (T) => S(T, s),
      sqrt: k || ((T) => (te || (te = se(s)), te($, T))),
      toBytes: (T) => y ? (0, e.numberToBytesLE)(T, C) : (0, e.numberToBytesBE)(T, C),
      fromBytes: (T, X = !0) => {
        if (I) {
          if (!I.includes(T.length) || T.length > C)
            throw new Error("Field.fromBytes: expected " + I + " bytes, got " + T.length);
          const ye = new Uint8Array(C);
          ye.set(T, y ? 0 : ye.length - T.length), T = ye;
        }
        if (T.length !== C)
          throw new Error("Field.fromBytes: expected " + C + " bytes, got " + T.length);
        let ae = y ? (0, e.bytesToNumberLE)(T) : (0, e.bytesToNumberBE)(T);
        if (Y && (ae = V(ae, s)), !X && !$.isValid(ae))
          throw new Error("invalid field element: outside of range 0..ORDER");
        return ae;
      },
      // TODO: we don't need it here, move out to separate fn
      invertBatch: (T) => _($, T),
      // We can't move this out because Fp6, Fp12 implement it
      // and it's unclear what to return in there.
      cmov: (T, X, ae) => ae ? X : T
    });
    return Object.freeze($);
  }
  function r(s, f) {
    if (!s.isOdd)
      throw new Error("Field doesn't have isOdd");
    const y = s.sqrt(f);
    return s.isOdd(y) ? y : s.neg(y);
  }
  function a(s, f) {
    if (!s.isOdd)
      throw new Error("Field doesn't have isOdd");
    const y = s.sqrt(f);
    return s.isOdd(y) ? s.neg(y) : y;
  }
  function i(s, f, y = !1) {
    s = (0, e.ensureBytes)("privateHash", s);
    const B = s.length, O = d(f).nByteLength + 8;
    if (O < 24 || B < O || B > 1024)
      throw new Error("hashToPrivateScalar: expected " + O + "-1024 bytes of input, got " + B);
    const k = y ? (0, e.bytesToNumberLE)(s) : (0, e.bytesToNumberBE)(s);
    return V(k, f - c) + c;
  }
  function o(s) {
    if (typeof s != "bigint")
      throw new Error("field order must be bigint");
    const f = s.toString(2).length;
    return Math.ceil(f / 8);
  }
  function h(s) {
    const f = o(s);
    return f + Math.ceil(f / 2);
  }
  function w(s, f, y = !1) {
    const B = s.length, O = o(f), k = h(f);
    if (B < 16 || B < k || B > 1024)
      throw new Error("expected " + k + "-1024 bytes of input, got " + B);
    const Y = y ? (0, e.bytesToNumberLE)(s) : (0, e.bytesToNumberBE)(s), I = V(Y, f - c) + c;
    return y ? (0, e.numberToBytesLE)(I, O) : (0, e.numberToBytesBE)(I, O);
  }
  return he;
}
var Ot;
function gn() {
  if (Ot) return Re;
  Ot = 1, Object.defineProperty(Re, "__esModule", { value: !0 }), Re.wNAF = void 0, Re.negateCt = u, Re.normalizeZ = m, Re.mulEndoUnsafe = M, Re.pippenger = Q, Re.precomputeMSMUnsafe = F, Re.validateBasic = G, Re._createCurveFields = ie;
  const e = /* @__PURE__ */ Ce(), n = /* @__PURE__ */ $e(), c = BigInt(0), t = BigInt(1);
  function u(j, R) {
    const L = R.negate();
    return j ? L : R;
  }
  function m(j, R) {
    const L = (0, n.FpInvertBatch)(j.Fp, R.map((_) => _.Z));
    return R.map((_, K) => j.fromAffine(_.toAffine(L[K])));
  }
  function g(j, R) {
    if (!Number.isSafeInteger(j) || j <= 0 || j > R)
      throw new Error("invalid window size, expected [1.." + R + "], got W=" + j);
  }
  function p(j, R) {
    g(j, R);
    const L = Math.ceil(R / j) + 1, _ = 2 ** (j - 1), K = 2 ** j, W = (0, e.bitMask)(j), D = BigInt(j);
    return { windows: L, windowSize: _, mask: W, maxNumber: K, shiftBy: D };
  }
  function v(j, R, L) {
    const { windowSize: _, mask: K, maxNumber: W, shiftBy: D } = L;
    let d = Number(j & K), l = j >> D;
    d > _ && (d -= W, l += t);
    const r = R * _, a = r + Math.abs(d) - 1, i = d === 0, o = d < 0, h = R % 2 !== 0;
    return { nextN: l, offset: a, isZero: i, isNeg: o, isNegF: h, offsetF: r };
  }
  function U(j, R) {
    if (!Array.isArray(j))
      throw new Error("array expected");
    j.forEach((L, _) => {
      if (!(L instanceof R))
        throw new Error("invalid point at index " + _);
    });
  }
  function H(j, R) {
    if (!Array.isArray(j))
      throw new Error("array of scalars expected");
    j.forEach((L, _) => {
      if (!R.isValid(L))
        throw new Error("invalid scalar at index " + _);
    });
  }
  const V = /* @__PURE__ */ new WeakMap(), E = /* @__PURE__ */ new WeakMap();
  function b(j) {
    return E.get(j) || 1;
  }
  function S(j) {
    if (j !== c)
      throw new Error("invalid wNAF");
  }
  class A {
    // Parametrized with a given Point class (not individual point)
    constructor(R, L) {
      this.BASE = R.BASE, this.ZERO = R.ZERO, this.Fn = R.Fn, this.bits = L;
    }
    // non-const time multiplication ladder
    _unsafeLadder(R, L, _ = this.ZERO) {
      let K = R;
      for (; L > c; )
        L & t && (_ = _.add(K)), K = K.double(), L >>= t;
      return _;
    }
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(ùëä‚àí1) * (Math.ceil(ùëõ / ùëä) + 1), where:
     * - ùëä is the window size
     * - ùëõ is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param point Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(R, L) {
      const { windows: _, windowSize: K } = p(L, this.bits), W = [];
      let D = R, d = D;
      for (let l = 0; l < _; l++) {
        d = D, W.push(d);
        for (let r = 1; r < K; r++)
          d = d.add(D), W.push(d);
        D = d.double();
      }
      return W;
    }
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * More compact implementation:
     * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
     * @returns real and fake (for const-time) points
     */
    wNAF(R, L, _) {
      if (!this.Fn.isValid(_))
        throw new Error("invalid scalar");
      let K = this.ZERO, W = this.BASE;
      const D = p(R, this.bits);
      for (let d = 0; d < D.windows; d++) {
        const { nextN: l, offset: r, isZero: a, isNeg: i, isNegF: o, offsetF: h } = v(_, d, D);
        _ = l, a ? W = W.add(u(o, L[h])) : K = K.add(u(i, L[r]));
      }
      return S(_), { p: K, f: W };
    }
    /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */
    wNAFUnsafe(R, L, _, K = this.ZERO) {
      const W = p(R, this.bits);
      for (let D = 0; D < W.windows && _ !== c; D++) {
        const { nextN: d, offset: l, isZero: r, isNeg: a } = v(_, D, W);
        if (_ = d, !r) {
          const i = L[l];
          K = K.add(a ? i.negate() : i);
        }
      }
      return S(_), K;
    }
    getPrecomputes(R, L, _) {
      let K = V.get(L);
      return K || (K = this.precomputeWindow(L, R), R !== 1 && (typeof _ == "function" && (K = _(K)), V.set(L, K))), K;
    }
    cached(R, L, _) {
      const K = b(R);
      return this.wNAF(K, this.getPrecomputes(K, R, _), L);
    }
    unsafe(R, L, _, K) {
      const W = b(R);
      return W === 1 ? this._unsafeLadder(R, L, K) : this.wNAFUnsafe(W, this.getPrecomputes(W, R, _), L, K);
    }
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    createCache(R, L) {
      g(L, this.bits), E.set(R, L), V.delete(R);
    }
    hasCache(R) {
      return b(R) !== 1;
    }
  }
  Re.wNAF = A;
  function M(j, R, L, _) {
    let K = R, W = j.ZERO, D = j.ZERO;
    for (; L > c || _ > c; )
      L & t && (W = W.add(K)), _ & t && (D = D.add(K)), K = K.double(), L >>= t, _ >>= t;
    return { p1: W, p2: D };
  }
  function Q(j, R, L, _) {
    U(L, j), H(_, R);
    const K = L.length, W = _.length;
    if (K !== W)
      throw new Error("arrays of points and scalars must have equal length");
    const D = j.ZERO, d = (0, e.bitLen)(BigInt(K));
    let l = 1;
    d > 12 ? l = d - 3 : d > 4 ? l = d - 2 : d > 0 && (l = 2);
    const r = (0, e.bitMask)(l), a = new Array(Number(r) + 1).fill(D), i = Math.floor((R.BITS - 1) / l) * l;
    let o = D;
    for (let h = i; h >= 0; h -= l) {
      a.fill(D);
      for (let s = 0; s < W; s++) {
        const f = _[s], y = Number(f >> BigInt(h) & r);
        a[y] = a[y].add(L[s]);
      }
      let w = D;
      for (let s = a.length - 1, f = D; s > 0; s--)
        f = f.add(a[s]), w = w.add(f);
      if (o = o.add(w), h !== 0)
        for (let s = 0; s < l; s++)
          o = o.double();
    }
    return o;
  }
  function F(j, R, L, _) {
    g(_, R.BITS), U(L, j);
    const K = j.ZERO, W = 2 ** _ - 1, D = Math.ceil(R.BITS / _), d = (0, e.bitMask)(_), l = L.map((r) => {
      const a = [];
      for (let i = 0, o = r; i < W; i++)
        a.push(o), o = o.add(r);
      return a;
    });
    return (r) => {
      if (H(r, R), r.length > L.length)
        throw new Error("array of scalars must be smaller than array of points");
      let a = K;
      for (let i = 0; i < D; i++) {
        if (a !== K)
          for (let h = 0; h < _; h++)
            a = a.double();
        const o = BigInt(D * _ - (i + 1) * _);
        for (let h = 0; h < r.length; h++) {
          const w = r[h], s = Number(w >> o & d);
          s && (a = a.add(l[h][s - 1]));
        }
      }
      return a;
    };
  }
  function G(j) {
    return (0, n.validateField)(j.Fp), (0, e.validateObject)(j, {
      n: "bigint",
      h: "bigint",
      Gx: "field",
      Gy: "field"
    }, {
      nBitLength: "isSafeInteger",
      nByteLength: "isSafeInteger"
    }), Object.freeze({
      ...(0, n.nLength)(j.n, j.nBitLength),
      ...j,
      p: j.Fp.ORDER
    });
  }
  function se(j, R, L) {
    if (R) {
      if (R.ORDER !== j)
        throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
      return (0, n.validateField)(R), R;
    } else
      return (0, n.Field)(j, { isLE: L });
  }
  function ie(j, R, L = {}, _) {
    if (_ === void 0 && (_ = j === "edwards"), !R || typeof R != "object")
      throw new Error(`expected valid ${j} CURVE object`);
    for (const l of ["p", "n", "h"]) {
      const r = R[l];
      if (!(typeof r == "bigint" && r > c))
        throw new Error(`CURVE.${l} must be positive bigint`);
    }
    const K = se(R.p, L.Fp, _), W = se(R.n, L.Fn, _), d = ["Gx", "Gy", "a", j === "weierstrass" ? "b" : "d"];
    for (const l of d)
      if (!K.isValid(R[l]))
        throw new Error(`CURVE.${l} must be valid field element of CURVE.Fp`);
    return R = Object.freeze(Object.assign({}, R)), { CURVE: R, Fp: K, Fn: W };
  }
  return Re;
}
var Tt;
function Ct() {
  return Tt || (Tt = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.DER = e.DERErr = void 0, e._splitEndoScalar = p, e._normFnElement = M, e.weierstrassN = Q, e.SWUFpSqrtRatio = G, e.mapToCurveSimpleSWU = se, e.ecdh = j, e.ecdsa = R, e.weierstrassPoints = L, e._legacyHelperEquat = W, e.weierstrass = l;
    const n = /* @__PURE__ */ ln(), c = /* @__PURE__ */ We(), t = /* @__PURE__ */ Ce(), u = /* @__PURE__ */ gn(), m = /* @__PURE__ */ $e(), g = (r, a) => (r + (r >= 0 ? a : -a) / b) / a;
    function p(r, a, i) {
      const [[o, h], [w, s]] = a, f = g(s * r, i), y = g(-h * r, i);
      let B = r - f * o - y * w, O = -f * h - y * s;
      const k = B < V, Y = O < V;
      k && (B = -B), Y && (O = -O);
      const I = (0, t.bitMask)(Math.ceil((0, t.bitLen)(i) / 2)) + E;
      if (B < V || B >= I || O < V || O >= I)
        throw new Error("splitScalar (endomorphism): failed, k=" + r);
      return { k1neg: k, k1: B, k2neg: Y, k2: O };
    }
    function v(r) {
      if (!["compact", "recovered", "der"].includes(r))
        throw new Error('Signature format must be "compact", "recovered", or "der"');
      return r;
    }
    function U(r, a) {
      const i = {};
      for (let o of Object.keys(a))
        i[o] = r[o] === void 0 ? a[o] : r[o];
      return (0, t._abool2)(i.lowS, "lowS"), (0, t._abool2)(i.prehash, "prehash"), i.format !== void 0 && v(i.format), i;
    }
    class H extends Error {
      constructor(a = "") {
        super(a);
      }
    }
    e.DERErr = H, e.DER = {
      // asn.1 DER encoding utils
      Err: H,
      // Basic building block is TLV (Tag-Length-Value)
      _tlv: {
        encode: (r, a) => {
          const { Err: i } = e.DER;
          if (r < 0 || r > 256)
            throw new i("tlv.encode: wrong tag");
          if (a.length & 1)
            throw new i("tlv.encode: unpadded data");
          const o = a.length / 2, h = (0, t.numberToHexUnpadded)(o);
          if (h.length / 2 & 128)
            throw new i("tlv.encode: long form length too big");
          const w = o > 127 ? (0, t.numberToHexUnpadded)(h.length / 2 | 128) : "";
          return (0, t.numberToHexUnpadded)(r) + w + h + a;
        },
        // v - value, l - left bytes (unparsed)
        decode(r, a) {
          const { Err: i } = e.DER;
          let o = 0;
          if (r < 0 || r > 256)
            throw new i("tlv.encode: wrong tag");
          if (a.length < 2 || a[o++] !== r)
            throw new i("tlv.decode: wrong tlv");
          const h = a[o++], w = !!(h & 128);
          let s = 0;
          if (!w)
            s = h;
          else {
            const y = h & 127;
            if (!y)
              throw new i("tlv.decode(long): indefinite length not supported");
            if (y > 4)
              throw new i("tlv.decode(long): byte length is too big");
            const B = a.subarray(o, o + y);
            if (B.length !== y)
              throw new i("tlv.decode: length bytes not complete");
            if (B[0] === 0)
              throw new i("tlv.decode(long): zero leftmost byte");
            for (const O of B)
              s = s << 8 | O;
            if (o += y, s < 128)
              throw new i("tlv.decode(long): not minimal encoding");
          }
          const f = a.subarray(o, o + s);
          if (f.length !== s)
            throw new i("tlv.decode: wrong value length");
          return { v: f, l: a.subarray(o + s) };
        }
      },
      // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
      // since we always use positive integers here. It must always be empty:
      // - add zero byte if exists
      // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
      _int: {
        encode(r) {
          const { Err: a } = e.DER;
          if (r < V)
            throw new a("integer: negative integers are not allowed");
          let i = (0, t.numberToHexUnpadded)(r);
          if (Number.parseInt(i[0], 16) & 8 && (i = "00" + i), i.length & 1)
            throw new a("unexpected DER parsing assertion: unpadded hex");
          return i;
        },
        decode(r) {
          const { Err: a } = e.DER;
          if (r[0] & 128)
            throw new a("invalid signature integer: negative");
          if (r[0] === 0 && !(r[1] & 128))
            throw new a("invalid signature integer: unnecessary leading zero");
          return (0, t.bytesToNumberBE)(r);
        }
      },
      toSig(r) {
        const { Err: a, _int: i, _tlv: o } = e.DER, h = (0, t.ensureBytes)("signature", r), { v: w, l: s } = o.decode(48, h);
        if (s.length)
          throw new a("invalid signature: left bytes after parsing");
        const { v: f, l: y } = o.decode(2, w), { v: B, l: O } = o.decode(2, y);
        if (O.length)
          throw new a("invalid signature: left bytes after parsing");
        return { r: i.decode(f), s: i.decode(B) };
      },
      hexFromSig(r) {
        const { _tlv: a, _int: i } = e.DER, o = a.encode(2, i.encode(r.r)), h = a.encode(2, i.encode(r.s)), w = o + h;
        return a.encode(48, w);
      }
    };
    const V = BigInt(0), E = BigInt(1), b = BigInt(2), S = BigInt(3), A = BigInt(4);
    function M(r, a) {
      const { BYTES: i } = r;
      let o;
      if (typeof a == "bigint")
        o = a;
      else {
        let h = (0, t.ensureBytes)("private key", a);
        try {
          o = r.fromBytes(h);
        } catch {
          throw new Error(`invalid private key: expected ui8a of size ${i}, got ${typeof a}`);
        }
      }
      if (!r.isValidNot0(o))
        throw new Error("invalid private key: out of range [1..N-1]");
      return o;
    }
    function Q(r, a = {}) {
      const i = (0, u._createCurveFields)("weierstrass", r, a), { Fp: o, Fn: h } = i;
      let w = i.CURVE;
      const { h: s, n: f } = w;
      (0, t._validateObject)(a, {}, {
        allowInfinityPoint: "boolean",
        clearCofactor: "function",
        isTorsionFree: "function",
        fromBytes: "function",
        toBytes: "function",
        endo: "object",
        wrapPrivateKey: "boolean"
      });
      const { endo: y } = a;
      if (y && (!o.is0(w.a) || typeof y.beta != "bigint" || !Array.isArray(y.basises)))
        throw new Error('invalid endo: expected "beta": bigint and "basises": array');
      const B = ie(o, h);
      function O() {
        if (!o.isOdd)
          throw new Error("compression is not supported: Field does not have .isOdd()");
      }
      function k(le, Z, N) {
        const { x, y: z } = Z.toAffine(), J = o.toBytes(x);
        if ((0, t._abool2)(N, "isCompressed"), N) {
          O();
          const re = !o.isOdd(z);
          return (0, t.concatBytes)(F(re), J);
        } else
          return (0, t.concatBytes)(Uint8Array.of(4), J, o.toBytes(z));
      }
      function Y(le) {
        (0, t._abytes2)(le, void 0, "Point");
        const { publicKey: Z, publicKeyUncompressed: N } = B, x = le.length, z = le[0], J = le.subarray(1);
        if (x === Z && (z === 2 || z === 3)) {
          const re = o.fromBytes(J);
          if (!o.isValid(re))
            throw new Error("bad point: is not on curve, wrong x");
          const ne = C(re);
          let ee;
          try {
            ee = o.sqrt(ne);
          } catch (we) {
            const de = we instanceof Error ? ": " + we.message : "";
            throw new Error("bad point: is not on curve, sqrt error" + de);
          }
          O();
          const oe = o.isOdd(ee);
          return (z & 1) === 1 !== oe && (ee = o.neg(ee)), { x: re, y: ee };
        } else if (x === N && z === 4) {
          const re = o.BYTES, ne = o.fromBytes(J.subarray(0, re)), ee = o.fromBytes(J.subarray(re, re * 2));
          if (!te(ne, ee))
            throw new Error("bad point: is not on curve");
          return { x: ne, y: ee };
        } else
          throw new Error(`bad point: got length ${x}, expected compressed=${Z} or uncompressed=${N}`);
      }
      const I = a.toBytes || k, q = a.fromBytes || Y;
      function C(le) {
        const Z = o.sqr(le), N = o.mul(Z, le);
        return o.add(o.add(N, o.mul(le, w.a)), w.b);
      }
      function te(le, Z) {
        const N = o.sqr(Z), x = C(le);
        return o.eql(N, x);
      }
      if (!te(w.Gx, w.Gy))
        throw new Error("bad curve params: generator point");
      const $ = o.mul(o.pow(w.a, S), A), T = o.mul(o.sqr(w.b), BigInt(27));
      if (o.is0(o.add($, T)))
        throw new Error("bad curve params: a or b");
      function X(le, Z, N = !1) {
        if (!o.isValid(Z) || N && o.is0(Z))
          throw new Error(`bad point coordinate ${le}`);
        return Z;
      }
      function ae(le) {
        if (!(le instanceof fe))
          throw new Error("ProjectivePoint expected");
      }
      function ye(le) {
        if (!y || !y.basises)
          throw new Error("no endo");
        return p(le, y.basises, h.ORDER);
      }
      const pe = (0, t.memoized)((le, Z) => {
        const { X: N, Y: x, Z: z } = le;
        if (o.eql(z, o.ONE))
          return { x: N, y: x };
        const J = le.is0();
        Z == null && (Z = J ? o.ONE : o.inv(z));
        const re = o.mul(N, Z), ne = o.mul(x, Z), ee = o.mul(z, Z);
        if (J)
          return { x: o.ZERO, y: o.ZERO };
        if (!o.eql(ee, o.ONE))
          throw new Error("invZ was invalid");
        return { x: re, y: ne };
      }), ve = (0, t.memoized)((le) => {
        if (le.is0()) {
          if (a.allowInfinityPoint && !o.is0(le.Y))
            return;
          throw new Error("bad point: ZERO");
        }
        const { x: Z, y: N } = le.toAffine();
        if (!o.isValid(Z) || !o.isValid(N))
          throw new Error("bad point: x or y not field elements");
        if (!te(Z, N))
          throw new Error("bad point: equation left != right");
        if (!le.isTorsionFree())
          throw new Error("bad point: not in prime-order subgroup");
        return !0;
      });
      function Te(le, Z, N, x, z) {
        return N = new fe(o.mul(N.X, le), N.Y, N.Z), Z = (0, u.negateCt)(x, Z), N = (0, u.negateCt)(z, N), Z.add(N);
      }
      class fe {
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
        constructor(Z, N, x) {
          this.X = X("x", Z), this.Y = X("y", N, !0), this.Z = X("z", x), Object.freeze(this);
        }
        static CURVE() {
          return w;
        }
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
        static fromAffine(Z) {
          const { x: N, y: x } = Z || {};
          if (!Z || !o.isValid(N) || !o.isValid(x))
            throw new Error("invalid affine point");
          if (Z instanceof fe)
            throw new Error("projective point not allowed");
          return o.is0(N) && o.is0(x) ? fe.ZERO : new fe(N, x, o.ONE);
        }
        static fromBytes(Z) {
          const N = fe.fromAffine(q((0, t._abytes2)(Z, void 0, "point")));
          return N.assertValidity(), N;
        }
        static fromHex(Z) {
          return fe.fromBytes((0, t.ensureBytes)("pointHex", Z));
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        /**
         *
         * @param windowSize
         * @param isLazy true will defer table computation until the first multiplication
         * @returns
         */
        precompute(Z = 8, N = !0) {
          return Ue.createCache(this, Z), N || this.multiply(S), this;
        }
        // TODO: return `this`
        /** A point on curve is valid if it conforms to equation. */
        assertValidity() {
          ve(this);
        }
        hasEvenY() {
          const { y: Z } = this.toAffine();
          if (!o.isOdd)
            throw new Error("Field doesn't support isOdd");
          return !o.isOdd(Z);
        }
        /** Compare one point to another. */
        equals(Z) {
          ae(Z);
          const { X: N, Y: x, Z: z } = this, { X: J, Y: re, Z: ne } = Z, ee = o.eql(o.mul(N, ne), o.mul(J, z)), oe = o.eql(o.mul(x, ne), o.mul(re, z));
          return ee && oe;
        }
        /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
        negate() {
          return new fe(this.X, o.neg(this.Y), this.Z);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
          const { a: Z, b: N } = w, x = o.mul(N, S), { X: z, Y: J, Z: re } = this;
          let ne = o.ZERO, ee = o.ZERO, oe = o.ZERO, ce = o.mul(z, z), we = o.mul(J, J), de = o.mul(re, re), ue = o.mul(z, J);
          return ue = o.add(ue, ue), oe = o.mul(z, re), oe = o.add(oe, oe), ne = o.mul(Z, oe), ee = o.mul(x, de), ee = o.add(ne, ee), ne = o.sub(we, ee), ee = o.add(we, ee), ee = o.mul(ne, ee), ne = o.mul(ue, ne), oe = o.mul(x, oe), de = o.mul(Z, de), ue = o.sub(ce, de), ue = o.mul(Z, ue), ue = o.add(ue, oe), oe = o.add(ce, ce), ce = o.add(oe, ce), ce = o.add(ce, de), ce = o.mul(ce, ue), ee = o.add(ee, ce), de = o.mul(J, re), de = o.add(de, de), ce = o.mul(de, ue), ne = o.sub(ne, ce), oe = o.mul(de, we), oe = o.add(oe, oe), oe = o.add(oe, oe), new fe(ne, ee, oe);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(Z) {
          ae(Z);
          const { X: N, Y: x, Z: z } = this, { X: J, Y: re, Z: ne } = Z;
          let ee = o.ZERO, oe = o.ZERO, ce = o.ZERO;
          const we = w.a, de = o.mul(w.b, S);
          let ue = o.mul(N, J), me = o.mul(x, re), ge = o.mul(z, ne), _e = o.add(N, x), be = o.add(J, re);
          _e = o.mul(_e, be), be = o.add(ue, me), _e = o.sub(_e, be), be = o.add(N, z);
          let Ee = o.add(J, ne);
          return be = o.mul(be, Ee), Ee = o.add(ue, ge), be = o.sub(be, Ee), Ee = o.add(x, z), ee = o.add(re, ne), Ee = o.mul(Ee, ee), ee = o.add(me, ge), Ee = o.sub(Ee, ee), ce = o.mul(we, be), ee = o.mul(de, ge), ce = o.add(ee, ce), ee = o.sub(me, ce), ce = o.add(me, ce), oe = o.mul(ee, ce), me = o.add(ue, ue), me = o.add(me, ue), ge = o.mul(we, ge), be = o.mul(de, be), me = o.add(me, ge), ge = o.sub(ue, ge), ge = o.mul(we, ge), be = o.add(be, ge), ue = o.mul(me, be), oe = o.add(oe, ue), ue = o.mul(Ee, be), ee = o.mul(_e, ee), ee = o.sub(ee, ue), ue = o.mul(_e, me), ce = o.mul(Ee, ce), ce = o.add(ce, ue), new fe(ee, oe, ce);
        }
        subtract(Z) {
          return this.add(Z.negate());
        }
        is0() {
          return this.equals(fe.ZERO);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(Z) {
          const { endo: N } = a;
          if (!h.isValidNot0(Z))
            throw new Error("invalid scalar: out of range");
          let x, z;
          const J = (re) => Ue.cached(this, re, (ne) => (0, u.normalizeZ)(fe, ne));
          if (N) {
            const { k1neg: re, k1: ne, k2neg: ee, k2: oe } = ye(Z), { p: ce, f: we } = J(ne), { p: de, f: ue } = J(oe);
            z = we.add(ue), x = Te(N.beta, ce, de, re, ee);
          } else {
            const { p: re, f: ne } = J(Z);
            x = re, z = ne;
          }
          return (0, u.normalizeZ)(fe, [x, z])[0];
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed secret key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(Z) {
          const { endo: N } = a, x = this;
          if (!h.isValid(Z))
            throw new Error("invalid scalar: out of range");
          if (Z === V || x.is0())
            return fe.ZERO;
          if (Z === E)
            return x;
          if (Ue.hasCache(this))
            return this.multiply(Z);
          if (N) {
            const { k1neg: z, k1: J, k2neg: re, k2: ne } = ye(Z), { p1: ee, p2: oe } = (0, u.mulEndoUnsafe)(fe, x, J, ne);
            return Te(N.beta, ee, oe, z, re);
          } else
            return Ue.unsafe(x, Z);
        }
        multiplyAndAddUnsafe(Z, N, x) {
          const z = this.multiplyUnsafe(N).add(Z.multiplyUnsafe(x));
          return z.is0() ? void 0 : z;
        }
        /**
         * Converts Projective point to affine (x, y) coordinates.
         * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
         */
        toAffine(Z) {
          return pe(this, Z);
        }
        /**
         * Checks whether Point is free of torsion elements (is in prime subgroup).
         * Always torsion-free for cofactor=1 curves.
         */
        isTorsionFree() {
          const { isTorsionFree: Z } = a;
          return s === E ? !0 : Z ? Z(fe, this) : Ue.unsafe(this, f).is0();
        }
        clearCofactor() {
          const { clearCofactor: Z } = a;
          return s === E ? this : Z ? Z(fe, this) : this.multiplyUnsafe(s);
        }
        isSmallOrder() {
          return this.multiplyUnsafe(s).is0();
        }
        toBytes(Z = !0) {
          return (0, t._abool2)(Z, "isCompressed"), this.assertValidity(), I(fe, this, Z);
        }
        toHex(Z = !0) {
          return (0, t.bytesToHex)(this.toBytes(Z));
        }
        toString() {
          return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
        }
        // TODO: remove
        get px() {
          return this.X;
        }
        get py() {
          return this.X;
        }
        get pz() {
          return this.Z;
        }
        toRawBytes(Z = !0) {
          return this.toBytes(Z);
        }
        _setWindowSize(Z) {
          this.precompute(Z);
        }
        static normalizeZ(Z) {
          return (0, u.normalizeZ)(fe, Z);
        }
        static msm(Z, N) {
          return (0, u.pippenger)(fe, h, Z, N);
        }
        static fromPrivateKey(Z) {
          return fe.BASE.multiply(M(h, Z));
        }
      }
      fe.BASE = new fe(w.Gx, w.Gy, o.ONE), fe.ZERO = new fe(o.ZERO, o.ONE, o.ZERO), fe.Fp = o, fe.Fn = h;
      const Ye = h.BITS, Ue = new u.wNAF(fe, a.endo ? Math.ceil(Ye / 2) : Ye);
      return fe.BASE.precompute(8), fe;
    }
    function F(r) {
      return Uint8Array.of(r ? 2 : 3);
    }
    function G(r, a) {
      const i = r.ORDER;
      let o = V;
      for (let q = i - E; q % b === V; q /= b)
        o += E;
      const h = o, w = b << h - E - E, s = w * b, f = (i - E) / s, y = (f - E) / b, B = s - E, O = w, k = r.pow(a, f), Y = r.pow(a, (f + E) / b);
      let I = (q, C) => {
        let te = k, $ = r.pow(C, B), T = r.sqr($);
        T = r.mul(T, C);
        let X = r.mul(q, T);
        X = r.pow(X, y), X = r.mul(X, $), $ = r.mul(X, C), T = r.mul(X, q);
        let ae = r.mul(T, $);
        X = r.pow(ae, O);
        let ye = r.eql(X, r.ONE);
        $ = r.mul(T, Y), X = r.mul(ae, te), T = r.cmov($, T, ye), ae = r.cmov(X, ae, ye);
        for (let pe = h; pe > E; pe--) {
          let ve = pe - b;
          ve = b << ve - E;
          let Te = r.pow(ae, ve);
          const fe = r.eql(Te, r.ONE);
          $ = r.mul(T, te), te = r.mul(te, te), Te = r.mul(ae, te), T = r.cmov($, T, fe), ae = r.cmov(Te, ae, fe);
        }
        return { isValid: ye, value: T };
      };
      if (r.ORDER % A === S) {
        const q = (r.ORDER - S) / A, C = r.sqrt(r.neg(a));
        I = (te, $) => {
          let T = r.sqr($);
          const X = r.mul(te, $);
          T = r.mul(T, X);
          let ae = r.pow(T, q);
          ae = r.mul(ae, X);
          const ye = r.mul(ae, C), pe = r.mul(r.sqr(ae), $), ve = r.eql(pe, te);
          let Te = r.cmov(ye, ae, ve);
          return { isValid: ve, value: Te };
        };
      }
      return I;
    }
    function se(r, a) {
      (0, m.validateField)(r);
      const { A: i, B: o, Z: h } = a;
      if (!r.isValid(i) || !r.isValid(o) || !r.isValid(h))
        throw new Error("mapToCurveSimpleSWU: invalid opts");
      const w = G(r, h);
      if (!r.isOdd)
        throw new Error("Field does not have .isOdd()");
      return (s) => {
        let f, y, B, O, k, Y, I, q;
        f = r.sqr(s), f = r.mul(f, h), y = r.sqr(f), y = r.add(y, f), B = r.add(y, r.ONE), B = r.mul(B, o), O = r.cmov(h, r.neg(y), !r.eql(y, r.ZERO)), O = r.mul(O, i), y = r.sqr(B), Y = r.sqr(O), k = r.mul(Y, i), y = r.add(y, k), y = r.mul(y, B), Y = r.mul(Y, O), k = r.mul(Y, o), y = r.add(y, k), I = r.mul(f, B);
        const { isValid: C, value: te } = w(y, Y);
        q = r.mul(f, s), q = r.mul(q, te), I = r.cmov(I, B, C), q = r.cmov(q, te, C);
        const $ = r.isOdd(s) === r.isOdd(q);
        q = r.cmov(r.neg(q), q, $);
        const T = (0, m.FpInvertBatch)(r, [O], !0)[0];
        return I = r.mul(I, T), { x: I, y: q };
      };
    }
    function ie(r, a) {
      return {
        secretKey: a.BYTES,
        publicKey: 1 + r.BYTES,
        publicKeyUncompressed: 1 + 2 * r.BYTES,
        publicKeyHasPrefix: !0,
        signature: 2 * a.BYTES
      };
    }
    function j(r, a = {}) {
      const { Fn: i } = r, o = a.randomBytes || t.randomBytes, h = Object.assign(ie(r.Fp, i), { seed: (0, m.getMinHashLength)(i.ORDER) });
      function w(I) {
        try {
          return !!M(i, I);
        } catch {
          return !1;
        }
      }
      function s(I, q) {
        const { publicKey: C, publicKeyUncompressed: te } = h;
        try {
          const $ = I.length;
          return q === !0 && $ !== C || q === !1 && $ !== te ? !1 : !!r.fromBytes(I);
        } catch {
          return !1;
        }
      }
      function f(I = o(h.seed)) {
        return (0, m.mapHashToField)((0, t._abytes2)(I, h.seed, "seed"), i.ORDER);
      }
      function y(I, q = !0) {
        return r.BASE.multiply(M(i, I)).toBytes(q);
      }
      function B(I) {
        const q = f(I);
        return { secretKey: q, publicKey: y(q) };
      }
      function O(I) {
        if (typeof I == "bigint")
          return !1;
        if (I instanceof r)
          return !0;
        const { secretKey: q, publicKey: C, publicKeyUncompressed: te } = h;
        if (i.allowedLengths || q === C)
          return;
        const $ = (0, t.ensureBytes)("key", I).length;
        return $ === C || $ === te;
      }
      function k(I, q, C = !0) {
        if (O(I) === !0)
          throw new Error("first arg must be private key");
        if (O(q) === !1)
          throw new Error("second arg must be public key");
        const te = M(i, I);
        return r.fromHex(q).multiply(te).toBytes(C);
      }
      return Object.freeze({ getPublicKey: y, getSharedSecret: k, keygen: B, Point: r, utils: {
        isValidSecretKey: w,
        isValidPublicKey: s,
        randomSecretKey: f,
        // TODO: remove
        isValidPrivateKey: w,
        randomPrivateKey: f,
        normPrivateKeyToScalar: (I) => M(i, I),
        precompute(I = 8, q = r.BASE) {
          return q.precompute(I, !1);
        }
      }, lengths: h });
    }
    function R(r, a, i = {}) {
      (0, c.ahash)(a), (0, t._validateObject)(i, {}, {
        hmac: "function",
        lowS: "boolean",
        randomBytes: "function",
        bits2int: "function",
        bits2int_modN: "function"
      });
      const o = i.randomBytes || t.randomBytes, h = i.hmac || ((N, ...x) => (0, n.hmac)(a, N, (0, t.concatBytes)(...x))), { Fp: w, Fn: s } = r, { ORDER: f, BITS: y } = s, { keygen: B, getPublicKey: O, getSharedSecret: k, utils: Y, lengths: I } = j(r, i), q = {
        prehash: !1,
        lowS: typeof i.lowS == "boolean" ? i.lowS : !1,
        format: void 0,
        //'compact' as ECDSASigFormat,
        extraEntropy: !1
      }, C = "compact";
      function te(N) {
        const x = f >> E;
        return N > x;
      }
      function $(N, x) {
        if (!s.isValidNot0(x))
          throw new Error(`invalid signature ${N}: out of range 1..Point.Fn.ORDER`);
        return x;
      }
      function T(N, x) {
        v(x);
        const z = I.signature, J = x === "compact" ? z : x === "recovered" ? z + 1 : void 0;
        return (0, t._abytes2)(N, J, `${x} signature`);
      }
      class X {
        constructor(x, z, J) {
          this.r = $("r", x), this.s = $("s", z), J != null && (this.recovery = J), Object.freeze(this);
        }
        static fromBytes(x, z = C) {
          T(x, z);
          let J;
          if (z === "der") {
            const { r: oe, s: ce } = e.DER.toSig((0, t._abytes2)(x));
            return new X(oe, ce);
          }
          z === "recovered" && (J = x[0], z = "compact", x = x.subarray(1));
          const re = s.BYTES, ne = x.subarray(0, re), ee = x.subarray(re, re * 2);
          return new X(s.fromBytes(ne), s.fromBytes(ee), J);
        }
        static fromHex(x, z) {
          return this.fromBytes((0, t.hexToBytes)(x), z);
        }
        addRecoveryBit(x) {
          return new X(this.r, this.s, x);
        }
        recoverPublicKey(x) {
          const z = w.ORDER, { r: J, s: re, recovery: ne } = this;
          if (ne == null || ![0, 1, 2, 3].includes(ne))
            throw new Error("recovery id invalid");
          if (f * b < z && ne > 1)
            throw new Error("recovery id is ambiguous for h>1 curve");
          const oe = ne === 2 || ne === 3 ? J + f : J;
          if (!w.isValid(oe))
            throw new Error("recovery id 2 or 3 invalid");
          const ce = w.toBytes(oe), we = r.fromBytes((0, t.concatBytes)(F((ne & 1) === 0), ce)), de = s.inv(oe), ue = ye((0, t.ensureBytes)("msgHash", x)), me = s.create(-ue * de), ge = s.create(re * de), _e = r.BASE.multiplyUnsafe(me).add(we.multiplyUnsafe(ge));
          if (_e.is0())
            throw new Error("point at infinify");
          return _e.assertValidity(), _e;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
          return te(this.s);
        }
        toBytes(x = C) {
          if (v(x), x === "der")
            return (0, t.hexToBytes)(e.DER.hexFromSig(this));
          const z = s.toBytes(this.r), J = s.toBytes(this.s);
          if (x === "recovered") {
            if (this.recovery == null)
              throw new Error("recovery bit must be present");
            return (0, t.concatBytes)(Uint8Array.of(this.recovery), z, J);
          }
          return (0, t.concatBytes)(z, J);
        }
        toHex(x) {
          return (0, t.bytesToHex)(this.toBytes(x));
        }
        // TODO: remove
        assertValidity() {
        }
        static fromCompact(x) {
          return X.fromBytes((0, t.ensureBytes)("sig", x), "compact");
        }
        static fromDER(x) {
          return X.fromBytes((0, t.ensureBytes)("sig", x), "der");
        }
        normalizeS() {
          return this.hasHighS() ? new X(this.r, s.neg(this.s), this.recovery) : this;
        }
        toDERRawBytes() {
          return this.toBytes("der");
        }
        toDERHex() {
          return (0, t.bytesToHex)(this.toBytes("der"));
        }
        toCompactRawBytes() {
          return this.toBytes("compact");
        }
        toCompactHex() {
          return (0, t.bytesToHex)(this.toBytes("compact"));
        }
      }
      const ae = i.bits2int || function(x) {
        if (x.length > 8192)
          throw new Error("input is too large");
        const z = (0, t.bytesToNumberBE)(x), J = x.length * 8 - y;
        return J > 0 ? z >> BigInt(J) : z;
      }, ye = i.bits2int_modN || function(x) {
        return s.create(ae(x));
      }, pe = (0, t.bitMask)(y);
      function ve(N) {
        return (0, t.aInRange)("num < 2^" + y, N, V, pe), s.toBytes(N);
      }
      function Te(N, x) {
        return (0, t._abytes2)(N, void 0, "message"), x ? (0, t._abytes2)(a(N), void 0, "prehashed message") : N;
      }
      function fe(N, x, z) {
        if (["recovered", "canonical"].some((me) => me in z))
          throw new Error("sign() legacy options not supported");
        const { lowS: J, prehash: re, extraEntropy: ne } = U(z, q);
        N = Te(N, re);
        const ee = ye(N), oe = M(s, x), ce = [ve(oe), ve(ee)];
        if (ne != null && ne !== !1) {
          const me = ne === !0 ? o(I.secretKey) : ne;
          ce.push((0, t.ensureBytes)("extraEntropy", me));
        }
        const we = (0, t.concatBytes)(...ce), de = ee;
        function ue(me) {
          const ge = ae(me);
          if (!s.isValidNot0(ge))
            return;
          const _e = s.inv(ge), be = r.BASE.multiply(ge).toAffine(), Ee = s.create(be.x);
          if (Ee === V)
            return;
          const Pe = s.create(_e * s.create(de + Ee * oe));
          if (Pe === V)
            return;
          let pt = (be.x === Ee ? 0 : 2) | Number(be.y & E), vt = Pe;
          return J && te(Pe) && (vt = s.neg(Pe), pt ^= 1), new X(Ee, vt, pt);
        }
        return { seed: we, k2sig: ue };
      }
      function Ye(N, x, z = {}) {
        N = (0, t.ensureBytes)("message", N);
        const { seed: J, k2sig: re } = fe(N, x, z);
        return (0, t.createHmacDrbg)(a.outputLen, s.BYTES, h)(J, re);
      }
      function Ue(N) {
        let x;
        const z = typeof N == "string" || (0, t.isBytes)(N), J = !z && N !== null && typeof N == "object" && typeof N.r == "bigint" && typeof N.s == "bigint";
        if (!z && !J)
          throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
        if (J)
          x = new X(N.r, N.s);
        else if (z) {
          try {
            x = X.fromBytes((0, t.ensureBytes)("sig", N), "der");
          } catch (re) {
            if (!(re instanceof e.DER.Err))
              throw re;
          }
          if (!x)
            try {
              x = X.fromBytes((0, t.ensureBytes)("sig", N), "compact");
            } catch {
              return !1;
            }
        }
        return x || !1;
      }
      function le(N, x, z, J = {}) {
        const { lowS: re, prehash: ne, format: ee } = U(J, q);
        if (z = (0, t.ensureBytes)("publicKey", z), x = Te((0, t.ensureBytes)("message", x), ne), "strict" in J)
          throw new Error("options.strict was renamed to lowS");
        const oe = ee === void 0 ? Ue(N) : X.fromBytes((0, t.ensureBytes)("sig", N), ee);
        if (oe === !1)
          return !1;
        try {
          const ce = r.fromBytes(z);
          if (re && oe.hasHighS())
            return !1;
          const { r: we, s: de } = oe, ue = ye(x), me = s.inv(de), ge = s.create(ue * me), _e = s.create(we * me), be = r.BASE.multiplyUnsafe(ge).add(ce.multiplyUnsafe(_e));
          return be.is0() ? !1 : s.create(be.x) === we;
        } catch {
          return !1;
        }
      }
      function Z(N, x, z = {}) {
        const { prehash: J } = U(z, q);
        return x = Te(x, J), X.fromBytes(N, "recovered").recoverPublicKey(x).toBytes();
      }
      return Object.freeze({
        keygen: B,
        getPublicKey: O,
        getSharedSecret: k,
        utils: Y,
        lengths: I,
        Point: r,
        sign: Ye,
        verify: le,
        recoverPublicKey: Z,
        Signature: X,
        hash: a
      });
    }
    function L(r) {
      const { CURVE: a, curveOpts: i } = _(r), o = Q(a, i);
      return D(r, o);
    }
    function _(r) {
      const a = {
        a: r.a,
        b: r.b,
        p: r.Fp.ORDER,
        n: r.n,
        h: r.h,
        Gx: r.Gx,
        Gy: r.Gy
      }, i = r.Fp;
      let o = r.allowedPrivateKeyLengths ? Array.from(new Set(r.allowedPrivateKeyLengths.map((s) => Math.ceil(s / 2)))) : void 0;
      const h = (0, m.Field)(a.n, {
        BITS: r.nBitLength,
        allowedLengths: o,
        modFromBytes: r.wrapPrivateKey
      }), w = {
        Fp: i,
        Fn: h,
        allowInfinityPoint: r.allowInfinityPoint,
        endo: r.endo,
        isTorsionFree: r.isTorsionFree,
        clearCofactor: r.clearCofactor,
        fromBytes: r.fromBytes,
        toBytes: r.toBytes
      };
      return { CURVE: a, curveOpts: w };
    }
    function K(r) {
      const { CURVE: a, curveOpts: i } = _(r), o = {
        hmac: r.hmac,
        randomBytes: r.randomBytes,
        lowS: r.lowS,
        bits2int: r.bits2int,
        bits2int_modN: r.bits2int_modN
      };
      return { CURVE: a, curveOpts: i, hash: r.hash, ecdsaOpts: o };
    }
    function W(r, a, i) {
      function o(h) {
        const w = r.sqr(h), s = r.mul(w, h);
        return r.add(r.add(s, r.mul(h, a)), i);
      }
      return o;
    }
    function D(r, a) {
      const { Fp: i, Fn: o } = a;
      function h(s) {
        return (0, t.inRange)(s, E, o.ORDER);
      }
      const w = W(i, r.a, r.b);
      return Object.assign({}, {
        CURVE: r,
        Point: a,
        ProjectivePoint: a,
        normPrivateKeyToScalar: (s) => M(o, s),
        weierstrassEquation: w,
        isWithinCurveOrder: h
      });
    }
    function d(r, a) {
      const i = a.Point;
      return Object.assign({}, a, {
        ProjectivePoint: i,
        CURVE: Object.assign({}, r, (0, m.nLength)(i.Fn.ORDER, i.Fn.BITS))
      });
    }
    function l(r) {
      const { CURVE: a, curveOpts: i, hash: o, ecdsaOpts: h } = K(r), w = Q(a, i), s = R(w, o, h);
      return d(r, s);
    }
  })(nt)), nt;
}
var Rt;
function En() {
  if (Rt) return Ke;
  Rt = 1, Object.defineProperty(Ke, "__esModule", { value: !0 }), Ke.getHash = n, Ke.createCurve = c;
  const e = /* @__PURE__ */ Ct();
  function n(t) {
    return { hash: t };
  }
  function c(t, u) {
    const m = (g) => (0, e.weierstrass)({ ...t, hash: g });
    return { ...m(u), create: m };
  }
  return Ke;
}
var ot = {}, xt;
function Bn() {
  return xt || (xt = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e._DST_scalar = void 0, e.expand_message_xmd = v, e.expand_message_xof = U, e.hash_to_field = H, e.isogenyMap = V, e.createHasher = E;
    const n = /* @__PURE__ */ Ce(), c = /* @__PURE__ */ $e(), t = n.bytesToNumberBE;
    function u(b, S) {
      if (g(b), g(S), b < 0 || b >= 1 << 8 * S)
        throw new Error("invalid I2OSP input: " + b);
      const A = Array.from({ length: S }).fill(0);
      for (let M = S - 1; M >= 0; M--)
        A[M] = b & 255, b >>>= 8;
      return new Uint8Array(A);
    }
    function m(b, S) {
      const A = new Uint8Array(b.length);
      for (let M = 0; M < b.length; M++)
        A[M] = b[M] ^ S[M];
      return A;
    }
    function g(b) {
      if (!Number.isSafeInteger(b))
        throw new Error("number expected");
    }
    function p(b) {
      if (!(0, n.isBytes)(b) && typeof b != "string")
        throw new Error("DST must be Uint8Array or string");
      return typeof b == "string" ? (0, n.utf8ToBytes)(b) : b;
    }
    function v(b, S, A, M) {
      (0, n.abytes)(b), g(A), S = p(S), S.length > 255 && (S = M((0, n.concatBytes)((0, n.utf8ToBytes)("H2C-OVERSIZE-DST-"), S)));
      const { outputLen: Q, blockLen: F } = M, G = Math.ceil(A / Q);
      if (A > 65535 || G > 255)
        throw new Error("expand_message_xmd: invalid lenInBytes");
      const se = (0, n.concatBytes)(S, u(S.length, 1)), ie = u(0, F), j = u(A, 2), R = new Array(G), L = M((0, n.concatBytes)(ie, b, j, u(0, 1), se));
      R[0] = M((0, n.concatBytes)(L, u(1, 1), se));
      for (let K = 1; K <= G; K++) {
        const W = [m(L, R[K - 1]), u(K + 1, 1), se];
        R[K] = M((0, n.concatBytes)(...W));
      }
      return (0, n.concatBytes)(...R).slice(0, A);
    }
    function U(b, S, A, M, Q) {
      if ((0, n.abytes)(b), g(A), S = p(S), S.length > 255) {
        const F = Math.ceil(2 * M / 8);
        S = Q.create({ dkLen: F }).update((0, n.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(S).digest();
      }
      if (A > 65535 || S.length > 255)
        throw new Error("expand_message_xof: invalid lenInBytes");
      return Q.create({ dkLen: A }).update(b).update(u(A, 2)).update(S).update(u(S.length, 1)).digest();
    }
    function H(b, S, A) {
      (0, n._validateObject)(A, {
        p: "bigint",
        m: "number",
        k: "number",
        hash: "function"
      });
      const { p: M, k: Q, m: F, hash: G, expand: se, DST: ie } = A;
      if (!(0, n.isHash)(A.hash))
        throw new Error("expected valid hash");
      (0, n.abytes)(b), g(S);
      const j = M.toString(2).length, R = Math.ceil((j + Q) / 8), L = S * F * R;
      let _;
      if (se === "xmd")
        _ = v(b, ie, L, G);
      else if (se === "xof")
        _ = U(b, ie, L, Q, G);
      else if (se === "_internal_pass")
        _ = b;
      else
        throw new Error('expand must be "xmd" or "xof"');
      const K = new Array(S);
      for (let W = 0; W < S; W++) {
        const D = new Array(F);
        for (let d = 0; d < F; d++) {
          const l = R * (d + W * F), r = _.subarray(l, l + R);
          D[d] = (0, c.mod)(t(r), M);
        }
        K[W] = D;
      }
      return K;
    }
    function V(b, S) {
      const A = S.map((M) => Array.from(M).reverse());
      return (M, Q) => {
        const [F, G, se, ie] = A.map((L) => L.reduce((_, K) => b.add(b.mul(_, M), K))), [j, R] = (0, c.FpInvertBatch)(b, [G, ie], !0);
        return M = b.mul(F, j), Q = b.mul(Q, b.mul(se, R)), { x: M, y: Q };
      };
    }
    e._DST_scalar = (0, n.utf8ToBytes)("HashToScalar-");
    function E(b, S, A) {
      if (typeof S != "function")
        throw new Error("mapToCurve() must be defined");
      function M(F) {
        return b.fromAffine(S(F));
      }
      function Q(F) {
        const G = F.clearCofactor();
        return G.equals(b.ZERO) ? b.ZERO : (G.assertValidity(), G);
      }
      return {
        defaults: A,
        hashToCurve(F, G) {
          const se = Object.assign({}, A, G), ie = H(F, 2, se), j = M(ie[0]), R = M(ie[1]);
          return Q(j.add(R));
        },
        encodeToCurve(F, G) {
          const se = A.encodeDST ? { DST: A.encodeDST } : {}, ie = Object.assign({}, A, se, G), j = H(F, 1, ie), R = M(j[0]);
          return Q(R);
        },
        /** See {@link H2CHasher} */
        mapToCurve(F) {
          if (!Array.isArray(F))
            throw new Error("expected array of bigints");
          for (const G of F)
            if (typeof G != "bigint")
              throw new Error("expected array of bigints");
          return Q(M(F));
        },
        // hash_to_scalar can produce 0: https://www.rfc-editor.org/errata/eid8393
        // RFC 9380, draft-irtf-cfrg-bbs-signatures-08
        hashToScalar(F, G) {
          const se = b.Fn.ORDER, ie = Object.assign({}, A, { p: se, m: 1, DST: e._DST_scalar }, G);
          return H(F, 1, ie)[0][0];
        }
      };
    }
  })(ot)), ot;
}
var qt;
function nr() {
  return qt || (qt = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.encodeToCurve = e.hashToCurve = e.secp256k1_hasher = e.schnorr = e.secp256k1 = void 0;
    const n = /* @__PURE__ */ dn(), c = /* @__PURE__ */ We(), t = /* @__PURE__ */ En(), u = /* @__PURE__ */ Bn(), m = /* @__PURE__ */ $e(), g = /* @__PURE__ */ Ct(), p = /* @__PURE__ */ Ce(), v = {
      p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
      n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
      h: BigInt(1),
      a: BigInt(0),
      b: BigInt(7),
      Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
      Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
    }, U = {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      basises: [
        [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
        [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
      ]
    }, H = /* @__PURE__ */ BigInt(0), V = /* @__PURE__ */ BigInt(1), E = /* @__PURE__ */ BigInt(2);
    function b(d) {
      const l = v.p, r = BigInt(3), a = BigInt(6), i = BigInt(11), o = BigInt(22), h = BigInt(23), w = BigInt(44), s = BigInt(88), f = d * d * d % l, y = f * f * d % l, B = (0, m.pow2)(y, r, l) * y % l, O = (0, m.pow2)(B, r, l) * y % l, k = (0, m.pow2)(O, E, l) * f % l, Y = (0, m.pow2)(k, i, l) * k % l, I = (0, m.pow2)(Y, o, l) * Y % l, q = (0, m.pow2)(I, w, l) * I % l, C = (0, m.pow2)(q, s, l) * q % l, te = (0, m.pow2)(C, w, l) * I % l, $ = (0, m.pow2)(te, r, l) * y % l, T = (0, m.pow2)($, h, l) * Y % l, X = (0, m.pow2)(T, a, l) * f % l, ae = (0, m.pow2)(X, E, l);
      if (!S.eql(S.sqr(ae), d))
        throw new Error("Cannot find square root");
      return ae;
    }
    const S = (0, m.Field)(v.p, { sqrt: b });
    e.secp256k1 = (0, t.createCurve)({ ...v, Fp: S, lowS: !0, endo: U }, n.sha256);
    const A = {};
    function M(d, ...l) {
      let r = A[d];
      if (r === void 0) {
        const a = (0, n.sha256)((0, p.utf8ToBytes)(d));
        r = (0, p.concatBytes)(a, a), A[d] = r;
      }
      return (0, n.sha256)((0, p.concatBytes)(r, ...l));
    }
    const Q = (d) => d.toBytes(!0).slice(1), F = e.secp256k1.Point, G = (d) => d % E === H;
    function se(d) {
      const { Fn: l, BASE: r } = F, a = (0, g._normFnElement)(l, d), i = r.multiply(a);
      return { scalar: G(i.y) ? a : l.neg(a), bytes: Q(i) };
    }
    function ie(d) {
      const l = S;
      if (!l.isValidNot0(d))
        throw new Error("invalid x: Fail if x ‚â• p");
      const r = l.create(d * d), a = l.create(r * d + BigInt(7));
      let i = l.sqrt(a);
      G(i) || (i = l.neg(i));
      const o = F.fromAffine({ x: d, y: i });
      return o.assertValidity(), o;
    }
    const j = p.bytesToNumberBE;
    function R(...d) {
      return F.Fn.create(j(M("BIP0340/challenge", ...d)));
    }
    function L(d) {
      return se(d).bytes;
    }
    function _(d, l, r = (0, c.randomBytes)(32)) {
      const { Fn: a } = F, i = (0, p.ensureBytes)("message", d), { bytes: o, scalar: h } = se(l), w = (0, p.ensureBytes)("auxRand", r, 32), s = a.toBytes(h ^ j(M("BIP0340/aux", w))), f = M("BIP0340/nonce", s, o, i), { bytes: y, scalar: B } = se(f), O = R(y, o, i), k = new Uint8Array(64);
      if (k.set(y, 0), k.set(a.toBytes(a.create(B + O * h)), 32), !K(k, i, o))
        throw new Error("sign: Invalid signature produced");
      return k;
    }
    function K(d, l, r) {
      const { Fn: a, BASE: i } = F, o = (0, p.ensureBytes)("signature", d, 64), h = (0, p.ensureBytes)("message", l), w = (0, p.ensureBytes)("publicKey", r, 32);
      try {
        const s = ie(j(w)), f = j(o.subarray(0, 32));
        if (!(0, p.inRange)(f, V, v.p))
          return !1;
        const y = j(o.subarray(32, 64));
        if (!(0, p.inRange)(y, V, v.n))
          return !1;
        const B = R(a.toBytes(f), Q(s), h), O = i.multiplyUnsafe(y).add(s.multiplyUnsafe(a.neg(B))), { x: k, y: Y } = O.toAffine();
        return !(O.is0() || !G(Y) || k !== f);
      } catch {
        return !1;
      }
    }
    e.schnorr = (() => {
      const r = (i = (0, c.randomBytes)(48)) => (0, m.mapHashToField)(i, v.n);
      e.secp256k1.utils.randomSecretKey;
      function a(i) {
        const o = r(i);
        return { secretKey: o, publicKey: L(o) };
      }
      return {
        keygen: a,
        getPublicKey: L,
        sign: _,
        verify: K,
        Point: F,
        utils: {
          randomSecretKey: r,
          randomPrivateKey: r,
          taggedHash: M,
          // TODO: remove
          lift_x: ie,
          pointToBytes: Q,
          numberToBytesBE: p.numberToBytesBE,
          bytesToNumberBE: p.bytesToNumberBE,
          mod: m.mod
        },
        lengths: {
          secretKey: 32,
          publicKey: 32,
          publicKeyHasPrefix: !1,
          signature: 64,
          seed: 48
        }
      };
    })();
    const W = (0, u.isogenyMap)(S, [
      // xNum
      [
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
        "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
        "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
      ],
      // xDen
      [
        "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
        "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ],
      // yNum
      [
        "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
        "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
        "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
        "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
      ],
      // yDen
      [
        "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
        "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
        "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ]
    ].map((d) => d.map((l) => BigInt(l)))), D = (0, g.mapToCurveSimpleSWU)(S, {
      A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
      B: BigInt("1771"),
      Z: S.create(BigInt("-11"))
    });
    e.secp256k1_hasher = (0, u.createHasher)(e.secp256k1.Point, (d) => {
      const { x: l, y: r } = D(S.create(d[0]));
      return W(l, r);
    }, {
      DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
      encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
      p: S.ORDER,
      m: 1,
      k: 128,
      expand: "xmd",
      hash: n.sha256
    }), e.hashToCurve = e.secp256k1_hasher.hashToCurve, e.encodeToCurve = e.secp256k1_hasher.encodeToCurve;
  })(tt)), tt;
}
var P = {}, It;
function rr() {
  if (It) return P;
  It = 1, Object.defineProperty(P, "__esModule", { value: !0 }), P.isHash = P.validateObject = P.memoized = P.notImplemented = P.createHmacDrbg = P.bitMask = P.bitSet = P.bitGet = P.bitLen = P.aInRange = P.inRange = P.asciiToBytes = P.copyBytes = P.equalBytes = P.ensureBytes = P.numberToVarBytesBE = P.numberToBytesLE = P.numberToBytesBE = P.bytesToNumberLE = P.bytesToNumberBE = P.hexToNumber = P.numberToHexUnpadded = P.abool = P.utf8ToBytes = P.randomBytes = P.isBytes = P.hexToBytes = P.concatBytes = P.bytesToUtf8 = P.bytesToHex = P.anumber = P.abytes = void 0;
  const e = /* @__PURE__ */ Ce();
  return P.abytes = e.abytes, P.anumber = e.anumber, P.bytesToHex = e.bytesToHex, P.bytesToUtf8 = e.bytesToUtf8, P.concatBytes = e.concatBytes, P.hexToBytes = e.hexToBytes, P.isBytes = e.isBytes, P.randomBytes = e.randomBytes, P.utf8ToBytes = e.utf8ToBytes, P.abool = e.abool, P.numberToHexUnpadded = e.numberToHexUnpadded, P.hexToNumber = e.hexToNumber, P.bytesToNumberBE = e.bytesToNumberBE, P.bytesToNumberLE = e.bytesToNumberLE, P.numberToBytesBE = e.numberToBytesBE, P.numberToBytesLE = e.numberToBytesLE, P.numberToVarBytesBE = e.numberToVarBytesBE, P.ensureBytes = e.ensureBytes, P.equalBytes = e.equalBytes, P.copyBytes = e.copyBytes, P.asciiToBytes = e.asciiToBytes, P.inRange = e.inRange, P.aInRange = e.aInRange, P.bitLen = e.bitLen, P.bitGet = e.bitGet, P.bitSet = e.bitSet, P.bitMask = e.bitMask, P.createHmacDrbg = e.createHmacDrbg, P.notImplemented = e.notImplemented, P.memoized = e.memoized, P.validateObject = e.validateObject, P.isHash = e.isHash, P;
}
function or(e, n = "") {
  if (typeof e != "boolean") {
    const c = n && `"${n}" `;
    throw new Error(c + "expected boolean, got type=" + typeof e);
  }
  return e;
}
function mt(e) {
  if (!Number.isSafeInteger(e) || e < 0 || e > 4294967295)
    throw new Error("wrong u32 integer:" + e);
  return e;
}
function Kt(e) {
  return mt(e), (e & e - 1) === 0 && e !== 0;
}
function pn(e, n) {
  mt(e);
  let c = 0;
  for (let t = 0; t < n; t++, e >>>= 1)
    c = c << 1 | e & 1;
  return c;
}
function Dt(e) {
  return mt(e), 31 - Math.clz32(e);
}
function Nt(e) {
  const n = e.length;
  if (n < 2 || !Kt(n))
    throw new Error("n must be a power of 2 and greater than 1. Got " + n);
  const c = Dt(n);
  for (let t = 0; t < n; t++) {
    const u = pn(t, c);
    if (t < u) {
      const m = e[t];
      e[t] = e[u], e[u] = m;
    }
  }
  return e;
}
const sr = (e, n) => {
  const { N: c, roots: t, dit: u, invertButterflies: m = !1, skipStages: g = 0, brp: p = !0 } = n, v = Dt(c);
  if (!Kt(c))
    throw new Error("FFT: Polynomial size should be power of two");
  const U = u !== m;
  return (H) => {
    if (H.length !== c)
      throw new Error("FFT: wrong Polynomial length");
    u && p && Nt(H);
    for (let V = 0, E = 1; V < v - g; V++) {
      const b = u ? V + 1 + g : v - V, S = 1 << b, A = S >> 1, M = c >> b;
      for (let Q = 0; Q < c; Q += S)
        for (let F = 0, G = E++; F < A; F++) {
          const se = m ? u ? c - G : G : F * M, ie = Q + F, j = Q + F + A, R = t[se], L = H[j], _ = H[ie];
          if (U) {
            const K = e.mul(L, R);
            H[ie] = e.add(_, K), H[j] = e.sub(_, K);
          } else m ? (H[ie] = e.add(L, _), H[j] = e.mul(e.sub(L, _), R)) : (H[ie] = e.add(_, L), H[j] = e.mul(e.sub(_, L), R));
        }
    }
    return !u && p && Nt(H), H;
  };
};
const bt = /* @__PURE__ */ BigInt(0), lt = /* @__PURE__ */ BigInt(1);
function Je(e, n = "") {
  if (typeof e != "boolean") {
    const c = n && `"${n}"`;
    throw new Error(c + "expected boolean, got type=" + typeof e);
  }
  return e;
}
function Ze(e, n, c = "") {
  const t = yt(e), u = e?.length, m = n !== void 0;
  if (!t || m && u !== n) {
    const g = c && `"${c}" `, p = m ? ` of length ${n}` : "", v = t ? `length=${u}` : `type=${typeof e}`;
    throw new Error(g + "expected Uint8Array" + p + ", got " + v);
  }
  return e;
}
function Xe(e) {
  const n = e.toString(16);
  return n.length & 1 ? "0" + n : n;
}
function zt(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return e === "" ? bt : BigInt("0x" + e);
}
function et(e) {
  return zt(Me(e));
}
function Yt(e) {
  return hn(e), zt(Me(Uint8Array.from(e).reverse()));
}
function wt(e, n) {
  return Qe(e.toString(16).padStart(n * 2, "0"));
}
function Pt(e, n) {
  return wt(e, n).reverse();
}
function Se(e, n, c) {
  let t;
  if (typeof n == "string")
    try {
      t = Qe(n);
    } catch (u) {
      throw new Error(e + " must be hex string or Uint8Array, cause: " + u);
    }
  else if (yt(n))
    t = Uint8Array.from(n);
  else
    throw new Error(e + " must be hex string or Uint8Array");
  return t.length, t;
}
const st = (e) => typeof e == "bigint" && bt <= e;
function vn(e, n, c) {
  return st(e) && st(n) && st(c) && n <= e && e < c;
}
function _n(e, n, c, t) {
  if (!vn(n, c, t))
    throw new Error("expected valid " + e + ": " + c + " <= n < " + t + ", got " + n);
}
function Xt(e) {
  let n;
  for (n = 0; e > bt; e >>= lt, n += 1)
    ;
  return n;
}
const De = (e) => (lt << BigInt(e)) - lt;
function Sn(e, n, c) {
  if (typeof e != "number" || e < 2)
    throw new Error("hashLen must be a number");
  if (typeof n != "number" || n < 2)
    throw new Error("qByteLen must be a number");
  if (typeof c != "function")
    throw new Error("hmacFn must be a function");
  const t = (b) => new Uint8Array(b), u = (b) => Uint8Array.of(b);
  let m = t(e), g = t(e), p = 0;
  const v = () => {
    m.fill(1), g.fill(0), p = 0;
  }, U = (...b) => c(g, m, ...b), H = (b = t(0)) => {
    g = U(u(0), b), m = U(), b.length !== 0 && (g = U(u(1), b), m = U());
  }, V = () => {
    if (p++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let b = 0;
    const S = [];
    for (; b < n; ) {
      m = U();
      const A = m.slice();
      S.push(A), b += m.length;
    }
    return Ae(...S);
  };
  return (b, S) => {
    v(), H(b);
    let A;
    for (; !(A = S(V())); )
      H();
    return v(), A;
  };
}
function gt(e, n, c = {}) {
  if (!e || typeof e != "object")
    throw new Error("expected valid options object");
  function t(u, m, g) {
    const p = e[u];
    if (g && p === void 0)
      return;
    const v = typeof p;
    if (v !== m || p === null)
      throw new Error(`param "${u}" is invalid: expected ${m}, got ${v}`);
  }
  Object.entries(n).forEach(([u, m]) => t(u, m, !1)), Object.entries(c).forEach(([u, m]) => t(u, m, !0));
}
function At(e) {
  const n = /* @__PURE__ */ new WeakMap();
  return (c, ...t) => {
    const u = n.get(c);
    if (u !== void 0)
      return u;
    const m = e(c, ...t);
    return n.set(c, m), m;
  };
}
const Oe = BigInt(0), Be = BigInt(1), je = /* @__PURE__ */ BigInt(2), Gt = /* @__PURE__ */ BigInt(3), Wt = /* @__PURE__ */ BigInt(4), Qt = /* @__PURE__ */ BigInt(5), On = /* @__PURE__ */ BigInt(7), Jt = /* @__PURE__ */ BigInt(8), Tn = /* @__PURE__ */ BigInt(9), Ft = /* @__PURE__ */ BigInt(16);
function qe(e, n) {
  const c = e % n;
  return c >= Oe ? c : n + c;
}
function xe(e, n, c) {
  let t = e;
  for (; n-- > Oe; )
    t *= t, t %= c;
  return t;
}
function Ut(e, n) {
  if (e === Oe)
    throw new Error("invert: expected non-zero number");
  if (n <= Oe)
    throw new Error("invert: expected positive modulus, got " + n);
  let c = qe(e, n), t = n, u = Oe, m = Be;
  for (; c !== Oe; ) {
    const p = t / c, v = t % c, U = u - m * p;
    t = c, c = v, u = m, m = U;
  }
  if (t !== Be)
    throw new Error("invert: does not exist");
  return qe(u, n);
}
function Et(e, n, c) {
  if (!e.eql(e.sqr(n), c))
    throw new Error("Cannot find square root");
}
function $t(e, n) {
  const c = (e.ORDER + Be) / Wt, t = e.pow(n, c);
  return Et(e, t, n), t;
}
function Rn(e, n) {
  const c = (e.ORDER - Qt) / Jt, t = e.mul(n, je), u = e.pow(t, c), m = e.mul(n, u), g = e.mul(e.mul(m, je), u), p = e.mul(m, e.sub(g, e.ONE));
  return Et(e, p, n), p;
}
function xn(e) {
  const n = ze(e), c = en(e), t = c(n, n.neg(n.ONE)), u = c(n, t), m = c(n, n.neg(t)), g = (e + On) / Ft;
  return (p, v) => {
    let U = p.pow(v, g), H = p.mul(U, t);
    const V = p.mul(U, u), E = p.mul(U, m), b = p.eql(p.sqr(H), v), S = p.eql(p.sqr(V), v);
    U = p.cmov(U, H, b), H = p.cmov(E, V, S);
    const A = p.eql(p.sqr(H), v), M = p.cmov(U, H, A);
    return Et(p, M, v), M;
  };
}
function en(e) {
  if (e < Gt)
    throw new Error("sqrt is not defined for small field");
  let n = e - Be, c = 0;
  for (; n % je === Oe; )
    n /= je, c++;
  let t = je;
  const u = ze(e);
  for (; Zt(u, t) === 1; )
    if (t++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  if (c === 1)
    return $t;
  let m = u.pow(t, n);
  const g = (n + Be) / je;
  return function(v, U) {
    if (v.is0(U))
      return U;
    if (Zt(v, U) !== 1)
      throw new Error("Cannot find square root");
    let H = c, V = v.mul(v.ONE, m), E = v.pow(U, n), b = v.pow(U, g);
    for (; !v.eql(E, v.ONE); ) {
      if (v.is0(E))
        return v.ZERO;
      let S = 1, A = v.sqr(E);
      for (; !v.eql(A, v.ONE); )
        if (S++, A = v.sqr(A), S === H)
          throw new Error("Cannot find square root");
      const M = Be << BigInt(H - S - 1), Q = v.pow(V, M);
      H = S, V = v.sqr(Q), E = v.mul(E, V), b = v.mul(b, Q);
    }
    return b;
  };
}
function qn(e) {
  return e % Wt === Gt ? $t : e % Jt === Qt ? Rn : e % Ft === Tn ? xn(e) : en(e);
}
const In = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function Nn(e) {
  const n = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "number",
    BITS: "number"
  }, c = In.reduce((t, u) => (t[u] = "function", t), n);
  return gt(e, c), e;
}
function An(e, n, c) {
  if (c < Oe)
    throw new Error("invalid exponent, negatives unsupported");
  if (c === Oe)
    return e.ONE;
  if (c === Be)
    return n;
  let t = e.ONE, u = n;
  for (; c > Oe; )
    c & Be && (t = e.mul(t, u)), u = e.sqr(u), c >>= Be;
  return t;
}
function tn(e, n, c = !1) {
  const t = new Array(n.length).fill(c ? e.ZERO : void 0), u = n.reduce((g, p, v) => e.is0(p) ? g : (t[v] = g, e.mul(g, p)), e.ONE), m = e.inv(u);
  return n.reduceRight((g, p, v) => e.is0(p) ? g : (t[v] = e.mul(g, t[v]), e.mul(g, p)), m), t;
}
function Zt(e, n) {
  const c = (e.ORDER - Be) / je, t = e.pow(n, c), u = e.eql(t, e.ONE), m = e.eql(t, e.ZERO), g = e.eql(t, e.neg(e.ONE));
  if (!u && !m && !g)
    throw new Error("invalid Legendre symbol result");
  return u ? 1 : m ? 0 : -1;
}
function nn(e, n) {
  n !== void 0 && yn(n);
  const c = n !== void 0 ? n : e.toString(2).length, t = Math.ceil(c / 8);
  return { nBitLength: c, nByteLength: t };
}
function ze(e, n, c = !1, t = {}) {
  if (e <= Oe)
    throw new Error("invalid field: expected ORDER > 0, got " + e);
  let u, m, g = !1, p;
  if (typeof n == "object" && n != null) {
    if (t.sqrt || c)
      throw new Error("cannot specify opts in two arguments");
    const E = n;
    E.BITS && (u = E.BITS), E.sqrt && (m = E.sqrt), typeof E.isLE == "boolean" && (c = E.isLE), typeof E.modFromBytes == "boolean" && (g = E.modFromBytes), p = E.allowedLengths;
  } else
    typeof n == "number" && (u = n), t.sqrt && (m = t.sqrt);
  const { nBitLength: v, nByteLength: U } = nn(e, u);
  if (U > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let H;
  const V = Object.freeze({
    ORDER: e,
    isLE: c,
    BITS: v,
    BYTES: U,
    MASK: De(v),
    ZERO: Oe,
    ONE: Be,
    allowedLengths: p,
    create: (E) => qe(E, e),
    isValid: (E) => {
      if (typeof E != "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof E);
      return Oe <= E && E < e;
    },
    is0: (E) => E === Oe,
    // is valid and invertible
    isValidNot0: (E) => !V.is0(E) && V.isValid(E),
    isOdd: (E) => (E & Be) === Be,
    neg: (E) => qe(-E, e),
    eql: (E, b) => E === b,
    sqr: (E) => qe(E * E, e),
    add: (E, b) => qe(E + b, e),
    sub: (E, b) => qe(E - b, e),
    mul: (E, b) => qe(E * b, e),
    pow: (E, b) => An(V, E, b),
    div: (E, b) => qe(E * Ut(b, e), e),
    // Same as above, but doesn't normalize
    sqrN: (E) => E * E,
    addN: (E, b) => E + b,
    subN: (E, b) => E - b,
    mulN: (E, b) => E * b,
    inv: (E) => Ut(E, e),
    sqrt: m || ((E) => (H || (H = qn(e)), H(V, E))),
    toBytes: (E) => c ? Pt(E, U) : wt(E, U),
    fromBytes: (E, b = !0) => {
      if (p) {
        if (!p.includes(E.length) || E.length > U)
          throw new Error("Field.fromBytes: expected " + p + " bytes, got " + E.length);
        const A = new Uint8Array(U);
        A.set(E, c ? 0 : A.length - E.length), E = A;
      }
      if (E.length !== U)
        throw new Error("Field.fromBytes: expected " + U + " bytes, got " + E.length);
      let S = c ? Yt(E) : et(E);
      if (g && (S = qe(S, e)), !b && !V.isValid(S))
        throw new Error("invalid field element: outside of range 0..ORDER");
      return S;
    },
    // TODO: we don't need it here, move out to separate fn
    invertBatch: (E) => tn(V, E),
    // We can't move this out because Fp6, Fp12 implement it
    // and it's unclear what to return in there.
    cmov: (E, b, S) => S ? b : E
  });
  return Object.freeze(V);
}
function rn(e) {
  if (typeof e != "bigint")
    throw new Error("field order must be bigint");
  const n = e.toString(2).length;
  return Math.ceil(n / 8);
}
function on(e) {
  const n = rn(e);
  return n + Math.ceil(n / 2);
}
function Un(e, n, c = !1) {
  const t = e.length, u = rn(n), m = on(n);
  if (t < 16 || t < m || t > 1024)
    throw new Error("expected " + m + "-1024 bytes of input, got " + t);
  const g = c ? Yt(e) : et(e), p = qe(g, n - Be) + Be;
  return c ? Pt(p, u) : wt(p, u);
}
const ke = BigInt(0), Le = BigInt(1);
function Fe(e, n) {
  const c = n.negate();
  return e ? c : n;
}
function it(e, n) {
  const c = tn(e.Fp, n.map((t) => t.Z));
  return n.map((t, u) => e.fromAffine(t.toAffine(c[u])));
}
function sn(e, n) {
  if (!Number.isSafeInteger(e) || e <= 0 || e > n)
    throw new Error("invalid window size, expected [1.." + n + "], got W=" + e);
}
function ct(e, n) {
  sn(e, n);
  const c = Math.ceil(n / e) + 1, t = 2 ** (e - 1), u = 2 ** e, m = De(e), g = BigInt(e);
  return { windows: c, windowSize: t, mask: m, maxNumber: u, shiftBy: g };
}
function jt(e, n, c) {
  const { windowSize: t, mask: u, maxNumber: m, shiftBy: g } = c;
  let p = Number(e & u), v = e >> g;
  p > t && (p -= m, v += Le);
  const U = n * t, H = U + Math.abs(p) - 1, V = p === 0, E = p < 0, b = n % 2 !== 0;
  return { nextN: v, offset: H, isZero: V, isNeg: E, isNegF: b, offsetF: U };
}
function Zn(e, n) {
  if (!Array.isArray(e))
    throw new Error("array expected");
  e.forEach((c, t) => {
    if (!(c instanceof n))
      throw new Error("invalid point at index " + t);
  });
}
function jn(e, n) {
  if (!Array.isArray(e))
    throw new Error("array of scalars expected");
  e.forEach((c, t) => {
    if (!n.isValid(c))
      throw new Error("invalid scalar at index " + t);
  });
}
const at = /* @__PURE__ */ new WeakMap(), cn = /* @__PURE__ */ new WeakMap();
function ft(e) {
  return cn.get(e) || 1;
}
function Lt(e) {
  if (e !== ke)
    throw new Error("invalid wNAF");
}
class Ln {
  // Parametrized with a given Point class (not individual point)
  constructor(n, c) {
    this.BASE = n.BASE, this.ZERO = n.ZERO, this.Fn = n.Fn, this.bits = c;
  }
  // non-const time multiplication ladder
  _unsafeLadder(n, c, t = this.ZERO) {
    let u = n;
    for (; c > ke; )
      c & Le && (t = t.add(u)), u = u.double(), c >>= Le;
    return t;
  }
  /**
   * Creates a wNAF precomputation window. Used for caching.
   * Default window size is set by `utils.precompute()` and is equal to 8.
   * Number of precomputed points depends on the curve size:
   * 2^(ùëä‚àí1) * (Math.ceil(ùëõ / ùëä) + 1), where:
   * - ùëä is the window size
   * - ùëõ is the bitlength of the curve order.
   * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
   * @param point Point instance
   * @param W window size
   * @returns precomputed point tables flattened to a single array
   */
  precomputeWindow(n, c) {
    const { windows: t, windowSize: u } = ct(c, this.bits), m = [];
    let g = n, p = g;
    for (let v = 0; v < t; v++) {
      p = g, m.push(p);
      for (let U = 1; U < u; U++)
        p = p.add(g), m.push(p);
      g = p.double();
    }
    return m;
  }
  /**
   * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
   * More compact implementation:
   * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
   * @returns real and fake (for const-time) points
   */
  wNAF(n, c, t) {
    if (!this.Fn.isValid(t))
      throw new Error("invalid scalar");
    let u = this.ZERO, m = this.BASE;
    const g = ct(n, this.bits);
    for (let p = 0; p < g.windows; p++) {
      const { nextN: v, offset: U, isZero: H, isNeg: V, isNegF: E, offsetF: b } = jt(t, p, g);
      t = v, H ? m = m.add(Fe(E, c[b])) : u = u.add(Fe(V, c[U]));
    }
    return Lt(t), { p: u, f: m };
  }
  /**
   * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
   * @param acc accumulator point to add result of multiplication
   * @returns point
   */
  wNAFUnsafe(n, c, t, u = this.ZERO) {
    const m = ct(n, this.bits);
    for (let g = 0; g < m.windows && t !== ke; g++) {
      const { nextN: p, offset: v, isZero: U, isNeg: H } = jt(t, g, m);
      if (t = p, !U) {
        const V = c[v];
        u = u.add(H ? V.negate() : V);
      }
    }
    return Lt(t), u;
  }
  getPrecomputes(n, c, t) {
    let u = at.get(c);
    return u || (u = this.precomputeWindow(c, n), n !== 1 && (typeof t == "function" && (u = t(u)), at.set(c, u))), u;
  }
  cached(n, c, t) {
    const u = ft(n);
    return this.wNAF(u, this.getPrecomputes(u, n, t), c);
  }
  unsafe(n, c, t, u) {
    const m = ft(n);
    return m === 1 ? this._unsafeLadder(n, c, u) : this.wNAFUnsafe(m, this.getPrecomputes(m, n, t), c, u);
  }
  // We calculate precomputes for elliptic curve point multiplication
  // using windowed method. This specifies window size and
  // stores precomputed values. Usually only base point would be precomputed.
  createCache(n, c) {
    sn(c, this.bits), cn.set(n, c), at.delete(n);
  }
  hasCache(n) {
    return ft(n) !== 1;
  }
}
function Hn(e, n, c, t) {
  let u = n, m = e.ZERO, g = e.ZERO;
  for (; c > ke || t > ke; )
    c & Le && (m = m.add(u)), t & Le && (g = g.add(u)), u = u.double(), c >>= Le, t >>= Le;
  return { p1: m, p2: g };
}
function Mn(e, n, c, t) {
  Zn(c, e), jn(t, n);
  const u = c.length, m = t.length;
  if (u !== m)
    throw new Error("arrays of points and scalars must have equal length");
  const g = e.ZERO, p = Xt(BigInt(u));
  let v = 1;
  p > 12 ? v = p - 3 : p > 4 ? v = p - 2 : p > 0 && (v = 2);
  const U = De(v), H = new Array(Number(U) + 1).fill(g), V = Math.floor((n.BITS - 1) / v) * v;
  let E = g;
  for (let b = V; b >= 0; b -= v) {
    H.fill(g);
    for (let A = 0; A < m; A++) {
      const M = t[A], Q = Number(M >> BigInt(b) & U);
      H[Q] = H[Q].add(c[A]);
    }
    let S = g;
    for (let A = H.length - 1, M = g; A > 0; A--)
      M = M.add(H[A]), S = S.add(M);
    if (E = E.add(S), b !== 0)
      for (let A = 0; A < v; A++)
        E = E.double();
  }
  return E;
}
function Ht(e, n, c) {
  if (n) {
    if (n.ORDER !== e)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    return Nn(n), n;
  } else
    return ze(e, { isLE: c });
}
function Vn(e, n, c = {}, t) {
  if (t === void 0 && (t = e === "edwards"), !n || typeof n != "object")
    throw new Error(`expected valid ${e} CURVE object`);
  for (const v of ["p", "n", "h"]) {
    const U = n[v];
    if (!(typeof U == "bigint" && U > ke))
      throw new Error(`CURVE.${v} must be positive bigint`);
  }
  const u = Ht(n.p, c.Fp, t), m = Ht(n.n, c.Fn, t), p = ["Gx", "Gy", "a", "b"];
  for (const v of p)
    if (!u.isValid(n[v]))
      throw new Error(`CURVE.${v} must be valid field element of CURVE.Fp`);
  return n = Object.freeze(Object.assign({}, n)), { CURVE: n, Fp: u, Fn: m };
}
const Mt = (e, n) => (e + (e >= 0 ? n : -n) / an) / n;
function kn(e, n, c) {
  const [[t, u], [m, g]] = n, p = Mt(g * e, c), v = Mt(-u * e, c);
  let U = e - p * t - v * m, H = -p * u - v * g;
  const V = U < Ne, E = H < Ne;
  V && (U = -U), E && (H = -H);
  const b = De(Math.ceil(Xt(c) / 2)) + Ve;
  if (U < Ne || U >= b || H < Ne || H >= b)
    throw new Error("splitScalar (endomorphism): failed, k=" + e);
  return { k1neg: V, k1: U, k2neg: E, k2: H };
}
function dt(e) {
  if (!["compact", "recovered", "der"].includes(e))
    throw new Error('Signature format must be "compact", "recovered", or "der"');
  return e;
}
function ut(e, n) {
  const c = {};
  for (let t of Object.keys(n))
    c[t] = e[t] === void 0 ? n[t] : e[t];
  return Je(c.lowS, "lowS"), Je(c.prehash, "prehash"), c.format !== void 0 && dt(c.format), c;
}
class Cn extends Error {
  constructor(n = "") {
    super(n);
  }
}
const Ie = {
  // asn.1 DER encoding utils
  Err: Cn,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (e, n) => {
      const { Err: c } = Ie;
      if (e < 0 || e > 256)
        throw new c("tlv.encode: wrong tag");
      if (n.length & 1)
        throw new c("tlv.encode: unpadded data");
      const t = n.length / 2, u = Xe(t);
      if (u.length / 2 & 128)
        throw new c("tlv.encode: long form length too big");
      const m = t > 127 ? Xe(u.length / 2 | 128) : "";
      return Xe(e) + m + u + n;
    },
    // v - value, l - left bytes (unparsed)
    decode(e, n) {
      const { Err: c } = Ie;
      let t = 0;
      if (e < 0 || e > 256)
        throw new c("tlv.encode: wrong tag");
      if (n.length < 2 || n[t++] !== e)
        throw new c("tlv.decode: wrong tlv");
      const u = n[t++], m = !!(u & 128);
      let g = 0;
      if (!m)
        g = u;
      else {
        const v = u & 127;
        if (!v)
          throw new c("tlv.decode(long): indefinite length not supported");
        if (v > 4)
          throw new c("tlv.decode(long): byte length is too big");
        const U = n.subarray(t, t + v);
        if (U.length !== v)
          throw new c("tlv.decode: length bytes not complete");
        if (U[0] === 0)
          throw new c("tlv.decode(long): zero leftmost byte");
        for (const H of U)
          g = g << 8 | H;
        if (t += v, g < 128)
          throw new c("tlv.decode(long): not minimal encoding");
      }
      const p = n.subarray(t, t + g);
      if (p.length !== g)
        throw new c("tlv.decode: wrong value length");
      return { v: p, l: n.subarray(t + g) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(e) {
      const { Err: n } = Ie;
      if (e < Ne)
        throw new n("integer: negative integers are not allowed");
      let c = Xe(e);
      if (Number.parseInt(c[0], 16) & 8 && (c = "00" + c), c.length & 1)
        throw new n("unexpected DER parsing assertion: unpadded hex");
      return c;
    },
    decode(e) {
      const { Err: n } = Ie;
      if (e[0] & 128)
        throw new n("invalid signature integer: negative");
      if (e[0] === 0 && !(e[1] & 128))
        throw new n("invalid signature integer: unnecessary leading zero");
      return et(e);
    }
  },
  toSig(e) {
    const { Err: n, _int: c, _tlv: t } = Ie, u = Se("signature", e), { v: m, l: g } = t.decode(48, u);
    if (g.length)
      throw new n("invalid signature: left bytes after parsing");
    const { v: p, l: v } = t.decode(2, m), { v: U, l: H } = t.decode(2, v);
    if (H.length)
      throw new n("invalid signature: left bytes after parsing");
    return { r: c.decode(p), s: c.decode(U) };
  },
  hexFromSig(e) {
    const { _tlv: n, _int: c } = Ie, t = n.encode(2, c.encode(e.r)), u = n.encode(2, c.encode(e.s)), m = t + u;
    return n.encode(48, m);
  }
}, Ne = BigInt(0), Ve = BigInt(1), an = BigInt(2), Ge = BigInt(3), Kn = BigInt(4);
function He(e, n) {
  const { BYTES: c } = e;
  let t;
  if (typeof n == "bigint")
    t = n;
  else {
    let u = Se("private key", n);
    try {
      t = e.fromBytes(u);
    } catch {
      throw new Error(`invalid private key: expected ui8a of size ${c}, got ${typeof n}`);
    }
  }
  if (!e.isValidNot0(t))
    throw new Error("invalid private key: out of range [1..N-1]");
  return t;
}
function Dn(e, n = {}) {
  const c = Vn("weierstrass", e, n), { Fp: t, Fn: u } = c;
  let m = c.CURVE;
  const { h: g, n: p } = m;
  gt(n, {}, {
    allowInfinityPoint: "boolean",
    clearCofactor: "function",
    isTorsionFree: "function",
    fromBytes: "function",
    toBytes: "function",
    endo: "object",
    wrapPrivateKey: "boolean"
  });
  const { endo: v } = n;
  if (v && (!t.is0(m.a) || typeof v.beta != "bigint" || !Array.isArray(v.basises)))
    throw new Error('invalid endo: expected "beta": bigint and "basises": array');
  const U = un(t, u);
  function H() {
    if (!t.isOdd)
      throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function V(D, d, l) {
    const { x: r, y: a } = d.toAffine(), i = t.toBytes(r);
    if (Je(l, "isCompressed"), l) {
      H();
      const o = !t.isOdd(a);
      return Ae(fn(o), i);
    } else
      return Ae(Uint8Array.of(4), i, t.toBytes(a));
  }
  function E(D) {
    Ze(D, void 0, "Point");
    const { publicKey: d, publicKeyUncompressed: l } = U, r = D.length, a = D[0], i = D.subarray(1);
    if (r === d && (a === 2 || a === 3)) {
      const o = t.fromBytes(i);
      if (!t.isValid(o))
        throw new Error("bad point: is not on curve, wrong x");
      const h = A(o);
      let w;
      try {
        w = t.sqrt(h);
      } catch (y) {
        const B = y instanceof Error ? ": " + y.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + B);
      }
      H();
      const s = t.isOdd(w);
      return (a & 1) === 1 !== s && (w = t.neg(w)), { x: o, y: w };
    } else if (r === l && a === 4) {
      const o = t.BYTES, h = t.fromBytes(i.subarray(0, o)), w = t.fromBytes(i.subarray(o, o * 2));
      if (!M(h, w))
        throw new Error("bad point: is not on curve");
      return { x: h, y: w };
    } else
      throw new Error(`bad point: got length ${r}, expected compressed=${d} or uncompressed=${l}`);
  }
  const b = n.toBytes || V, S = n.fromBytes || E;
  function A(D) {
    const d = t.sqr(D), l = t.mul(d, D);
    return t.add(t.add(l, t.mul(D, m.a)), m.b);
  }
  function M(D, d) {
    const l = t.sqr(d), r = A(D);
    return t.eql(l, r);
  }
  if (!M(m.Gx, m.Gy))
    throw new Error("bad curve params: generator point");
  const Q = t.mul(t.pow(m.a, Ge), Kn), F = t.mul(t.sqr(m.b), BigInt(27));
  if (t.is0(t.add(Q, F)))
    throw new Error("bad curve params: a or b");
  function G(D, d, l = !1) {
    if (!t.isValid(d) || l && t.is0(d))
      throw new Error(`bad point coordinate ${D}`);
    return d;
  }
  function se(D) {
    if (!(D instanceof _))
      throw new Error("ProjectivePoint expected");
  }
  function ie(D) {
    if (!v || !v.basises)
      throw new Error("no endo");
    return kn(D, v.basises, u.ORDER);
  }
  const j = At((D, d) => {
    const { X: l, Y: r, Z: a } = D;
    if (t.eql(a, t.ONE))
      return { x: l, y: r };
    const i = D.is0();
    d == null && (d = i ? t.ONE : t.inv(a));
    const o = t.mul(l, d), h = t.mul(r, d), w = t.mul(a, d);
    if (i)
      return { x: t.ZERO, y: t.ZERO };
    if (!t.eql(w, t.ONE))
      throw new Error("invZ was invalid");
    return { x: o, y: h };
  }), R = At((D) => {
    if (D.is0()) {
      if (n.allowInfinityPoint && !t.is0(D.Y))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: d, y: l } = D.toAffine();
    if (!t.isValid(d) || !t.isValid(l))
      throw new Error("bad point: x or y not field elements");
    if (!M(d, l))
      throw new Error("bad point: equation left != right");
    if (!D.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return !0;
  });
  function L(D, d, l, r, a) {
    return l = new _(t.mul(l.X, D), l.Y, l.Z), d = Fe(r, d), l = Fe(a, l), d.add(l);
  }
  class _ {
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    constructor(d, l, r) {
      this.X = G("x", d), this.Y = G("y", l, !0), this.Z = G("z", r), Object.freeze(this);
    }
    static CURVE() {
      return m;
    }
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    static fromAffine(d) {
      const { x: l, y: r } = d || {};
      if (!d || !t.isValid(l) || !t.isValid(r))
        throw new Error("invalid affine point");
      if (d instanceof _)
        throw new Error("projective point not allowed");
      return t.is0(l) && t.is0(r) ? _.ZERO : new _(l, r, t.ONE);
    }
    static fromBytes(d) {
      const l = _.fromAffine(S(Ze(d, void 0, "point")));
      return l.assertValidity(), l;
    }
    static fromHex(d) {
      return _.fromBytes(Se("pointHex", d));
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */
    precompute(d = 8, l = !0) {
      return W.createCache(this, d), l || this.multiply(Ge), this;
    }
    // TODO: return `this`
    /** A point on curve is valid if it conforms to equation. */
    assertValidity() {
      R(this);
    }
    hasEvenY() {
      const { y: d } = this.toAffine();
      if (!t.isOdd)
        throw new Error("Field doesn't support isOdd");
      return !t.isOdd(d);
    }
    /** Compare one point to another. */
    equals(d) {
      se(d);
      const { X: l, Y: r, Z: a } = this, { X: i, Y: o, Z: h } = d, w = t.eql(t.mul(l, h), t.mul(i, a)), s = t.eql(t.mul(r, h), t.mul(o, a));
      return w && s;
    }
    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
    negate() {
      return new _(this.X, t.neg(this.Y), this.Z);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: d, b: l } = m, r = t.mul(l, Ge), { X: a, Y: i, Z: o } = this;
      let h = t.ZERO, w = t.ZERO, s = t.ZERO, f = t.mul(a, a), y = t.mul(i, i), B = t.mul(o, o), O = t.mul(a, i);
      return O = t.add(O, O), s = t.mul(a, o), s = t.add(s, s), h = t.mul(d, s), w = t.mul(r, B), w = t.add(h, w), h = t.sub(y, w), w = t.add(y, w), w = t.mul(h, w), h = t.mul(O, h), s = t.mul(r, s), B = t.mul(d, B), O = t.sub(f, B), O = t.mul(d, O), O = t.add(O, s), s = t.add(f, f), f = t.add(s, f), f = t.add(f, B), f = t.mul(f, O), w = t.add(w, f), B = t.mul(i, o), B = t.add(B, B), f = t.mul(B, O), h = t.sub(h, f), s = t.mul(B, y), s = t.add(s, s), s = t.add(s, s), new _(h, w, s);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(d) {
      se(d);
      const { X: l, Y: r, Z: a } = this, { X: i, Y: o, Z: h } = d;
      let w = t.ZERO, s = t.ZERO, f = t.ZERO;
      const y = m.a, B = t.mul(m.b, Ge);
      let O = t.mul(l, i), k = t.mul(r, o), Y = t.mul(a, h), I = t.add(l, r), q = t.add(i, o);
      I = t.mul(I, q), q = t.add(O, k), I = t.sub(I, q), q = t.add(l, a);
      let C = t.add(i, h);
      return q = t.mul(q, C), C = t.add(O, Y), q = t.sub(q, C), C = t.add(r, a), w = t.add(o, h), C = t.mul(C, w), w = t.add(k, Y), C = t.sub(C, w), f = t.mul(y, q), w = t.mul(B, Y), f = t.add(w, f), w = t.sub(k, f), f = t.add(k, f), s = t.mul(w, f), k = t.add(O, O), k = t.add(k, O), Y = t.mul(y, Y), q = t.mul(B, q), k = t.add(k, Y), Y = t.sub(O, Y), Y = t.mul(y, Y), q = t.add(q, Y), O = t.mul(k, q), s = t.add(s, O), O = t.mul(C, q), w = t.mul(I, w), w = t.sub(w, O), O = t.mul(I, k), f = t.mul(C, f), f = t.add(f, O), new _(w, s, f);
    }
    subtract(d) {
      return this.add(d.negate());
    }
    is0() {
      return this.equals(_.ZERO);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(d) {
      const { endo: l } = n;
      if (!u.isValidNot0(d))
        throw new Error("invalid scalar: out of range");
      let r, a;
      const i = (o) => W.cached(this, o, (h) => it(_, h));
      if (l) {
        const { k1neg: o, k1: h, k2neg: w, k2: s } = ie(d), { p: f, f: y } = i(h), { p: B, f: O } = i(s);
        a = y.add(O), r = L(l.beta, f, B, o, w);
      } else {
        const { p: o, f: h } = i(d);
        r = o, a = h;
      }
      return it(_, [r, a])[0];
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed secret key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(d) {
      const { endo: l } = n, r = this;
      if (!u.isValid(d))
        throw new Error("invalid scalar: out of range");
      if (d === Ne || r.is0())
        return _.ZERO;
      if (d === Ve)
        return r;
      if (W.hasCache(this))
        return this.multiply(d);
      if (l) {
        const { k1neg: a, k1: i, k2neg: o, k2: h } = ie(d), { p1: w, p2: s } = Hn(_, r, i, h);
        return L(l.beta, w, s, a, o);
      } else
        return W.unsafe(r, d);
    }
    multiplyAndAddUnsafe(d, l, r) {
      const a = this.multiplyUnsafe(l).add(d.multiplyUnsafe(r));
      return a.is0() ? void 0 : a;
    }
    /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */
    toAffine(d) {
      return j(this, d);
    }
    /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */
    isTorsionFree() {
      const { isTorsionFree: d } = n;
      return g === Ve ? !0 : d ? d(_, this) : W.unsafe(this, p).is0();
    }
    clearCofactor() {
      const { clearCofactor: d } = n;
      return g === Ve ? this : d ? d(_, this) : this.multiplyUnsafe(g);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(g).is0();
    }
    toBytes(d = !0) {
      return Je(d, "isCompressed"), this.assertValidity(), b(_, this, d);
    }
    toHex(d = !0) {
      return Me(this.toBytes(d));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
    // TODO: remove
    get px() {
      return this.X;
    }
    get py() {
      return this.X;
    }
    get pz() {
      return this.Z;
    }
    toRawBytes(d = !0) {
      return this.toBytes(d);
    }
    _setWindowSize(d) {
      this.precompute(d);
    }
    static normalizeZ(d) {
      return it(_, d);
    }
    static msm(d, l) {
      return Mn(_, u, d, l);
    }
    static fromPrivateKey(d) {
      return _.BASE.multiply(He(u, d));
    }
  }
  _.BASE = new _(m.Gx, m.Gy, t.ONE), _.ZERO = new _(t.ZERO, t.ONE, t.ZERO), _.Fp = t, _.Fn = u;
  const K = u.BITS, W = new Ln(_, n.endo ? Math.ceil(K / 2) : K);
  return _.BASE.precompute(8), _;
}
function fn(e) {
  return Uint8Array.of(e ? 2 : 3);
}
function un(e, n) {
  return {
    secretKey: n.BYTES,
    publicKey: 1 + e.BYTES,
    publicKeyUncompressed: 1 + 2 * e.BYTES,
    publicKeyHasPrefix: !0,
    signature: 2 * n.BYTES
  };
}
function zn(e, n = {}) {
  const { Fn: c } = e, t = n.randomBytes || kt, u = Object.assign(un(e.Fp, c), { seed: on(c.ORDER) });
  function m(b) {
    try {
      return !!He(c, b);
    } catch {
      return !1;
    }
  }
  function g(b, S) {
    const { publicKey: A, publicKeyUncompressed: M } = u;
    try {
      const Q = b.length;
      return S === !0 && Q !== A || S === !1 && Q !== M ? !1 : !!e.fromBytes(b);
    } catch {
      return !1;
    }
  }
  function p(b = t(u.seed)) {
    return Un(Ze(b, u.seed, "seed"), c.ORDER);
  }
  function v(b, S = !0) {
    return e.BASE.multiply(He(c, b)).toBytes(S);
  }
  function U(b) {
    const S = p(b);
    return { secretKey: S, publicKey: v(S) };
  }
  function H(b) {
    if (typeof b == "bigint")
      return !1;
    if (b instanceof e)
      return !0;
    const { secretKey: S, publicKey: A, publicKeyUncompressed: M } = u;
    if (c.allowedLengths || S === A)
      return;
    const Q = Se("key", b).length;
    return Q === A || Q === M;
  }
  function V(b, S, A = !0) {
    if (H(b) === !0)
      throw new Error("first arg must be private key");
    if (H(S) === !1)
      throw new Error("second arg must be public key");
    const M = He(c, b);
    return e.fromHex(S).multiply(M).toBytes(A);
  }
  return Object.freeze({ getPublicKey: v, getSharedSecret: V, keygen: U, Point: e, utils: {
    isValidSecretKey: m,
    isValidPublicKey: g,
    randomSecretKey: p,
    // TODO: remove
    isValidPrivateKey: m,
    randomPrivateKey: p,
    normPrivateKeyToScalar: (b) => He(c, b),
    precompute(b = 8, S = e.BASE) {
      return S.precompute(b, !1);
    }
  }, lengths: u });
}
function Yn(e, n, c = {}) {
  mn(n), gt(c, {}, {
    hmac: "function",
    lowS: "boolean",
    randomBytes: "function",
    bits2int: "function",
    bits2int_modN: "function"
  });
  const t = c.randomBytes || kt, u = c.hmac || ((l, ...r) => bn(n, l, Ae(...r))), { Fp: m, Fn: g } = e, { ORDER: p, BITS: v } = g, { keygen: U, getPublicKey: H, getSharedSecret: V, utils: E, lengths: b } = zn(e, c), S = {
    prehash: !1,
    lowS: typeof c.lowS == "boolean" ? c.lowS : !1,
    format: void 0,
    //'compact' as ECDSASigFormat,
    extraEntropy: !1
  }, A = "compact";
  function M(l) {
    const r = p >> Ve;
    return l > r;
  }
  function Q(l, r) {
    if (!g.isValidNot0(r))
      throw new Error(`invalid signature ${l}: out of range 1..Point.Fn.ORDER`);
    return r;
  }
  function F(l, r) {
    dt(r);
    const a = b.signature, i = r === "compact" ? a : r === "recovered" ? a + 1 : void 0;
    return Ze(l, i, `${r} signature`);
  }
  class G {
    constructor(r, a, i) {
      this.r = Q("r", r), this.s = Q("s", a), i != null && (this.recovery = i), Object.freeze(this);
    }
    static fromBytes(r, a = A) {
      F(r, a);
      let i;
      if (a === "der") {
        const { r: s, s: f } = Ie.toSig(Ze(r));
        return new G(s, f);
      }
      a === "recovered" && (i = r[0], a = "compact", r = r.subarray(1));
      const o = g.BYTES, h = r.subarray(0, o), w = r.subarray(o, o * 2);
      return new G(g.fromBytes(h), g.fromBytes(w), i);
    }
    static fromHex(r, a) {
      return this.fromBytes(Qe(r), a);
    }
    addRecoveryBit(r) {
      return new G(this.r, this.s, r);
    }
    recoverPublicKey(r) {
      const a = m.ORDER, { r: i, s: o, recovery: h } = this;
      if (h == null || ![0, 1, 2, 3].includes(h))
        throw new Error("recovery id invalid");
      if (p * an < a && h > 1)
        throw new Error("recovery id is ambiguous for h>1 curve");
      const s = h === 2 || h === 3 ? i + p : i;
      if (!m.isValid(s))
        throw new Error("recovery id 2 or 3 invalid");
      const f = m.toBytes(s), y = e.fromBytes(Ae(fn((h & 1) === 0), f)), B = g.inv(s), O = ie(Se("msgHash", r)), k = g.create(-O * B), Y = g.create(o * B), I = e.BASE.multiplyUnsafe(k).add(y.multiplyUnsafe(Y));
      if (I.is0())
        throw new Error("point at infinify");
      return I.assertValidity(), I;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return M(this.s);
    }
    toBytes(r = A) {
      if (dt(r), r === "der")
        return Qe(Ie.hexFromSig(this));
      const a = g.toBytes(this.r), i = g.toBytes(this.s);
      if (r === "recovered") {
        if (this.recovery == null)
          throw new Error("recovery bit must be present");
        return Ae(Uint8Array.of(this.recovery), a, i);
      }
      return Ae(a, i);
    }
    toHex(r) {
      return Me(this.toBytes(r));
    }
    // TODO: remove
    assertValidity() {
    }
    static fromCompact(r) {
      return G.fromBytes(Se("sig", r), "compact");
    }
    static fromDER(r) {
      return G.fromBytes(Se("sig", r), "der");
    }
    normalizeS() {
      return this.hasHighS() ? new G(this.r, g.neg(this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return this.toBytes("der");
    }
    toDERHex() {
      return Me(this.toBytes("der"));
    }
    toCompactRawBytes() {
      return this.toBytes("compact");
    }
    toCompactHex() {
      return Me(this.toBytes("compact"));
    }
  }
  const se = c.bits2int || function(r) {
    if (r.length > 8192)
      throw new Error("input is too large");
    const a = et(r), i = r.length * 8 - v;
    return i > 0 ? a >> BigInt(i) : a;
  }, ie = c.bits2int_modN || function(r) {
    return g.create(se(r));
  }, j = De(v);
  function R(l) {
    return _n("num < 2^" + v, l, Ne, j), g.toBytes(l);
  }
  function L(l, r) {
    return Ze(l, void 0, "message"), r ? Ze(n(l), void 0, "prehashed message") : l;
  }
  function _(l, r, a) {
    if (["recovered", "canonical"].some((k) => k in a))
      throw new Error("sign() legacy options not supported");
    const { lowS: i, prehash: o, extraEntropy: h } = ut(a, S);
    l = L(l, o);
    const w = ie(l), s = He(g, r), f = [R(s), R(w)];
    if (h != null && h !== !1) {
      const k = h === !0 ? t(b.secretKey) : h;
      f.push(Se("extraEntropy", k));
    }
    const y = Ae(...f), B = w;
    function O(k) {
      const Y = se(k);
      if (!g.isValidNot0(Y))
        return;
      const I = g.inv(Y), q = e.BASE.multiply(Y).toAffine(), C = g.create(q.x);
      if (C === Ne)
        return;
      const te = g.create(I * g.create(B + C * s));
      if (te === Ne)
        return;
      let $ = (q.x === C ? 0 : 2) | Number(q.y & Ve), T = te;
      return i && M(te) && (T = g.neg(te), $ ^= 1), new G(C, T, $);
    }
    return { seed: y, k2sig: O };
  }
  function K(l, r, a = {}) {
    l = Se("message", l);
    const { seed: i, k2sig: o } = _(l, r, a);
    return Sn(n.outputLen, g.BYTES, u)(i, o);
  }
  function W(l) {
    let r;
    const a = typeof l == "string" || yt(l), i = !a && l !== null && typeof l == "object" && typeof l.r == "bigint" && typeof l.s == "bigint";
    if (!a && !i)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    if (i)
      r = new G(l.r, l.s);
    else if (a) {
      try {
        r = G.fromBytes(Se("sig", l), "der");
      } catch (o) {
        if (!(o instanceof Ie.Err))
          throw o;
      }
      if (!r)
        try {
          r = G.fromBytes(Se("sig", l), "compact");
        } catch {
          return !1;
        }
    }
    return r || !1;
  }
  function D(l, r, a, i = {}) {
    const { lowS: o, prehash: h, format: w } = ut(i, S);
    if (a = Se("publicKey", a), r = L(Se("message", r), h), "strict" in i)
      throw new Error("options.strict was renamed to lowS");
    const s = w === void 0 ? W(l) : G.fromBytes(Se("sig", l), w);
    if (s === !1)
      return !1;
    try {
      const f = e.fromBytes(a);
      if (o && s.hasHighS())
        return !1;
      const { r: y, s: B } = s, O = ie(r), k = g.inv(B), Y = g.create(O * k), I = g.create(y * k), q = e.BASE.multiplyUnsafe(Y).add(f.multiplyUnsafe(I));
      return q.is0() ? !1 : g.create(q.x) === y;
    } catch {
      return !1;
    }
  }
  function d(l, r, a = {}) {
    const { prehash: i } = ut(a, S);
    return r = L(r, i), G.fromBytes(l, "recovered").recoverPublicKey(r).toBytes();
  }
  return Object.freeze({
    keygen: U,
    getPublicKey: H,
    getSharedSecret: V,
    utils: E,
    lengths: b,
    Point: e,
    sign: K,
    verify: D,
    recoverPublicKey: d,
    Signature: G,
    hash: n
  });
}
function Pn(e) {
  const n = {
    a: e.a,
    b: e.b,
    p: e.Fp.ORDER,
    n: e.n,
    h: e.h,
    Gx: e.Gx,
    Gy: e.Gy
  }, c = e.Fp;
  let t = e.allowedPrivateKeyLengths ? Array.from(new Set(e.allowedPrivateKeyLengths.map((g) => Math.ceil(g / 2)))) : void 0;
  const u = ze(n.n, {
    BITS: e.nBitLength,
    allowedLengths: t,
    modFromBytes: e.wrapPrivateKey
  }), m = {
    Fp: c,
    Fn: u,
    allowInfinityPoint: e.allowInfinityPoint,
    endo: e.endo,
    isTorsionFree: e.isTorsionFree,
    clearCofactor: e.clearCofactor,
    fromBytes: e.fromBytes,
    toBytes: e.toBytes
  };
  return { CURVE: n, curveOpts: m };
}
function Xn(e) {
  const { CURVE: n, curveOpts: c } = Pn(e), t = {
    hmac: e.hmac,
    randomBytes: e.randomBytes,
    lowS: e.lowS,
    bits2int: e.bits2int,
    bits2int_modN: e.bits2int_modN
  };
  return { CURVE: n, curveOpts: c, hash: e.hash, ecdsaOpts: t };
}
function Gn(e, n) {
  const c = n.Point;
  return Object.assign({}, n, {
    ProjectivePoint: c,
    CURVE: Object.assign({}, e, nn(c.Fn.ORDER, c.Fn.BITS))
  });
}
function Wn(e) {
  const { CURVE: n, curveOpts: c, hash: t, ecdsaOpts: u } = Xn(e), m = Dn(n, c), g = Yn(m, t, u);
  return Gn(e, g);
}
function Qn(e, n) {
  const c = (t) => Wn({ ...e, hash: t });
  return { ...c(n), create: c };
}
const Bt = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
}, Jn = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  basises: [
    [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
    [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
  ]
}, Vt = /* @__PURE__ */ BigInt(2);
function Fn(e) {
  const n = Bt.p, c = BigInt(3), t = BigInt(6), u = BigInt(11), m = BigInt(22), g = BigInt(23), p = BigInt(44), v = BigInt(88), U = e * e * e % n, H = U * U * e % n, V = xe(H, c, n) * H % n, E = xe(V, c, n) * H % n, b = xe(E, Vt, n) * U % n, S = xe(b, u, n) * b % n, A = xe(S, m, n) * S % n, M = xe(A, p, n) * A % n, Q = xe(M, v, n) * M % n, F = xe(Q, p, n) * A % n, G = xe(F, c, n) * H % n, se = xe(G, g, n) * S % n, ie = xe(se, t, n) * U % n, j = xe(ie, Vt, n);
  if (!ht.eql(ht.sqr(j), e))
    throw new Error("Cannot find square root");
  return j;
}
const ht = ze(Bt.p, { sqrt: Fn }), ir = Qn({ ...Bt, Fp: ht, lowS: !0, endo: Jn }, wn);
export {
  sr as F,
  rr as a,
  $e as b,
  tr as c,
  pn as d,
  or as e,
  et as f,
  er as g,
  qe as m,
  nr as r,
  ir as s
};
