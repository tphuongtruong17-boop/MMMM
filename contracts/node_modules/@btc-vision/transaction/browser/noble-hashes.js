const ft = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
function Ae(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function Ht(t) {
  if (!Number.isSafeInteger(t) || t < 0)
    throw new Error("positive integer expected, got " + t);
}
function ht(t, ...e) {
  if (!Ae(t))
    throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length))
    throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length);
}
function $t(t) {
  if (typeof t != "function" || typeof t.create != "function")
    throw new Error("Hash should be wrapped by utils.createHasher");
  Ht(t.outputLen), Ht(t.blockLen);
}
function St(t, e = !0) {
  if (t.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && t.finished)
    throw new Error("Hash#digest() has already been called");
}
function ye(t, e) {
  ht(t);
  const s = e.outputLen;
  if (t.length < s)
    throw new Error("digestInto() expects output buffer of length at least " + s);
}
function ct(...t) {
  for (let e = 0; e < t.length; e++)
    t[e].fill(0);
}
function wt(t) {
  return new DataView(t.buffer, t.byteOffset, t.byteLength);
}
function Z(t, e) {
  return t << 32 - e | t >>> e;
}
const te = /* @ts-ignore */ typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function", ge = /* @__PURE__ */ Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function ls(t) {
  if (ht(t), te)
    return t.toHex();
  let e = "";
  for (let s = 0; s < t.length; s++)
    e += ge[t[s]];
  return e;
}
const z = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function Vt(t) {
  if (t >= z._0 && t <= z._9)
    return t - z._0;
  if (t >= z.A && t <= z.F)
    return t - (z.A - 10);
  if (t >= z.a && t <= z.f)
    return t - (z.a - 10);
}
function bs(t) {
  if (typeof t != "string")
    throw new Error("hex string expected, got " + typeof t);
  if (te)
    return Uint8Array.fromHex(t);
  const e = t.length, s = e / 2;
  if (e % 2)
    throw new Error("hex string expected, got unpadded hex of length " + e);
  const i = new Uint8Array(s);
  for (let o = 0, r = 0; o < s; o++, r += 2) {
    const n = Vt(t.charCodeAt(r)), h = Vt(t.charCodeAt(r + 1));
    if (n === void 0 || h === void 0) {
      const b = t[r] + t[r + 1];
      throw new Error('hex string expected, got non-hex character "' + b + '" at index ' + r);
    }
    i[o] = n * 16 + h;
  }
  return i;
}
function ee(t) {
  if (typeof t != "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t));
}
function Ut(t) {
  return typeof t == "string" && (t = ee(t)), ht(t), t;
}
function Ct(t) {
  return typeof t == "string" && (t = ee(t)), ht(t), t;
}
function xs(...t) {
  let e = 0;
  for (let i = 0; i < t.length; i++) {
    const o = t[i];
    ht(o), e += o.length;
  }
  const s = new Uint8Array(e);
  for (let i = 0, o = 0; i < t.length; i++) {
    const r = t[i];
    s.set(r, o), o += r.length;
  }
  return s;
}
function _e(t, e) {
  if (e !== void 0 && {}.toString.call(e) !== "[object Object]")
    throw new Error("options should be object or undefined");
  return Object.assign(t, e);
}
class se {
}
function ne(t) {
  const e = (i) => t().update(Ut(i)).digest(), s = t();
  return e.outputLen = s.outputLen, e.blockLen = s.blockLen, e.create = () => t(), e;
}
function Hs(t = 32) {
  if (ft && typeof ft.getRandomValues == "function")
    return ft.getRandomValues(new Uint8Array(t));
  if (ft && typeof ft.randomBytes == "function")
    return Uint8Array.from(ft.randomBytes(t));
  throw new Error("crypto.getRandomValues must be defined");
}
function we(t, e, s, i) {
  if (typeof t.setBigUint64 == "function")
    return t.setBigUint64(e, s, i);
  const o = BigInt(32), r = BigInt(4294967295), n = Number(s >> o & r), h = Number(s & r), b = i ? 4 : 0, x = i ? 0 : 4;
  t.setUint32(e + b, n, i), t.setUint32(e + x, h, i);
}
function Se(t, e, s) {
  return t & e ^ ~t & s;
}
function Ie(t, e, s) {
  return t & e ^ t & s ^ e & s;
}
class re extends se {
  constructor(e, s, i, o) {
    super(), this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.blockLen = e, this.outputLen = s, this.padOffset = i, this.isLE = o, this.buffer = new Uint8Array(e), this.view = wt(this.buffer);
  }
  update(e) {
    St(this), e = Ut(e), ht(e);
    const { view: s, buffer: i, blockLen: o } = this, r = e.length;
    for (let n = 0; n < r; ) {
      const h = Math.min(o - this.pos, r - n);
      if (h === o) {
        const b = wt(e);
        for (; o <= r - n; n += o)
          this.process(b, n);
        continue;
      }
      i.set(e.subarray(n, n + h), this.pos), this.pos += h, n += h, this.pos === o && (this.process(s, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    St(this), ye(e, this), this.finished = !0;
    const { buffer: s, view: i, blockLen: o, isLE: r } = this;
    let { pos: n } = this;
    s[n++] = 128, ct(this.buffer.subarray(n)), this.padOffset > o - n && (this.process(i, 0), n = 0);
    for (let u = n; u < o; u++)
      s[u] = 0;
    we(i, o - 8, BigInt(this.length * 8), r), this.process(i, 0);
    const h = wt(e), b = this.outputLen;
    if (b % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const x = b / 4, H = this.get();
    if (x > H.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let u = 0; u < x; u++)
      h.setUint32(4 * u, H[u], r);
  }
  digest() {
    const { buffer: e, outputLen: s } = this;
    this.digestInto(e);
    const i = e.slice(0, s);
    return this.destroy(), i;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: s, buffer: i, length: o, finished: r, destroyed: n, pos: h } = this;
    return e.destroyed = n, e.finished = r, e.length = o, e.pos = h, o % s && e.buffer.set(i), e;
  }
  clone() {
    return this._cloneInto();
  }
}
const st = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), q = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  4089235720,
  3144134277,
  2227873595,
  1013904242,
  4271175723,
  2773480762,
  1595750129,
  1359893119,
  2917565137,
  2600822924,
  725511199,
  528734635,
  4215389547,
  1541459225,
  327033209
]), At = /* @__PURE__ */ BigInt(2 ** 32 - 1), Dt = /* @__PURE__ */ BigInt(32);
function Le(t, e = !1) {
  return e ? { h: Number(t & At), l: Number(t >> Dt & At) } : { h: Number(t >> Dt & At) | 0, l: Number(t & At) | 0 };
}
function Be(t, e = !1) {
  const s = t.length;
  let i = new Uint32Array(s), o = new Uint32Array(s);
  for (let r = 0; r < s; r++) {
    const { h: n, l: h } = Le(t[r], e);
    [i[r], o[r]] = [n, h];
  }
  return [i, o];
}
const Ot = (t, e, s) => t >>> s, Ft = (t, e, s) => t << 32 - s | e >>> s, dt = (t, e, s) => t >>> s | e << 32 - s, ut = (t, e, s) => t << 32 - s | e >>> s, yt = (t, e, s) => t << 64 - s | e >>> s - 32, gt = (t, e, s) => t >>> s - 32 | e << 64 - s;
function $(t, e, s, i) {
  const o = (e >>> 0) + (i >>> 0);
  return { h: t + s + (o / 2 ** 32 | 0) | 0, l: o | 0 };
}
const me = (t, e, s) => (t >>> 0) + (e >>> 0) + (s >>> 0), Ue = (t, e, s, i) => e + s + i + (t / 2 ** 32 | 0) | 0, Ee = (t, e, s, i) => (t >>> 0) + (e >>> 0) + (s >>> 0) + (i >>> 0), ke = (t, e, s, i, o) => e + s + i + o + (t / 2 ** 32 | 0) | 0, Ve = (t, e, s, i, o) => (t >>> 0) + (e >>> 0) + (s >>> 0) + (i >>> 0) + (o >>> 0), Ce = (t, e, s, i, o, r) => e + s + i + o + r + (t / 2 ** 32 | 0) | 0, De = /* @__PURE__ */ Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), nt = /* @__PURE__ */ new Uint32Array(64);
class Oe extends re {
  constructor(e = 32) {
    super(64, e, 8, !1), this.A = st[0] | 0, this.B = st[1] | 0, this.C = st[2] | 0, this.D = st[3] | 0, this.E = st[4] | 0, this.F = st[5] | 0, this.G = st[6] | 0, this.H = st[7] | 0;
  }
  get() {
    const { A: e, B: s, C: i, D: o, E: r, F: n, G: h, H: b } = this;
    return [e, s, i, o, r, n, h, b];
  }
  // prettier-ignore
  set(e, s, i, o, r, n, h, b) {
    this.A = e | 0, this.B = s | 0, this.C = i | 0, this.D = o | 0, this.E = r | 0, this.F = n | 0, this.G = h | 0, this.H = b | 0;
  }
  process(e, s) {
    for (let u = 0; u < 16; u++, s += 4)
      nt[u] = e.getUint32(s, !1);
    for (let u = 16; u < 64; u++) {
      const A = nt[u - 15], m = nt[u - 2], w = Z(A, 7) ^ Z(A, 18) ^ A >>> 3, I = Z(m, 17) ^ Z(m, 19) ^ m >>> 10;
      nt[u] = I + nt[u - 7] + w + nt[u - 16] | 0;
    }
    let { A: i, B: o, C: r, D: n, E: h, F: b, G: x, H } = this;
    for (let u = 0; u < 64; u++) {
      const A = Z(h, 6) ^ Z(h, 11) ^ Z(h, 25), m = H + A + Se(h, b, x) + De[u] + nt[u] | 0, I = (Z(i, 2) ^ Z(i, 13) ^ Z(i, 22)) + Ie(i, o, r) | 0;
      H = x, x = b, b = h, h = n + m | 0, n = r, r = o, o = i, i = m + I | 0;
    }
    i = i + this.A | 0, o = o + this.B | 0, r = r + this.C | 0, n = n + this.D | 0, h = h + this.E | 0, b = b + this.F | 0, x = x + this.G | 0, H = H + this.H | 0, this.set(i, o, r, n, h, b, x, H);
  }
  roundClean() {
    ct(nt);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), ct(this.buffer);
  }
}
const ie = Be([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((t) => BigInt(t))), Fe = ie[0], Te = ie[1], rt = /* @__PURE__ */ new Uint32Array(80), it = /* @__PURE__ */ new Uint32Array(80);
class Me extends re {
  constructor(e = 64) {
    super(128, e, 16, !1), this.Ah = q[0] | 0, this.Al = q[1] | 0, this.Bh = q[2] | 0, this.Bl = q[3] | 0, this.Ch = q[4] | 0, this.Cl = q[5] | 0, this.Dh = q[6] | 0, this.Dl = q[7] | 0, this.Eh = q[8] | 0, this.El = q[9] | 0, this.Fh = q[10] | 0, this.Fl = q[11] | 0, this.Gh = q[12] | 0, this.Gl = q[13] | 0, this.Hh = q[14] | 0, this.Hl = q[15] | 0;
  }
  // prettier-ignore
  get() {
    const { Ah: e, Al: s, Bh: i, Bl: o, Ch: r, Cl: n, Dh: h, Dl: b, Eh: x, El: H, Fh: u, Fl: A, Gh: m, Gl: w, Hh: I, Hl: C } = this;
    return [e, s, i, o, r, n, h, b, x, H, u, A, m, w, I, C];
  }
  // prettier-ignore
  set(e, s, i, o, r, n, h, b, x, H, u, A, m, w, I, C) {
    this.Ah = e | 0, this.Al = s | 0, this.Bh = i | 0, this.Bl = o | 0, this.Ch = r | 0, this.Cl = n | 0, this.Dh = h | 0, this.Dl = b | 0, this.Eh = x | 0, this.El = H | 0, this.Fh = u | 0, this.Fl = A | 0, this.Gh = m | 0, this.Gl = w | 0, this.Hh = I | 0, this.Hl = C | 0;
  }
  process(e, s) {
    for (let y = 0; y < 16; y++, s += 4)
      rt[y] = e.getUint32(s), it[y] = e.getUint32(s += 4);
    for (let y = 16; y < 80; y++) {
      const O = rt[y - 15] | 0, L = it[y - 15] | 0, E = dt(O, L, 1) ^ dt(O, L, 8) ^ Ot(O, L, 7), D = ut(O, L, 1) ^ ut(O, L, 8) ^ Ft(O, L, 7), B = rt[y - 2] | 0, a = it[y - 2] | 0, d = dt(B, a, 19) ^ yt(B, a, 61) ^ Ot(B, a, 6), f = ut(B, a, 19) ^ gt(B, a, 61) ^ Ft(B, a, 6), p = Ee(D, f, it[y - 7], it[y - 16]), l = ke(p, E, d, rt[y - 7], rt[y - 16]);
      rt[y] = l | 0, it[y] = p | 0;
    }
    let { Ah: i, Al: o, Bh: r, Bl: n, Ch: h, Cl: b, Dh: x, Dl: H, Eh: u, El: A, Fh: m, Fl: w, Gh: I, Gl: C, Hh: R, Hl: M } = this;
    for (let y = 0; y < 80; y++) {
      const O = dt(u, A, 14) ^ dt(u, A, 18) ^ yt(u, A, 41), L = ut(u, A, 14) ^ ut(u, A, 18) ^ gt(u, A, 41), E = u & m ^ ~u & I, D = A & w ^ ~A & C, B = Ve(M, L, D, Te[y], it[y]), a = Ce(B, R, O, E, Fe[y], rt[y]), d = B | 0, f = dt(i, o, 28) ^ yt(i, o, 34) ^ yt(i, o, 39), p = ut(i, o, 28) ^ gt(i, o, 34) ^ gt(i, o, 39), l = i & r ^ i & h ^ r & h, S = o & n ^ o & b ^ n & b;
      R = I | 0, M = C | 0, I = m | 0, C = w | 0, m = u | 0, w = A | 0, { h: u, l: A } = $(x | 0, H | 0, a | 0, d | 0), x = h | 0, H = b | 0, h = r | 0, b = n | 0, r = i | 0, n = o | 0;
      const U = me(d, p, S);
      i = Ue(U, a, f, l), o = U | 0;
    }
    ({ h: i, l: o } = $(this.Ah | 0, this.Al | 0, i | 0, o | 0)), { h: r, l: n } = $(this.Bh | 0, this.Bl | 0, r | 0, n | 0), { h, l: b } = $(this.Ch | 0, this.Cl | 0, h | 0, b | 0), { h: x, l: H } = $(this.Dh | 0, this.Dl | 0, x | 0, H | 0), { h: u, l: A } = $(this.Eh | 0, this.El | 0, u | 0, A | 0), { h: m, l: w } = $(this.Fh | 0, this.Fl | 0, m | 0, w | 0), { h: I, l: C } = $(this.Gh | 0, this.Gl | 0, I | 0, C | 0), { h: R, l: M } = $(this.Hh | 0, this.Hl | 0, R | 0, M | 0), this.set(i, o, r, n, h, b, x, H, u, A, m, w, I, C, R, M);
  }
  roundClean() {
    ct(rt, it);
  }
  destroy() {
    ct(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
const ve = /* @__PURE__ */ ne(() => new Oe()), Re = /* @__PURE__ */ ne(() => new Me()), ps = ve;
var j = {}, K = {}, Bt = {}, lt = {}, Tt;
function Ge() {
  return Tt || (Tt = 1, Object.defineProperty(lt, "__esModule", { value: !0 }), lt.crypto = void 0, lt.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0), lt;
}
var Mt;
function pt() {
  return Mt || (Mt = 1, (function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.wrapXOFConstructorWithOpts = t.wrapConstructorWithOpts = t.wrapConstructor = t.Hash = t.nextTick = t.swap32IfBE = t.byteSwapIfBE = t.swap8IfBE = t.isLE = void 0, t.isBytes = s, t.anumber = i, t.abytes = o, t.ahash = r, t.aexists = n, t.aoutput = h, t.u8 = b, t.u32 = x, t.clean = H, t.createView = u, t.rotr = A, t.rotl = m, t.byteSwap = w, t.byteSwap32 = I, t.bytesToHex = M, t.hexToBytes = L, t.asyncLoop = D, t.utf8ToBytes = B, t.bytesToUtf8 = a, t.toBytes = d, t.kdfInputToBytes = f, t.concatBytes = p, t.checkOpts = l, t.createHasher = U, t.createOptHasher = k, t.createXOFer = F, t.randomBytes = v;
    const e = /* @__PURE__ */ Ge();
    function s(c) {
      return c instanceof Uint8Array || ArrayBuffer.isView(c) && c.constructor.name === "Uint8Array";
    }
    function i(c) {
      if (!Number.isSafeInteger(c) || c < 0)
        throw new Error("positive integer expected, got " + c);
    }
    function o(c, ...g) {
      if (!s(c))
        throw new Error("Uint8Array expected");
      if (g.length > 0 && !g.includes(c.length))
        throw new Error("Uint8Array expected of length " + g + ", got length=" + c.length);
    }
    function r(c) {
      if (typeof c != "function" || typeof c.create != "function")
        throw new Error("Hash should be wrapped by utils.createHasher");
      i(c.outputLen), i(c.blockLen);
    }
    function n(c, g = !0) {
      if (c.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (g && c.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function h(c, g) {
      o(c);
      const _ = g.outputLen;
      if (c.length < _)
        throw new Error("digestInto() expects output buffer of length at least " + _);
    }
    function b(c) {
      return new Uint8Array(c.buffer, c.byteOffset, c.byteLength);
    }
    function x(c) {
      return new Uint32Array(c.buffer, c.byteOffset, Math.floor(c.byteLength / 4));
    }
    function H(...c) {
      for (let g = 0; g < c.length; g++)
        c[g].fill(0);
    }
    function u(c) {
      return new DataView(c.buffer, c.byteOffset, c.byteLength);
    }
    function A(c, g) {
      return c << 32 - g | c >>> g;
    }
    function m(c, g) {
      return c << g | c >>> 32 - g >>> 0;
    }
    t.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    function w(c) {
      return c << 24 & 4278190080 | c << 8 & 16711680 | c >>> 8 & 65280 | c >>> 24 & 255;
    }
    t.swap8IfBE = t.isLE ? (c) => c : (c) => w(c), t.byteSwapIfBE = t.swap8IfBE;
    function I(c) {
      for (let g = 0; g < c.length; g++)
        c[g] = w(c[g]);
      return c;
    }
    t.swap32IfBE = t.isLE ? (c) => c : I;
    const C = /* @ts-ignore */ typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function", R = /* @__PURE__ */ Array.from({ length: 256 }, (c, g) => g.toString(16).padStart(2, "0"));
    function M(c) {
      if (o(c), C)
        return c.toHex();
      let g = "";
      for (let _ = 0; _ < c.length; _++)
        g += R[c[_]];
      return g;
    }
    const y = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function O(c) {
      if (c >= y._0 && c <= y._9)
        return c - y._0;
      if (c >= y.A && c <= y.F)
        return c - (y.A - 10);
      if (c >= y.a && c <= y.f)
        return c - (y.a - 10);
    }
    function L(c) {
      if (typeof c != "string")
        throw new Error("hex string expected, got " + typeof c);
      if (C)
        return Uint8Array.fromHex(c);
      const g = c.length, _ = g / 2;
      if (g % 2)
        throw new Error("hex string expected, got unpadded hex of length " + g);
      const T = new Uint8Array(_);
      for (let G = 0, P = 0; G < _; G++, P += 2) {
        const tt = O(c.charCodeAt(P)), X = O(c.charCodeAt(P + 1));
        if (tt === void 0 || X === void 0) {
          const J = c[P] + c[P + 1];
          throw new Error('hex string expected, got non-hex character "' + J + '" at index ' + P);
        }
        T[G] = tt * 16 + X;
      }
      return T;
    }
    const E = async () => {
    };
    t.nextTick = E;
    async function D(c, g, _) {
      let T = Date.now();
      for (let G = 0; G < c; G++) {
        _(G);
        const P = Date.now() - T;
        P >= 0 && P < g || (await (0, t.nextTick)(), T += P);
      }
    }
    function B(c) {
      if (typeof c != "string")
        throw new Error("string expected");
      return new Uint8Array(new TextEncoder().encode(c));
    }
    function a(c) {
      return new TextDecoder().decode(c);
    }
    function d(c) {
      return typeof c == "string" && (c = B(c)), o(c), c;
    }
    function f(c) {
      return typeof c == "string" && (c = B(c)), o(c), c;
    }
    function p(...c) {
      let g = 0;
      for (let T = 0; T < c.length; T++) {
        const G = c[T];
        o(G), g += G.length;
      }
      const _ = new Uint8Array(g);
      for (let T = 0, G = 0; T < c.length; T++) {
        const P = c[T];
        _.set(P, G), G += P.length;
      }
      return _;
    }
    function l(c, g) {
      if (g !== void 0 && {}.toString.call(g) !== "[object Object]")
        throw new Error("options should be object or undefined");
      return Object.assign(c, g);
    }
    class S {
    }
    t.Hash = S;
    function U(c) {
      const g = (T) => c().update(d(T)).digest(), _ = c();
      return g.outputLen = _.outputLen, g.blockLen = _.blockLen, g.create = () => c(), g;
    }
    function k(c) {
      const g = (T, G) => c(G).update(d(T)).digest(), _ = c({});
      return g.outputLen = _.outputLen, g.blockLen = _.blockLen, g.create = (T) => c(T), g;
    }
    function F(c) {
      const g = (T, G) => c(G).update(d(T)).digest(), _ = c({});
      return g.outputLen = _.outputLen, g.blockLen = _.blockLen, g.create = (T) => c(T), g;
    }
    t.wrapConstructor = U, t.wrapConstructorWithOpts = k, t.wrapXOFConstructorWithOpts = F;
    function v(c = 32) {
      if (e.crypto && typeof e.crypto.getRandomValues == "function")
        return e.crypto.getRandomValues(new Uint8Array(c));
      if (e.crypto && typeof e.crypto.randomBytes == "function")
        return Uint8Array.from(e.crypto.randomBytes(c));
      throw new Error("crypto.getRandomValues must be defined");
    }
  })(Bt)), Bt;
}
var vt;
function oe() {
  if (vt) return K;
  vt = 1, Object.defineProperty(K, "__esModule", { value: !0 }), K.SHA512_IV = K.SHA384_IV = K.SHA224_IV = K.SHA256_IV = K.HashMD = void 0, K.setBigUint64 = e, K.Chi = s, K.Maj = i;
  const t = /* @__PURE__ */ pt();
  function e(r, n, h, b) {
    if (typeof r.setBigUint64 == "function")
      return r.setBigUint64(n, h, b);
    const x = BigInt(32), H = BigInt(4294967295), u = Number(h >> x & H), A = Number(h & H), m = b ? 4 : 0, w = b ? 0 : 4;
    r.setUint32(n + m, u, b), r.setUint32(n + w, A, b);
  }
  function s(r, n, h) {
    return r & n ^ ~r & h;
  }
  function i(r, n, h) {
    return r & n ^ r & h ^ n & h;
  }
  class o extends t.Hash {
    constructor(n, h, b, x) {
      super(), this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.blockLen = n, this.outputLen = h, this.padOffset = b, this.isLE = x, this.buffer = new Uint8Array(n), this.view = (0, t.createView)(this.buffer);
    }
    update(n) {
      (0, t.aexists)(this), n = (0, t.toBytes)(n), (0, t.abytes)(n);
      const { view: h, buffer: b, blockLen: x } = this, H = n.length;
      for (let u = 0; u < H; ) {
        const A = Math.min(x - this.pos, H - u);
        if (A === x) {
          const m = (0, t.createView)(n);
          for (; x <= H - u; u += x)
            this.process(m, u);
          continue;
        }
        b.set(n.subarray(u, u + A), this.pos), this.pos += A, u += A, this.pos === x && (this.process(h, 0), this.pos = 0);
      }
      return this.length += n.length, this.roundClean(), this;
    }
    digestInto(n) {
      (0, t.aexists)(this), (0, t.aoutput)(n, this), this.finished = !0;
      const { buffer: h, view: b, blockLen: x, isLE: H } = this;
      let { pos: u } = this;
      h[u++] = 128, (0, t.clean)(this.buffer.subarray(u)), this.padOffset > x - u && (this.process(b, 0), u = 0);
      for (let C = u; C < x; C++)
        h[C] = 0;
      e(b, x - 8, BigInt(this.length * 8), H), this.process(b, 0);
      const A = (0, t.createView)(n), m = this.outputLen;
      if (m % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const w = m / 4, I = this.get();
      if (w > I.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let C = 0; C < w; C++)
        A.setUint32(4 * C, I[C], H);
    }
    digest() {
      const { buffer: n, outputLen: h } = this;
      this.digestInto(n);
      const b = n.slice(0, h);
      return this.destroy(), b;
    }
    _cloneInto(n) {
      n || (n = new this.constructor()), n.set(...this.get());
      const { blockLen: h, buffer: b, length: x, finished: H, destroyed: u, pos: A } = this;
      return n.destroyed = u, n.finished = H, n.length = x, n.pos = A, x % h && n.buffer.set(b), n;
    }
    clone() {
      return this._cloneInto();
    }
  }
  return K.HashMD = o, K.SHA256_IV = Uint32Array.from([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]), K.SHA224_IV = Uint32Array.from([
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ]), K.SHA384_IV = Uint32Array.from([
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ]), K.SHA512_IV = Uint32Array.from([
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ]), K;
}
var V = {}, Rt;
function je() {
  if (Rt) return V;
  Rt = 1, Object.defineProperty(V, "__esModule", { value: !0 }), V.toBig = V.shrSL = V.shrSH = V.rotrSL = V.rotrSH = V.rotrBL = V.rotrBH = V.rotr32L = V.rotr32H = V.rotlSL = V.rotlSH = V.rotlBL = V.rotlBH = V.add5L = V.add5H = V.add4L = V.add4H = V.add3L = V.add3H = void 0, V.add = R, V.fromBig = s, V.split = i;
  const t = /* @__PURE__ */ BigInt(2 ** 32 - 1), e = /* @__PURE__ */ BigInt(32);
  function s(a, d = !1) {
    return d ? { h: Number(a & t), l: Number(a >> e & t) } : { h: Number(a >> e & t) | 0, l: Number(a & t) | 0 };
  }
  function i(a, d = !1) {
    const f = a.length;
    let p = new Uint32Array(f), l = new Uint32Array(f);
    for (let S = 0; S < f; S++) {
      const { h: U, l: k } = s(a[S], d);
      [p[S], l[S]] = [U, k];
    }
    return [p, l];
  }
  const o = (a, d) => BigInt(a >>> 0) << e | BigInt(d >>> 0);
  V.toBig = o;
  const r = (a, d, f) => a >>> f;
  V.shrSH = r;
  const n = (a, d, f) => a << 32 - f | d >>> f;
  V.shrSL = n;
  const h = (a, d, f) => a >>> f | d << 32 - f;
  V.rotrSH = h;
  const b = (a, d, f) => a << 32 - f | d >>> f;
  V.rotrSL = b;
  const x = (a, d, f) => a << 64 - f | d >>> f - 32;
  V.rotrBH = x;
  const H = (a, d, f) => a >>> f - 32 | d << 64 - f;
  V.rotrBL = H;
  const u = (a, d) => d;
  V.rotr32H = u;
  const A = (a, d) => a;
  V.rotr32L = A;
  const m = (a, d, f) => a << f | d >>> 32 - f;
  V.rotlSH = m;
  const w = (a, d, f) => d << f | a >>> 32 - f;
  V.rotlSL = w;
  const I = (a, d, f) => d << f - 32 | a >>> 64 - f;
  V.rotlBH = I;
  const C = (a, d, f) => a << f - 32 | d >>> 64 - f;
  V.rotlBL = C;
  function R(a, d, f, p) {
    const l = (d >>> 0) + (p >>> 0);
    return { h: a + f + (l / 2 ** 32 | 0) | 0, l: l | 0 };
  }
  const M = (a, d, f) => (a >>> 0) + (d >>> 0) + (f >>> 0);
  V.add3L = M;
  const y = (a, d, f, p) => d + f + p + (a / 2 ** 32 | 0) | 0;
  V.add3H = y;
  const O = (a, d, f, p) => (a >>> 0) + (d >>> 0) + (f >>> 0) + (p >>> 0);
  V.add4L = O;
  const L = (a, d, f, p, l) => d + f + p + l + (a / 2 ** 32 | 0) | 0;
  V.add4H = L;
  const E = (a, d, f, p, l) => (a >>> 0) + (d >>> 0) + (f >>> 0) + (p >>> 0) + (l >>> 0);
  V.add5L = E;
  const D = (a, d, f, p, l, S) => d + f + p + l + S + (a / 2 ** 32 | 0) | 0;
  V.add5H = D;
  const B = {
    fromBig: s,
    split: i,
    toBig: o,
    shrSH: r,
    shrSL: n,
    rotrSH: h,
    rotrSL: b,
    rotrBH: x,
    rotrBL: H,
    rotr32H: u,
    rotr32L: A,
    rotlSH: m,
    rotlSL: w,
    rotlBH: I,
    rotlBL: C,
    add: R,
    add3L: M,
    add3H: y,
    add4L: O,
    add4H: L,
    add5H: D,
    add5L: E
  };
  return V.default = B, V;
}
var Gt;
function ce() {
  if (Gt) return j;
  Gt = 1, Object.defineProperty(j, "__esModule", { value: !0 }), j.sha512_224 = j.sha512_256 = j.sha384 = j.sha512 = j.sha224 = j.sha256 = j.SHA512_256 = j.SHA512_224 = j.SHA384 = j.SHA512 = j.SHA224 = j.SHA256 = void 0;
  const t = /* @__PURE__ */ oe(), e = /* @__PURE__ */ je(), s = /* @__PURE__ */ pt(), i = /* @__PURE__ */ Uint32Array.from([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]), o = /* @__PURE__ */ new Uint32Array(64);
  class r extends t.HashMD {
    constructor(y = 32) {
      super(64, y, 8, !1), this.A = t.SHA256_IV[0] | 0, this.B = t.SHA256_IV[1] | 0, this.C = t.SHA256_IV[2] | 0, this.D = t.SHA256_IV[3] | 0, this.E = t.SHA256_IV[4] | 0, this.F = t.SHA256_IV[5] | 0, this.G = t.SHA256_IV[6] | 0, this.H = t.SHA256_IV[7] | 0;
    }
    get() {
      const { A: y, B: O, C: L, D: E, E: D, F: B, G: a, H: d } = this;
      return [y, O, L, E, D, B, a, d];
    }
    // prettier-ignore
    set(y, O, L, E, D, B, a, d) {
      this.A = y | 0, this.B = O | 0, this.C = L | 0, this.D = E | 0, this.E = D | 0, this.F = B | 0, this.G = a | 0, this.H = d | 0;
    }
    process(y, O) {
      for (let l = 0; l < 16; l++, O += 4)
        o[l] = y.getUint32(O, !1);
      for (let l = 16; l < 64; l++) {
        const S = o[l - 15], U = o[l - 2], k = (0, s.rotr)(S, 7) ^ (0, s.rotr)(S, 18) ^ S >>> 3, F = (0, s.rotr)(U, 17) ^ (0, s.rotr)(U, 19) ^ U >>> 10;
        o[l] = F + o[l - 7] + k + o[l - 16] | 0;
      }
      let { A: L, B: E, C: D, D: B, E: a, F: d, G: f, H: p } = this;
      for (let l = 0; l < 64; l++) {
        const S = (0, s.rotr)(a, 6) ^ (0, s.rotr)(a, 11) ^ (0, s.rotr)(a, 25), U = p + S + (0, t.Chi)(a, d, f) + i[l] + o[l] | 0, F = ((0, s.rotr)(L, 2) ^ (0, s.rotr)(L, 13) ^ (0, s.rotr)(L, 22)) + (0, t.Maj)(L, E, D) | 0;
        p = f, f = d, d = a, a = B + U | 0, B = D, D = E, E = L, L = U + F | 0;
      }
      L = L + this.A | 0, E = E + this.B | 0, D = D + this.C | 0, B = B + this.D | 0, a = a + this.E | 0, d = d + this.F | 0, f = f + this.G | 0, p = p + this.H | 0, this.set(L, E, D, B, a, d, f, p);
    }
    roundClean() {
      (0, s.clean)(o);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0), (0, s.clean)(this.buffer);
    }
  }
  j.SHA256 = r;
  class n extends r {
    constructor() {
      super(28), this.A = t.SHA224_IV[0] | 0, this.B = t.SHA224_IV[1] | 0, this.C = t.SHA224_IV[2] | 0, this.D = t.SHA224_IV[3] | 0, this.E = t.SHA224_IV[4] | 0, this.F = t.SHA224_IV[5] | 0, this.G = t.SHA224_IV[6] | 0, this.H = t.SHA224_IV[7] | 0;
    }
  }
  j.SHA224 = n;
  const h = e.split([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
  ].map((M) => BigInt(M))), b = h[0], x = h[1], H = /* @__PURE__ */ new Uint32Array(80), u = /* @__PURE__ */ new Uint32Array(80);
  class A extends t.HashMD {
    constructor(y = 64) {
      super(128, y, 16, !1), this.Ah = t.SHA512_IV[0] | 0, this.Al = t.SHA512_IV[1] | 0, this.Bh = t.SHA512_IV[2] | 0, this.Bl = t.SHA512_IV[3] | 0, this.Ch = t.SHA512_IV[4] | 0, this.Cl = t.SHA512_IV[5] | 0, this.Dh = t.SHA512_IV[6] | 0, this.Dl = t.SHA512_IV[7] | 0, this.Eh = t.SHA512_IV[8] | 0, this.El = t.SHA512_IV[9] | 0, this.Fh = t.SHA512_IV[10] | 0, this.Fl = t.SHA512_IV[11] | 0, this.Gh = t.SHA512_IV[12] | 0, this.Gl = t.SHA512_IV[13] | 0, this.Hh = t.SHA512_IV[14] | 0, this.Hl = t.SHA512_IV[15] | 0;
    }
    // prettier-ignore
    get() {
      const { Ah: y, Al: O, Bh: L, Bl: E, Ch: D, Cl: B, Dh: a, Dl: d, Eh: f, El: p, Fh: l, Fl: S, Gh: U, Gl: k, Hh: F, Hl: v } = this;
      return [y, O, L, E, D, B, a, d, f, p, l, S, U, k, F, v];
    }
    // prettier-ignore
    set(y, O, L, E, D, B, a, d, f, p, l, S, U, k, F, v) {
      this.Ah = y | 0, this.Al = O | 0, this.Bh = L | 0, this.Bl = E | 0, this.Ch = D | 0, this.Cl = B | 0, this.Dh = a | 0, this.Dl = d | 0, this.Eh = f | 0, this.El = p | 0, this.Fh = l | 0, this.Fl = S | 0, this.Gh = U | 0, this.Gl = k | 0, this.Hh = F | 0, this.Hl = v | 0;
    }
    process(y, O) {
      for (let _ = 0; _ < 16; _++, O += 4)
        H[_] = y.getUint32(O), u[_] = y.getUint32(O += 4);
      for (let _ = 16; _ < 80; _++) {
        const T = H[_ - 15] | 0, G = u[_ - 15] | 0, P = e.rotrSH(T, G, 1) ^ e.rotrSH(T, G, 8) ^ e.shrSH(T, G, 7), tt = e.rotrSL(T, G, 1) ^ e.rotrSL(T, G, 8) ^ e.shrSL(T, G, 7), X = H[_ - 2] | 0, J = u[_ - 2] | 0, at = e.rotrSH(X, J, 19) ^ e.rotrBH(X, J, 61) ^ e.shrSH(X, J, 6), Q = e.rotrSL(X, J, 19) ^ e.rotrBL(X, J, 61) ^ e.shrSL(X, J, 6), et = e.add4L(tt, Q, u[_ - 7], u[_ - 16]), Lt = e.add4H(et, P, at, H[_ - 7], H[_ - 16]);
        H[_] = Lt | 0, u[_] = et | 0;
      }
      let { Ah: L, Al: E, Bh: D, Bl: B, Ch: a, Cl: d, Dh: f, Dl: p, Eh: l, El: S, Fh: U, Fl: k, Gh: F, Gl: v, Hh: c, Hl: g } = this;
      for (let _ = 0; _ < 80; _++) {
        const T = e.rotrSH(l, S, 14) ^ e.rotrSH(l, S, 18) ^ e.rotrBH(l, S, 41), G = e.rotrSL(l, S, 14) ^ e.rotrSL(l, S, 18) ^ e.rotrBL(l, S, 41), P = l & U ^ ~l & F, tt = S & k ^ ~S & v, X = e.add5L(g, G, tt, x[_], u[_]), J = e.add5H(X, c, T, P, b[_], H[_]), at = X | 0, Q = e.rotrSH(L, E, 28) ^ e.rotrBH(L, E, 34) ^ e.rotrBH(L, E, 39), et = e.rotrSL(L, E, 28) ^ e.rotrBL(L, E, 34) ^ e.rotrBL(L, E, 39), Lt = L & D ^ L & a ^ D & a, pe = E & B ^ E & d ^ B & d;
        c = F | 0, g = v | 0, F = U | 0, v = k | 0, U = l | 0, k = S | 0, { h: l, l: S } = e.add(f | 0, p | 0, J | 0, at | 0), f = a | 0, p = d | 0, a = D | 0, d = B | 0, D = L | 0, B = E | 0;
        const kt = e.add3L(at, et, pe);
        L = e.add3H(kt, J, Q, Lt), E = kt | 0;
      }
      ({ h: L, l: E } = e.add(this.Ah | 0, this.Al | 0, L | 0, E | 0)), { h: D, l: B } = e.add(this.Bh | 0, this.Bl | 0, D | 0, B | 0), { h: a, l: d } = e.add(this.Ch | 0, this.Cl | 0, a | 0, d | 0), { h: f, l: p } = e.add(this.Dh | 0, this.Dl | 0, f | 0, p | 0), { h: l, l: S } = e.add(this.Eh | 0, this.El | 0, l | 0, S | 0), { h: U, l: k } = e.add(this.Fh | 0, this.Fl | 0, U | 0, k | 0), { h: F, l: v } = e.add(this.Gh | 0, this.Gl | 0, F | 0, v | 0), { h: c, l: g } = e.add(this.Hh | 0, this.Hl | 0, c | 0, g | 0), this.set(L, E, D, B, a, d, f, p, l, S, U, k, F, v, c, g);
    }
    roundClean() {
      (0, s.clean)(H, u);
    }
    destroy() {
      (0, s.clean)(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  }
  j.SHA512 = A;
  class m extends A {
    constructor() {
      super(48), this.Ah = t.SHA384_IV[0] | 0, this.Al = t.SHA384_IV[1] | 0, this.Bh = t.SHA384_IV[2] | 0, this.Bl = t.SHA384_IV[3] | 0, this.Ch = t.SHA384_IV[4] | 0, this.Cl = t.SHA384_IV[5] | 0, this.Dh = t.SHA384_IV[6] | 0, this.Dl = t.SHA384_IV[7] | 0, this.Eh = t.SHA384_IV[8] | 0, this.El = t.SHA384_IV[9] | 0, this.Fh = t.SHA384_IV[10] | 0, this.Fl = t.SHA384_IV[11] | 0, this.Gh = t.SHA384_IV[12] | 0, this.Gl = t.SHA384_IV[13] | 0, this.Hh = t.SHA384_IV[14] | 0, this.Hl = t.SHA384_IV[15] | 0;
    }
  }
  j.SHA384 = m;
  const w = /* @__PURE__ */ Uint32Array.from([
    2352822216,
    424955298,
    1944164710,
    2312950998,
    502970286,
    855612546,
    1738396948,
    1479516111,
    258812777,
    2077511080,
    2011393907,
    79989058,
    1067287976,
    1780299464,
    286451373,
    2446758561
  ]), I = /* @__PURE__ */ Uint32Array.from([
    573645204,
    4230739756,
    2673172387,
    3360449730,
    596883563,
    1867755857,
    2520282905,
    1497426621,
    2519219938,
    2827943907,
    3193839141,
    1401305490,
    721525244,
    746961066,
    246885852,
    2177182882
  ]);
  class C extends A {
    constructor() {
      super(28), this.Ah = w[0] | 0, this.Al = w[1] | 0, this.Bh = w[2] | 0, this.Bl = w[3] | 0, this.Ch = w[4] | 0, this.Cl = w[5] | 0, this.Dh = w[6] | 0, this.Dl = w[7] | 0, this.Eh = w[8] | 0, this.El = w[9] | 0, this.Fh = w[10] | 0, this.Fl = w[11] | 0, this.Gh = w[12] | 0, this.Gl = w[13] | 0, this.Hh = w[14] | 0, this.Hl = w[15] | 0;
    }
  }
  j.SHA512_224 = C;
  class R extends A {
    constructor() {
      super(32), this.Ah = I[0] | 0, this.Al = I[1] | 0, this.Bh = I[2] | 0, this.Bl = I[3] | 0, this.Ch = I[4] | 0, this.Cl = I[5] | 0, this.Dh = I[6] | 0, this.Dl = I[7] | 0, this.Eh = I[8] | 0, this.El = I[9] | 0, this.Fh = I[10] | 0, this.Fl = I[11] | 0, this.Gh = I[12] | 0, this.Gl = I[13] | 0, this.Hh = I[14] | 0, this.Hl = I[15] | 0;
    }
  }
  return j.SHA512_256 = R, j.sha256 = (0, s.createHasher)(() => new r()), j.sha224 = (0, s.createHasher)(() => new n()), j.sha512 = (0, s.createHasher)(() => new A()), j.sha384 = (0, s.createHasher)(() => new m()), j.sha512_256 = (0, s.createHasher)(() => new R()), j.sha512_224 = (0, s.createHasher)(() => new C()), j;
}
var mt = {}, jt;
function Pe() {
  return jt || (jt = 1, (function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.hmac = t.HMAC = void 0;
    const e = /* @__PURE__ */ pt();
    class s extends e.Hash {
      constructor(r, n) {
        super(), this.finished = !1, this.destroyed = !1, (0, e.ahash)(r);
        const h = (0, e.toBytes)(n);
        if (this.iHash = r.create(), typeof this.iHash.update != "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
        const b = this.blockLen, x = new Uint8Array(b);
        x.set(h.length > b ? r.create().update(h).digest() : h);
        for (let H = 0; H < x.length; H++)
          x[H] ^= 54;
        this.iHash.update(x), this.oHash = r.create();
        for (let H = 0; H < x.length; H++)
          x[H] ^= 106;
        this.oHash.update(x), (0, e.clean)(x);
      }
      update(r) {
        return (0, e.aexists)(this), this.iHash.update(r), this;
      }
      digestInto(r) {
        (0, e.aexists)(this), (0, e.abytes)(r, this.outputLen), this.finished = !0, this.iHash.digestInto(r), this.oHash.update(r), this.oHash.digestInto(r), this.destroy();
      }
      digest() {
        const r = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(r), r;
      }
      _cloneInto(r) {
        r || (r = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash: n, iHash: h, finished: b, destroyed: x, blockLen: H, outputLen: u } = this;
        return r = r, r.finished = b, r.destroyed = x, r.blockLen = H, r.outputLen = u, r.oHash = n._cloneInto(r.oHash), r.iHash = h._cloneInto(r.iHash), r;
      }
      clone() {
        return this._cloneInto();
      }
      destroy() {
        this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
      }
    }
    t.HMAC = s;
    const i = (o, r, n) => new s(o, r).update(n).digest();
    t.hmac = i, t.hmac.create = (o, r) => new s(o, r);
  })(mt)), mt;
}
var ot = {}, N = {}, Pt;
function We() {
  if (Pt) return N;
  Pt = 1, Object.defineProperty(N, "__esModule", { value: !0 }), N.ripemd160 = N.RIPEMD160 = N.md5 = N.MD5 = N.sha1 = N.SHA1 = void 0;
  const t = /* @__PURE__ */ oe(), e = /* @__PURE__ */ pt(), s = /* @__PURE__ */ Uint32Array.from([
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ]), i = /* @__PURE__ */ new Uint32Array(80);
  class o extends t.HashMD {
    constructor() {
      super(64, 20, 8, !1), this.A = s[0] | 0, this.B = s[1] | 0, this.C = s[2] | 0, this.D = s[3] | 0, this.E = s[4] | 0;
    }
    get() {
      const { A: a, B: d, C: f, D: p, E: l } = this;
      return [a, d, f, p, l];
    }
    set(a, d, f, p, l) {
      this.A = a | 0, this.B = d | 0, this.C = f | 0, this.D = p | 0, this.E = l | 0;
    }
    process(a, d) {
      for (let k = 0; k < 16; k++, d += 4)
        i[k] = a.getUint32(d, !1);
      for (let k = 16; k < 80; k++)
        i[k] = (0, e.rotl)(i[k - 3] ^ i[k - 8] ^ i[k - 14] ^ i[k - 16], 1);
      let { A: f, B: p, C: l, D: S, E: U } = this;
      for (let k = 0; k < 80; k++) {
        let F, v;
        k < 20 ? (F = (0, t.Chi)(p, l, S), v = 1518500249) : k < 40 ? (F = p ^ l ^ S, v = 1859775393) : k < 60 ? (F = (0, t.Maj)(p, l, S), v = 2400959708) : (F = p ^ l ^ S, v = 3395469782);
        const c = (0, e.rotl)(f, 5) + F + U + v + i[k] | 0;
        U = S, S = l, l = (0, e.rotl)(p, 30), p = f, f = c;
      }
      f = f + this.A | 0, p = p + this.B | 0, l = l + this.C | 0, S = S + this.D | 0, U = U + this.E | 0, this.set(f, p, l, S, U);
    }
    roundClean() {
      (0, e.clean)(i);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0), (0, e.clean)(this.buffer);
    }
  }
  N.SHA1 = o, N.sha1 = (0, e.createHasher)(() => new o());
  const r = /* @__PURE__ */ Math.pow(2, 32), n = /* @__PURE__ */ Array.from({ length: 64 }, (B, a) => Math.floor(r * Math.abs(Math.sin(a + 1)))), h = /* @__PURE__ */ s.slice(0, 4), b = /* @__PURE__ */ new Uint32Array(16);
  class x extends t.HashMD {
    constructor() {
      super(64, 16, 8, !0), this.A = h[0] | 0, this.B = h[1] | 0, this.C = h[2] | 0, this.D = h[3] | 0;
    }
    get() {
      const { A: a, B: d, C: f, D: p } = this;
      return [a, d, f, p];
    }
    set(a, d, f, p) {
      this.A = a | 0, this.B = d | 0, this.C = f | 0, this.D = p | 0;
    }
    process(a, d) {
      for (let U = 0; U < 16; U++, d += 4)
        b[U] = a.getUint32(d, !0);
      let { A: f, B: p, C: l, D: S } = this;
      for (let U = 0; U < 64; U++) {
        let k, F, v;
        U < 16 ? (k = (0, t.Chi)(p, l, S), F = U, v = [7, 12, 17, 22]) : U < 32 ? (k = (0, t.Chi)(S, p, l), F = (5 * U + 1) % 16, v = [5, 9, 14, 20]) : U < 48 ? (k = p ^ l ^ S, F = (3 * U + 5) % 16, v = [4, 11, 16, 23]) : (k = l ^ (p | ~S), F = 7 * U % 16, v = [6, 10, 15, 21]), k = k + f + n[U] + b[F], f = S, S = l, l = p, p = p + (0, e.rotl)(k, v[U % 4]);
      }
      f = f + this.A | 0, p = p + this.B | 0, l = l + this.C | 0, S = S + this.D | 0, this.set(f, p, l, S);
    }
    roundClean() {
      (0, e.clean)(b);
    }
    destroy() {
      this.set(0, 0, 0, 0), (0, e.clean)(this.buffer);
    }
  }
  N.MD5 = x, N.md5 = (0, e.createHasher)(() => new x());
  const H = /* @__PURE__ */ Uint8Array.from([
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8
  ]), u = Uint8Array.from(new Array(16).fill(0).map((B, a) => a)), A = u.map((B) => (9 * B + 5) % 16), m = /* @__PURE__ */ (() => {
    const d = [[u], [A]];
    for (let f = 0; f < 4; f++)
      for (let p of d)
        p.push(p[f].map((l) => H[l]));
    return d;
  })(), w = m[0], I = m[1], C = /* @__PURE__ */ [
    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
  ].map((B) => Uint8Array.from(B)), R = /* @__PURE__ */ w.map((B, a) => B.map((d) => C[a][d])), M = /* @__PURE__ */ I.map((B, a) => B.map((d) => C[a][d])), y = /* @__PURE__ */ Uint32Array.from([
    0,
    1518500249,
    1859775393,
    2400959708,
    2840853838
  ]), O = /* @__PURE__ */ Uint32Array.from([
    1352829926,
    1548603684,
    1836072691,
    2053994217,
    0
  ]);
  function L(B, a, d, f) {
    return B === 0 ? a ^ d ^ f : B === 1 ? a & d | ~a & f : B === 2 ? (a | ~d) ^ f : B === 3 ? a & f | d & ~f : a ^ (d | ~f);
  }
  const E = /* @__PURE__ */ new Uint32Array(16);
  class D extends t.HashMD {
    constructor() {
      super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
    }
    get() {
      const { h0: a, h1: d, h2: f, h3: p, h4: l } = this;
      return [a, d, f, p, l];
    }
    set(a, d, f, p, l) {
      this.h0 = a | 0, this.h1 = d | 0, this.h2 = f | 0, this.h3 = p | 0, this.h4 = l | 0;
    }
    process(a, d) {
      for (let _ = 0; _ < 16; _++, d += 4)
        E[_] = a.getUint32(d, !0);
      let f = this.h0 | 0, p = f, l = this.h1 | 0, S = l, U = this.h2 | 0, k = U, F = this.h3 | 0, v = F, c = this.h4 | 0, g = c;
      for (let _ = 0; _ < 5; _++) {
        const T = 4 - _, G = y[_], P = O[_], tt = w[_], X = I[_], J = R[_], at = M[_];
        for (let Q = 0; Q < 16; Q++) {
          const et = (0, e.rotl)(f + L(_, l, U, F) + E[tt[Q]] + G, J[Q]) + c | 0;
          f = c, c = F, F = (0, e.rotl)(U, 10) | 0, U = l, l = et;
        }
        for (let Q = 0; Q < 16; Q++) {
          const et = (0, e.rotl)(p + L(T, S, k, v) + E[X[Q]] + P, at[Q]) + g | 0;
          p = g, g = v, v = (0, e.rotl)(k, 10) | 0, k = S, S = et;
        }
      }
      this.set(this.h1 + U + v | 0, this.h2 + F + g | 0, this.h3 + c + p | 0, this.h4 + f + S | 0, this.h0 + l + k | 0);
    }
    roundClean() {
      (0, e.clean)(E);
    }
    destroy() {
      this.destroyed = !0, (0, e.clean)(this.buffer), this.set(0, 0, 0, 0, 0);
    }
  }
  return N.RIPEMD160 = D, N.ripemd160 = (0, e.createHasher)(() => new D()), N;
}
var Wt;
function As() {
  if (Wt) return ot;
  Wt = 1, Object.defineProperty(ot, "__esModule", { value: !0 }), ot.ripemd160 = ot.RIPEMD160 = void 0;
  const t = /* @__PURE__ */ We();
  return ot.RIPEMD160 = t.RIPEMD160, ot.ripemd160 = t.ripemd160, ot;
}
var Y = {}, qt;
function ys() {
  if (qt) return Y;
  qt = 1, Object.defineProperty(Y, "__esModule", { value: !0 }), Y.sha224 = Y.SHA224 = Y.sha256 = Y.SHA256 = void 0;
  const t = /* @__PURE__ */ ce();
  return Y.SHA256 = t.SHA256, Y.sha256 = t.sha256, Y.SHA224 = t.SHA224, Y.sha224 = t.sha224, Y;
}
var W = {}, Kt;
function gs() {
  if (Kt) return W;
  Kt = 1, Object.defineProperty(W, "__esModule", { value: !0 }), W.sha512_256 = W.SHA512_256 = W.sha512_224 = W.SHA512_224 = W.sha384 = W.SHA384 = W.sha512 = W.SHA512 = void 0;
  const t = /* @__PURE__ */ ce();
  return W.SHA512 = t.SHA512, W.sha512 = t.sha512, W.SHA384 = t.SHA384, W.sha384 = t.sha384, W.SHA512_224 = t.SHA512_224, W.sha512_224 = t.sha512_224, W.SHA512_256 = t.SHA512_256, W.sha512_256 = t.sha512_256, W;
}
function qe(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function Nt(t, e = "") {
  if (!Number.isSafeInteger(t) || t < 0) {
    const s = e && `"${e}" `;
    throw new Error(`${s}expected integer >= 0, got ${t}`);
  }
}
function It(t, e, s = "") {
  const i = qe(t), o = t?.length, r = e !== void 0;
  if (!i || r && o !== e) {
    const n = s && `"${s}" `, h = r ? ` of length ${e}` : "", b = i ? `length=${o}` : `type=${typeof t}`;
    throw new Error(n + "expected Uint8Array" + h + ", got " + b);
  }
  return t;
}
function Xt(t, e = !0) {
  if (t.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && t.finished)
    throw new Error("Hash#digest() has already been called");
}
function Ke(t, e) {
  It(t, void 0, "digestInto() output");
  const s = e.outputLen;
  if (t.length < s)
    throw new Error('"digestInto() output" expected to be of length >=' + s);
}
function Ne(t) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
}
function he(...t) {
  for (let e = 0; e < t.length; e++)
    t[e].fill(0);
}
const Xe = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function Je(t) {
  return t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255;
}
function Qe(t) {
  for (let e = 0; e < t.length; e++)
    t[e] = Je(t[e]);
  return t;
}
const Jt = Xe ? (t) => t : Qe;
function _s(...t) {
  let e = 0;
  for (let i = 0; i < t.length; i++) {
    const o = t[i];
    It(o), e += o.length;
  }
  const s = new Uint8Array(e);
  for (let i = 0, o = 0; i < t.length; i++) {
    const r = t[i];
    s.set(r, o), o += r.length;
  }
  return s;
}
function Ye(t, e = {}) {
  const s = (o, r) => t(r).update(o).digest(), i = t(void 0);
  return s.outputLen = i.outputLen, s.blockLen = i.blockLen, s.create = (o) => t(o), Object.assign(s, e), Object.freeze(s);
}
function ws(t = 32) {
  const e = typeof globalThis == "object" ? globalThis.crypto : null;
  if (typeof e?.getRandomValues != "function")
    throw new Error("crypto.getRandomValues must be defined");
  return e.getRandomValues(new Uint8Array(t));
}
const ae = (t) => ({
  oid: Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2, t])
}), _t = /* @__PURE__ */ BigInt(2 ** 32 - 1), Qt = /* @__PURE__ */ BigInt(32);
function Ze(t, e = !1) {
  return e ? { h: Number(t & _t), l: Number(t >> Qt & _t) } : { h: Number(t >> Qt & _t) | 0, l: Number(t & _t) | 0 };
}
function ze(t, e = !1) {
  const s = t.length;
  let i = new Uint32Array(s), o = new Uint32Array(s);
  for (let r = 0; r < s; r++) {
    const { h: n, l: h } = Ze(t[r], e);
    [i[r], o[r]] = [n, h];
  }
  return [i, o];
}
const $e = (t, e, s) => t << s | e >>> 32 - s, ts = (t, e, s) => e << s | t >>> 32 - s, es = (t, e, s) => e << s - 32 | t >>> 64 - s, ss = (t, e, s) => t << s - 32 | e >>> 64 - s, ns = BigInt(0), bt = BigInt(1), rs = BigInt(2), is = BigInt(7), os = BigInt(256), cs = BigInt(113), fe = [], de = [], ue = [];
for (let t = 0, e = bt, s = 1, i = 0; t < 24; t++) {
  [s, i] = [i, (2 * s + 3 * i) % 5], fe.push(2 * (5 * i + s)), de.push((t + 1) * (t + 2) / 2 % 64);
  let o = ns;
  for (let r = 0; r < 7; r++)
    e = (e << bt ^ (e >> is) * cs) % os, e & rs && (o ^= bt << (bt << BigInt(r)) - bt);
  ue.push(o);
}
const le = ze(ue, !0), hs = le[0], as = le[1], Yt = (t, e, s) => s > 32 ? es(t, e, s) : $e(t, e, s), Zt = (t, e, s) => s > 32 ? ss(t, e, s) : ts(t, e, s);
function fs(t, e = 24) {
  const s = new Uint32Array(10);
  for (let i = 24 - e; i < 24; i++) {
    for (let n = 0; n < 10; n++)
      s[n] = t[n] ^ t[n + 10] ^ t[n + 20] ^ t[n + 30] ^ t[n + 40];
    for (let n = 0; n < 10; n += 2) {
      const h = (n + 8) % 10, b = (n + 2) % 10, x = s[b], H = s[b + 1], u = Yt(x, H, 1) ^ s[h], A = Zt(x, H, 1) ^ s[h + 1];
      for (let m = 0; m < 50; m += 10)
        t[n + m] ^= u, t[n + m + 1] ^= A;
    }
    let o = t[2], r = t[3];
    for (let n = 0; n < 24; n++) {
      const h = de[n], b = Yt(o, r, h), x = Zt(o, r, h), H = fe[n];
      o = t[H], r = t[H + 1], t[H] = b, t[H + 1] = x;
    }
    for (let n = 0; n < 50; n += 10) {
      for (let h = 0; h < 10; h++)
        s[h] = t[n + h];
      for (let h = 0; h < 10; h++)
        t[n + h] ^= ~s[(h + 2) % 10] & s[(h + 4) % 10];
    }
    t[0] ^= hs[i], t[1] ^= as[i];
  }
  he(s);
}
class Et {
  state;
  pos = 0;
  posOut = 0;
  finished = !1;
  state32;
  destroyed = !1;
  blockLen;
  suffix;
  outputLen;
  enableXOF = !1;
  rounds;
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(e, s, i, o = !1, r = 24) {
    if (this.blockLen = e, this.suffix = s, this.outputLen = i, this.enableXOF = o, this.rounds = r, Nt(i, "outputLen"), !(0 < e && e < 200))
      throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200), this.state32 = Ne(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    Jt(this.state32), fs(this.state32, this.rounds), Jt(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    Xt(this), It(e);
    const { blockLen: s, state: i } = this, o = e.length;
    for (let r = 0; r < o; ) {
      const n = Math.min(s - this.pos, o - r);
      for (let h = 0; h < n; h++)
        i[this.pos++] ^= e[r++];
      this.pos === s && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: e, suffix: s, pos: i, blockLen: o } = this;
    e[i] ^= s, (s & 128) !== 0 && i === o - 1 && this.keccak(), e[o - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    Xt(this, !1), It(e), this.finish();
    const s = this.state, { blockLen: i } = this;
    for (let o = 0, r = e.length; o < r; ) {
      this.posOut >= i && this.keccak();
      const n = Math.min(i - this.posOut, r - o);
      e.set(s.subarray(this.posOut, this.posOut + n), o), this.posOut += n, o += n;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return Nt(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (Ke(e, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, he(this.state);
  }
  _cloneInto(e) {
    const { blockLen: s, suffix: i, outputLen: o, rounds: r, enableXOF: n } = this;
    return e ||= new Et(s, i, o, n, r), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = r, e.suffix = i, e.outputLen = o, e.enableXOF = n, e.destroyed = this.destroyed, e;
  }
}
const be = (t, e, s, i = {}) => Ye((o = {}) => new Et(e, t, o.dkLen === void 0 ? s : o.dkLen, !0), i), Ss = /* @__PURE__ */ be(31, 168, 16, /* @__PURE__ */ ae(11)), Is = /* @__PURE__ */ be(31, 136, 32, /* @__PURE__ */ ae(12));
class xe extends se {
  constructor(e, s) {
    super(), this.finished = !1, this.destroyed = !1, $t(e);
    const i = Ut(s);
    if (this.iHash = e.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const o = this.blockLen, r = new Uint8Array(o);
    r.set(i.length > o ? e.create().update(i).digest() : i);
    for (let n = 0; n < r.length; n++)
      r[n] ^= 54;
    this.iHash.update(r), this.oHash = e.create();
    for (let n = 0; n < r.length; n++)
      r[n] ^= 106;
    this.oHash.update(r), ct(r);
  }
  update(e) {
    return St(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    St(this), ht(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: s, iHash: i, finished: o, destroyed: r, blockLen: n, outputLen: h } = this;
    return e = e, e.finished = o, e.destroyed = r, e.blockLen = n, e.outputLen = h, e.oHash = s._cloneInto(e.oHash), e.iHash = i._cloneInto(e.iHash), e;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const He = (t, e, s) => new xe(t, e).update(s).digest();
He.create = (t, e) => new xe(t, e);
function ds(t, e, s, i) {
  $t(t);
  const o = _e({ dkLen: 32, asyncTick: 10 }, i), { c: r, dkLen: n, asyncTick: h } = o;
  if (Ht(r), Ht(n), Ht(h), r < 1)
    throw new Error("iterations (c) should be >= 1");
  const b = Ct(e), x = Ct(s), H = new Uint8Array(n), u = He.create(t, b), A = u._cloneInto().update(x);
  return { c: r, dkLen: n, asyncTick: h, DK: H, PRF: u, PRFSalt: A };
}
function us(t, e, s, i, o) {
  return t.destroy(), e.destroy(), i && i.destroy(), ct(o), s;
}
function Ls(t, e, s, i) {
  const { c: o, dkLen: r, DK: n, PRF: h, PRFSalt: b } = ds(t, e, s, i);
  let x;
  const H = new Uint8Array(4), u = wt(H), A = new Uint8Array(h.outputLen);
  for (let m = 1, w = 0; w < r; m++, w += h.outputLen) {
    const I = n.subarray(w, w + h.outputLen);
    u.setInt32(0, m, !1), (x = b._cloneInto(x)).update(H).digestInto(A), I.set(A.subarray(0, I.length));
    for (let C = 1; C < o; C++) {
      h._cloneInto(x).update(A).digestInto(A);
      for (let R = 0; R < I.length; R++)
        I[R] ^= A[R];
    }
  }
  return us(h, b, n, x, A);
}
const Bs = Re;
var xt = {}, zt;
function ms() {
  if (zt) return xt;
  zt = 1, Object.defineProperty(xt, "__esModule", { value: !0 }), xt.pbkdf2 = o, xt.pbkdf2Async = r;
  const t = /* @__PURE__ */ Pe(), e = /* @__PURE__ */ pt();
  function s(n, h, b, x) {
    (0, e.ahash)(n);
    const H = (0, e.checkOpts)({ dkLen: 32, asyncTick: 10 }, x), { c: u, dkLen: A, asyncTick: m } = H;
    if ((0, e.anumber)(u), (0, e.anumber)(A), (0, e.anumber)(m), u < 1)
      throw new Error("iterations (c) should be >= 1");
    const w = (0, e.kdfInputToBytes)(h), I = (0, e.kdfInputToBytes)(b), C = new Uint8Array(A), R = t.hmac.create(n, w), M = R._cloneInto().update(I);
    return { c: u, dkLen: A, asyncTick: m, DK: C, PRF: R, PRFSalt: M };
  }
  function i(n, h, b, x, H) {
    return n.destroy(), h.destroy(), x && x.destroy(), (0, e.clean)(H), b;
  }
  function o(n, h, b, x) {
    const { c: H, dkLen: u, DK: A, PRF: m, PRFSalt: w } = s(n, h, b, x);
    let I;
    const C = new Uint8Array(4), R = (0, e.createView)(C), M = new Uint8Array(m.outputLen);
    for (let y = 1, O = 0; O < u; y++, O += m.outputLen) {
      const L = A.subarray(O, O + m.outputLen);
      R.setInt32(0, y, !1), (I = w._cloneInto(I)).update(C).digestInto(M), L.set(M.subarray(0, L.length));
      for (let E = 1; E < H; E++) {
        m._cloneInto(I).update(M).digestInto(M);
        for (let D = 0; D < L.length; D++)
          L[D] ^= M[D];
      }
    }
    return i(m, w, A, I, M);
  }
  async function r(n, h, b, x) {
    const { c: H, dkLen: u, asyncTick: A, DK: m, PRF: w, PRFSalt: I } = s(n, h, b, x);
    let C;
    const R = new Uint8Array(4), M = (0, e.createView)(R), y = new Uint8Array(w.outputLen);
    for (let O = 1, L = 0; L < u; O++, L += w.outputLen) {
      const E = m.subarray(L, L + w.outputLen);
      M.setInt32(0, O, !1), (C = I._cloneInto(C)).update(R).digestInto(y), E.set(y.subarray(0, E.length)), await (0, e.asyncLoop)(H - 1, A, () => {
        w._cloneInto(C).update(y).digestInto(y);
        for (let D = 0; D < E.length; D++)
          E[D] ^= y[D];
      });
    }
    return i(w, I, m, C, y);
  }
  return xt;
}
export {
  ee as A,
  Pe as a,
  ce as b,
  ls as c,
  ht as d,
  xs as e,
  Ht as f,
  $t as g,
  bs as h,
  Ae as i,
  Hs as j,
  He as k,
  ps as l,
  As as m,
  ys as n,
  gs as o,
  It as p,
  ws as q,
  pt as r,
  ve as s,
  _s as t,
  qe as u,
  Ss as v,
  Is as w,
  Bs as x,
  Ls as y,
  ms as z
};
