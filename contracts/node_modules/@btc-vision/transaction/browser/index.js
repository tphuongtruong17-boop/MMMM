import { B as a, f as Vt, g as Ie, h as P, j as G, s as di, k as Qt, a as T, L as ve, d as Lt, l as Kt, m as pt, c as fi, e as pi, b as gi, n as Si } from "./vendors.js";
import { i as ot, b as I, p as wi, a as lt, c as jt, t as O, d as rt, e as it, f as L, g as ke, h as Zt, j as gt, k as Te, l as yi, o as g, m as R, n as Ut, q as Yt, r as Le, s as mi, u as Y, v as dt, w as bi, x as Ii, y as Ue, z as At, A as zt, B as _e, C as Ti, D as Ke, P as v, E as Pi, F as Pe, G as Ei, H as Ee, I as Ai, J as Oi, K as Bi, L as xi, M as F, T as Jt, N as vi } from "./btc-vision-bitcoin.js";
import { s as ki, m as Li, f as Ui } from "./noble-curves.js";
import { A as _i, s as ne, j as Ki, e as Ci } from "./noble-hashes.js";
const Di = "1.7.31";
function Fi(n, t = {}) {
  return a.from(Vt.gzip(n, { level: t.level || 6 }));
}
function Ri(n) {
  return a.from(Vt.ungzip(n));
}
function Wi(n, t = {}) {
  return a.from(Vt.deflate(n, { level: t.level || 6 }));
}
function Mi(n) {
  return a.from(Vt.inflate(n));
}
const Ae = {
  gzipSync: Fi,
  gunzipSync: Ri,
  deflateSync: Wi,
  inflateSync: Mi
};
class N {
  static {
    this.zlibOptions = {
      level: 9,
      maxOutputLength: 1024 * 1024 * 16
      // 16mb, limit it to 16mb.
    };
  }
  /**
   * Compresses the data using gzip.
   * @param {Uint8Array | Buffer} data The data to compress.
   * @returns {Buffer} The compressed data.
   */
  static compress(t) {
    return Ae.gzipSync(t, N.zlibOptions);
  }
  /**
   * Decompresses the data using gunzip.
   * @param {Uint8Array | Buffer} data The data to decompress.
   * @returns {Buffer} The decompressed data.
   */
  static decompress(t) {
    return Ae.gunzipSync(t, N.zlibOptions);
  }
}
ot(G);
const Ce = typeof Ie == "function" ? Ie : P.BIP32Factory;
if (!Ce)
  throw new Error("Failed to load BIP32 library");
const at = ki.Point, Ni = at.Fn.ORDER, Hi = _i("TapTweak"), Oe = ne(Hi);
function Vi(n) {
  return ne(Ci(Oe, Oe, n));
}
class A {
  static {
    this.BIP32 = Ce(G);
  }
  static {
    this.ECPair = di.ECPairFactory(G);
  }
  static {
    at.BASE.precompute(8);
  }
  /**
   * Generate a keypair from a WIF
   * @param {string} wif - The WIF to use
   * @param {Network} network - The network to use
   * @returns {ECPairInterface} - The generated keypair
   */
  static fromWIF(t, e = I) {
    return this.ECPair.fromWIF(t, e);
  }
  /**
   * Generate a keypair from a private key
   * @param {Buffer} privateKey - The private key to use
   * @param {Network} network - The network to use
   * @returns {ECPairInterface} - The generated keypair
   */
  static fromPrivateKey(t, e = I) {
    return this.ECPair.fromPrivateKey(
      a.isBuffer(t) ? t : a.from(t),
      { network: e }
    );
  }
  /**
   * Generate a keypair from a public key
   * @param {Buffer | Uint8Array} publicKey - The public key to use
   * @param {Network} network - The network to use
   * @returns {ECPairInterface} - The generated keypair
   */
  static fromPublicKey(t, e = I) {
    const i = a.isBuffer(t) ? t : a.from(t);
    return this.ECPair.fromPublicKey(i, { network: e });
  }
  /**
   * Generate a multi-sig address
   * @param {Buffer[]} pubKeys - The public keys to use
   * @param {number} minimumSignatureRequired - The minimum number of signatures required
   * @param {Network} network - The network to use
   * @returns {string} - The generated address
   * @throws {Error} - If the address cannot be generated
   */
  static generateMultiSigAddress(t, e, i = I) {
    const r = this.verifyPubKeys(t, i);
    if (r.length !== t.length) throw new Error("Contains invalid public keys");
    const s = wi({
      m: e,
      pubkeys: r,
      network: i
    }), c = lt({ redeem: s, network: i }).address;
    if (!c)
      throw new Error("Failed to generate address");
    return c;
  }
  /**
   * Verify public keys and return the public keys
   * @param {Buffer[]} pubKeys - The public keys to verify
   * @param {Network} network - The network to use
   * @returns {Buffer[]} - The verified public keys
   * @throws {Error} - If the key cannot be regenerated
   */
  static verifyPubKeys(t, e = I) {
    return t.map((i) => {
      const r = A.fromPublicKey(i, e);
      if (!r)
        throw new Error("Failed to regenerate key");
      return a.from(r.publicKey);
    });
  }
  /**
   * Get a P2WPKH address from a keypair
   * @param {ECPairInterface} keyPair - The keypair to get the address for
   * @param {Network} network - The network to use
   * @returns {string} - The address
   */
  static getP2WPKHAddress(t, e = I) {
    const i = jt({ pubkey: a.from(t.publicKey), network: e });
    if (!i.address)
      throw new Error("Failed to generate wallet");
    return i.address;
  }
  /**
   * Get the address of a tweaked public key
   * @param {string} tweakedPubKeyHex - The tweaked public key hex string
   * @param {Network} network - The network to use
   * @returns {string} - The address
   * @throws {Error} - If the address cannot be generated
   */
  static tweakedPubKeyToAddress(t, e) {
    t.startsWith("0x") && (t = t.slice(2));
    let i = a.from(t, "hex");
    return i.length !== 32 && (i = O(i)), A.tweakedPubKeyBufferToAddress(i, e);
  }
  /**
   * Get the address of a tweaked public key
   * @param {Buffer | Uint8Array} tweakedPubKeyBuffer - The tweaked public key buffer
   * @param {Network} network - The network to use
   * @returns {string} - The address
   * @throws {Error} - If the address cannot be generated
   */
  static tweakedPubKeyBufferToAddress(t, e) {
    const { address: i } = rt({
      pubkey: a.isBuffer(t) ? t : a.from(t),
      network: e
    });
    if (!i)
      throw new Error("Failed to generate Taproot address");
    return i;
  }
  /**
   * Generate a P2OP address
   * @param bytes - The bytes to use for the P2OP address
   * @param network - The network to use
   * @param deploymentVersion - The deployment version (default is 0)
   * @returns {string} - The generated P2OP address
   */
  static p2op(t, e = I, i = 0) {
    const r = a.concat([
      a.from([i]),
      it.crypto.hash160(a.from(t))
    ]);
    if (r.length < 2 || r.length > 40)
      throw new Error("Witness program must be 2-40 bytes.");
    const s = L([g.OP_16, r]);
    return ke(s, e);
  }
  /**
   * Get the address of a xOnly tweaked public key
   * @param {string} tweakedPubKeyHex - The xOnly tweaked public key hex string
   * @param {Network} network - The network to use
   * @returns {string} - The address
   * @throws {Error} - If the address cannot be generated
   */
  static xOnlyTweakedPubKeyToAddress(t, e) {
    t.startsWith("0x") && (t = t.slice(2));
    const i = a.from(t, "hex"), { address: r } = rt({
      pubkey: i,
      network: e
    });
    if (!r)
      throw new Error("Failed to generate Taproot address");
    return r;
  }
  /**
   * Tweak a public key
   * @param {Buffer | Uint8Array | string} pub - The public key to tweak
   * @returns {Buffer} - The tweaked public key hex string
   * @throws {Error} - If the public key cannot be tweaked
   */
  static tweakPublicKey(t) {
    typeof t == "string" && t.startsWith("0x") && (t = t.slice(2));
    const e = at.fromHex(t), i = (e.y & 1n) === 0n ? e : e.negate(), r = a.from(i.toBytes(!0).subarray(1)), s = Vi(r), o = Li(Ui(s), Ni), c = i.add(at.BASE.multiply(o));
    return a.from(c.toBytes(!0));
  }
  /**
   * Tweak a batch of public keys
   * @param {readonly Uint8Array[]} pubkeys - The public keys to tweak
   * @param {bigint} tweakScalar - The scalar to use for tweaking
   * @returns {Uint8Array[]} - The tweaked public keys
   */
  static tweakBatchSharedT(t, e) {
    const i = at.BASE.multiply(e);
    return t.map((r) => {
      const s = at.fromHex(r);
      return (s.y % 2n === 0n ? s : s.negate()).add(i).toBytes(!0);
    });
  }
  /**
   * Generate a random wallet with both classical and quantum keys
   *
   * @param network - The network to use
   * @param securityLevel - The ML-DSA security level for quantum keys (default: LEVEL2/44)
   * @returns An object containing both classical and quantum key information
   */
  static generateWallet(t = I, e = P.MLDSASecurityLevel.LEVEL2) {
    const i = this.ECPair.makeRandom({
      network: t
    }), r = this.getP2WPKHAddress(i, t);
    if (!r)
      throw new Error("Failed to generate wallet");
    const s = this.generateQuantumKeyPair(e, t);
    return {
      address: r,
      privateKey: i.toWIF(),
      publicKey: a.from(i.publicKey).toString("hex"),
      quantumPrivateKey: a.from(s.privateKey).toString("hex"),
      quantumPublicKey: a.from(s.publicKey).toString("hex")
    };
  }
  /**
   * Generate a random quantum ML-DSA keypair
   *
   * This creates a standalone quantum-resistant keypair without using BIP32 derivation.
   * The keys are generated using cryptographically secure random bytes.
   *
   * @param securityLevel - The ML-DSA security level (default: LEVEL2/44)
   * @param network - The Bitcoin network (default: bitcoin mainnet)
   * @returns A random ML-DSA keypair
   */
  static generateQuantumKeyPair(t = P.MLDSASecurityLevel.LEVEL2, e = I) {
    const i = Ki(64), r = P.QuantumBIP32Factory.fromSeed(
      a.from(i),
      e,
      t
    );
    if (!r.privateKey || !r.publicKey)
      throw new Error("Failed to generate quantum keypair");
    return {
      privateKey: a.from(r.privateKey),
      publicKey: a.from(r.publicKey)
    };
  }
  /**
   * Verify that a contract address is a valid p2tr address
   * @param {string} contractAddress - The contract address to verify
   * @param {Network} network - The network to use
   * @returns {boolean} - Whether the address is valid
   */
  static verifyContractAddress(t, e = I) {
    return !!Zt(t, e);
  }
  /**
   * Get the legacy segwit address from a keypair
   * @param {ECPairInterface} keyPair - The keypair to get the address for
   * @param {Network} network - The network to use
   * @returns {string} - The legacy address
   */
  static getLegacySegwitAddress(t, e = I) {
    const i = gt({
      redeem: jt({ pubkey: a.from(t.publicKey), network: e }),
      network: e
    });
    if (!i.address)
      throw new Error("Failed to generate wallet");
    return i.address;
  }
  /**
   * Get the legacy address from a keypair
   * @param {ECPairInterface} keyPair - The keypair to get the address for
   * @param {Network} network - The network to use
   * @returns {string} - The legacy address
   */
  static getLegacyAddress(t, e = I) {
    const i = Te({ pubkey: a.from(t.publicKey), network: e });
    if (!i.address)
      throw new Error("Failed to generate wallet");
    return i.address;
  }
  /**
   * Get the legacy address from a keypair
   * @param publicKey
   * @param {Network} network - The network to use
   * @returns {string} - The legacy address
   */
  static getP2PKH(t, e = I) {
    const i = Te({ pubkey: a.from(t), network: e });
    if (!i.address)
      throw new Error("Failed to generate wallet");
    return i.address;
  }
  /**
   * Get the legacy address from a keypair
   * @param {ECPairInterface} keyPair - The keypair to get the address for
   * @param {Network} network - The network to use
   * @returns {string} - The legacy address
   */
  static getP2PKAddress(t, e = I) {
    const i = yi({ pubkey: a.from(t.publicKey), network: e });
    if (!i.output)
      throw new Error("Failed to generate wallet");
    return "0x" + i.output.toString("hex");
  }
  /**
   * Generate a random keypair
   * @param {Network} network - The network to use
   * @returns {ECPairInterface} - The generated keypair
   */
  static generateRandomKeyPair(t = I) {
    return this.ECPair.makeRandom({
      network: t
    });
  }
  /**
   * Generate a BIP32 keypair from a seed
   * @param {Buffer} seed - The seed to generate the keypair from
   * @param {Network} network - The network to use
   * @returns {BIP32Interface} - The generated keypair
   */
  static fromSeed(t, e = I) {
    return this.BIP32.fromSeed(t, e);
  }
  /**
   * Get taproot address from keypair
   * @param {ECPairInterface} keyPair - The keypair to get the taproot address for
   * @param {Network} network - The network to use
   * @returns {string} - The taproot address
   */
  static getTaprootAddress(t, e = I) {
    const { address: i } = rt({
      internalPubkey: O(a.from(t.publicKey)),
      network: e
    });
    if (!i)
      throw new Error("Failed to generate sender address for transaction");
    return i;
  }
  /**
   * Get taproot address from address
   * @param {string} inAddr - The address to convert to taproot
   * @param {Network} network - The network to use
   * @returns {string} - The taproot address
   */
  static getTaprootAddressFromAddress(t, e = I) {
    const { address: i } = rt({
      address: t,
      network: e
    });
    if (!i)
      throw new Error("Failed to generate sender address for transaction");
    return i;
  }
  /**
   * Get a keypair from a given seed.
   * @param {Buffer} seed - The seed to generate the key pair from
   * @param {Network} network - The network to use
   * @returns {ECPairInterface} - The generated key pair
   */
  static fromSeedKeyPair(t, e = I) {
    const r = this.BIP32.fromSeed(t, e).privateKey;
    if (!r) throw new Error("Failed to generate key pair");
    return this.ECPair.fromPrivateKey(a.from(r), { network: e });
  }
}
const C = 32, zi = 4, It = 32, wt = 16, Ct = 8, ht = 4, Tt = 2, Dt = 1, qi = 32, yt = 16, $i = 8, Xi = 4, Yi = 2, Gi = 1, Qi = 1;
class X {
  static {
    this.EXPECTED_BUFFER_LENGTH = 32;
  }
  static bufferToUint8Array(t) {
    if (a.isBuffer(t)) {
      const e = t.byteLength, i = new ArrayBuffer(e), r = new Uint8Array(i);
      for (let s = 0; s < e; ++s)
        r[s] = t[s];
      return r;
    }
    return t;
  }
  static uint8ArrayToHex(t) {
    return a.from(t.buffer, 0, t.byteLength).toString("hex");
  }
  static hexToUint8Array(t) {
    t.startsWith("0x") && (t = t.substring(2)), t.length % 2 !== 0 && (t = "0" + t);
    const e = t.length / 2, i = new Uint8Array(e);
    for (let r = 0; r < e; r++)
      i[r] = parseInt(t.substring(r * 2, r * 2 + 2), 16);
    return i;
  }
  static pointerToUint8Array(t) {
    const e = t.toString(16).padStart(64, "0");
    return X.hexToUint8Array(e);
  }
  static uint8ArrayToPointer(t) {
    const e = X.uint8ArrayToHex(t);
    return BigInt("0x" + e);
  }
  static valueToUint8Array(t, e = It) {
    const i = t.toString(16).padStart(e * 2, "0");
    return X.hexToUint8Array(i);
  }
  static uint8ArrayToValue(t) {
    const e = X.uint8ArrayToHex(t);
    return BigInt(e ? "0x" + e : 0);
  }
}
const ji = /^[0-9a-fA-F]+$/;
class K {
  /**
   * Converts satoshi to BTC
   * @param {number} btc - The amount in BTC
   * @returns {bigint} The amount in satoshi
   */
  static btcToSatoshi(t) {
    return BigInt(t * 1e8);
  }
  /**
   * Generates random bytes.
   * @public
   * @returns {Buffer} The random bytes
   */
  static rndBytes() {
    const t = K.getSafeRandomValues(64);
    return a.from(t);
  }
  static getSafeRandomValues(t) {
    if (typeof globalThis.window < "u" && globalThis.window.crypto && typeof globalThis.window.crypto.getRandomValues == "function") {
      const e = new Uint8Array(t);
      return window.crypto.getRandomValues(e), a.from(e);
    } else if (globalThis.crypto && typeof globalThis.crypto.getRandomValues == "function") {
      const e = new Uint8Array(t);
      return globalThis.crypto.getRandomValues(e), a.from(e);
    } else
      throw console.log(
        "No secure random number generator available. Please upgrade your environment.",
        globalThis.window.crypto,
        globalThis.crypto
      ), new Error(
        "No secure random number generator available. Please upgrade your environment."
      );
  }
  static isValidHex(t) {
    return ji.test(t);
  }
  /**
   * Hashes the given data
   * @param {Buffer} data - The data to hash
   * @returns {string} The hashed data
   */
  static opnetHash(t) {
    const e = Qt("sha512");
    e.update(t);
    const i = e.digest();
    return `0x${a.from(i).toString("hex")}`;
  }
}
class z {
  /**
   * Check if a UTXO is a P2WDA output by examining its script structure
   *
   * @param utxo The UTXO to check
   * @returns true if this is a P2WDA UTXO
   */
  static isP2WDAUTXO(t) {
    if (!t.witnessScript)
      return !1;
    const e = T.isBuffer(t.witnessScript) ? t.witnessScript : T.from(t.witnessScript, "hex");
    return this.isP2WDAWitnessScript(e);
  }
  /**
   * Check if a witness script follows the P2WDA pattern
   *
   * P2WDA witness script pattern: (OP_2DROP * 5) <pubkey> OP_CHECKSIG
   * This allows for up to 10 witness data fields (5 * 2 = 10)
   *
   * @param witnessScript The witness script to check
   * @returns true if this is a P2WDA witness script
   */
  static isP2WDAWitnessScript(t) {
    try {
      const e = R(t);
      if (!e || e.length !== 7)
        return !1;
      for (let i = 0; i < 5; i++)
        if (e[i] !== g.OP_2DROP)
          return !1;
      return T.isBuffer(e[5]) && e[5].length === 33 && // Compressed public key
      e[6] === g.OP_CHECKSIG;
    } catch {
      return !1;
    }
  }
  /**
   * Generate a P2WDA address from a public key
   *
   * @param publicKey The public key to use (33 bytes compressed)
   * @param network The Bitcoin network
   * @returns The P2WDA address and related payment information
   */
  static generateP2WDAAddress(t, e) {
    if (t.length !== 33)
      throw new Error("Public key must be 33 bytes (compressed)");
    const i = L([
      g.OP_2DROP,
      g.OP_2DROP,
      g.OP_2DROP,
      g.OP_2DROP,
      g.OP_2DROP,
      t,
      g.OP_CHECKSIG
    ]), r = lt({
      redeem: { output: i },
      network: e
    });
    if (!r.address || !r.output)
      throw new Error("Failed to generate P2WDA address");
    return {
      address: r.address,
      witnessScript: i,
      scriptPubKey: r.output
    };
  }
  /**
   * Extract the public key from a P2WDA witness script
   *
   * @param witnessScript The P2WDA witness script
   * @returns The public key or null if not a valid P2WDA script
   */
  static extractPublicKeyFromP2WDA(t) {
    try {
      const e = R(t);
      if (!e || e.length !== 7)
        return null;
      for (let i = 0; i < 5; i++)
        if (e[i] !== g.OP_2DROP)
          return null;
      return T.isBuffer(e[5]) && e[5].length === 33 && e[6] === g.OP_CHECKSIG ? e[5] : null;
    } catch {
      return null;
    }
  }
  /**
   * Create witness data for a simple P2WDA spend (no operation data)
   *
   * For simple transfers, P2WDA requires 10 dummy witness items (zeros) before the signature
   *
   * @param transactionSignature The transaction signature
   * @param witnessScript The P2WDA witness script
   * @returns The witness stack for a simple P2WDA spend
   */
  static createSimpleP2WDAWitness(t, e) {
    const i = [t];
    for (let r = 0; r < 10; r++)
      i.push(T.alloc(0));
    return i.push(e), i;
  }
  /**
   * Validate P2WDA operation data signature
   *
   * @param publicKey The public key from the witness script
   * @param dataSignature The Schnorr signature
   * @param operationData The operation data that was signed
   * @returns true if the signature is valid
   */
  static validateP2WDASignature(t, e, i) {
    return e.length === 64;
  }
  /**
   * Calculate the witness size for P2WDA transaction estimation
   *
   * @param dataSize The size of the operation data (0 for simple transfers)
   * @returns The estimated witness size in bytes
   */
  static estimateP2WDAWitnessSize(t = 0) {
    return 72 + t + 39 + 12;
  }
  /**
   * Check if a scriptPubKey is a P2WSH that could be P2WDA
   *
   * @param scriptPubKey The script public key to check
   * @returns true if this could be a P2WDA output
   */
  static couldBeP2WDA(t) {
    return t.length === 34 && t[0] === 0 && t[1] === 32;
  }
}
ot(G);
var J = /* @__PURE__ */ ((n) => (n.P2PKH = "P2PKH", n.P2OP = "P2OP", n.P2SH_OR_P2SH_P2WPKH = "P2SH_OR_P2SH-P2WPKH", n.P2PK = "P2PK", n.P2TR = "P2TR", n.P2WPKH = "P2WPKH", n.P2WSH = "P2WSH", n.P2WDA = "P2WDA", n))(J || {});
class H {
  /**
   * Checks if the given address is a valid P2PKH address.
   * @param inAddress - The address to check.
   * @param network - The network to validate against.
   * @returns - True if the address is a valid P2PKH address, false otherwise.
   * @remarks This method is useful for validating legacy addresses (P2PKH) without
   */
  static isValidP2TRAddress(t, e) {
    if (!t || t.length < 50) return !1;
    let i = !1;
    try {
      Zt(t, e), i = Ut(t).version === 1;
    } catch {
    }
    return i;
  }
  /**
   * Checks if the given address is a valid P2PKH address.
   * @param inAddress - The address to check.
   * @param network - The network to validate against.
   * @returns - True if the address is a valid P2PKH address, false otherwise.
   * @remarks This method is useful for validating legacy addresses (P2PKH) without
   */
  static isP2WPKHAddress(t, e) {
    if (!t || t.length < 20 || t.length > 50) return !1;
    let i = !1;
    try {
      const r = Ut(t);
      Zt(t, e), i = r.version === 0 && r.data.length === 20;
    } catch {
    }
    return i;
  }
  /**
   * Check if a given witness script is a P2WDA witness script
   *
   * P2WDA witness scripts have a specific pattern:
   * (OP_2DROP * 5) <pubkey> OP_CHECKSIG
   *
   * This pattern allows for 10 witness data fields (5 * 2 = 10),
   * which can be used to embed authenticated operation data.
   *
   * @param witnessScript The witness script to check
   * @returns true if this is a valid P2WDA witness script
   */
  static isP2WDAWitnessScript(t) {
    return z.isP2WDAWitnessScript(t);
  }
  /**
   * Checks if the given address is a valid P2PKH or P2SH address.
   * @param addy - The address to check.
   * @param network - The network to validate against.
   * @returns - True if the address is a valid P2PKH or P2SH address, false otherwise.
   * @remarks This method is useful for validating legacy addresses (P2PKH or P2SH) without
   */
  static isP2PKHOrP2SH(t, e) {
    try {
      const i = Yt(t);
      return i.version === e.pubKeyHash ? !0 : i.version === e.scriptHash;
    } catch {
      return !1;
    }
  }
  /**
   * Checks if the input is a valid hexadecimal public key (P2PK).
   * Public keys can be compressed (66 characters) or uncompressed (130 characters).
   *
   * @param input - The input string to check.
   * @param network - The Bitcoin network to validate against (mainnet, testnet, etc.).
   * @returns - True if the input is a valid public key, false otherwise.
   */
  static isValidPublicKey(t, e) {
    try {
      if (t.startsWith("0x") && (t = t.slice(2)), !K.isValidHex(t))
        return !1;
      if (t.length === 64)
        return !0;
      const i = a.from(t, "hex");
      if (t.length === 130 && i[0] === 6 || i[0] === 7)
        return !0;
      if (t.length === 66 || t.length === 130)
        return A.fromPublicKey(i, e), !0;
    } catch {
      return !1;
    }
    return !1;
  }
  /**
   * Checks if the input is a valid ML-DSA public key.
   * ML-DSA public keys have specific lengths depending on the security level:
   * - ML-DSA-44 (Level 2): 1312 bytes (2624 hex characters)
   * - ML-DSA-65 (Level 3): 1952 bytes (3904 hex characters)
   * - ML-DSA-87 (Level 5): 2592 bytes (5184 hex characters)
   *
   * @param input - The input string (hex format) or Buffer to check.
   * @returns - The security level if valid, null otherwise.
   */
  static isValidMLDSAPublicKey(t) {
    try {
      let e;
      if (a.isBuffer(t) || t instanceof Uint8Array)
        e = t.length;
      else {
        if (t.startsWith("0x") && (t = t.slice(2)), !K.isValidHex(t))
          return null;
        e = t.length / 2;
      }
      switch (e) {
        case 1312:
          return P.MLDSASecurityLevel.LEVEL2;
        // ML-DSA-44
        case 1952:
          return P.MLDSASecurityLevel.LEVEL3;
        // ML-DSA-65
        case 2592:
          return P.MLDSASecurityLevel.LEVEL5;
        // ML-DSA-87
        default:
          return null;
      }
    } catch {
      return null;
    }
  }
  /**
   * Checks if the given address is a valid P2OP (OPNet) address.
   * P2OP addresses use witness version 16 and are encoded in Bech32m format.
   *
   * @param inAddress - The address to check.
   * @param network - The network to validate against.
   * @returns - True if the address is a valid P2OP address, false otherwise.
   */
  static isValidP2OPAddress(t, e) {
    if (!t || t.length < 20) return !1;
    try {
      const i = Ut(t);
      return i.prefix === e.bech32 || i.prefix === e.bech32Opnet ? i.version === 16 && i.data.length === 21 : !1;
    } catch {
      return !1;
    }
  }
  /**
   * Checks if the address requires a redeem script to spend funds.
   * @param {string} addy - The address to check.
   * @param {Network} network - The network to validate against.
   * @returns {boolean} - True if the address requires a redeem script, false otherwise.
   */
  static requireRedeemScript(t, e) {
    try {
      const i = Yt(t);
      return i.version === e.pubKeyHash ? !1 : i.version === e.scriptHash;
    } catch {
      return !1;
    }
  }
  /**
   * Validates if a given Bitcoin address is of the specified type and network.
   * - P2PKH (Legacy address starting with '1' for mainnet or 'm/n' for testnet)
   * - P2SH (Legacy address starting with '3' for mainnet or '2' for testnet)
   * - P2SH-P2WPKH (Wrapped SegWit)
   * - P2PK (Pay to PubKey, technically treated similarly to P2PKH)
   * - P2WPKH (SegWit address starting with 'bc1q' for mainnet or 'tb1q' for testnet)
   * - P2WSH (SegWit script hash address)
   * - P2TR (Taproot address starting with 'bc1p' for mainnet or 'tb1p' for testnet)
   * - P2OP (OPNet contract address with witness version 16)
   *
   * @param addy - The Bitcoin address to validate.
   * @param network - The Bitcoin network to validate against (mainnet, testnet, etc.).
   * @returns - The type of the valid Bitcoin address, or null if invalid.
   */
  static detectAddressType(t, e) {
    if (H.isValidPublicKey(t, e))
      return "P2PK";
    try {
      const i = Yt(t);
      if (i.version === e.pubKeyHash)
        return "P2PKH";
      if (i.version === e.scriptHash)
        return "P2SH_OR_P2SH-P2WPKH";
    } catch {
    }
    try {
      const i = Ut(t);
      if ((i.prefix === e.bech32Opnet || i.prefix === e.bech32) && i.version === 16 && i.data.length === 21)
        return "P2OP";
      if (i.prefix === e.bech32) {
        if (i.version === 0 && i.data.length === 20)
          return "P2WPKH";
        if (i.version === 0 && i.data.length === 32)
          return "P2WSH";
        if (i.version === 1 && i.data.length === 32)
          return "P2TR";
      }
    } catch {
    }
    return null;
  }
  /**
   * Enhanced detectAddressType that provides hints about P2WDA
   *
   * Note: P2WDA addresses cannot be distinguished from regular P2WSH
   * addresses without the witness script. When a P2WSH address is detected,
   * it could potentially be P2WDA if it has the correct witness script.
   *
   * @param addy The address to analyze
   * @param network The Bitcoin network
   * @param witnessScript Optional witness script for P2WSH addresses
   * @returns The address type, with P2WDA detection if witness script provided
   */
  static detectAddressTypeWithWitnessScript(t, e, i) {
    const r = H.detectAddressType(t, e);
    return r === "P2WSH" && i && H.isP2WDAWitnessScript(i) ? "P2WDA" : r;
  }
  /**
   * Validate a P2WDA address and extract information
   *
   * This method validates that an address is a properly formatted P2WSH
   * address and, if a witness script is provided, verifies it matches
   * the P2WDA pattern and corresponds to the address.
   *
   * @param address The address to validate
   * @param network The Bitcoin network
   * @param witnessScript Optional witness script to verify
   * @returns Validation result with extracted information
   */
  static validateP2WDAAddress(t, e, i) {
    try {
      if (H.detectAddressType(t, e) !== "P2WSH")
        return {
          isValid: !1,
          isPotentiallyP2WDA: !1,
          isDefinitelyP2WDA: !1,
          error: "Not a P2WSH address"
        };
      if (!i)
        return {
          isValid: !0,
          isPotentiallyP2WDA: !0,
          isDefinitelyP2WDA: !1
        };
      if (!H.isP2WDAWitnessScript(i))
        return {
          isValid: !0,
          isPotentiallyP2WDA: !0,
          isDefinitelyP2WDA: !1,
          error: "Witness script does not match P2WDA pattern"
        };
      if (lt({
        redeem: { output: i },
        network: e
      }).address !== t)
        return {
          isValid: !1,
          isPotentiallyP2WDA: !1,
          isDefinitelyP2WDA: !1,
          error: "Witness script does not match address"
        };
      const o = z.extractPublicKeyFromP2WDA(i);
      return o ? {
        isValid: !0,
        isPotentiallyP2WDA: !0,
        isDefinitelyP2WDA: !0,
        publicKey: o
      } : {
        isValid: !1,
        isPotentiallyP2WDA: !1,
        isDefinitelyP2WDA: !1,
        error: "Failed to extract public key from witness script"
      };
    } catch (r) {
      return {
        isValid: !1,
        isPotentiallyP2WDA: !1,
        isDefinitelyP2WDA: !1,
        error: r.message
      };
    }
  }
}
const nt = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn;
class De {
  constructor(t = 1e4) {
    this.maxTries = t;
  }
  /**
   * Main entry point.
   * Given a 32-byte input, ensures we obtain a "real" x on secp256k1.
   * - If the given x is valid, we use it.
   * - Otherwise, we increment x (mod p) until we find one whose (x^3 + 7) is a quadratic residue.
   * Then we return { x, y1, y2 } for that valid point.
   *
   * @param xBytes A 32-byte Uint8Array for the candidate x
   * @param failOnInvalidX (optional) whether to throw if the given x is not a valid curve point, defaults to true
   * @param maxTries (optional) number of increments to attempt, defaults to this.maxTries
   * @returns An object { x: bigint; y1: bigint; y2: bigint } describing a valid curve point
   * @throws If no valid x found within maxTries
   */
  findOrDeriveValidPoint(t, e = !0, i = this.maxTries) {
    if (t.length !== 32)
      throw new Error("xBytes must be exactly 32 bytes.");
    let r = this.bytesToBigInt(t) % nt, s = this.isValidX(r);
    if (e && s === null)
      throw new Error("The given x is not a valid curve point.");
    let o = 0;
    for (; s === null; )
      if (r = (r + 1n) % nt, s = this.isValidX(r), o++, o > i)
        throw new Error(`Could not find a valid X point within ${i} increments.`);
    const c = s, u = (nt - c) % nt;
    return { x: r, y1: c, y2: u };
  }
  /**
   * Given two candidate y values, returns the one with the smaller y-coordinate.
   * @param {bigint} y
   * @param {bigint} y2
   */
  getCanonicalY(t, e) {
    return t < e ? t : e;
  }
  /**
   * Creates a 65-byte "hybrid public key" from the specified x and y.
   * - First byte:
   *   - 0x06 if y is even
   *   - 0x07 if y is odd
   * - Next 32 bytes: x
   * - Last 32 bytes: y
   *
   * @param x X-coordinate as a bigint
   * @param y Y-coordinate as a bigint
   * @returns A Uint8Array of length 65
   */
  getHybridPublicKey(t, e) {
    const i = e % 2n === 0n ? 6 : 7, r = this.bigIntTo32Bytes(t), s = this.bigIntTo32Bytes(e), o = new Uint8Array(65);
    return o[0] = i, o.set(r, 1), o.set(s, 33), o;
  }
  /**
   * Checks if (x^3 + 7) is a quadratic residue mod p.
   * Returns the square root if it is, or null if not.
   */
  isValidX(t) {
    const e = (this.modPow(t, 3n, nt) + 7n) % nt;
    return this.sqrtModP(e, nt);
  }
  /**
   * Computes base^exp (mod m) using exponentiation by squaring.
   */
  modPow(t, e, i) {
    let r = 1n, s = t % i, o = e;
    for (; o > 0; )
      (o & 1n) === 1n && (r = r * s % i), s = s * s % i, o >>= 1n;
    return r;
  }
  /**
   * sqrtModP(a, p):
   *   Attempts to compute the square root of `a` modulo prime `p`.
   *   Returns the root if it exists, or null if `a` is not a quadratic residue.
   *
   * Since p â‰¡ 3 (mod 4), we can do:
   *   sqrt(a) = a^((p+1)/4) mod p
   */
  sqrtModP(t, e) {
    const i = this.modPow(t, e + 1n >> 2n, e);
    return i * i % e !== t % e ? null : i;
  }
  /**
   * Convert a 32-byte Uint8Array (big-endian) to a BigInt.
   */
  bytesToBigInt(t) {
    let e = 0n;
    for (const i of t)
      e = e << 8n | BigInt(i);
    return e;
  }
  /**
   * Convert a BigInt to a 32-byte array (big-endian).
   */
  bigIntTo32Bytes(t) {
    const e = new Uint8Array(32);
    for (let i = 31; i >= 0; i--)
      e[i] = Number(t & 0xffn), t >>= 8n;
    return e;
  }
}
class Zi {
  constructor() {
    this.deriver = new De();
  }
  generateHybridKeyFromHash(t) {
    const e = this.deriver.findOrDeriveValidPoint(this.cloneBuffer(t), !1), i = this.deriver.getCanonicalY(e.y1, e.y2);
    return a.from(this.deriver.getHybridPublicKey(e.x, i));
  }
  cloneBuffer(t) {
    return a.from(t);
  }
}
const te = new Zi();
class M {
  static {
    this.UNSPENDABLE_INTERNAL_KEY = a.from(
      "50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0",
      "hex"
    );
  }
  static {
    this.CSV_BLOCKS = 75;
  }
  /**
   * Generate a P2WSH address with CSV timelock
   * Note: This uses ECDSA, not Schnorr (Schnorr only available in Taproot)
   */
  static generateTimeLockAddress(t, e = I, i = M.CSV_BLOCKS) {
    const r = this.generateTimeLockScript(t, i), s = it.payments.p2wsh({
      redeem: { output: r },
      network: e
    });
    if (!s.address)
      throw new Error("Failed to generate P2WSH address");
    return {
      address: s.address,
      witnessScript: r
    };
  }
  /**
   * Generate a P2TR address with CSV time lock
   * Note: This uses Schnorr signatures
   */
  static generateTimeLockAddressP2TR(t, e = I, i = M.CSV_BLOCKS) {
    if (t.length !== 32)
      throw new Error("Public key must be 32 bytes for Taproot");
    const r = this.generateTimeLockScript(t, i), s = it.payments.p2tr({
      redeem: { output: r },
      network: e,
      internalPubkey: M.UNSPENDABLE_INTERNAL_KEY
    });
    if (!s.address)
      throw new Error("Failed to generate P2TR address");
    return s.address;
  }
  static generateTimeLockScript(t, e = M.CSV_BLOCKS) {
    return L([
      Le.encode(e),
      g.OP_CHECKSEQUENCEVERIFY,
      g.OP_DROP,
      t,
      g.OP_CHECKSIG
    ]);
  }
}
class k extends Uint8Array {
  #t;
  #e;
  #s;
  #i;
  #u;
  #r;
  #n;
  #h;
  #l;
  #o;
  #a;
  #f;
  #p;
  // Lazy loading state - defers expensive EC operations until actually needed
  #d;
  #g = !1;
  // After processing, this is 32-byte tweaked x-only (same as original behavior)
  #c;
  constructor(t, e) {
    if (super(C), !!t) {
      if (e) {
        if (![C, 33, 65].includes(e.length))
          throw new Error(`Invalid public key length ${e.length}`);
        this.#d = new Uint8Array(e.length), this.#d.set(e);
      }
      this.setMldsaKey(t);
    }
  }
  get mldsaLevel() {
    return this.#p;
  }
  set mldsaLevel(t) {
    this.#p = t;
  }
  get originalMDLSAPublicKey() {
    return this.#f;
  }
  set originalMDLSAPublicKey(t) {
    this.#f = new Uint8Array(t);
  }
  /**
   * If available, this will return the original public key associated with the address.
   * @returns {Uint8Array} The original public key used to create the address.
   */
  get originalPublicKey() {
    return this.ensureLegacyProcessed(), this.#i;
  }
  get mldsaPublicKey() {
    return this.#l;
  }
  /**
   * Get the legacy public key (32-byte tweaked x-only after processing).
   * Triggers lazy processing if not yet done.
   */
  get legacyPublicKey() {
    return this.ensureLegacyProcessed(), this.#c;
  }
  /**
   * Get the key pair for the address
   * @description This is only for internal use. Please use address.tweakedBytes instead.
   */
  get keyPair() {
    if (this.ensureLegacyProcessed(), !this.#u)
      throw new Error("Legacy public key not set for address");
    return this.#u;
  }
  static dead() {
    return k.fromString(
      "0x0000000000000000000000000000000000000000000000000000000000000000",
      // DEAD ADDRESS
      "0x04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f"
    );
  }
  /**
   * Create an address from a hex string
   * @param {string} mldsaPublicKey The ml-dsa public key in hex format
   * @param {string} legacyPublicKey The classical public key in hex format
   * @returns {Address} The address
   */
  static fromString(t, e) {
    if (!t)
      throw new Error("Invalid public key");
    if (t.startsWith("0x") && (t = t.slice(2)), !K.isValidHex(t))
      throw new Error(
        'You must only pass public keys in hexadecimal format. If you have an address such as bc1q... you must convert it to a public key first. Please refer to await provider.getPublicKeyInfo("bc1q..."). If the public key associated with the address is not found, you must force the user to enter the destination public key. It looks like: 0x020373626d317ae8788ce3280b491068610d840c23ecb64c14075bbb9f670af52c.'
      );
    let i;
    if (e) {
      if (e.startsWith("0x") && (e = e.slice(2)), !K.isValidHex(e))
        throw new Error(
          'You must only pass classical public keys in hexadecimal format. If you have an address such as bc1q... you must convert it to a public key first. Please refer to await provider.getPublicKeyInfo("bc1q..."). If the public key associated with the address is not found, you must force the user to enter the destination public key. It looks like: 0x020373626d317ae8788ce3280b491068610d840c23ecb64c14075bbb9f670af52c.'
        );
      i = a.from(e, "hex");
    }
    return new k(a.from(t, "hex"), i);
  }
  /**
   * Create an address from a public key
   * @returns {Address} The address
   * @param {ArrayLike<number>} bytes The public key
   */
  static wrap(t) {
    return new k(t);
  }
  static uncompressedToCompressed(t) {
    const e = Uint8Array.from(t), i = e.slice(1, 33), r = e.slice(33), s = a.alloc(33);
    return s[0] = 2 + (r[r.length - 1] & 1), s.set(i, 1), s;
  }
  /**
   * Creates an Address instance from a BigInt value.
   *
   * Converts a 256-bit unsigned integer into a 32-byte address by splitting it
   * into four 64-bit chunks and writing them in big-endian format using DataView.
   * This is the inverse operation of toBigInt().
   *
   * @param {bigint} value - The 256-bit unsigned integer to convert (0 to 2^256-1)
   * @returns {Address} A new Address instance containing the converted value
   *
   * @throws {RangeError} If the value is negative or exceeds 2^256-1
   *
   * @example
   * ```typescript
   * const bigIntValue = 12345678901234567890n;
   * const address = Address.fromBigInt(bigIntValue);
   * console.log(address.toHex()); // 0x0000000000000000000000000000000000000000000000000000abc123...
   * ```
   */
  static fromBigInt(t) {
    const e = new Uint8Array(32), i = new DataView(e.buffer);
    return i.setBigUint64(0, t >> 192n & 0xffffffffffffffffn, !1), i.setBigUint64(8, t >> 128n & 0xffffffffffffffffn, !1), i.setBigUint64(16, t >> 64n & 0xffffffffffffffffn, !1), i.setBigUint64(24, t & 0xffffffffffffffffn, !1), new k(e);
  }
  /**
   * Creates an Address instance from four 64-bit unsigned integers.
   *
   * Constructs a 32-byte address by combining four 64-bit big-endian unsigned integers.
   * This is the inverse operation of toUint64Array() and provides an efficient way
   * to create addresses from word-aligned data.
   *
   * @param {bigint} w0 - Most significant 64 bits (bytes 0-7)
   * @param {bigint} w1 - Second 64 bits (bytes 8-15)
   * @param {bigint} w2 - Third 64 bits (bytes 16-23)
   * @param {bigint} w3 - Least significant 64 bits (bytes 24-31)
   * @returns {Address} A new Address instance containing the combined value
   *
   * @throws {RangeError} If any value exceeds 64 bits (2^64-1)
   *
   * @example
   * ```typescript
   * const address = Address.fromUint64Array(
   *     0x0123456789abcdefn,
   *     0xfedcba9876543210n,
   *     0x1111222233334444n,
   *     0x5555666677778888n
   * );
   * console.log(address.toHex());
   * ```
   */
  static fromUint64Array(t, e, i, r) {
    const s = new Uint8Array(32), o = new DataView(s.buffer);
    return o.setBigUint64(0, t, !1), o.setBigUint64(8, e, !1), o.setBigUint64(16, i, !1), o.setBigUint64(24, r, !1), new k(s);
  }
  /**
   * Converts the address to four 64-bit unsigned integers.
   *
   * Splits the 32-byte (256-bit) address into four 64-bit big-endian unsigned integers.
   * This representation is useful for efficient storage, comparison operations, or
   * interfacing with systems that work with 64-bit word sizes.
   *
   * @returns {[bigint, bigint, bigint, bigint]} An array of four 64-bit unsigned integers
   *          representing the address from most significant to least significant bits
   *
   * @example
   * ```typescript
   * const address = Address.fromString('0x0123456789abcdef...');
   * const [w0, w1, w2, w3] = address.toUint64Array();
   * console.log(w0); // Most significant 64 bits
   * console.log(w3); // Least significant 64 bits
   * ```
   */
  toUint64Array() {
    if (this.#a !== void 0)
      return this.#a;
    const t = new DataView(this.buffer, this.byteOffset, 32);
    return this.#a = [
      t.getBigUint64(0, !1),
      t.getBigUint64(8, !1),
      t.getBigUint64(16, !1),
      t.getBigUint64(24, !1)
    ], this.#a;
  }
  /**
   * Check if the address is the dead address
   * @returns {boolean}
   */
  isDead() {
    for (let t = 0; t < C; t++)
      if (this[t] !== 0)
        return !1;
    return !0;
  }
  /**
   * Converts the address to a hex string
   * @returns {string} The hex string
   */
  toHex() {
    return "0x" + a.from(this).toString("hex");
  }
  /**
   * Converts the classical public key to a hex string
   * @returns {string} The hex string
   */
  tweakedToHex() {
    const t = this.legacyPublicKey;
    if (!t)
      throw new Error("Legacy public key not set");
    return "0x" + a.from(t).toString("hex");
  }
  /**
   * Converts the address content (SHA256 hash of ML-DSA public key) to a buffer
   * @returns {Buffer} The buffer containing the hashed ML-DSA public key
   */
  toBuffer() {
    return a.from(this);
  }
  /**
   * Converts the classical public key to a buffer
   * @returns {Buffer} The buffer
   */
  tweakedPublicKeyToBuffer() {
    const t = this.legacyPublicKey;
    if (!t)
      throw new Error("Legacy public key not set");
    return a.from(t);
  }
  toUncompressedHex() {
    if (this.ensureLegacyProcessed(), !this.#r)
      throw new Error("Legacy public key not set");
    return "0x" + this.#r.uncompressed.toString("hex");
  }
  toUncompressedBuffer() {
    if (this.ensureLegacyProcessed(), !this.#r)
      throw new Error("Legacy public key not set");
    return this.#r.uncompressed;
  }
  toHybridPublicKeyHex() {
    if (this.ensureLegacyProcessed(), !this.#r)
      throw new Error("Legacy public key not set");
    return "0x" + this.#r.hybrid.toString("hex");
  }
  toHybridPublicKeyBuffer() {
    if (this.ensureLegacyProcessed(), !this.#r)
      throw new Error("Legacy public key not set");
    return this.#r.hybrid;
  }
  originalPublicKeyBuffer() {
    if (this.ensureLegacyProcessed(), !this.#i)
      throw new Error("Legacy public key not set");
    return a.from(this.#i);
  }
  /**
   * Converts the address to a BigInt representation.
   *
   * This method uses an optimized DataView approach to read the 32-byte address
   * as four 64-bit big-endian unsigned integers, then combines them using bitwise
   * operations. This is approximately 10-20x faster than string-based conversion.
   *
   * @returns {bigint} The address as a 256-bit unsigned integer
   *
   * @example
   * ```typescript
   * const address = Address.fromString('0x0123456789abcdef...');
   * const bigIntValue = address.toBigInt();
   * console.log(bigIntValue); // 123456789...n
   * ```
   */
  toBigInt() {
    if (this.#o !== void 0)
      return this.#o;
    const t = new DataView(this.buffer, this.byteOffset, 32);
    return this.#o = t.getBigUint64(0, !1) << 192n | t.getBigUint64(8, !1) << 128n | t.getBigUint64(16, !1) << 64n | t.getBigUint64(24, !1), this.#o;
  }
  equals(t) {
    const e = this;
    if (t.length !== e.length)
      return !1;
    for (let i = 0; i < e.length; i++)
      if (e[i] !== t[i])
        return !1;
    return !0;
  }
  /**
   * Check if the address is bigger than another address
   * @returns {boolean} If bigger
   */
  lessThan(t) {
    const e = this;
    for (let i = 0; i < C; i++) {
      const r = e[i], s = t[i];
      if (r < s)
        return !0;
      if (r > s)
        return !1;
    }
    return !1;
  }
  /**
   * Check if the address is smaller than another address
   * @returns {boolean} If smaller
   */
  greaterThan(t) {
    const e = this;
    for (let i = 0; i < C; i++) {
      const r = e[i], s = t[i];
      if (r > s)
        return !0;
      if (r < s)
        return !1;
    }
    return !1;
  }
  /**
   * Set the public key
   * @param {ArrayLike<number>} mldsaPublicKey ML-DSA public key
   * @returns {void}
   */
  set(t) {
    this.setMldsaKey(t);
  }
  /**
   * Check if the public key is valid
   * @param {Network} network The network
   * @returns {boolean} If the public key is valid
   */
  isValidLegacyPublicKey(t) {
    const e = this.legacyPublicKey;
    if (!e)
      throw new Error("Legacy key not set.");
    return H.isValidPublicKey(a.from(e).toString("hex"), t);
  }
  /**
   * Get the public key as address
   */
  p2pk() {
    return this.toHex();
  }
  /**
   * Get the address in p2wpkh format
   * @param {Network} network The network
   */
  p2wpkh(t) {
    return A.getP2WPKHAddress(this.keyPair, t);
  }
  /**
   * Get the address in p2pkh format
   * @param {Network} network The network
   */
  p2pkh(t) {
    return A.getLegacyAddress(this.keyPair, t);
  }
  /**
   * Get the address in p2sh-p2wpkh format
   * @param {Network} network The network
   */
  p2shp2wpkh(t) {
    return A.getLegacySegwitAddress(this.keyPair, t);
  }
  /**
   * Convert the address to a string
   */
  toString() {
    return this.toHex();
  }
  /**
   * Convert the address to a JSON string
   */
  toJSON() {
    return this.toHex();
  }
  /**
   * Get the address in p2tr format
   * @param {Network} network The network
   */
  p2tr(t) {
    if (this.#t && this.#s === t)
      return this.#t;
    const e = this.legacyPublicKey;
    if (!e)
      throw new Error("Legacy public key not set");
    const i = A.tweakedPubKeyBufferToAddress(e, t);
    if (i)
      return this.#s = t, this.#t = i, i;
    throw new Error("Legacy public key not set");
  }
  /**
   * Generate a P2WDA (Pay-to-Witness-Data-Authentication) address
   *
   * P2WDA addresses are a special type of P2WSH address that allows embedding
   * authenticated data directly in the witness field, achieving 75% cost reduction
   * through Bitcoin's witness discount.
   *
   * The witness script pattern is: (OP_2DROP * 5) <pubkey> OP_CHECKSIG
   * This allows up to 10 witness data fields (5 * 2 = 10), where each field
   * can hold up to 80 bytes of data due to relay rules.
   *
   * @param {Network} network - The Bitcoin network to use
   * @returns {IP2WSHAddress} The P2WDA address
   * @throws {Error} If the public key is not set or address generation fails
   *
   * @example
   * ```typescript
   * const address = Address.fromString('0x02...');
   * const p2wdaAddress = address.p2wda(networks.bitcoin);
   * console.log(p2wdaAddress); // bc1q...
   * ```
   */
  p2wda(t) {
    if (this.#h && this.#s === t)
      return this.#h;
    if (this.ensureLegacyProcessed(), !this.#i)
      throw new Error("Cannot create P2WDA address: public key not set");
    const e = a.from(this.#i);
    if (e.length !== 33)
      throw new Error("P2WDA requires a compressed public key (33 bytes)");
    try {
      const i = z.generateP2WDAAddress(e, t);
      return this.#s = t, this.#h = i, {
        address: i.address,
        witnessScript: i.witnessScript
      };
    } catch (i) {
      throw new Error(`Failed to generate P2WDA address: ${i.message}`);
    }
  }
  /**
   * Generate a P2WSH address with CSV (CheckSequenceVerify) time lock
   * The resulting address can only be spent after the specified number of blocks
   * have passed since the UTXO was created.
   *
   * @param {bigint | number | string} duration - The number of blocks that must pass before spending (1-65535)
   * @param {Network} network - The Bitcoin network to use
   * @returns {IP2WSHAddress} The timelocked address and its witness script
   * @throws {Error} If the block number is out of range or public key is not available
   */
  toCSV(t, e) {
    const i = Number(t);
    if (i < 1 || i > 65535)
      throw new Error("CSV block number must be between 1 and 65535");
    if (this.ensureLegacyProcessed(), !this.#i)
      throw new Error("Cannot create CSV address: public key not set");
    const r = a.from(this.#i);
    return M.generateTimeLockAddress(r, e, i);
  }
  /**
   * Generate a P2TR address with CSV (CheckSequenceVerify) time lock
   * The resulting address can only be spent after the specified number of blocks
   * have passed since the UTXO was created.
   *
   * @param {bigint | number | string} duration - The number of blocks that must pass before spending (1-65535)
   * @param {Network} network - The Bitcoin network to use
   * @returns {IP2WSHAddress} The timelocked address and its witness script
   * @throws {Error} If the block number is out of range or public key is not available
   */
  toCSVTweaked(t, e) {
    const i = Number(t);
    if (i < 1 || i > 65535)
      throw new Error("CSV block number must be between 1 and 65535");
    if (this.ensureLegacyProcessed(), !this.#i)
      throw new Error("Cannot create CSV address: public key not set");
    return M.generateTimeLockAddressP2TR(
      this.tweakedPublicKeyToBuffer(),
      e,
      i
    );
  }
  /**
   * Returns the OPNet address encoded in bech32m format, derived from the SHA256 hash of the ML-DSA public key
   * (which is what the Address internally stores).
   *
   * This method generates a P2OP (Pay-to-OPNet) address using witness version 16, suitable for
   * quantum-resistant transactions on the OPNet protocol.
   *
   * @param network - The Bitcoin network to use (mainnet, testnet, regtest)
   * @returns The P2OP address in bech32m format
   */
  p2op(t) {
    if (this.#e && this.#s === t)
      return this.#e;
    const e = A.p2op(this, t);
    if (e)
      return this.#s = t, this.#e = e, e;
    throw new Error("ML-DSA public key not set");
  }
  toTweakedHybridPublicKeyHex() {
    if (this.ensureLegacyProcessed(), !this.#n)
      throw new Error("Legacy public key not set");
    return "0x" + this.#n.toString("hex");
  }
  toTweakedHybridPublicKeyBuffer() {
    if (this.ensureLegacyProcessed(), !this.#n)
      throw new Error("Legacy public key not set");
    return this.#n;
  }
  /**
   * Sets the MLDSA key portion of the address.
   * @param {ArrayLike<number>} mldsaPublicKey - The MLDSA public key or its hash
   */
  setMldsaKey(t) {
    if (t.length === C) {
      const e = new Uint8Array(C);
      e.set(t), super.set(e);
    } else {
      if (![1312, 1952, 2592].includes(t.length))
        throw new Error(
          `Invalid ML-DSA public key length: ${t.length}. Expected 1312 (ML-DSA-44/LEVEL2), 1952 (ML-DSA-65/LEVEL3), or 2592 (ML-DSA-87/LEVEL5) bytes.`
        );
      this.#l = new Uint8Array(t.length), this.#l.set(t);
      const i = ne(new Uint8Array(t)), r = new Uint8Array(C);
      r.set(i), super.set(r);
    }
  }
  /**
   * Lazy processing of legacy key - defers expensive EC operations until actually needed.
   * Does the EXACT same logic as the original set() method did for legacy keys.
   */
  ensureLegacyProcessed() {
    if (this.#g) return;
    this.#g = !0;
    const t = this.#d;
    if (t)
      if (t.length === C) {
        const e = a.alloc(C);
        e.set(t), this.#n = te.generateHybridKeyFromHash(e), this.#c = t;
      } else
        this.autoFormat(t);
  }
  /**
   * Processes a 33 or 65 byte public key, performing EC operations.
   * Sets #legacyPublicKey to 32-byte tweaked x-only (same as original behavior).
   */
  autoFormat(t) {
    const e = t[0];
    e === 3 || e === 2 || (e === 4 || e === 6 || e === 7) && (t = k.uncompressedToCompressed(t)), this.#i = Uint8Array.from(t), this.#u = A.fromPublicKey(this.#i), this.#r = mi(this.#i);
    const i = O(
      A.tweakPublicKey(a.from(this.#i))
    );
    this.#n = te.generateHybridKeyFromHash(i), this.#c = new Uint8Array(C), this.#c.set(i);
  }
}
class Ot {
  constructor(t) {
    if (this._keys = [], this._values = {}, t instanceof Ot)
      this.setAll(t);
    else if (t)
      for (const [e, i] of t)
        this.set(e, i);
  }
  get size() {
    return this._keys.length;
  }
  setAll(t) {
    this._keys = [...t._keys], this._values = { ...t._values };
  }
  addAll(t) {
    for (const [e, i] of t.entries())
      this.set(e, i);
  }
  *keys() {
    yield* this._keys;
  }
  *values() {
    for (const t of this._keys)
      yield this._values[t];
  }
  *entries() {
    for (const t of this._keys)
      yield [t, this._values[t]];
  }
  set(t, e) {
    return this.has(t) || this._keys.push(t), this._values[t] = e, this;
  }
  indexOf(t) {
    if (!this.has(t))
      return -1;
    for (let e = 0; e < this._keys.length; e++)
      if (this._keys[e] === t)
        return e;
    throw new Error("Key not found, this should not happen.");
  }
  get(t) {
    return this._values[t];
  }
  has(t) {
    return Object.prototype.hasOwnProperty.call(this._values, t);
  }
  delete(t) {
    if (!this.has(t))
      return !1;
    const e = this.indexOf(t);
    return this._keys.splice(e, 1), delete this._values[t], !0;
  }
  clear() {
    this._keys = [], this._values = {};
  }
  forEach(t, e) {
    for (const i of this._keys)
      t.call(e, this._values[i], i, this);
  }
  *[Symbol.iterator]() {
    for (const t of this._keys)
      yield [t, this._values[t]];
  }
}
class Fe {
  constructor(t) {
    if (this.items = new Ot(), t)
      for (const [e, i] of t)
        this.set(e, i);
  }
  get size() {
    return this.items.size;
  }
  set(t, e) {
    const i = t.toBigInt();
    return this.items.set(i, e), this;
  }
  get(t) {
    return this.items.get(t.toBigInt());
  }
  has(t) {
    return this.items.has(t.toBigInt());
  }
  delete(t) {
    const e = t.toBigInt();
    return this.items.delete(e);
  }
  clear() {
    this.items.clear();
  }
  indexOf(t) {
    return this.items.indexOf(t.toBigInt());
  }
  /**
   * WARNING, THIS RETURN NEW COPY OF THE KEYS
   */
  *entries() {
    for (const [t, e] of this.items.entries())
      yield [k.fromBigInt(t), e];
  }
  *keys() {
    for (const t of this.items.keys())
      yield k.fromBigInt(t);
  }
  *values() {
    for (const t of this.items.values())
      yield t;
  }
  forEach(t, e) {
    for (const [i, r] of this.items.entries()) {
      const s = k.fromBigInt(i);
      t.call(e, r, s, this);
    }
  }
  *[Symbol.iterator]() {
    yield* this.entries();
  }
}
class qt {
  constructor(t) {
    this.currentOffset = 0, this.buffer = new DataView(t.buffer, t.byteOffset, t.byteLength);
  }
  // Helpers for comparisons; unchanged
  static stringCompare(t, e) {
    return t.localeCompare(e);
  }
  static bigintCompare(t, e) {
    return t < e ? -1 : t > e ? 1 : 0;
  }
  static numberCompare(t, e) {
    return t < e ? -1 : t > e ? 1 : 0;
  }
  setBuffer(t) {
    this.buffer = new DataView(t.buffer, t.byteOffset, t.byteLength), this.currentOffset = 0;
  }
  length() {
    return this.buffer.byteLength;
  }
  bytesLeft() {
    return this.buffer.byteLength - this.currentOffset;
  }
  /**
   * Reads a single unsigned byte (u8).
   */
  readU8() {
    this.verifyEnd(this.currentOffset + Dt);
    const t = this.buffer.getUint8(this.currentOffset);
    return this.currentOffset += Dt, t;
  }
  /**
   * Reads an unsigned 16-bit integer. By default, big-endian.
   * @param be - Endianness; true means big-endian (the default).
   */
  readU16(t = !0) {
    this.verifyEnd(this.currentOffset + Tt);
    const e = this.buffer.getUint16(this.currentOffset, !t);
    return this.currentOffset += Tt, e;
  }
  /**
   * Reads an unsigned 32-bit integer. By default, big-endian.
   * @param be - Endianness; true means big-endian (the default).
   */
  readU32(t = !0) {
    this.verifyEnd(this.currentOffset + ht);
    const e = this.buffer.getUint32(this.currentOffset, !t);
    return this.currentOffset += ht, e;
  }
  /**
   * Reads an unsigned 64-bit integer. By default, big-endian.
   * @param be - Endianness; true means big-endian (the default).
   */
  readU64(t = !0) {
    this.verifyEnd(this.currentOffset + Ct);
    const e = this.buffer.getBigUint64(this.currentOffset, !t);
    return this.currentOffset += Ct, e;
  }
  /**
   * Reads a 128-bit unsigned integer. By default, read big-endian.
   * @param be - Endianness; true => big-endian (default).
   */
  readU128(t = !0) {
    const e = this.readBytes(wt);
    let i = e;
    return t || (i = this.reverseBytes(e)), BigInt("0x" + this.toHexString(i));
  }
  /**
   * Reads a 256-bit unsigned integer. Same approach as readU128.
   * @param be - Endianness; true => big-endian (default).
   */
  readU256(t = !0) {
    const e = this.readBytes(It);
    let i = e;
    return t || (i = this.reverseBytes(e)), BigInt("0x" + this.toHexString(i));
  }
  /**
   * Reads a 128-bit signed integer. Interpret the sign bit if big-endian.
   * @param be - Endianness; true => big-endian (default).
   */
  readI128(t = !0) {
    const e = this.readBytes(yt);
    let i = e;
    t || (i = this.reverseBytes(e));
    let r = BigInt("0x" + this.toHexString(i));
    if (i[0] & 128) {
      const o = BigInt(1) << BigInt(128);
      r = r - o;
    }
    return r;
  }
  /**
   * Read a boolean (u8 != 0).
   */
  readBoolean() {
    return this.readU8() !== 0;
  }
  /**
   * Reads 32 bits
   */
  readSelector() {
    return this.readU32(!0);
  }
  /**
   * Reads a raw sequence of bytes (length must be known).
   * If zeroStop = true, stops if we encounter 0x00 early.
   */
  readBytes(t, e = !1) {
    this.verifyEnd(this.currentOffset + t);
    let i = new Uint8Array(t);
    for (let r = 0; r < t; r++) {
      const s = this.buffer.getUint8(this.currentOffset++);
      if (e && s === 0) {
        i = a.from(i.subarray(0, r));
        break;
      }
      i[r] = s;
    }
    return i;
  }
  /**
   * Reads a string of the given length in raw bytes. By default, do NOT zero-stop
   * (matching how we wrote the raw bytes).
   */
  readString(t) {
    const e = new TextDecoder(), i = this.readBytes(t, !1);
    return e.decode(i);
  }
  /**
   * Reads a string that was written as [u16 length][raw bytes].
   */
  readStringWithLength(t = !0) {
    const e = this.readU32(t);
    return this.readString(e);
  }
  /**
   * Reads an address.
   */
  readAddress() {
    const t = Array.from(this.readBytes(C));
    return new k(t);
  }
  /**
   * Reads bytes written as [u32 length][bytes].
   * @param maxLength if > 0, enforces an upper bound
   * @param be
   */
  readBytesWithLength(t = 0, e = !0) {
    const i = this.readU32(e);
    if (t > 0 && i > t)
      throw new Error("Data length exceeds maximum length.");
    return this.readBytes(i);
  }
  // ------------------ Array readers ------------------ //
  readArrayOfBuffer(t = !0) {
    const e = this.readU16(t), i = new Array(e);
    for (let r = 0; r < e; r++)
      i[r] = this.readBytesWithLength();
    return i;
  }
  readAddressArray(t = !0) {
    const e = this.readU16(t), i = new Array(e);
    for (let r = 0; r < e; r++)
      i[r] = this.readAddress();
    return i;
  }
  readU256Array(t = !0) {
    const e = this.readU16(t), i = new Array(e);
    for (let r = 0; r < e; r++)
      i[r] = this.readU256(t);
    return i;
  }
  readU128Array(t = !0) {
    const e = this.readU16(t), i = new Array(e);
    for (let r = 0; r < e; r++)
      i[r] = this.readU128(t);
    return i;
  }
  readU64Array(t = !0) {
    const e = this.readU16(t), i = new Array(e);
    for (let r = 0; r < e; r++)
      i[r] = this.readU64(t);
    return i;
  }
  readU32Array(t = !0) {
    const e = this.readU16(t), i = new Array(e);
    for (let r = 0; r < e; r++)
      i[r] = this.readU32(t);
    return i;
  }
  readU16Array(t = !0) {
    const e = this.readU16(t), i = new Array(e);
    for (let r = 0; r < e; r++)
      i[r] = this.readU16(t);
    return i;
  }
  readU8Array() {
    const t = this.readU16(!0), e = new Array(t);
    for (let i = 0; i < t; i++)
      e[i] = this.readU8();
    return e;
  }
  readStringArray(t = !0) {
    const e = this.readU16(t), i = new Array(e);
    for (let r = 0; r < e; r++)
      i[r] = this.readStringWithLength(t);
    return i;
  }
  readBytesArray(t = !0) {
    const e = this.readU16(t), i = new Array(e);
    for (let r = 0; r < e; r++)
      i[r] = this.readBytesWithLength(0, t);
    return i;
  }
  /**
   * Reads [u16 length][ (address, u256) pairs ].
   */
  readAddressValueTuple(t = !0) {
    const e = this.readU16(t), i = new Fe();
    for (let r = 0; r < e; r++) {
      const s = this.readAddress(), o = this.readU256(t);
      if (i.has(s))
        throw new Error("Duplicate address found in map");
      i.set(s, o);
    }
    return i;
  }
  // --------------------------------------------------- //
  getOffset() {
    return this.currentOffset;
  }
  setOffset(t) {
    this.currentOffset = t;
  }
  /**
   * Verifies we have enough bytes in the buffer to read up to `size`.
   */
  verifyEnd(t) {
    if (t > this.buffer.byteLength)
      throw new Error(
        `Attempt to read beyond buffer length: requested up to byte offset ${t}, but buffer is only ${this.buffer.byteLength} bytes.`
      );
  }
  /**
   * Utility: reverses a byte array in-place or returns a reversed copy.
   */
  reverseBytes(t) {
    const e = new Uint8Array(t.length);
    for (let i = 0; i < t.length; i++)
      e[i] = t[t.length - 1 - i];
    return e;
  }
  /**
   * Utility: turn bytes into a hex string without `0x` prefix.
   */
  toHexString(t) {
    return Array.from(t, (e) => e.toString(16).padStart(2, "0")).join("");
  }
}
class D {
  constructor(t = 0) {
    this.currentOffset = 0, this.buffer = this.getDefaultBuffer(t);
  }
  static estimateArrayOfBufferLength(t) {
    if (t.length > 65535) throw new Error("Array size is too large");
    let e = Tt;
    for (let i = 0; i < t.length; i++)
      e += ht + t[i].length;
    return e;
  }
  writeU8(t) {
    if (t > 255) throw new Error("u8 value is too large.");
    this.allocSafe(Dt), this.buffer.setUint8(this.currentOffset++, t);
  }
  writeU16(t, e = !0) {
    if (t > 65535) throw new Error("u16 value is too large.");
    this.allocSafe(Tt), this.buffer.setUint16(this.currentOffset, t, !e), this.currentOffset += 2;
  }
  writeU32(t, e = !0) {
    if (t > 4294967295) throw new Error("u32 value is too large.");
    this.allocSafe(ht), this.buffer.setUint32(this.currentOffset, t, !e), this.currentOffset += 4;
  }
  writeU64(t, e = !0) {
    if (t > 18446744073709551615n) throw new Error("u64 value is too large.");
    this.allocSafe(Ct), this.buffer.setBigUint64(this.currentOffset, t, !e), this.currentOffset += 8;
  }
  writeSelector(t) {
    this.writeU32(t, !0);
  }
  writeBoolean(t) {
    this.writeU8(t ? 1 : 0);
  }
  writeI128(t, e = !0) {
    if (t > 170141183460469231731687303715884105727n || t < -170141183460469231731687303715884105728n)
      throw new Error("i128 value is too large.");
    this.allocSafe(yt);
    const i = X.valueToUint8Array(t, yt);
    if (i.byteLength !== yt)
      throw new Error(`Invalid i128 value: ${t}`);
    if (e)
      for (let r = 0; r < i.byteLength; r++)
        this.writeU8(i[r]);
    else
      for (let r = i.byteLength - 1; r >= 0; r--)
        this.writeU8(i[r]);
  }
  writeU256(t, e = !0) {
    if (t > 115792089237316195423570985008687907853269984665640564039457584007913129639935n && t < 0n)
      throw new Error("u256 value is too large or negative.");
    this.allocSafe(It);
    const i = X.valueToUint8Array(t);
    if (i.byteLength !== It)
      throw new Error(`Invalid u256 value: ${t}`);
    if (e)
      for (let r = 0; r < i.byteLength; r++)
        this.writeU8(i[r]);
    else
      for (let r = i.byteLength - 1; r >= 0; r--)
        this.writeU8(i[r]);
  }
  writeU128(t, e = !0) {
    if (t > 340282366920938463463374607431768211455n && t < 0n)
      throw new Error("u128 value is too large or negative.");
    this.allocSafe(wt);
    const i = X.valueToUint8Array(t, wt);
    if (i.byteLength !== wt)
      throw new Error(`Invalid u128 value: ${t}`);
    if (e)
      for (let r = 0; r < i.byteLength; r++)
        this.writeU8(i[r]);
    else
      for (let r = i.byteLength - 1; r >= 0; r--)
        this.writeU8(i[r]);
  }
  writeBytes(t) {
    this.allocSafe(t.byteLength);
    for (let e = 0; e < t.byteLength; e++)
      this.writeU8(t[e]);
  }
  writeString(t) {
    const i = new TextEncoder().encode(t);
    this.allocSafe(i.length), this.writeBytes(i);
  }
  writeStringWithLength(t) {
    const i = new TextEncoder().encode(t);
    this.allocSafe(ht + i.length), this.writeU32(i.length), this.writeBytes(i);
  }
  writeAddress(t) {
    this.verifyAddress(t), this.writeBytes(t);
  }
  getBuffer(t = !0) {
    const e = new Uint8Array(this.buffer.byteLength);
    for (let i = 0; i < this.buffer.byteLength; i++)
      e[i] = this.buffer.getUint8(i);
    return t && this.clear(), e;
  }
  reset() {
    this.currentOffset = 0, this.buffer = this.getDefaultBuffer(4);
  }
  toBytesReader() {
    return new qt(this.getBuffer());
  }
  getOffset() {
    return this.currentOffset;
  }
  setOffset(t) {
    this.currentOffset = t;
  }
  clear() {
    this.currentOffset = 0, this.buffer = this.getDefaultBuffer();
  }
  allocSafe(t) {
    this.currentOffset + t > this.buffer.byteLength && this.resize(t);
  }
  writeAddressValueTuple(t, e = !0) {
    if (t.size > 65535) throw new Error("Map size is too large");
    this.writeU16(t.size, e);
    const i = Array.from(t.keys());
    for (let r = 0; r < i.length; r++) {
      const s = i[r], o = t.get(s);
      if (o == null) throw new Error("Value not found");
      this.writeAddress(s), this.writeU256(o, e);
    }
  }
  writeBytesWithLength(t) {
    this.writeU32(t.length), this.writeBytes(t);
  }
  writeArrayOfBuffer(t, e = !0) {
    const i = D.estimateArrayOfBufferLength(t);
    this.allocSafe(i), this.writeU16(t.length, e);
    for (let r = 0; r < t.length; r++)
      this.writeU32(t[r].length, e), this.writeBytes(t[r]);
  }
  writeAddressArray(t) {
    if (t.length > 65535) throw new Error("Array size is too large");
    this.writeU16(t.length);
    for (let e = 0; e < t.length; e++)
      this.writeAddress(t[e]);
  }
  writeU32Array(t, e = !0) {
    if (t.length > 65535) throw new Error("Array size is too large");
    this.writeU16(t.length, e);
    for (let i = 0; i < t.length; i++)
      this.writeU32(t[i], e);
  }
  writeU256Array(t, e = !0) {
    if (t.length > 65535) throw new Error("Array size is too large");
    this.writeU16(t.length, e);
    for (let i = 0; i < t.length; i++)
      this.writeU256(t[i], e);
  }
  writeU128Array(t, e = !0) {
    if (t.length > 65535) throw new Error("Array size is too large");
    this.writeU16(t.length, e);
    for (let i = 0; i < t.length; i++)
      this.writeU128(t[i], e);
  }
  writeStringArray(t) {
    if (t.length > 65535) throw new Error("Array size is too large");
    this.writeU16(t.length);
    for (let e = 0; e < t.length; e++)
      this.writeStringWithLength(t[e]);
  }
  writeU16Array(t, e = !0) {
    if (t.length > 65535) throw new Error("Array size is too large");
    this.writeU16(t.length, e);
    for (let i = 0; i < t.length; i++)
      this.writeU16(t[i], e);
  }
  writeU8Array(t) {
    if (t.length > 65535) throw new Error("Array size is too large");
    this.writeU16(t.length);
    for (let e = 0; e < t.length; e++)
      this.writeU8(t[e]);
  }
  writeU64Array(t, e = !0) {
    if (t.length > 65535) throw new Error("Array size is too large");
    this.writeU16(t.length, e);
    for (let i = 0; i < t.length; i++)
      this.writeU64(t[i], e);
  }
  writeBytesArray(t) {
    if (t.length > 65535) throw new Error("Array size is too large");
    this.writeU16(t.length);
    for (let e = 0; e < t.length; e++)
      this.writeBytesWithLength(t[e]);
  }
  verifyAddress(t) {
    if (t.byteLength > C)
      throw new Error(
        `Address is too long ${t.byteLength} > ${C} bytes`
      );
  }
  resize(t) {
    const e = new Uint8Array(this.buffer.byteLength + t);
    for (let i = 0; i < this.buffer.byteLength; i++)
      e[i] = this.buffer.getUint8(i);
    this.buffer = new DataView(e.buffer, e.byteOffset, e.byteLength);
  }
  getDefaultBuffer(t = 0) {
    return new DataView(new ArrayBuffer(t));
  }
}
var W = /* @__PURE__ */ ((n) => (n[n.ACCESS_LIST = 1] = "ACCESS_LIST", n[n.EPOCH_SUBMISSION = 2] = "EPOCH_SUBMISSION", n[n.MLDSA_LINK_PUBKEY = 4] = "MLDSA_LINK_PUBKEY", n))(W || {}), Q = /* @__PURE__ */ ((n) => (n[n.ACCESS_LIST = 1] = "ACCESS_LIST", n[n.EPOCH_SUBMISSION = 2] = "EPOCH_SUBMISSION", n[n.MLDSA_LINK_PUBKEY = 3] = "MLDSA_LINK_PUBKEY", n))(Q || {});
class q {
  constructor(t, e, i = I) {
    this.network = I, this.senderPubKey = t, this.contractSaltPubKey = e, this.network = i, this.xSenderPubKey = O(t);
  }
  static {
    this.DATA_CHUNK_SIZE = 512;
  }
  static {
    this.MAGIC = a.from("op", "utf-8");
  }
  buildHeader(t) {
    let e = 0;
    for (const r of t)
      e |= r;
    const i = a.alloc(3);
    return i.writeUIntBE(e, 0, 3), a.from([this.senderPubKey[0], ...i]);
  }
  getHeader(t, e = []) {
    const i = new D(12);
    return i.writeBytes(this.buildHeader(e)), i.writeU64(t), a.from(i.getBuffer());
  }
  /**
   * Split a buffer into chunks
   * @param {Buffer} buffer - The buffer to split
   * @param {number} chunkSize - The size of each chunk
   * @protected
   * @returns {Array<Buffer[]>} - The chunks
   */
  splitBufferIntoChunks(t, e = q.DATA_CHUNK_SIZE) {
    const i = [];
    for (let r = 0; r < t.length; r += e) {
      const s = Math.min(e, t.length - r), o = a.alloc(s);
      for (let c = 0; c < s; c++)
        o.writeUInt8(t[r + c], c);
      i.push([o]);
    }
    return i;
  }
  encodeFeature(t, e) {
    switch (t.opcode) {
      case W.ACCESS_LIST:
        return this.encodeAccessListFeature(t, e);
      case W.EPOCH_SUBMISSION:
        return this.encodeChallengeSubmission(
          t,
          e
        );
      case W.MLDSA_LINK_PUBKEY:
        return this.encodeLinkRequest(t, e);
      default:
        throw new Error(`Unknown feature type: ${t.opcode}`);
    }
  }
  encodeAccessListFeature(t, e) {
    const i = new D();
    i.writeU16(Object.keys(t.data).length);
    for (const r in t.data) {
      const s = k.fromString(r), o = t.data[r];
      i.writeAddress(s), i.writeU32(o.length);
      for (const c of o) {
        const u = a.from(c, "base64");
        if (u.length !== 32)
          throw new Error(`Invalid pointer length: ${u.length}`);
        i.writeBytes(u);
      }
    }
    e.writeBytesWithLength(N.compress(a.from(i.getBuffer())));
  }
  encodeChallengeSubmission(t, e) {
    if ("verifySignature" in t.data && !t.data.verifySignature())
      throw new Error("Invalid signature in challenge submission feature");
    const i = new D();
    i.writeBytes(t.data.publicKey.toBuffer()), i.writeBytes(t.data.solution), t.data.graffiti && i.writeBytesWithLength(t.data.graffiti), e.writeBytesWithLength(i.getBuffer());
  }
  encodeLinkRequest(t, e) {
    const i = t.data, r = new D();
    if (r.writeU8(i.level), r.writeBytes(i.hashedPublicKey), r.writeBoolean(i.verifyRequest), i.verifyRequest) {
      if (!i.publicKey || !i.mldsaSignature)
        throw new Error(
          "MLDSA public key and signature required when verifyRequest is true"
        );
      r.writeBytes(i.publicKey), r.writeBytes(i.mldsaSignature);
    }
    if (!i.legacySignature || i.legacySignature.length !== 64)
      throw new Error("Legacy signature must be exactly 64 bytes");
    r.writeBytes(i.legacySignature), e.writeBytesWithLength(r.getBuffer());
  }
}
class oe extends q {
  constructor(t, e, i = I) {
    super(t, e, i);
  }
  /**
   * Get the public key as a buffer
   * @param {Buffer[]} witnessKeys - The public keys
   * @param {Network} network - The network to use
   * @private
   * @returns {Buffer} - The public key as a buffer
   */
  static getPubKeyAsBuffer(t, e) {
    let i = a.alloc(0);
    for (const s of t) {
      if (!A.fromPublicKey(s, e).compressed)
        throw new Error("Public key must be compressed");
      if (s.byteLength !== 33)
        throw new Error(`Public key must be 33 bytes, got ${s.byteLength} bytes.`);
      i = a.concat([i, s]);
    }
    const r = N.compress(i);
    return r.byteLength >= i.byteLength ? i : r;
  }
  /**
   * Compile an interaction bitcoin script
   * @param {Buffer} calldata - The calldata to use
   * @param {Buffer} contractSecret - The contract secret
   * @param {IChallengeSolution} challenge
   * @param maxPriority - Amount of satoshis to spend max on priority fee
   * @param {Feature<Features>[]} featuresRaw - The features to use
   * @returns {Buffer} - The compiled script
   * @throws {Error} - If something goes wrong
   */
  compile(t, e, i, r, s = []) {
    if (!this.contractSaltPubKey) throw new Error("Contract salt public key not set");
    const o = this.splitBufferIntoChunks(t);
    if (!o.length) throw new Error("No data chunks found");
    const c = [], u = [];
    if (s && s.length) {
      const f = s.sort(
        (S, b) => S.priority - b.priority
      ), w = new D();
      for (let S = 0; S < f.length; S++) {
        const b = f[S];
        c.push(b.opcode), this.encodeFeature(b, w);
      }
      u.push(...this.splitBufferIntoChunks(a.from(w.getBuffer())));
    }
    let h = [
      this.getHeader(r, c),
      g.OP_TOALTSTACK,
      // CHALLENGE PREIMAGE FOR REWARD,
      i.publicKey.toBuffer(),
      g.OP_TOALTSTACK,
      i.solution,
      g.OP_TOALTSTACK,
      this.xSenderPubKey,
      g.OP_DUP,
      g.OP_HASH256,
      Y(this.xSenderPubKey),
      g.OP_EQUALVERIFY,
      g.OP_CHECKSIGVERIFY,
      this.contractSaltPubKey,
      g.OP_CHECKSIGVERIFY,
      g.OP_HASH160,
      dt(e),
      g.OP_EQUALVERIFY,
      g.OP_DEPTH,
      g.OP_1,
      g.OP_NUMEQUAL,
      g.OP_IF,
      q.MAGIC
    ];
    h = h.concat(
      ...u,
      g.OP_1NEGATE,
      ...o,
      g.OP_ELSE,
      g.OP_1,
      g.OP_ENDIF
    );
    const l = h.flat(), d = L(l);
    if (!R(d))
      throw new Error("Failed to decompile script??");
    return d;
  }
}
class Re extends q {
  constructor(t, e = I) {
    super(t, void 0, e);
  }
  /**
   * Compile an interaction bitcoin script
   * @param compiledData - The compiled data
   * @returns {Buffer} - The compiled script
   * @throws {Error} - If something goes wrong
   */
  compile(t) {
    const e = t.flat(), i = L(e);
    if (!R(i))
      throw new Error("Failed to decompile script??");
    return i;
  }
}
const We = 0, Me = a.from([We]);
class Ft extends q {
  constructor(t, e, i = I) {
    super(t, e, i);
  }
  /**
   * Compile a bitcoin script representing a contract deployment
   * @param {Buffer} contractBytecode - The contract bytecode
   * @param {Buffer} contractSalt - The contract salt
   * @param {ChallengeSolution} challenge - The challenge for reward
   * @param {bigint} maxPriority - The maximum priority for the contract
   * @param {Buffer} [calldata] - The calldata to be passed to the contract
   * @param {Feature<Features>[]} [features] - Optional features to include in the script
   * @returns {Buffer} - The compiled script
   */
  compile(t, e, i, r, s, o) {
    const c = this.getAsm(
      t,
      e,
      i,
      r,
      s,
      o
    ), u = L(c);
    if (!R(u))
      throw new Error("Failed to decompile script??");
    return u;
  }
  getAsm(t, e, i, r, s, o) {
    if (!this.contractSaltPubKey) throw new Error("Contract salt public key not set");
    const c = this.splitBufferIntoChunks(t), u = s ? this.splitBufferIntoChunks(s) : [], h = [], l = [];
    if (o && o.length) {
      const p = o.sort(
        (w, S) => w.priority - S.priority
      ), f = new D();
      for (let w = 0; w < p.length; w++) {
        const S = p[w];
        h.push(S.opcode), this.encodeFeature(S, f);
      }
      l.push(...this.splitBufferIntoChunks(a.from(f.getBuffer())));
    }
    return [
      this.getHeader(r, h),
      g.OP_TOALTSTACK,
      // CHALLENGE PREIMAGE FOR REWARD,
      i.publicKey.toBuffer(),
      g.OP_TOALTSTACK,
      i.solution,
      g.OP_TOALTSTACK,
      this.xSenderPubKey,
      g.OP_DUP,
      g.OP_HASH256,
      Y(this.xSenderPubKey),
      g.OP_EQUALVERIFY,
      g.OP_CHECKSIGVERIFY,
      this.contractSaltPubKey,
      g.OP_CHECKSIGVERIFY,
      g.OP_HASH256,
      Y(e),
      g.OP_EQUALVERIFY,
      g.OP_DEPTH,
      g.OP_1,
      g.OP_NUMEQUAL,
      g.OP_IF,
      q.MAGIC,
      ...l,
      g.OP_0,
      ...u,
      g.OP_1NEGATE,
      ...c,
      g.OP_ELSE,
      g.OP_1,
      g.OP_ENDIF
    ].flat();
  }
}
class E extends ve {
  constructor(t, e = I) {
    if (super(), this.logColor = "#4a90d9", t.length !== 33)
      throw new Error("Public key must be 33 bytes (compressed)");
    this.publicKey = t, this.network = e;
  }
  static {
    this.MAX_CHUNK_SIZE = 80;
  }
  static {
    this.MAX_STACK_ITEMS = 100;
  }
  static {
    this.MAX_WITNESS_SIZE = 1650;
  }
  static {
    this.MAX_STANDARD_WEIGHT = 4e5;
  }
  static {
    this.MIN_OUTPUT_VALUE = 330n;
  }
  static {
    this.BYTES_PER_COMMITMENT = 23;
  }
  static {
    this.SIG_CHECK_BYTES = 35;
  }
  static {
    this.WITNESS_FIXED_OVERHEAD = 112;
  }
  static {
    this.WITNESS_PER_CHUNK_OVERHEAD = E.MAX_CHUNK_SIZE + 1 + E.BYTES_PER_COMMITMENT;
  }
  static {
    this.MAX_CHUNKS_PER_OUTPUT = Math.floor(
      (E.MAX_WITNESS_SIZE - E.WITNESS_FIXED_OVERHEAD) / E.WITNESS_PER_CHUNK_OVERHEAD
    );
  }
  static {
    this.INPUT_BASE_WEIGHT = 164;
  }
  static {
    this.INPUT_WITNESS_WEIGHT_MAX = E.MAX_WITNESS_SIZE;
  }
  static {
    this.WEIGHT_PER_INPUT = E.INPUT_BASE_WEIGHT + E.INPUT_WITNESS_WEIGHT_MAX;
  }
  /**
   * Calculate the maximum number of inputs per standard reveal transaction.
   *
   * Standard tx weight limit: 400,000
   * With max chunks per input (~10,385 weight), only ~38 inputs fit
   *
   * @returns Maximum inputs per reveal tx (~38 with max chunks)
   */
  static calculateMaxInputsPerTx() {
    const i = E.MAX_STANDARD_WEIGHT - 40 - 200;
    return Math.floor(i / E.WEIGHT_PER_INPUT);
  }
  /**
   * Calculate maximum data per standard reveal transaction.
   *
   * @returns Maximum data in bytes (~300KB with batched chunks at 70 chunks/output)
   */
  static calculateMaxDataPerTx() {
    return E.calculateMaxInputsPerTx() * E.MAX_CHUNKS_PER_OUTPUT * E.MAX_CHUNK_SIZE;
  }
  /**
   * Estimate the number of P2WSH outputs needed for a given data size.
   *
   * @param dataSize Data size in bytes
   * @returns Number of P2WSH outputs needed
   */
  static estimateOutputCount(t) {
    return Math.ceil(
      t / (E.MAX_CHUNKS_PER_OUTPUT * E.MAX_CHUNK_SIZE)
    );
  }
  /**
   * Estimate the number of 80-byte chunks for a given data size.
   *
   * @param dataSize Data size in bytes
   * @returns Number of 80-byte chunks needed
   */
  static estimateChunkCount(t) {
    return Math.ceil(t / E.MAX_CHUNK_SIZE);
  }
  /**
   * Validate that a witness script is a valid multi-hash committed script.
   *
   * Script structure: (OP_HASH160 <hash> OP_EQUALVERIFY)+ <pubkey> OP_CHECKSIG
   *
   * @param witnessScript The witness script to validate
   * @returns true if valid hash-committed script
   */
  static validateHashCommittedScript(t) {
    try {
      const e = R(t);
      if (!e || e.length < 5)
        return !1;
      const i = e.length - 1;
      if (e[i] !== g.OP_CHECKSIG)
        return !1;
      const r = e[i - 1];
      if (!a.isBuffer(r) || r.length !== 33)
        return !1;
      const s = e.slice(0, -2);
      if (s.length % 3 !== 0 || s.length === 0)
        return !1;
      for (let o = 0; o < s.length; o += 3) {
        const c = s[o + 1];
        if (s[o] !== g.OP_HASH160 || !a.isBuffer(c) || c.length !== 20 || s[o + 2] !== g.OP_EQUALVERIFY)
          return !1;
      }
      return !0;
    } catch {
      return !1;
    }
  }
  /**
   * Extract all data hashes from a hash-committed witness script.
   *
   * @param witnessScript The witness script
   * @returns Array of 20-byte data hashes (in data order), or null if invalid
   */
  static extractDataHashes(t) {
    try {
      const e = R(t);
      if (!e || !E.validateHashCommittedScript(t))
        return null;
      const i = e.slice(0, -2), r = [];
      for (let s = 0; s < i.length; s += 3)
        r.push(i[s + 1]);
      return r.reverse();
    } catch {
      return null;
    }
  }
  /**
   * Extract the public key from a hash-committed witness script.
   *
   * @param witnessScript The witness script
   * @returns The 33-byte public key, or null if invalid script
   */
  static extractPublicKey(t) {
    try {
      const e = R(t);
      return !e || !E.validateHashCommittedScript(t) ? null : e[e.length - 2];
    } catch {
      return null;
    }
  }
  /**
   * Verify that data chunks match their committed hashes.
   *
   * @param dataChunks Array of data chunks (in order)
   * @param witnessScript The witness script containing the hash commitments
   * @returns true if all chunks match their commitments
   */
  static verifyChunkCommitments(t, e) {
    const i = E.extractDataHashes(e);
    if (!i || i.length !== t.length)
      return !1;
    for (let r = 0; r < t.length; r++) {
      const s = dt(t[r]);
      if (!i[r].equals(s))
        return !1;
    }
    return !0;
  }
  /**
   * Estimate fees for a complete CHCT flow (setup + reveal).
   *
   * @param dataSize Data size in bytes (before compression)
   * @param feeRate Fee rate in sat/vB
   * @param compressionRatio Expected compression ratio (default: 0.7)
   * @returns Fee estimates
   */
  static estimateFees(t, e, i = 0.7) {
    const r = Math.ceil(t * i), s = E.estimateOutputCount(r), o = E.estimateChunkCount(r), c = 116, u = s * 43 + 43, l = 11 + c + u, d = 40 + s * E.WEIGHT_PER_INPUT + 200, p = Math.ceil(d / 4), f = BigInt(Math.ceil(l * e)), w = BigInt(Math.ceil(p * e)), S = f + w, b = BigInt(s) * E.MIN_OUTPUT_VALUE, _ = S + b;
    return {
      compressedSize: r,
      outputCount: s,
      chunkCount: o,
      setupVBytes: l,
      revealVBytes: p,
      setupFee: f,
      revealFee: w,
      totalFee: S,
      outputsValue: b,
      totalCost: _
    };
  }
  /**
   * Calculate the HASH160 of a data chunk.
   * HASH160 = RIPEMD160(SHA256(data))
   */
  hashChunk(t) {
    return dt(t);
  }
  /**
   * Generate a hash-committed witness script for multiple data chunks.
   *
   * Script structure (for N chunks):
   * OP_HASH160 <hash_N> OP_EQUALVERIFY
   * OP_HASH160 <hash_N-1> OP_EQUALVERIFY
   * ...
   * OP_HASH160 <hash_1> OP_EQUALVERIFY
   * <pubkey> OP_CHECKSIG
   *
   * Hashes are in reverse order because witness stack is LIFO.
   * Witness stack: [sig, data_1, data_2, ..., data_N, witnessScript]
   * Stack before execution: [sig, data_1, data_2, ..., data_N] (data_N on top)
   *
   * @param dataHashes Array of HASH160 values (in data order, will be reversed in script)
   * @returns The compiled witness script
   */
  generateWitnessScript(t) {
    if (t.length === 0)
      throw new Error("At least one data hash is required");
    if (t.length > E.MAX_CHUNKS_PER_OUTPUT)
      throw new Error(
        `Too many chunks: ${t.length} exceeds limit of ${E.MAX_CHUNKS_PER_OUTPUT}`
      );
    for (const i of t)
      if (i.length !== 20)
        throw new Error(`HASH160 requires 20-byte hash, got ${i.length}`);
    const e = [];
    for (let i = t.length - 1; i >= 0; i--)
      e.push(g.OP_HASH160), e.push(t[i]), e.push(g.OP_EQUALVERIFY);
    return e.push(this.publicKey), e.push(g.OP_CHECKSIG), L(e);
  }
  /**
   * Generate a P2WSH address from a witness script.
   *
   * @param witnessScript The witness script
   * @returns P2WSH address info
   */
  generateP2WSHAddress(t) {
    const e = lt({
      redeem: { output: t },
      network: this.network
    });
    if (!e.address || !e.output)
      throw new Error("Failed to generate P2WSH address");
    return {
      address: e.address,
      witnessScript: t,
      scriptPubKey: e.output
    };
  }
  /**
   * Split data into chunks and generate hash-committed P2WSH outputs.
   *
   * Each output commits to up to 98 data chunks (80 bytes each = 7,840 bytes).
   * This is MUCH more efficient than one output per chunk.
   *
   * @param data The data to chunk and commit
   * @param maxChunkSize Maximum bytes per stack item (default: 80, P2WSH stack item limit)
   * @returns Array of hash-committed P2WSH outputs
   */
  prepareChunks(t, e = E.MAX_CHUNK_SIZE) {
    if (e > E.MAX_CHUNK_SIZE)
      throw new Error(
        `Chunk size ${e} exceeds P2WSH stack item limit of ${E.MAX_CHUNK_SIZE}`
      );
    if (t.length === 0)
      throw new Error("Data cannot be empty");
    const i = [];
    let r = 0;
    for (; r < t.length; ) {
      const u = Math.min(e, t.length - r);
      i.push(a.from(t.subarray(r, r + u))), r += u;
    }
    const s = [];
    let o = 0;
    for (; o < i.length; ) {
      const u = i.slice(
        o,
        o + E.MAX_CHUNKS_PER_OUTPUT
      ), h = u, l = h.map((f) => this.hashChunk(f)), d = this.generateWitnessScript(l), p = this.generateP2WSHAddress(d);
      s.push({
        address: p.address,
        witnessScript: p.witnessScript,
        scriptPubKey: p.scriptPubKey,
        dataHashes: l,
        dataChunks: h,
        chunkStartIndex: o
      }), o += u.length;
    }
    const c = i.length;
    return this.log(
      `Prepared ${s.length} P2WSH outputs with ${c} chunks (${t.length} bytes, ~${Math.ceil(t.length / s.length)} bytes/output)`
    ), s;
  }
}
class Ji extends q {
  constructor(t, e = I) {
    super(t, a.alloc(0), e);
  }
  /**
   * Get the public key as a buffer
   * @param {Buffer[]} witnessKeys - The public keys
   * @param {Network} network - The network to use
   * @private
   * @returns {Buffer} - The public key as a buffer
   */
  static getPubKeyAsBuffer(t, e) {
    let i = a.alloc(0);
    for (const s of t) {
      if (!A.fromPublicKey(s, e).compressed)
        throw new Error("Public key must be compressed");
      if (s.byteLength !== 33)
        throw new Error(`Public key must be 33 bytes, got ${s.byteLength} bytes.`);
      i = a.concat([i, s]);
    }
    const r = N.compress(i);
    return r.byteLength >= i.byteLength ? i : r;
  }
  /**
   * Compile an interaction bitcoin script
   * @param {Buffer} calldata - The calldata to use
   * @param {Buffer} contractSecret - The contract secret
   * @param {Buffer} challenge - The challenge to use
   * @param {bigint} maxPriority - The maximum priority
   * @param {number[]} [featuresRaw=[]] - The features to use (optional)
   * @returns {Buffer} - The compiled script
   * @throws {Error} - If something goes wrong
   */
  compile(t, e, i, r, s = []) {
    const o = this.splitBufferIntoChunks(t);
    if (!o.length) throw new Error("No data chunks found");
    const c = [], u = [];
    if (s && s.length) {
      const f = s.sort(
        (S, b) => S.priority - b.priority
      ), w = new D();
      for (let S = 0; S < f.length; S++) {
        const b = f[S];
        c.push(b.opcode), this.encodeFeature(b, w);
      }
      u.push(...this.splitBufferIntoChunks(a.from(w.getBuffer())));
    }
    let h = [
      this.getHeader(r, c),
      g.OP_TOALTSTACK,
      // CHALLENGE PREIMAGE FOR REWARD,
      i,
      g.OP_TOALTSTACK,
      this.senderPubKey,
      g.OP_DUP,
      g.OP_HASH256,
      Y(this.senderPubKey),
      g.OP_EQUALVERIFY,
      g.OP_CHECKSIGVERIFY,
      e,
      g.OP_TOALTSTACK,
      g.OP_DEPTH,
      g.OP_1,
      g.OP_NUMEQUAL,
      g.OP_IF,
      q.MAGIC
    ];
    h = h.concat(
      ...u,
      g.OP_1NEGATE,
      ...o,
      g.OP_ELSE,
      g.OP_1,
      g.OP_ENDIF
    );
    const l = h.flat(), d = L(l);
    if (!R(d))
      throw new Error("Failed to decompile script??");
    return d;
  }
}
class Pt {
  static {
    this.MAXIMUM_SUPPORTED_SIGNATURE = 255;
  }
  static compile(t, e = 0, i) {
    if (e < 2)
      throw new Error("Minimum signatures must be greater than 1");
    if (t.length < e)
      throw new Error("The amount of public keys is lower than the minimum required");
    if (e > Pt.MAXIMUM_SUPPORTED_SIGNATURE)
      throw new Error(
        `The maximum amount of signatures is ${Pt.MAXIMUM_SUPPORTED_SIGNATURE}`
      );
    const r = a.alloc(1);
    r.writeUInt8(e), t = t.filter(
      (d, p, f) => p === f.findIndex((w) => d.equals(w))
    ), t = t.sort((d, p) => d.compare(p));
    let s = !1;
    const o = t.map((d) => {
      const p = O(d);
      return i && !s && (s = i.equals(p)), p;
    });
    i && !s && o.push(i);
    const u = [
      // Push the initial 0 (for OP_CHECKSIGADD)
      g.OP_0,
      // For each public key, add CHECKSIGADD operation
      ...o.flatMap((d) => [
        d,
        // Push the public key
        g.OP_CHECKSIGADD
        // Add the public key to the signature set
      ]),
      // Finally, compare the sum with the minimum required signatures
      r,
      g.OP_NUMEQUAL
      // Use NUMEQUALVERIFY to ensure the correct number of signatures
    ].flat(), h = L(u);
    if (!R(h))
      throw new Error("Failed to decompile script.");
    return h;
  }
}
class Et extends q {
  static {
    this.P2WDA_VERSION = 1;
  }
  constructor(t, e, i = I) {
    super(t, e, i);
  }
  /**
   * Validate that operation data will fit in P2WDA witness fields
   *
   * @param dataSize Size of the operation data
   * @param maxWitnessFields Maximum number of witness fields (default 10)
   * @param maxBytesPerWitness Maximum bytes per witness field (default 80)
   * @returns true if data will fit, false otherwise
   */
  static validateWitnessSize(t, e = 10, i = 80) {
    const o = t + 64, c = Math.ceil(o * 0.7);
    return Math.ceil(c / i) <= e;
  }
  /**
   * Compile operation data for P2WDA witness embedding
   *
   * This creates a binary structure containing all operation information
   * without Bitcoin script opcodes. The structure is:
   *
   * [version(1)] [header(12)] [contract(32)] [challenge_pubkey(33)] [challenge_solution(32)]
   * [calldata_length(4)] [calldata] [features_length(2)] [features_data]
   *
   * @param calldata The compressed calldata for the contract interaction
   * @param contractSecret The 32-byte contract secret
   * @param challenge The challenge solution for epoch rewards
   * @param maxPriority Maximum priority fee in satoshis
   * @param featuresRaw Optional features like access lists
   * @returns Raw operation data ready for signing and compression
   */
  compile(t, e, i, r, s = []) {
    if (!this.contractSaltPubKey)
      throw new Error("Contract salt public key not set");
    if (e.length !== 32)
      throw new Error("Contract secret must be exactly 32 bytes");
    const o = new D();
    o.writeU8(Et.P2WDA_VERSION);
    const c = s.sort((u, h) => u.priority - h.priority);
    return o.writeBytes(
      this.getHeader(
        r,
        c.map((u) => u.opcode)
      )
    ), o.writeBytes(e), o.writeBytes(i.publicKey.toBuffer()), o.writeBytes(i.solution), o.writeU32(t.length), o.writeBytes(t), this.writeFeatures(o, c), a.from(o.getBuffer());
  }
  getHeader(t, e = []) {
    return super.getHeader(t, e);
  }
  /**
   * Write features section to the operation data
   *
   * Features are encoded as:
   * [feature_count(2)] [feature1_opcode(1)] [feature1_length(4)] [feature1_data] ...
   *
   * @param writer Binary writer to write to
   * @param features Array of features to encode
   */
  writeFeatures(t, e) {
    t.writeU16(e.length);
    for (const i of e)
      t.writeU8(i.opcode), this.encodeFeature(i, t);
  }
}
ot(G);
class ae {
  // Generate a valid SegWit address from random bytes
  static generatePKSH(t, e) {
    if (t.length !== 32) throw new Error("Invalid hash length");
    const i = bi(t);
    return this.toSegwitAddress(i, e);
  }
  // Generate a valid Taproot address from a public key
  static generateTaprootAddress(t, e) {
    if (t.length !== 32) throw new Error("Invalid public key length");
    const i = Lt.bech32m.toWords(t);
    return i.unshift(1), Lt.bech32m.encode(e.bech32, i);
  }
  // Convert a hash to a SegWit address
  static toSegwitAddress(t, e) {
    const i = Lt.bech32.toWords(t);
    return i.unshift(0), Lt.bech32.encode(e.bech32, i);
  }
}
class tt {
  static {
    this.TAP_SCRIPT_VERSION = 192;
  }
  static getContractAddress(t) {
    const e = t.network || I, r = new Ft(
      t.deployerPubKey,
      O(t.contractSaltPubKey),
      e
    ).compile(
      t.bytecode,
      t.originalSalt,
      t.challenge,
      t.priorityFee,
      t.calldata,
      t.features
    ), s = L([
      O(t.deployerPubKey),
      g.OP_CHECKSIG
    ]), o = [
      {
        output: r,
        version: tt.TAP_SCRIPT_VERSION
      },
      {
        output: s,
        version: tt.TAP_SCRIPT_VERSION
      }
    ];
    return tt.generateAddressFromScript(t, o);
  }
  static verifyControlBlock(t, e) {
    const i = t.network || I, s = new Ft(
      t.deployerPubKey,
      O(t.contractSaltPubKey),
      i
    ).compile(
      t.bytecode,
      t.originalSalt,
      t.challenge,
      t.priorityFee,
      t.calldata,
      t.features
    ), o = L([
      O(t.deployerPubKey),
      g.OP_CHECKSIG
    ]), c = [
      {
        output: s,
        version: tt.TAP_SCRIPT_VERSION
      },
      {
        output: o,
        version: tt.TAP_SCRIPT_VERSION
      }
    ], h = rt({
      internalPubkey: O(t.deployerPubKey),
      network: i,
      scriptTree: c,
      redeem: {
        output: s,
        redeemVersion: tt.TAP_SCRIPT_VERSION
      }
    }).witness;
    return !h || h.length === 0 ? !1 : h[h.length - 1].equals(e);
  }
  static getContractSeed(t, e, i) {
    const r = Y(e), s = a.concat([t, i, r]);
    return Y(s);
  }
  static generateAddressFromScript(t, e) {
    const i = t.network || I, r = {
      internalPubkey: O(t.deployerPubKey),
      network: i,
      scriptTree: e
    };
    return rt(r).address;
  }
}
ot(G);
class ce {
  /**
   * Tweak a signer
   * @param {Signer} signer - The signer to tweak
   * @param {TweakSettings} opts - The tweak settings
   * @returns {ECPairInterface} - The tweaked signer
   */
  static tweakSigner(t, e = {}) {
    let i = t.privateKey;
    if (!i)
      throw new Error("Private key is required for tweaking signer!");
    t.publicKey[0] === 3 && (i = Kt.privateNegate(i));
    const r = Kt.privateAdd(
      i,
      Ii(O(a.from(t.publicKey)), e.tweakHash)
    );
    if (!r)
      throw new Error("Invalid tweaked private key!");
    return A.fromPrivateKey(a.from(r), e.network);
  }
}
function Ne(n) {
  return typeof n == "object" && n !== null && "web3" in n && typeof n.web3 == "object" && "getMLDSAPublicKey" in n.web3 && "signMLDSAMessage" in n.web3;
}
class tr {
  sha256(t) {
    return Ue(a.from(t));
  }
  /**
   * Attempts to sign a message using OP_WALLET if available in browser environment.
   * Returns null if not in browser or OP_WALLET is not available.
   * @param {Uint8Array | Buffer | string} message - The message to sign.
   * @returns {Promise<SignedMessage | null>} The Schnorr signature or null if OP_WALLET unavailable.
   */
  async trySignSchnorrWithOPWallet(t) {
    const e = this.getOPWallet();
    if (!e)
      return null;
    const i = typeof t == "string" ? a.from(t, "utf-8") : a.from(t), r = this.sha256(i), s = r.toString("hex"), o = await e.web3.signSchnorr(s);
    return {
      signature: a.from(o, "hex"),
      message: r
    };
  }
  /**
   * Attempts to sign a message using OP_WALLET ML-DSA if available.
   * Returns null if not in browser or OP_WALLET is not available.
   * @param {Uint8Array | Buffer | string} message - The message to sign.
   * @returns {Promise<MLDSASignedMessage | null>} The ML-DSA signature or null if OP_WALLET unavailable.
   */
  async trySignMLDSAWithOPWallet(t) {
    const e = this.getOPWallet();
    if (!e)
      return null;
    const i = typeof t == "string" ? a.from(t, "utf-8") : a.from(t), r = this.sha256(i), s = r.toString("hex"), o = await e.web3.signMLDSAMessage(s);
    return {
      signature: a.from(o.signature, "hex"),
      message: r,
      publicKey: a.from(o.publicKey, "hex"),
      securityLevel: o.securityLevel
    };
  }
  /**
   * Signs a message using Schnorr, automatically using OP_WALLET if available and no keypair provided.
   * @param {Uint8Array | Buffer | string} message - The message to sign.
   * @param {ECPairInterface} [keypair] - Optional keypair for local signing.
   * @returns {Promise<SignedMessage>} The Schnorr signature.
   * @throws {Error} If no keypair provided and OP_WALLET is not available.
   */
  async signMessageAuto(t, e) {
    if (!e) {
      const i = await this.trySignSchnorrWithOPWallet(t);
      if (i)
        return i;
      throw new Error("No keypair provided and OP_WALLET is not available.");
    }
    return this.signMessage(e, t);
  }
  /**
   * Signs a message with tweaking, automatically using OP_WALLET if available.
   * Note: OP_WALLET signSchnorr may already return a tweaked signature depending on wallet implementation.
   * @param {Uint8Array | Buffer | string} message - The message to sign.
   * @param {ECPairInterface} [keypair] - Optional keypair for local signing.
   * @param {Network} [network] - Network required when signing with a local keypair.
   * @returns {Promise<SignedMessage>} The Schnorr signature.
   * @throws {Error} If no keypair provided and OP_WALLET is not available.
   * @throws {Error} If keypair provided but network is missing.
   */
  async tweakAndSignMessageAuto(t, e, i) {
    if (!e) {
      const r = await this.trySignSchnorrWithOPWallet(t);
      if (r)
        return r;
      throw new Error("No keypair provided and OP_WALLET is not available.");
    }
    if (!i)
      throw new Error("Network is required when signing with a local keypair.");
    return this.tweakAndSignMessage(e, t, i);
  }
  /**
   * Signs an ML-DSA message, automatically using OP_WALLET if available.
   * @param {Uint8Array | Buffer | string} message - The message to sign.
   * @param {QuantumBIP32Interface} [mldsaKeypair] - Optional ML-DSA keypair for local signing.
   * @returns {Promise<MLDSASignedMessage>} The ML-DSA signature with metadata.
   * @throws {Error} If no keypair provided and OP_WALLET is not available.
   */
  async signMLDSAMessageAuto(t, e) {
    if (!e) {
      const i = await this.trySignMLDSAWithOPWallet(t);
      if (i)
        return i;
      throw new Error("No ML-DSA keypair provided and OP_WALLET is not available.");
    }
    return this.signMLDSAMessage(e, t);
  }
  /**
   * Verifies an ML-DSA signature using OP_WALLET if available.
   * Returns null if OP_WALLET is not available.
   * @param {Uint8Array | Buffer | string} message - The message to verify.
   * @param {MLDSASignedMessage} signature - The ML-DSA signature to verify.
   * @returns {Promise<boolean | null>} True if valid, false if invalid, null if OP_WALLET unavailable.
   */
  async verifyMLDSAWithOPWallet(t, e) {
    const i = this.getOPWallet();
    if (!i)
      return null;
    const r = typeof t == "string" ? a.from(t, "utf-8") : a.from(t), s = this.sha256(r), o = {
      signature: a.from(e.signature).toString("hex"),
      publicKey: a.from(e.publicKey).toString("hex"),
      securityLevel: e.securityLevel,
      messageHash: s.toString("hex")
    };
    return i.web3.verifyMLDSASignature(s.toString("hex"), o);
  }
  /**
   * Gets the ML-DSA public key from OP_WALLET if available.
   * Returns null if OP_WALLET is not available.
   * @returns {Promise<Buffer | null>} The ML-DSA public key or null if OP_WALLET unavailable.
   */
  async getMLDSAPublicKeyFromOPWallet() {
    const t = this.getOPWallet();
    if (!t)
      return null;
    const e = await t.web3.getMLDSAPublicKey();
    return a.from(e, "hex");
  }
  /**
   * Tweak the keypair and sign a message.
   * @param {ECPairInterface} keypair - The keypair to sign the message with. Must contain a private key.
   * @param {Uint8Array | Buffer | string} message - The message to sign.
   * @param {Network} network - The network to sign the message for.
   * @returns {SignedMessage} The Schnorr signature.
   */
  tweakAndSignMessage(t, e, i) {
    const r = ce.tweakSigner(t, { network: i });
    return this.signMessage(r, e);
  }
  /**
   * Signs a message using the provided keypair.
   * @param {ECPairInterface} keypair - The keypair to sign the message with. Must contain a private key.
   * @param {Uint8Array | Buffer | string} message - The message to sign.
   * @returns {SignedMessage} The Schnorr signature.
   * @throws {Error} If the private key is missing or invalid.
   */
  signMessage(t, e) {
    if (typeof e == "string" && (e = a.from(e, "utf-8")), !t.privateKey)
      throw new Error("Private key not found in keypair.");
    const i = this.sha256(e);
    return {
      signature: Kt.signSchnorr(i, t.privateKey),
      message: i
    };
  }
  /**
   * Verifies a Schnorr signature.
   * @param {Uint8Array | Buffer} publicKey - The public key as a Uint8Array or Buffer.
   * @param {Uint8Array | Buffer | string} message - The message to verify.
   * @param {Uint8Array | Buffer} signature - The signature to verify.
   * @returns {boolean} True if the signature is valid, false otherwise.
   * @throws {Error} If the signature length is invalid.
   */
  verifySignature(t, e, i) {
    if (typeof e == "string" && (e = a.from(e, "utf-8")), i.length !== 64)
      throw new Error("Invalid signature length.");
    const r = this.sha256(e);
    return Kt.verifySchnorr(r, O(a.from(t)), i);
  }
  /**
   * Tweak the public key and verify a signature.
   * @param {Uint8Array | Buffer} publicKey - The public key as a Uint8Array or Buffer.
   * @param {Uint8Array | Buffer | string} message - The message to verify.
   * @param {Uint8Array | Buffer} signature - The signature to verify.
   * @returns {boolean} True if the signature is valid, false otherwise.
   * @throws {Error} If the signature length is invalid.
   */
  tweakAndVerifySignature(t, e, i) {
    const r = A.tweakPublicKey(a.from(t));
    return this.verifySignature(r, e, i);
  }
  /**
   * Signs a message using ML-DSA signature scheme.
   * @param {QuantumBIP32Interface} mldsaKeypair - The ML-DSA keypair to sign with. Must contain a private key.
   * @param {Uint8Array | Buffer | string} message - The message to sign.
   * @returns {MLDSASignedMessage} The ML-DSA signature with metadata.
   * @throws {Error} If the private key is missing.
   */
  signMLDSAMessage(t, e) {
    if (typeof e == "string" && (e = a.from(e, "utf-8")), !t.privateKey)
      throw new Error("ML-DSA private key not found in keypair.");
    const i = this.sha256(e), r = t.sign(i);
    return {
      signature: a.from(r),
      message: i,
      publicKey: a.from(t.publicKey),
      securityLevel: t.securityLevel
    };
  }
  /**
   * Verifies an ML-DSA signature using the provided keypair.
   * @param {QuantumBIP32Interface} mldsaKeypair - The ML-DSA keypair with the public key.
   * @param {Uint8Array | Buffer | string} message - The message to verify.
   * @param {Uint8Array | Buffer} signature - The ML-DSA signature to verify.
   * @returns {boolean} True if the signature is valid, false otherwise.
   */
  verifyMLDSASignature(t, e, i) {
    typeof e == "string" && (e = a.from(e, "utf-8"));
    const r = this.sha256(e);
    return t.verify(r, i);
  }
  /**
   * Checks if OP_WALLET is available in the current environment.
   * @returns {boolean} True if OP_WALLET is available, false otherwise.
   */
  isOPWalletAvailable() {
    return this.getOPWallet() !== null;
  }
  getOPWallet() {
    if (typeof window > "u")
      return null;
    const t = window;
    return !t.opnet || !Ne(t.opnet) ? null : t.opnet;
  }
}
const st = new tr();
ot(G);
class Z {
  /**
   * Create a new Wallet instance
   *
   * @param privateKeyOrWif - Classical private key (hex or WIF format)
   * @param mldsaPrivateKeyOrBase58 - ML-DSA private key (hex format) or full base58 extended key
   * @param network - The Bitcoin network to use (default: bitcoin mainnet)
   * @param securityLevel - The ML-DSA security level (default: LEVEL2/44)
   * @param chainCode - Optional chain code for BIP32 derivation (32 bytes)
   * @throws {Error} If the private keys are invalid
   */
  constructor(t, e, i = I, r = P.MLDSASecurityLevel.LEVEL2, s) {
    this.network = i, this._securityLevel = r;
    const o = t.startsWith("0x") ? t.replace("0x", "") : t;
    K.isValidHex(o) ? this._keypair = A.fromPrivateKey(
      a.from(o, "hex"),
      this.network
    ) : this._keypair = A.fromWIF(o, this.network);
    const c = e.startsWith("0x") ? e.replace("0x", "") : e;
    if (K.isValidHex(c)) {
      const u = a.from(c, "hex"), h = P.getMLDSAConfig(r, this.network), l = h.privateKeySize, d = h.publicKeySize, p = l + d;
      let f;
      if (u.length === l)
        f = u;
      else if (u.length === p)
        f = u.subarray(0, l);
      else
        throw new Error(
          `Invalid ML-DSA key length for security level ${r}. Expected ${l} bytes (private only) or ${p} bytes (private+public), got ${u.length} bytes.`
        );
      if (s && s.length !== 32)
        throw new Error("Chain code must be 32 bytes");
      this._chainCode = s || a.alloc(32), this._mldsaKeypair = P.QuantumBIP32Factory.fromPrivateKey(
        f,
        this._chainCode,
        this.network,
        r
      );
    } else
      this._mldsaKeypair = P.QuantumBIP32Factory.fromBase58(c), this._chainCode = a.from(this._mldsaKeypair.chainCode), this._securityLevel = this._mldsaKeypair.securityLevel;
    this._bufferPubKey = this._keypair.publicKey, this._address = new k(this._mldsaKeypair.publicKey, this._keypair.publicKey), this._p2tr = this._address.p2tr(this.network), this._p2wpkh = this._address.p2wpkh(this.network), this._legacy = this._address.p2pkh(this.network), this._segwitLegacy = this._address.p2shp2wpkh(this.network), this._p2wda = this._address.p2wda(this.network), this._tweakedKey = this._address.tweakedPublicKeyToBuffer();
  }
  /**
   * Get the address for the wallet
   */
  get address() {
    return this._address;
  }
  /**
   * Get the tweaked public key for Taproot
   */
  get tweakedPubKeyKey() {
    return this._tweakedKey;
  }
  /**
   * Get the classical keypair for the wallet
   */
  get keypair() {
    if (!this._keypair) throw new Error("Keypair not set");
    return this._keypair;
  }
  /**
   * Get the quantum ML-DSA keypair
   */
  get mldsaKeypair() {
    return this._mldsaKeypair;
  }
  /**
   * Get the ML-DSA security level
   */
  get securityLevel() {
    return this._securityLevel;
  }
  /**
   * Get the chain code for BIP32 derivation
   */
  get chainCode() {
    return this._chainCode;
  }
  /**
   * Get the P2WPKH (Native SegWit) address
   */
  get p2wpkh() {
    return this._p2wpkh;
  }
  /**
   * Get the P2TR (Taproot) address
   */
  get p2tr() {
    return this._p2tr;
  }
  /**
   * Get the P2WDA address
   */
  get p2wda() {
    return this._p2wda;
  }
  /**
   * Get the legacy P2PKH address
   */
  get legacy() {
    return this._legacy;
  }
  /**
   * Get all addresses for the wallet
   */
  get addresses() {
    return [this.p2wpkh, this.p2tr, this.legacy, this.segwitLegacy];
  }
  /**
   * Get the legacy SegWit (P2SH-P2WPKH) address
   */
  get segwitLegacy() {
    return this._segwitLegacy;
  }
  /**
   * Get the classical public key
   */
  get publicKey() {
    if (!this._bufferPubKey) throw new Error("Public key not set");
    return this._bufferPubKey;
  }
  /**
   * Get the quantum ML-DSA public key
   */
  get quantumPublicKey() {
    return a.from(this._mldsaKeypair.publicKey);
  }
  /**
   * Get the quantum ML-DSA private key
   */
  get quantumPrivateKey() {
    if (!this._mldsaKeypair.privateKey)
      throw new Error("Quantum private key not set");
    return a.from(this._mldsaKeypair.privateKey);
  }
  /**
   * Get the quantum ML-DSA public key as hex string
   */
  get quantumPublicKeyHex() {
    return a.from(this._mldsaKeypair.publicKey).toString("hex");
  }
  /**
   * Get the quantum ML-DSA private key as hex string
   */
  get quantumPrivateKeyHex() {
    if (!this._mldsaKeypair.privateKey)
      throw new Error("Quantum private key not set");
    return a.from(this._mldsaKeypair.privateKey).toString("hex");
  }
  /**
   * Get the x-only public key for Taproot
   */
  get xOnly() {
    if (!this.keypair) throw new Error("Keypair not set");
    return O(this._bufferPubKey);
  }
  /**
   * Create a wallet from WIF strings
   *
   * @param wif - The classical WIF private key
   * @param quantumPrivateKeyHex - The quantum ML-DSA private key (hex)
   * @param network - The network (default: bitcoin mainnet)
   * @param securityLevel - The ML-DSA security level (default: LEVEL2/44)
   * @param chainCode - Optional chain code for BIP32 derivation
   * @returns A Wallet instance
   */
  static fromWif(t, e, i = I, r = P.MLDSASecurityLevel.LEVEL2, s) {
    return new Z(t, e, i, r, s);
  }
  /**
   * Generate a new random wallet with both classical and quantum keys
   *
   * @param network - The network (default: bitcoin mainnet)
   * @param securityLevel - The ML-DSA security level (default: LEVEL2/44)
   * @returns A new Wallet instance with randomly generated keys
   */
  static generate(t = I, e = P.MLDSASecurityLevel.LEVEL2) {
    const i = A.generateWallet(t, e);
    if (!i.quantumPrivateKey)
      throw new Error("Failed to generate quantum keys");
    return new Z(
      i.privateKey,
      i.quantumPrivateKey,
      t,
      e
    );
  }
  /**
   * Create a wallet from private key hex strings
   *
   * @param privateKeyHexOrWif - The classical private key
   * @param mldsaPrivateKeyOrBase58 - The quantum ML-DSA private key
   * @param network - The network (default: bitcoin mainnet)
   * @param securityLevel - The ML-DSA security level (default: LEVEL2/44)
   * @param chainCode - Optional chain code for BIP32 derivation
   * @returns A Wallet instance
   */
  static fromPrivateKeys(t, e, i = I, r = P.MLDSASecurityLevel.LEVEL2, s) {
    return new Z(
      t,
      e,
      i,
      r,
      s
    );
  }
  /**
   * Export the classical private key as WIF
   *
   * @returns The WIF-encoded private key
   */
  toWIF() {
    return this._keypair.toWIF();
  }
  /**
   * Export the classical private key as hex
   *
   * @returns The hex-encoded private key
   */
  toPrivateKeyHex() {
    if (!this._keypair.privateKey)
      throw new Error("Private key not available");
    return this._keypair.privateKey.toString("hex");
  }
  /**
   * Export the classical public key as hex
   *
   * @returns The hex-encoded public key
   */
  toPublicKeyHex() {
    return this._bufferPubKey.toString("hex");
  }
  /**
   * Export quantum keypair as base58 extended key
   *
   * @returns The base58-encoded extended quantum key
   */
  toQuantumBase58() {
    return this._mldsaKeypair.toBase58();
  }
  /**
   * Derive a child wallet using BIP32 path
   *
   * @param path - BIP32 derivation path (e.g., "m/0'/0/0")
   * @returns A new Wallet instance derived from this wallet
   * @throws {Error} If the private key is not available for derivation
   */
  derivePath(t) {
    const e = this._mldsaKeypair.derivePath(t);
    if (!this._keypair.privateKey)
      throw new Error("Cannot derive from a watch-only wallet (no private key available)");
    const r = A.BIP32.fromPrivateKey(
      this._keypair.privateKey,
      this._chainCode,
      this.network
    ).derivePath(t);
    if (!r.privateKey)
      throw new Error("Failed to derive classical private key");
    if (!r.chainCode)
      throw new Error("Failed to derive classical chain code");
    return new Z(
      a.from(r.privateKey).toString("hex"),
      e.toBase58(),
      this.network,
      this._securityLevel,
      a.from(r.chainCode)
    );
  }
}
var Rt = /* @__PURE__ */ ((n) => (n[n.MINIMUM = 128] = "MINIMUM", n[n.LOW = 160] = "LOW", n[n.MEDIUM = 192] = "MEDIUM", n[n.HIGH = 224] = "HIGH", n[n.MAXIMUM = 256] = "MAXIMUM", n))(Rt || {}), mt = /* @__PURE__ */ ((n) => (n[n.BIP44 = 44] = "BIP44", n[n.BIP49 = 49] = "BIP49", n[n.BIP84 = 84] = "BIP84", n[n.BIP86 = 86] = "BIP86", n))(mt || {});
function er(n) {
  switch (n) {
    case 44:
      return "BIP44: Legacy addresses (P2PKH), widely used by Unisat and other wallets";
    case 49:
      return "BIP49: Wrapped SegWit addresses (P2SH-P2WPKH)";
    case 84:
      return "BIP84: Native SegWit addresses (P2WPKH) - DEFAULT";
    case 86:
      return "BIP86: Taproot addresses (P2TR)";
    default:
      return "Unknown BIP standard";
  }
}
function He(n, t, e, i, r) {
  return `m/${n}'/${t}'/${e}'/${i}/${r}`;
}
ot(G);
const ir = P.BIP32Factory(G);
class ue {
  /**
   * Create a new Mnemonic instance from an existing phrase
   *
   * @param phrase - The BIP39 mnemonic phrase (12, 15, 18, 21, or 24 words)
   * @param passphrase - Optional BIP39 passphrase for additional security (default: '')
   * @param network - The Bitcoin network to use (default: bitcoin mainnet)
   * @param securityLevel - The ML-DSA security level for quantum keys (default: LEVEL2/44)
   * @throws {Error} If the mnemonic phrase is invalid
   */
  constructor(t, e = "", i = I, r = P.MLDSASecurityLevel.LEVEL2) {
    if (!pt.validateMnemonic(t))
      throw new Error("Invalid mnemonic phrase");
    this._phrase = t, this._passphrase = e, this._network = i, this._securityLevel = r, this._seed = pt.mnemonicToSeedSync(this._phrase, this._passphrase), this._classicalRoot = ir.fromSeed(this._seed, this._network), this._quantumRoot = P.QuantumBIP32Factory.fromSeed(
      this._seed,
      this._network,
      this._securityLevel
    );
  }
  /**
   * Get the mnemonic phrase
   *
   * @warning This phrase is highly sensitive and can be used to derive all keys in the wallet.
   * Handle with extreme care, never log or transmit insecurely, and store only in secure environments.
   *
   * @returns The BIP39 mnemonic phrase
   */
  get phrase() {
    return this._phrase;
  }
  /**
   * Get the network
   */
  get network() {
    return this._network;
  }
  /**
   * Get the ML-DSA security level
   */
  get securityLevel() {
    return this._securityLevel;
  }
  /**
   * Get the seed derived from the mnemonic phrase
   *
   * @warning This seed is highly sensitive and can be used to derive all keys in the wallet.
   * Handle with extreme care, never log or transmit insecurely, and store only in secure environments.
   *
   * @returns A copy of the seed buffer to prevent external modification
   */
  get seed() {
    return a.from(this._seed);
  }
  /**
   * Generate a new mnemonic phrase
   *
   * @param strength - The entropy strength in bits (default: 256 for 24 words)
   * @returns A new random mnemonic phrase
   */
  static generatePhrase(t = Rt.MAXIMUM) {
    return pt.generateMnemonic(t);
  }
  /**
   * Generate a new Mnemonic instance with a random phrase
   *
   * @param strength - The entropy strength in bits (default: 256 for 24 words)
   * @param passphrase - Optional BIP39 passphrase for additional security (default: '')
   * @param network - The Bitcoin network to use (default: bitcoin mainnet)
   * @param securityLevel - The ML-DSA security level for quantum keys (default: LEVEL2/44)
   * @returns A new Mnemonic instance
   */
  static generate(t = Rt.MAXIMUM, e = "", i = I, r = P.MLDSASecurityLevel.LEVEL2) {
    const s = pt.generateMnemonic(t);
    return new ue(s, e, i, r);
  }
  /**
   * Validate a mnemonic phrase
   *
   * @param phrase - The mnemonic phrase to validate
   * @returns True if the phrase is valid, false otherwise
   */
  static validate(t) {
    return pt.validateMnemonic(t);
  }
  /**
   * Derive a wallet at a specific index using BIP360 (quantum) and configurable BIP standard (classical) paths
   *
   * This method derives both classical ECDSA/Schnorr keys and quantum-resistant ML-DSA keys
   * for the wallet, providing hybrid post-quantum security.
   *
   * @param index - The address index to derive (default: 0)
   * @param account - The account index (default: 0)
   * @param isChange - Whether this is a change address (default: false)
   * @param bipStandard - The BIP standard to use for classical derivation (default: BIP84)
   * @returns A Wallet instance with both classical and quantum keys
   *
   * @example
   * ```typescript
   * // Default: BIP84 (Native SegWit)
   * const wallet1 = mnemonic.derive(0);
   *
   * // BIP44 (Compatible with Unisat)
   * const wallet2 = mnemonic.derive(0, 0, false, BIPStandard.BIP44);
   *
   * // BIP86 (Taproot)
   * const wallet3 = mnemonic.derive(0, 0, false, BIPStandard.BIP86);
   * ```
   */
  derive(t = 0, e = 0, i = !1, r = mt.BIP84) {
    const s = this.buildClassicalPath(e, t, i, r), o = this._classicalRoot.derivePath(s);
    if (!o.privateKey)
      throw new Error(`Failed to derive classical private key at index ${t}`);
    const c = this.buildQuantumPath(e, t, i), u = this._quantumRoot.derivePath(c);
    if (!u.privateKey)
      throw new Error(`Failed to derive quantum private key at index ${t}`);
    return new Z(
      a.from(o.privateKey).toString("hex"),
      a.from(u.privateKey).toString("hex"),
      this._network,
      this._securityLevel,
      a.from(this._quantumRoot.chainCode)
    );
  }
  /**
   * Derive a Unisat-compatible wallet
   *
   * Unisat uses different derivation paths based on address type:
   * - Legacy (P2PKH): m/44'/coinType'/account'/change/index
   * - Nested SegWit (P2SH-P2WPKH): m/49'/coinType'/account'/change/index
   * - Native SegWit (P2WPKH): m/84'/coinType'/account'/change/index
   * - Taproot (P2TR): m/86'/coinType'/account'/change/index
   *
   * @param addressType - The address type to generate
   * @param index - The address index (default: 0)
   * @param account - The account index (default: 0)
   * @param isChange - Whether this is a change address (default: false)
   * @returns A Wallet instance with both classical and quantum keys
   */
  deriveUnisat(t = J.P2TR, e = 0, i = 0, r = !1) {
    let s;
    switch (t) {
      case J.P2PKH:
        s = 44;
        break;
      case J.P2SH_OR_P2SH_P2WPKH:
        s = 49;
        break;
      case J.P2WPKH:
        s = 84;
        break;
      case J.P2TR:
        s = 86;
        break;
      default:
        throw new Error(`Unsupported address type: ${t}`);
    }
    const o = this.getCoinType(), c = r ? 1 : 0, u = `m/${s}'/0'/${i}'/${c}/${e}`, h = this._classicalRoot.derivePath(u);
    if (!h.privateKey)
      throw new Error(`Failed to derive classical private key at path ${u}`);
    const l = `m/360'/${o}'/${i}'/${c}/${e}`, d = this._quantumRoot.derivePath(l);
    if (!d.privateKey)
      throw new Error(`Failed to derive quantum private key at path ${l}`);
    return new Z(
      a.from(h.privateKey).toString("hex"),
      a.from(d.privateKey).toString("hex"),
      this._network,
      this._securityLevel,
      a.from(this._quantumRoot.chainCode)
    );
  }
  /**
   * Derive multiple Unisat-compatible wallets
   *
   * @param addressType - The address type to generate
   * @param count - Number of wallets to derive
   * @param startIndex - Starting index (default: 0)
   * @param account - The account index (default: 0)
   * @param isChange - Whether these are change addresses (default: false)
   * @returns Array of Wallet instances
   */
  deriveMultipleUnisat(t = J.P2TR, e = 5, i = 0, r = 0, s = !1) {
    const o = [];
    for (let c = 0; c < e; c++)
      o.push(this.deriveUnisat(t, i + c, r, s));
    return o;
  }
  /**
   * Derive multiple wallets with sequential indices
   *
   * @param count - The number of wallets to derive
   * @param startIndex - The starting address index (default: 0)
   * @param account - The account index (default: 0)
   * @param isChange - Whether these are change addresses (default: false)
   * @param bipStandard - The BIP standard to use for classical derivation (default: BIP84)
   * @returns An array of Wallet instances
   */
  deriveMultiple(t, e = 0, i = 0, r = !1, s = mt.BIP84) {
    const o = [];
    for (let c = 0; c < t; c++)
      o.push(this.derive(e + c, i, r, s));
    return o;
  }
  /**
   * Derive a wallet using a custom derivation path
   *
   * @param classicalPath - The BIP32 path for classical keys (e.g., "m/84'/0'/0'/0/0")
   * @param quantumPath - The BIP360 path for quantum keys (e.g., "m/360'/0'/0'/0/0")
   * @returns A Wallet instance
   */
  deriveCustomPath(t, e) {
    const i = this._classicalRoot.derivePath(t), r = this._quantumRoot.derivePath(e);
    if (!i.privateKey)
      throw new Error(`Failed to derive classical private key at path ${t}`);
    if (!r.privateKey)
      throw new Error(`Failed to derive quantum private key at path ${e}`);
    return new Z(
      a.from(i.privateKey).toString("hex"),
      a.from(r.privateKey).toString("hex"),
      this._network,
      this._securityLevel,
      a.from(this._quantumRoot.chainCode)
    );
  }
  /**
   * Get the classical BIP32 root
   *
   * @returns The classical BIP32Interface for manual derivation
   */
  getClassicalRoot() {
    return this._classicalRoot;
  }
  /**
   * Get the quantum BIP32 root
   *
   * @returns The quantum BIP32Interface for manual derivation
   */
  getQuantumRoot() {
    return this._quantumRoot;
  }
  /**
   * Build a classical derivation path using specified BIP standard
   *
   * @param account - The account index
   * @param index - The address index
   * @param isChange - Whether this is a change address
   * @param bipStandard - The BIP standard to use (default: BIP84)
   * @returns The derivation path string
   */
  buildClassicalPath(t, e, i, r = mt.BIP84) {
    const s = this.getCoinType();
    return He(r, s, t, i ? 1 : 0, e);
  }
  /**
   * Build a quantum derivation path (BIP360)
   *
   * @param account - The account index
   * @param index - The address index
   * @param isChange - Whether this is a change address
   * @returns The derivation path string
   */
  buildQuantumPath(t, e, i) {
    return `m/360'/${this.getCoinType()}'/${t}'/${i ? 1 : 0}/${e}`;
  }
  /**
   * Get the coin type based on the network
   *
   * @returns The coin type (0 for mainnet, 1 for testnet/regtest)
   */
  getCoinType() {
    return this._network.bech32 === At.bech32 || this._network.bech32 === zt.bech32 ? 1 : 0;
  }
}
var Ve = /* @__PURE__ */ ((n) => (n[n.MLDSA44 = 1312] = "MLDSA44", n[n.MLDSA65 = 1952] = "MLDSA65", n[n.MLDSA87 = 2592] = "MLDSA87", n))(Ve || {});
function ee(n) {
  switch (n) {
    case 1312:
      return P.MLDSASecurityLevel.LEVEL2;
    case 1952:
      return P.MLDSASecurityLevel.LEVEL3;
    case 2592:
      return P.MLDSASecurityLevel.LEVEL5;
    default:
      throw new Error(`Invalid MLDSA public key length: ${n}`);
  }
}
class rr {
  constructor(t = I) {
    this.network = t;
  }
  /**
   * @description Get the contract address
   * @param {Network} network - The network to get the address for
   */
  static getAddress(t = I) {
    throw new Error("Method not implemented.");
  }
  /**
   * @description Get the contract address
   */
  getAddress() {
    return this.address;
  }
}
var he = /* @__PURE__ */ ((n) => (n[n.Bitcoin = 0] = "Bitcoin", n[n.Fractal = 1] = "Fractal", n))(he || {});
function ze(n) {
  return new Map(n);
}
function sr(n) {
  return {
    enabled: !0,
    signerMap: n instanceof Map ? n : ze(n)
  };
}
function nr() {
  return {
    enabled: !1,
    signerMap: /* @__PURE__ */ new Map()
  };
}
var y = /* @__PURE__ */ ((n) => (n[n.GENERIC = 0] = "GENERIC", n[n.FUNDING = 1] = "FUNDING", n[n.DEPLOYMENT = 2] = "DEPLOYMENT", n[n.INTERACTION = 3] = "INTERACTION", n[n.MULTI_SIG = 4] = "MULTI_SIG", n[n.CUSTOM_CODE = 5] = "CUSTOM_CODE", n[n.CANCEL = 6] = "CANCEL", n[n.CONSOLIDATED_SETUP = 7] = "CONSOLIDATED_SETUP", n[n.CONSOLIDATED_REVEAL = 8] = "CONSOLIDATED_REVEAL", n))(y || {}), Bt = /* @__PURE__ */ ((n) => (n[n.Roswell = 0] = "Roswell", n[n.Rachel = 1] = "Rachel", n[n.Kecksburg = 2] = "Kecksburg", n[n.Phoenix = 3] = "Phoenix", n[n.Aurora = 4] = "Aurora", n[n.Rendlesham = 5] = "Rendlesham", n[n.Lazar = 6] = "Lazar", n[n.ShagHarbor = 7] = "ShagHarbor", n[n.Exeter = 8] = "Exeter", n[n.Stephenville = 9] = "Stephenville", n[n.Valensole = 10] = "Valensole", n[n.Socorro = 11] = "Socorro", n[n.Pascagoula = 12] = "Pascagoula", n[n.Tehran = 13] = "Tehran", n[n.Westall = 14] = "Westall", n[n.Hopkinsville = 15] = "Hopkinsville", n[n.Belgium = 16] = "Belgium", n[n.Breeze = 17] = "Breeze", n[n.Flatwoods = 18] = "Flatwoods", n[n.Maury = 20] = "Maury", n[n.Varginha = 21] = "Varginha", n[n.Trindade = 22] = "Trindade", n[n.Levelland = 23] = "Levelland", n[n.Wanaque = 24] = "Wanaque", n[n.Coyame = 25] = "Coyame", n[n.Delphos = 26] = "Delphos", n))(Bt || {});
const qe = {
  CONSENSUS: Bt.Roswell,
  CONSENSUS_NAME: "Roswell",
  // The block height at which this consensus was enabled.
  ENABLED_AT_BLOCK: 0n
  // Defines the minimum amount that can be consolidated in a single transaction.
  //VAULT_MINIMUM_AMOUNT: 200000n,
  // Defines the requested minimum acceptance for joining UTXOs when an unwrap is being done.
  // If the consolidate output going back to the vault is lower than this amount, the transaction will be rejected.
  // User must pay for the consolidation, this help the network by having fewer UTXOs.
  //VAULT_NETWORK_CONSOLIDATION_ACCEPTANCE: 200000n * 2n,
  // Everytime an user wrap bitcoin, he prepays the fees for the consolidation at a maximum fee rate of the following determined value.
  // If the fees are lower, the user will be refunded the difference.
  // If the fees are higher, the user must pay the difference.
  //UNWRAP_CONSOLIDATION_PREPAID_FEES: 250n,
  // Equivalent to 56500 satoshis, calculated from UNWRAP_CONSOLIDATION_PREPAID_FEES.
  //UNWRAP_CONSOLIDATION_PREPAID_FEES_SAT: 56500n,
}, $e = {
  [Bt.Roswell]: qe
}, $t = Bt.Roswell, or = $e[$t];
function ie(n) {
  let t = a.allocUnsafe(0);
  function e(o) {
    t = a.concat([t, a.from(o)]);
  }
  function i(o) {
    const c = t.length, u = fi(o);
    t = a.concat([t, a.allocUnsafe(u)]), pi(o, t, c);
  }
  function r(o) {
    i(o.length), e(o);
  }
  function s(o) {
    i(o.length), o.forEach(r);
  }
  return s(n), t;
}
function le(n) {
  return n && !!(n.tapInternalKey || n.tapMerkleRoot || n.tapLeafScript && n.tapLeafScript.length || n.tapBip32Derivation && n.tapBip32Derivation.length || n.witnessUtxo && _e(n.witnessUtxo.script));
}
function ar(n) {
  return n.redeemScript ? n.redeemScript : n.witnessScript ? n.witnessScript : n.witnessUtxo ? n.witnessUtxo.script : (n.nonWitnessUtxo, null);
}
function de(n, t) {
  if (n.nonWitnessUtxo && !n.redeemScript && !n.witnessScript && !n.witnessUtxo || n.redeemScript)
    return !0;
  const e = ar(n);
  return e ? fe(t, e) : !1;
}
function fe(n, t) {
  return Ti(n, t) !== -1;
}
var Xe = /* @__PURE__ */ ((n) => (n[n.REPLACE_BY_FEE = 4294967293] = "REPLACE_BY_FEE", n[n.FINAL = 4294967295] = "FINAL", n))(Xe || {}), Ye = /* @__PURE__ */ ((n) => (n[n.BLOCKS = 0] = "BLOCKS", n[n.TIMESTAMPS = 1] = "TIMESTAMPS", n))(Ye || {});
class Xt extends ve {
  constructor(t) {
    super(), this.logColor = "#00ffe1", this.finalized = !1, this.signed = !1, this.scriptData = null, this.tapData = null, this.inputs = [], this.sequence = 4294967293, this.tapLeafScript = null, this.isBrowser = !1, this.csvInputIndices = /* @__PURE__ */ new Set(), this.anchorInputIndices = /* @__PURE__ */ new Set(), this.regenerated = !1, this.ignoreSignatureErrors = !1, this.noSignatures = !1, this.txVersion = 2, this._mldsaSigner = null, this._hashedPublicKey = null, this.addressRotationEnabled = !1, this.signerMap = /* @__PURE__ */ new Map(), this.inputSignerMap = /* @__PURE__ */ new Map(), this.tweakedSignerCache = /* @__PURE__ */ new Map(), this.customFinalizerP2SH = (e, i, r, s, o, c) => {
      const u = this.inputs[e];
      if (o && i.partialSig && u && u.redeemScript) {
        const h = i.partialSig.map((d) => d.signature) || [];
        return {
          finalScriptSig: L([...h, u.redeemScript]),
          finalScriptWitness: void 0
        };
      }
      if (this.anchorInputIndices.has(e))
        return {
          finalScriptSig: void 0,
          finalScriptWitness: T.from([0])
        };
      if (c && s && i.witnessScript) {
        if (!i.partialSig || i.partialSig.length === 0)
          throw new Error(`No signatures for P2WSH input #${e}`);
        if (z.isP2WDAWitnessScript(i.witnessScript))
          return this.finalizeSecondaryP2WDA(e, i);
        if (this.csvInputIndices.has(e)) {
          const d = [i.partialSig[0].signature, i.witnessScript];
          return {
            finalScriptSig: void 0,
            finalScriptWitness: ie(d)
          };
        }
      }
      return Ke(
        e,
        i,
        r,
        s,
        o,
        c,
        !0,
        this.unlockScript
      );
    }, this.signer = t.signer, this.network = t.network, this.noSignatures = t.noSignatures || !1, this.nonWitnessUtxo = t.nonWitnessUtxo, this.unlockScript = t.unlockScript, this.isBrowser = typeof window < "u", t.txVersion && (this.txVersion = t.txVersion), t.mldsaSigner && (this._mldsaSigner = t.mldsaSigner, this._hashedPublicKey = st.sha256(this._mldsaSigner.publicKey)), t.addressRotation?.enabled && (this.addressRotationEnabled = !0, this.signerMap = t.addressRotation.signerMap);
  }
  /**
   * Get the MLDSA signer
   * @protected
   */
  get mldsaSigner() {
    if (!this._mldsaSigner)
      throw new Error("MLDSA Signer is not set");
    return this._mldsaSigner;
  }
  /**
   * Get the hashed public key
   * @protected
   */
  get hashedPublicKey() {
    if (!this._hashedPublicKey)
      throw new Error("Hashed public key is not set");
    return this._hashedPublicKey;
  }
  /**
   * Read witnesses
   * @protected
   */
  static readScriptWitnessToWitnessStack(t) {
    let e = 0;
    function i(c) {
      const u = T.from(t.subarray(e, e + c));
      return e += c, u;
    }
    function r() {
      const c = gi(t, e);
      return e += c.bytes, c.numberValue || 0;
    }
    function s() {
      const c = r();
      return i(c);
    }
    function o() {
      const c = r(), u = [];
      for (let h = 0; h < c; h++)
        u.push(s());
      return u;
    }
    return o();
  }
  /**
   * Pre-estimate the transaction fees for a Taproot transaction
   * @param {bigint} feeRate - The fee rate in satoshis per virtual byte
   * @param {bigint} numInputs - The number of inputs
   * @param {bigint} numOutputs - The number of outputs
   * @param {bigint} numWitnessElements - The number of witness elements (e.g., number of control blocks and witnesses)
   * @param {bigint} witnessElementSize - The average size of each witness element in bytes
   * @param {bigint} emptyWitness - The amount of empty witnesses
   * @param {bigint} [taprootControlWitnessSize=139n] - The size of the control block witness in bytes
   * @param {bigint} [taprootScriptSize=32n] - The size of the taproot script in bytes
   * @returns {bigint} - The estimated transaction fees
   */
  static preEstimateTaprootTransactionFees(t, e, i, r, s, o, c = 32n, u = 139n) {
    const h = 10n, l = 41n, d = 68n, p = 1n, f = h + l * e + d * i, w = e * p + r * s + c * e + u * e + o;
    return (f * 3n + (f + w)) / 4n * t;
  }
  static signInput(t, e, i, r, s) {
    s && s[0] && (e.sighashType = s[0]), t.signInput(i, r, s.length ? s : void 0);
  }
  /**
   * Calculate the sign hash number
   * @description Calculates the sign hash
   * @protected
   * @returns {number}
   */
  static calculateSignHash(t) {
    if (!t)
      throw new Error("Sighash types are required");
    let e = 0;
    for (const i of t)
      e |= i;
    return e || 0;
  }
  /**
   * Check if address rotation mode is enabled.
   */
  isAddressRotationEnabled() {
    return this.addressRotationEnabled;
  }
  ignoreSignatureError() {
    this.ignoreSignatureErrors = !0;
  }
  /**
   * @description Returns the script address
   * @returns {string}
   */
  getScriptAddress() {
    if (!this.scriptData || !this.scriptData.address)
      throw new Error("Tap data is required");
    return this.scriptData.address;
  }
  /**
   * @description Returns the transaction
   * @returns {Transaction}
   */
  getTransaction() {
    return this.transaction.extractTransaction(!1);
  }
  /**
   * @description Returns the tap address
   * @returns {string}
   * @throws {Error} - If tap data is not set
   */
  getTapAddress() {
    if (!this.tapData || !this.tapData.address)
      throw new Error("Tap data is required");
    return this.tapData.address;
  }
  /**
   * @description Disables replace by fee on the transaction
   */
  disableRBF() {
    if (this.signed) throw new Error("Transaction is already signed");
    this.sequence = 4294967295;
    for (const t of this.inputs)
      this.csvInputIndices.has(this.inputs.indexOf(t)) || (t.sequence = 4294967295);
  }
  /**
   * Get the tweaked hash
   * @private
   *
   * @returns {Buffer | undefined} The tweaked hash
   */
  getTweakerHash() {
    return this.tapData?.hash;
  }
  /**
   * Pre-estimate the transaction fees
   * @param {bigint} feeRate - The fee rate
   * @param {bigint} numInputs - The number of inputs
   * @param {bigint} numOutputs - The number of outputs
   * @param {bigint} numSignatures - The number of signatures
   * @param {bigint} numPubkeys - The number of public keys
   * @returns {bigint} - The estimated transaction fees
   */
  preEstimateTransactionFees(t, e, i, r, s) {
    const o = 10n, c = 41n, u = 68n, h = 144n, l = 34n, d = o + c * e + u * i, p = 1n + s * (1n + l) + 1n + r, f = r * h + s * l + p;
    return (d * 3n + (d + f)) / 4n * t;
  }
  /**
   * Get the signer for a specific input index.
   * Returns the input-specific signer if in rotation mode, otherwise the default signer.
   * @param inputIndex - The index of the input
   */
  getSignerForInput(t) {
    if (this.addressRotationEnabled) {
      const e = this.inputSignerMap.get(t);
      if (e)
        return e;
    }
    return this.signer;
  }
  /**
   * Register a signer for a specific input index.
   * Called during UTXO processing to map each input to its signer.
   * @param inputIndex - The index of the input
   * @param utxo - The UTXO being added
   */
  registerInputSigner(t, e) {
    if (!this.addressRotationEnabled)
      return;
    if (e.signer) {
      this.inputSignerMap.set(t, e.signer);
      return;
    }
    const i = e.scriptPubKey?.address;
    if (i && this.signerMap.has(i)) {
      const r = this.signerMap.get(i);
      if (r) {
        this.inputSignerMap.set(t, r);
        return;
      }
    }
  }
  /**
   * Get the x-only public key for a specific input's signer.
   * Used for taproot inputs in address rotation mode.
   * @param inputIndex - The index of the input
   */
  internalPubKeyToXOnlyForInput(t) {
    const e = this.getSignerForInput(t);
    return O(T.from(e.publicKey));
  }
  /**
   * Get the tweaked signer for a specific input.
   * Caches the result for efficiency.
   * @param inputIndex - The index of the input
   * @param useTweakedHash - Whether to use the tweaked hash
   */
  getTweakedSignerForInput(t, e = !1) {
    if (!this.addressRotationEnabled)
      return e ? (this.tweakSigner(), this.tweakedSigner) : this.getTweakedSigner(e);
    const i = t * 2 + (e ? 1 : 0);
    if (this.tweakedSignerCache.has(i))
      return this.tweakedSignerCache.get(i);
    const r = this.getSignerForInput(t), s = this.getTweakedSigner(e, r);
    return this.tweakedSignerCache.set(i, s), s;
  }
  generateTapData() {
    return {
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      name: v.P2TR
    };
  }
  /**
   * Generates the script address.
   * @protected
   * @returns {Payment}
   */
  generateScriptAddress() {
    return {
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      name: v.P2TR
    };
  }
  /**
   * Returns the signer key.
   * @protected
   * @returns {Signer | ECPairInterface}
   */
  getSignerKey() {
    return this.signer;
  }
  /**
   * Signs an input of the transaction.
   * @param {Psbt} transaction - The transaction to sign
   * @param {PsbtInput} input - The input to sign
   * @param {number} i - The index of the input
   * @param {Signer} signer - The signer to use
   * @param {boolean} [reverse=false] - Should the input be signed in reverse
   * @param {boolean} [errored=false] - Was there an error
   * @protected
   */
  async signInput(t, e, i, r, s = !1, o = !1) {
    if (this.anchorInputIndices.has(i)) return;
    const c = r.publicKey;
    let u = le(e);
    s && (u = !u);
    let h = !1, l = !1;
    if (u)
      try {
        await this.attemptSignTaproot(t, e, i, r, c), h = !0;
      } catch (d) {
        this.error(
          `Failed to sign Taproot script path input ${i} (reverse: ${s}): ${d.message}`
        ), l = !0;
      }
    else if (s || de(e, c))
      try {
        await this.signNonTaprootInput(r, t, i), h = !0;
      } catch (d) {
        this.error(`Failed to sign non-Taproot input ${i}: ${d.stack}`), l = !0;
      }
    if (!h) {
      if (l && o)
        throw new Error(`Failed to sign input ${i} with the provided signer.`);
      try {
        await this.signInput(t, e, i, r, !0, l);
      } catch {
        throw new Error(`Cannot sign input ${i} with the provided signer.`);
      }
    }
  }
  splitArray(t, e) {
    if (e <= 0)
      throw new Error("Chunk size must be greater than 0.");
    const i = [];
    for (let r = 0; r < t.length; r += e)
      i.push(t.slice(r, r + e));
    return i;
  }
  /**
   * Signs all the inputs of the transaction.
   * @param {Psbt} transaction - The transaction to sign
   * @protected
   * @returns {Promise<void>}
   */
  async signInputs(t) {
    if ("multiSignPsbt" in this.signer) {
      await this.signInputsWalletBased(t);
      return;
    }
    await this.signInputsNonWalletBased(t);
  }
  async signInputsNonWalletBased(t) {
    const e = t.data.inputs, i = 20, r = this.splitArray(e, i);
    if (!this.noSignatures)
      for (let s = 0; s < r.length; s++) {
        const o = r[s], c = [], u = s * i;
        for (let h = 0; h < o.length; h++) {
          const l = u + h, d = o[h];
          try {
            const p = this.getSignerForInput(l);
            c.push(this.signInput(t, d, l, p));
          } catch (p) {
            this.log(`Failed to sign input ${l}: ${p.stack}`);
          }
        }
        await Promise.all(c);
      }
    for (let s = 0; s < t.data.inputs.length; s++)
      t.finalizeInput(s, this.customFinalizerP2SH.bind(this));
    this.finalized = !0;
  }
  /**
   * Converts the public key to x-only.
   * @protected
   * @returns {Buffer}
   */
  internalPubKeyToXOnly() {
    return O(T.from(this.signer.publicKey));
  }
  /**
   * Internal init.
   * @protected
   */
  internalInit() {
    this.scriptData = rt(this.generateScriptAddress()), this.tapData = rt(this.generateTapData());
  }
  /**
   * Tweak the signer for the interaction
   * @protected
   */
  tweakSigner() {
    this.tweakedSigner || (this.tweakedSigner = this.getTweakedSigner(!0));
  }
  /**
   * Get the tweaked signer
   * @private
   * @returns {ECPairInterface} The tweaked signer
   */
  getTweakedSigner(t = !1, e = this.signer) {
    const i = {
      network: this.network
    };
    if (t && (i.tweakHash = this.getTweakerHash()), "privateKey" in e)
      return ce.tweakSigner(e, i);
  }
  generateP2SHRedeemScript(t) {
    const e = lt({
      redeem: { output: t },
      network: this.network
    });
    return gt({
      redeem: e,
      network: this.network
    }).output;
  }
  generateP2SHRedeemScriptLegacy(t) {
    const e = dt(this.signer.publicKey), i = L([
      g.OP_DUP,
      g.OP_HASH160,
      e,
      g.OP_EQUALVERIFY,
      g.OP_CHECKSIG
    ]), r = dt(i), s = L([
      g.OP_HASH160,
      r,
      g.OP_EQUAL
    ]), o = lt({
      redeem: { output: i },
      // Use the custom redeem script
      network: this.network
    }), c = gt({
      redeem: o,
      // The P2WSH is wrapped inside the P2SH
      network: this.network
    });
    if (ke(s, this.network) === t && c.redeem && c.redeem.output)
      return {
        redeemScript: i,
        outputScript: c.redeem.output
      };
  }
  generateP2SHP2PKHRedeemScript(t, e) {
    const i = this.addressRotationEnabled && e !== void 0 ? this.getSignerForInput(e) : this.signer, r = T.isBuffer(i.publicKey) ? i.publicKey : T.from(i.publicKey, "hex"), s = jt({
      pubkey: r,
      network: this.network
    }), o = gt({
      redeem: s,
      network: this.network
    }), c = o.address;
    if (!o.redeem?.output)
      throw new Error("Failed to generate P2SH-P2WPKH redeem script");
    if (c === t && o.redeem && o.redeem.output && o.output)
      return {
        redeemScript: o.redeem.output,
        outputScript: o.output
      };
  }
  /**
   * Generate the PSBT input extended, supporting various script types
   * @param {UTXO} utxo The UTXO
   * @param {number} i The index of the input
   * @param {UTXO} _extra Extra UTXO
   * @protected
   * @returns {PsbtInputExtended} The PSBT input extended
   */
  generatePsbtInputExtended(t, e, i = !1) {
    const r = T.from(t.scriptPubKey.hex, "hex"), s = {
      hash: t.transactionId,
      index: t.outputIndex,
      sequence: this.sequence,
      witnessUtxo: {
        value: Number(t.value),
        script: r
      }
    };
    if (Pi(r))
      if (t.nonWitnessUtxo)
        s.nonWitnessUtxo = T.isBuffer(t.nonWitnessUtxo) ? t.nonWitnessUtxo : T.from(t.nonWitnessUtxo, "hex");
      else
        throw new Error("Missing nonWitnessUtxo for P2PKH UTXO");
    else if (!(Pe(r) || Ei(r))) if (Ee(r))
      this.processP2WSHInput(t, s, e);
    else if (Ai(r)) {
      let o;
      if (t.redeemScript)
        o = T.isBuffer(t.redeemScript) ? t.redeemScript : T.from(t.redeemScript, "hex");
      else {
        if (!t.scriptPubKey.address)
          throw new Error(
            "Missing redeemScript and no address to regenerate it for P2SH UTXO"
          );
        const h = this.generateP2SHP2PKHRedeemScript(
          t.scriptPubKey.address,
          e
        );
        if (!h)
          throw new Error("Missing redeemScript for P2SH UTXO and unable to regenerate");
        o = h.redeemScript;
      }
      s.redeemScript = o;
      const c = gt({ redeem: { output: s.redeemScript } });
      if (!c.redeem)
        throw new Error("Failed to extract redeem script from P2SH UTXO");
      const u = c.redeem.output;
      if (!u)
        throw new Error("Failed to extract redeem output from P2SH UTXO");
      t.nonWitnessUtxo && (s.nonWitnessUtxo = T.isBuffer(t.nonWitnessUtxo) ? t.nonWitnessUtxo : T.from(t.nonWitnessUtxo, "hex")), Pe(u) ? delete s.nonWitnessUtxo : Ee(u) ? (delete s.nonWitnessUtxo, this.processP2WSHInput(t, s, e)) : delete s.witnessUtxo;
    } else if (_e(r)) {
      if (this.sighashTypes) {
        const o = Xt.calculateSignHash(this.sighashTypes);
        o && (s.sighashType = o);
      }
      this.addressRotationEnabled ? s.tapInternalKey = this.internalPubKeyToXOnlyForInput(e) : (this.tweakSigner(), s.tapInternalKey = this.internalPubKeyToXOnly());
    } else if (Oi(r))
      this.anchorInputIndices.add(e), s.isPayToAnchor = !0;
    else if (Bi(r) || xi(r))
      if (t.nonWitnessUtxo)
        s.nonWitnessUtxo = T.isBuffer(t.nonWitnessUtxo) ? t.nonWitnessUtxo : T.from(t.nonWitnessUtxo, "hex");
      else
        throw new Error("Missing nonWitnessUtxo for P2PK or P2MS UTXO");
    else
      this.error(`Unknown or unsupported script type for output: ${t.scriptPubKey.hex}`);
    return e === 0 && (this.tapLeafScript && (s.tapLeafScript = [this.tapLeafScript]), this.nonWitnessUtxo && (s.nonWitnessUtxo = this.nonWitnessUtxo)), s;
  }
  processP2WSHInput(t, e, i) {
    if (!t.witnessScript)
      throw new Error("Missing witnessScript for P2WSH UTXO");
    e.witnessScript = T.isBuffer(t.witnessScript) ? t.witnessScript : T.from(t.witnessScript, "hex");
    const r = R(e.witnessScript);
    if (r && this.isCSVScript(r)) {
      const s = R(e.witnessScript);
      if (s && this.isCSVScript(s)) {
        this.csvInputIndices.add(i);
        const o = this.extractCSVBlocks(s);
        e.sequence = this.setCSVSequence(o, this.sequence);
      }
    }
  }
  secondsToCSVTimeUnits(t) {
    return Math.floor(t / 512);
  }
  createTimeBasedCSV(t) {
    const e = this.secondsToCSVTimeUnits(t);
    if (e > 65535)
      throw new Error(`Time units ${e} exceeds maximum of 65,535`);
    return e | 1 << 22;
  }
  isCSVEnabled(t) {
    return (t & 1 << 31) === 0;
  }
  extractCSVValue(t) {
    return t & 65535;
  }
  /**
   * Finalize secondary P2WDA inputs with empty data
   */
  finalizeSecondaryP2WDA(t, e) {
    if (!e.partialSig || e.partialSig.length === 0)
      throw new Error(`No signature for P2WDA input #${t}`);
    if (!e.witnessScript)
      throw new Error(`No witness script for P2WDA input #${t}`);
    const i = z.createSimpleP2WDAWitness(
      e.partialSig[0].signature,
      e.witnessScript
    );
    return {
      finalScriptSig: void 0,
      finalScriptWitness: ie(i)
    };
  }
  async signInputsWalletBased(t) {
    await this.signer.multiSignPsbt([t]);
    for (let i = 0; i < t.data.inputs.length; i++)
      t.finalizeInput(i, this.customFinalizerP2SH.bind(this));
    this.finalized = !0;
  }
  isCSVScript(t) {
    return t.some((e) => e === g.OP_CHECKSEQUENCEVERIFY);
  }
  setCSVSequence(t, e) {
    if (this.txVersion < 2)
      throw new Error("CSV requires transaction version 2 or higher");
    if (t > 65535)
      throw new Error(`CSV blocks ${t} exceeds maximum of 65,535`);
    const i = (t & 1 << 22) !== 0;
    let r = t & 65535;
    return i && (r |= 1 << 22), e === 4294967293 && (r |= 1 << 25), r = r & 2147483647, r;
  }
  getCSVType(t) {
    return t & 1 << 22 ? 1 : 0;
  }
  extractCSVBlocks(t) {
    for (let e = 0; e < t.length; e++)
      if (t[e] === g.OP_CHECKSEQUENCEVERIFY && e > 0) {
        const i = t[e - 1];
        if (T.isBuffer(i))
          return Le.decode(i);
        if (typeof i == "number") {
          if (i === g.OP_0 || i === g.OP_FALSE)
            return 0;
          if (i === g.OP_1NEGATE)
            return -1;
          if (i >= g.OP_1 && i <= g.OP_16)
            return i - g.OP_1 + 1;
          throw new Error(`Unexpected raw number in script: ${i}`);
        }
      }
    return 0;
  }
  async attemptSignTaproot(t, e, i, r, s) {
    if (this.isTaprootScriptSpend(e, s))
      await this.signTaprootInput(r, t, i);
    else {
      let c;
      if (r !== this.signer ? c = this.getTweakedSigner(!0, r) : (this.tweakedSigner || this.tweakSigner(), c = this.tweakedSigner), c)
        try {
          await this.signTaprootInput(c, t, i);
        } catch {
          if (c = this.getTweakedSigner(!1, this.signer), !c)
            throw new Error(`Failed to obtain tweaked signer for input ${i}.`);
          await this.signTaprootInput(c, t, i);
        }
      else
        this.error(`Failed to obtain tweaked signer for input ${i}.`);
    }
  }
  isTaprootScriptSpend(t, e) {
    if (t.tapLeafScript && t.tapLeafScript.length > 0) {
      for (const i of t.tapLeafScript)
        if (fe(e, i.script))
          return !0;
    }
    return !1;
  }
  async signTaprootInput(t, e, i, r) {
    if ("signTaprootInput" in t)
      try {
        await t.signTaprootInput(e, i, r);
      } catch {
        throw new Error("Failed to sign Taproot input with provided signer.");
      }
    else
      e.signTaprootInput(i, t);
  }
  async signNonTaprootInput(t, e, i) {
    "signInput" in t ? await t.signInput(e, i) : e.signInput(i, t);
  }
}
function Gt(n, t) {
  return JSON.stringify(n) === JSON.stringify(t);
}
function cr(n) {
  if (Gt(n, I))
    return "000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f";
  if (Gt(n, At))
    return "000000000933ea01ad0ee984209779baaec3ced90fa3f408719526f8d77f4943";
  if (Gt(n, zt))
    return "0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206";
  throw new Error("Unsupported network for chain ID retrieval");
}
function Be(n) {
  return Uint8Array.from(a.from(cr(n), "hex"));
}
const xe = Uint8Array.from(
  a.from(
    "e784995a412d773988c4b8e333d7b39dfb3cabf118d0d645411a916ca2407939",
    // sha256("OP_NET")
    "hex"
  )
);
ot(G);
const V = 330n, St = 297n, re = a.from("51024e73", "hex");
class m extends Xt {
  constructor(t) {
    if (super(t), this.logColor = "#785def", this.debugFees = !1, this.overflowFees = 0n, this.transactionFee = 0n, this.estimatedFees = 0n, this.updateInputs = [], this.outputs = [], this.feeOutput = null, this._maximumFeeRate = 1e8, this.optionalOutputsAdded = !1, t.estimatedFees && (this.estimatedFees = t.estimatedFees), this.signer = t.signer, this.network = t.network, this.feeRate = t.feeRate, this.priorityFee = t.priorityFee ?? 0n, this.gasSatFee = t.gasSatFee ?? 0n, this.utxos = t.utxos, this.optionalInputs = t.optionalInputs || [], this.to = t.to || void 0, this.debugFees = t.debugFees || !1, this.LOCK_LEAF_SCRIPT = this.defineLockScript(), t.note && (typeof t.note == "string" ? this.note = a.from(t.note, "utf8") : this.note = t.note), this.anchor = t.anchor ?? !1, this.isPubKeyDestination = this.to ? H.isValidPublicKey(this.to, this.network) : !1, this.optionalOutputs = t.optionalOutputs, this.from = m.getFrom(t.from, this.signer, this.network), this.totalInputAmount = this.calculateTotalUTXOAmount(), this.calculateTotalVOutAmount() < this.totalInputAmount)
      throw new Error("Vout value is less than the value to send");
    this.transaction = new F({
      network: this.network,
      version: this.txVersion
    });
  }
  static {
    this.MINIMUM_DUST = 330n;
  }
  static getFrom(t, e, i) {
    return t || A.getTaprootAddress(e, i);
  }
  /**
   * @description Converts the witness stack to a script witness
   * @param {Buffer[]} witness - The witness stack
   * @protected
   * @returns {Buffer}
   */
  static witnessStackToScriptWitness(t) {
    return ie(t);
  }
  addOPReturn(t) {
    const e = L([g.OP_RETURN, t]);
    this.addOutput({
      value: 0,
      script: e
    });
  }
  addAnchor() {
    this.addOutput({
      value: 0,
      script: re
    });
  }
  async getFundingTransactionParameters() {
    return this.estimatedFees || (this.estimatedFees = await this.estimateTransactionFees()), {
      utxos: this.utxos,
      to: this.getScriptAddress(),
      signer: this.signer,
      network: this.network,
      feeRate: this.feeRate,
      priorityFee: this.priorityFee ?? 0n,
      gasSatFee: this.gasSatFee ?? 0n,
      from: this.from,
      amount: this.estimatedFees,
      optionalOutputs: this.optionalOutputs,
      optionalInputs: this.optionalInputs,
      mldsaSigner: null
    };
  }
  /**
   * Set the destination address of the transaction
   * @param {string} address - The address to set
   */
  setDestinationAddress(t) {
    this.to = t;
  }
  /**
   * Set the maximum fee rate of the transaction in satoshis per byte
   * @param {number} feeRate - The fee rate to set
   * @public
   */
  setMaximumFeeRate(t) {
    this._maximumFeeRate = t;
  }
  /**
   * @description Signs the transaction
   * @public
   * @returns {Promise<Transaction>} - The signed transaction in hex format
   * @throws {Error} - If something went wrong
   */
  async signTransaction() {
    if (!this.utxos.length)
      throw new Error("No UTXOs specified");
    if (this.to && !this.isPubKeyDestination && !A.verifyContractAddress(this.to, this.network))
      throw new Error(
        "Invalid contract address. The contract address must be a taproot address."
      );
    if (this.signed) throw new Error("Transaction is already signed");
    if (this.signed = !0, await this.buildTransaction(), await this.internalBuildTransaction(this.transaction)) {
      if (this.regenerated)
        throw new Error("Transaction was regenerated");
      return this.transaction.extractTransaction(!0, !0);
    }
    throw new Error("Could not sign transaction");
  }
  /**
   * @description Generates the transaction minimal signatures
   * @public
   */
  async generateTransactionMinimalSignatures(t = !1) {
    if (this.to && !this.isPubKeyDestination && !A.verifyContractAddress(this.to, this.network))
      throw new Error(
        "Invalid contract address. The contract address must be a taproot address."
      );
    if (await this.buildTransaction(), this.transaction.data.inputs.length === 0) {
      const e = this.getInputs(), i = this.getOutputs();
      this.transaction.setMaximumFeeRate(this._maximumFeeRate), this.transaction.addInputs(e, t);
      for (let r = 0; r < this.updateInputs.length; r++)
        this.transaction.updateInput(r, this.updateInputs[r]);
      this.transaction.addOutputs(i);
    }
  }
  /**
   * @description Signs the transaction
   * @public
   * @returns {Promise<Psbt>} - The signed transaction in hex format
   * @throws {Error} - If something went wrong
   */
  async signPSBT() {
    if (await this.signTransaction())
      return this.transaction;
    throw new Error("Could not sign transaction");
  }
  /**
   * Add an input to the transaction.
   * @param {PsbtInputExtended} input - The input to add
   * @public
   * @returns {void}
   */
  addInput(t) {
    this.inputs.push(t);
  }
  /**
   * Add an output to the transaction.
   * @param {PsbtOutputExtended} output - The output to add
   * @param bypassMinCheck
   * @public
   * @returns {void}
   */
  addOutput(t, e = !1) {
    if (t.value === 0) {
      const i = t;
      if (!i.script || i.script.length === 0)
        throw new Error("Output value is 0 and no script provided");
      if (i.script.length < 2)
        throw new Error("Output script is too short");
      if (i.script[0] !== g.OP_RETURN && !i.script.equals(re))
        throw new Error(
          "Output script must start with OP_RETURN or be an ANCHOR when value is 0"
        );
    } else if (!e && t.value < m.MINIMUM_DUST)
      throw new Error(
        `Output value is less than the minimum dust ${t.value} < ${m.MINIMUM_DUST}`
      );
    this.outputs.push(t);
  }
  /**
   * Returns the total value of all outputs added so far (excluding the fee/change output).
   * @public
   * @returns {bigint}
   */
  getTotalOutputValue() {
    return this.outputs.reduce((t, e) => t + BigInt(e.value), 0n);
  }
  /**
   * Receiver address.
   * @public
   * @returns {string} - The receiver address
   */
  toAddress() {
    return this.to;
  }
  /**
   * @description Returns the script address
   * @returns {string} - The script address
   */
  address() {
    return this.tapData?.address;
  }
  /**
   * Estimates the transaction fees with accurate size calculation.
   * @public
   * @returns {Promise<bigint>}
   */
  async estimateTransactionFees() {
    await Promise.resolve();
    const t = new F({ network: this.network }), e = this.getInputs(), i = this.getOutputs();
    t.addInputs(e), t.addOutputs(i);
    const r = a.alloc(64, 0), s = a.alloc(72, 0), o = a.alloc(33, 2), c = (p, f) => {
      if (f.isPayToAnchor || this.anchorInputIndices.has(p))
        return {
          finalScriptSig: void 0,
          finalScriptWitness: a.from([0])
        };
      if (f.witnessScript && z.isP2WDAWitnessScript(f.witnessScript)) {
        const S = [];
        for (let _ = 0; _ < 10; _++)
          S.push(a.alloc(0));
        const b = a.alloc(72, 0);
        return {
          finalScriptWitness: m.witnessStackToScriptWitness([
            ...S,
            b,
            f.witnessScript
          ])
        };
      }
      if (p === 0 && this.tapLeafScript) {
        const S = a.alloc(32, 0), b = this.tapLeafScript.script, _ = a.alloc(65, 0);
        return {
          finalScriptWitness: m.witnessStackToScriptWitness([
            S,
            r,
            // It's a tapScriptSig, which is Schnorr
            r,
            // Second Schnorr signature
            b,
            _
          ])
        };
      }
      if (f.witnessUtxo) {
        const S = f.witnessUtxo.script, b = it.script.decompile(S);
        if (b && b.length === 5 && b[0] === g.OP_DUP && b[1] === g.OP_HASH160 && b[3] === g.OP_EQUALVERIFY && b[4] === g.OP_CHECKSIG)
          return {
            finalScriptSig: it.script.compile([
              s,
              o
            ]),
            finalScriptWitness: void 0
          };
      }
      if (f.witnessScript) {
        if (this.csvInputIndices.has(p))
          return {
            finalScriptWitness: m.witnessStackToScriptWitness([
              s,
              f.witnessScript
            ])
          };
        if (f.redeemScript) {
          const b = [s, f.witnessScript];
          return {
            finalScriptSig: f.redeemScript,
            finalScriptWitness: m.witnessStackToScriptWitness(b)
          };
        }
        const S = it.script.decompile(f.witnessScript);
        if (S && S.length >= 4) {
          const b = S[0], _ = S[S.length - 1];
          if (typeof b == "number" && b >= g.OP_1 && _ === g.OP_CHECKMULTISIG) {
            const xt = b - g.OP_1 + 1, vt = [];
            for (let kt = 0; kt < xt; kt++)
              vt.push(s);
            return {
              finalScriptWitness: m.witnessStackToScriptWitness([
                a.alloc(0),
                // OP_0 due to multisig bug
                ...vt,
                f.witnessScript
              ])
            };
          }
        }
        return {
          finalScriptWitness: m.witnessStackToScriptWitness([
            s,
            f.witnessScript
          ])
        };
      } else if (f.redeemScript) {
        const S = it.script.decompile(f.redeemScript);
        if (S && S.length === 2 && S[0] === g.OP_0 && a.isBuffer(S[1]) && S[1].length === 20)
          return {
            finalScriptSig: f.redeemScript,
            finalScriptWitness: m.witnessStackToScriptWitness([
              s,
              o
            ])
          };
      }
      if (f.redeemScript && !f.witnessScript && !f.witnessUtxo)
        return {
          finalScriptSig: it.script.compile([s, f.redeemScript]),
          finalScriptWitness: void 0
        };
      const w = f.witnessUtxo?.script;
      return w ? f.tapInternalKey ? {
        finalScriptWitness: m.witnessStackToScriptWitness([
          r
        ])
      } : w.length === 22 && w[0] === g.OP_0 ? {
        finalScriptWitness: m.witnessStackToScriptWitness([
          s,
          o
        ])
      } : f.redeemScript?.length === 22 && f.redeemScript[0] === g.OP_0 ? {
        finalScriptWitness: m.witnessStackToScriptWitness([
          s,
          o
        ])
      } : Ke(
        p,
        f,
        w,
        !0,
        !!f.redeemScript,
        !!f.witnessScript
      ) : { finalScriptSig: void 0, finalScriptWitness: void 0 };
    };
    try {
      for (let p = 0; p < t.data.inputs.length; p++) {
        const f = e[p];
        f && t.finalizeInput(p, (w) => c(w, f));
      }
    } catch (p) {
      this.warn(`Could not finalize dummy tx: ${p.message}`);
    }
    const h = t.extractTransaction(!0, !0).virtualSize(), l = this.feeRate * h, d = BigInt(Math.ceil(l));
    return this.debugFees && this.log(
      `Estimating fees: feeRate=${this.feeRate}, accurate_vSize=${h}, fee=${d}n`
    ), d;
  }
  async rebuildFromBase64(t) {
    return this.transaction = F.fromBase64(t, {
      network: this.network,
      version: this.txVersion
    }), this.signed = !1, this.sighashTypes = [Jt.SIGHASH_ANYONECANPAY, Jt.SIGHASH_ALL], await this.signPSBT();
  }
  setPSBT(t) {
    this.transaction = t;
  }
  /**
   * Returns the inputs of the transaction.
   * @protected
   * @returns {PsbtInputExtended[]}
   */
  getInputs() {
    return this.inputs;
  }
  /**
   * Returns the outputs of the transaction.
   * @protected
   * @returns {PsbtOutputExtended[]}
   */
  getOutputs() {
    const t = [...this.outputs];
    return this.feeOutput && t.push(this.feeOutput), t;
  }
  getOptionalOutputValue() {
    if (!this.optionalOutputs) return 0n;
    let t = 0n;
    for (let e = 0; e < this.optionalOutputs.length; e++)
      t += BigInt(this.optionalOutputs[e].value);
    return t;
  }
  async addRefundOutput(t, e = !1) {
    this.note && this.addOPReturn(this.note), this.anchor && this.addAnchor();
    let i = -1n, r = 0n, s = 0;
    const o = 5;
    let c = 0n;
    for (; s < o && r !== i; ) {
      i = r, r = await this.estimateTransactionFees();
      const u = t + r;
      if (c = this.totalInputAmount - u, this.debugFees && this.log(
        `Iteration ${s + 1}: inputAmount=${this.totalInputAmount}, totalSpent=${u}, sendBackAmount=${c}`
      ), c >= m.MINIMUM_DUST) {
        if (H.isValidP2TRAddress(this.from, this.network))
          this.feeOutput = {
            value: Number(c),
            address: this.from,
            tapInternalKey: this.internalPubKeyToXOnly()
          };
        else if (H.isValidPublicKey(this.from, this.network)) {
          const h = L([
            a.from(this.from.replace("0x", ""), "hex"),
            g.OP_CHECKSIG
          ]);
          this.feeOutput = {
            value: Number(c),
            script: h
          };
        } else
          this.feeOutput = {
            value: Number(c),
            address: this.from
          };
        this.overflowFees = c;
      } else {
        if (this.feeOutput = null, this.overflowFees = 0n, c < 0n && s === o)
          throw new Error(
            `Insufficient funds: need ${u} sats but only have ${this.totalInputAmount} sats`
          );
        this.debugFees && this.warn(
          `Amount to send back (${c} sat) is less than minimum dust...`
        );
      }
      s++;
    }
    if (e && c < 0n)
      throw new Error(
        `Insufficient funds: need at least ${-c} more sats to cover fees.`
      );
    s >= o && this.warn(`Fee calculation did not stabilize after ${o} iterations`), this.transactionFee = r, this.debugFees && this.log(
      `Final fee: ${r} sats, Change output: ${this.feeOutput ? `${this.feeOutput.value} sats` : "none"}`
    );
  }
  defineLockScript() {
    return L([O(a.from(this.signer.publicKey)), g.OP_CHECKSIG]);
  }
  /**
   * @description Adds the value to the output
   * @param {number | bigint} value - The value to add
   * @protected
   * @returns {void}
   */
  addValueToToOutput(t) {
    if (t < m.MINIMUM_DUST)
      throw new Error(
        `Value to send is less than the minimum dust ${t} < ${m.MINIMUM_DUST}`
      );
    for (const e of this.outputs)
      if ("address" in e && e.address === this.to) {
        e.value += Number(t);
        return;
      }
    throw new Error("Output not found");
  }
  generateLegacySignature() {
    if (this.tweakSigner(), !this.tweakedSigner)
      throw new Error("Tweaked signer is not defined");
    const t = O(this.tweakedSigner.publicKey), e = this.signer.publicKey;
    if (e.length !== 33)
      throw new Error("Original public key must be compressed (33 bytes)");
    const i = Be(this.network), r = new D();
    r.writeU8(P.MLDSASecurityLevel.LEVEL2), r.writeBytes(this.hashedPublicKey), r.writeBytes(t), r.writeBytes(e), r.writeBytes(xe), r.writeBytes(i);
    const s = r.getBuffer(), o = st.signMessage(this.tweakedSigner, s);
    if (!st.verifySignature(t, s, o.signature))
      throw new Error("Could not verify generated legacy signature for MLDSA link request");
    return a.from(o.signature);
  }
  generateMLDSASignature() {
    if (!this.mldsaSigner)
      throw new Error("MLDSA signer is not defined");
    if (this.tweakSigner(), !this.tweakedSigner)
      throw new Error("Tweaked signer is not defined");
    const t = O(this.tweakedSigner.publicKey), e = this.signer.publicKey;
    if (e.length !== 33)
      throw new Error("Original public key must be compressed (33 bytes)");
    const i = Be(this.network), r = ee(this.mldsaSigner.publicKey.length);
    if (r !== P.MLDSASecurityLevel.LEVEL2)
      throw new Error("Only MLDSA level 2 is supported for link requests");
    const s = new D();
    s.writeU8(r), s.writeBytes(this.hashedPublicKey), s.writeBytes(this.mldsaSigner.publicKey), s.writeBytes(t), s.writeBytes(e), s.writeBytes(xe), s.writeBytes(i);
    const o = s.getBuffer(), c = st.signMLDSAMessage(this.mldsaSigner, o);
    if (!st.verifyMLDSASignature(
      this.mldsaSigner,
      o,
      c.signature
    ))
      throw new Error("Could not verify generated MLDSA signature for link request");
    return a.from(c.signature);
  }
  generateMLDSALinkRequest(t, e) {
    const i = this.mldsaSigner, r = this.generateLegacySignature();
    let s = null;
    t.revealMLDSAPublicKey && (s = this.generateMLDSASignature());
    const o = {
      priority: Q.MLDSA_LINK_PUBKEY,
      opcode: W.MLDSA_LINK_PUBKEY,
      data: {
        verifyRequest: !!t.revealMLDSAPublicKey,
        publicKey: i.publicKey,
        hashedPublicKey: this.hashedPublicKey,
        level: ee(i.publicKey.length),
        legacySignature: r,
        mldsaSignature: s
      }
    };
    e.push(o);
  }
  /**
   * @description Returns the transaction opnet fee
   * @protected
   * @returns {bigint}
   */
  getTransactionOPNetFee() {
    const t = this.priorityFee + this.gasSatFee;
    return t > m.MINIMUM_DUST ? t : m.MINIMUM_DUST;
  }
  /**
   * @description Returns the total amount of satoshis in the inputs
   * @protected
   * @returns {bigint}
   */
  calculateTotalUTXOAmount() {
    let t = 0n;
    for (const e of this.utxos)
      t += e.value;
    for (const e of this.optionalInputs)
      t += e.value;
    return t;
  }
  /**
   * @description Returns the total amount of satoshis in the outputs
   * @protected
   * @returns {bigint}
   */
  calculateTotalVOutAmount() {
    let t = 0n;
    for (const e of this.utxos)
      t += e.value;
    for (const e of this.optionalInputs)
      t += e.value;
    return t;
  }
  /**
   * @description Adds optional outputs to transaction and returns their total value in satoshi to calculate refund transaction
   * @protected
   * @returns {bigint}
   */
  addOptionalOutputsAndGetAmount() {
    if (!this.optionalOutputs || this.optionalOutputsAdded) return 0n;
    let t = 0n;
    for (let e = 0; e < this.optionalOutputs.length; e++)
      this.addOutput(this.optionalOutputs[e]), t += BigInt(this.optionalOutputs[e].value);
    return this.optionalOutputsAdded = !0, t;
  }
  /**
   * @description Adds the inputs from the utxos
   * @protected
   * @returns {void}
   */
  addInputsFromUTXO() {
    if (this.utxos.length) {
      if (this.totalInputAmount < m.MINIMUM_DUST)
        throw new Error(
          `Total input amount is ${this.totalInputAmount} sat which is less than the minimum dust ${m.MINIMUM_DUST} sat.`
        );
      for (let t = 0; t < this.utxos.length; t++) {
        const e = this.utxos[t];
        this.registerInputSigner(t, e);
        const i = this.generatePsbtInputExtended(e, t);
        this.addInput(i);
      }
    }
    if (this.optionalInputs)
      for (let t = this.utxos.length; t < this.optionalInputs.length + this.utxos.length; t++) {
        const e = this.optionalInputs[t - this.utxos.length];
        this.registerInputSigner(t, e);
        const i = this.generatePsbtInputExtended(e, t, !0);
        this.addInput(i);
      }
  }
  /**
   * Internal init.
   * @protected
   */
  internalInit() {
    this.verifyUTXOValidity(), super.internalInit();
  }
  /**
   * Add an input update
   * @param {UpdateInput} input - The input to update
   * @protected
   * @returns {void}
   */
  updateInput(t) {
    this.updateInputs.push(t);
  }
  /**
   * Adds the fee to the output.
   * @param amountSpent
   * @param contractAddress
   * @param epochChallenge
   * @param addContractOutput
   * @protected
   */
  addFeeToOutput(t, e, i, r) {
    if (r) {
      let s;
      t > V + St ? s = St : s = t, this.addOutput(
        {
          value: Number(s),
          address: e
        },
        !0
      ), s === St && t - St > V && this.addOutput(
        {
          value: Number(t - s),
          address: i.address
        },
        !0
      );
    } else {
      const s = t < V ? V : t;
      this.addOutput(
        {
          value: Number(s),
          address: i.address
        },
        !0
      );
    }
  }
  /**
   * Returns the witness of the tap transaction.
   * @protected
   * @returns {Buffer}
   */
  getWitness() {
    if (!this.tapData || !this.tapData.witness)
      throw new Error("Witness is required");
    if (this.tapData.witness.length === 0)
      throw new Error("Witness is empty");
    return this.tapData.witness[this.tapData.witness.length - 1];
  }
  /**
   * Returns the tap output.
   * @protected
   * @returns {Buffer}
   */
  getTapOutput() {
    if (!this.tapData || !this.tapData.output)
      throw new Error("Tap data is required");
    return this.tapData.output;
  }
  /**
   * Verifies that the utxos are valid.
   * @protected
   */
  verifyUTXOValidity() {
    for (const t of this.utxos)
      if (!t.scriptPubKey)
        throw new Error("Address is required");
    for (const t of this.optionalInputs)
      if (!t.scriptPubKey)
        throw new Error("Address is required");
  }
  /**
   * Set transaction fee output.
   * @param {PsbtOutputExtended} output - The output to set the fees
   * @protected
   * @returns {Promise<void>}
   */
  async setFeeOutput(t) {
    const e = t.value;
    this.feeOutput = null;
    let i = 0n, r = -1n;
    this.log(
      `setFeeOutput: Starting fee calculation for change. Initial available value: ${e} sats.`
    );
    for (let o = 0; o < 3 && i !== r; o++) {
      r = i, i = await this.estimateTransactionFees();
      const c = BigInt(e) - i;
      this.debugFees && this.log(
        ` -> Iteration ${o + 1}: Estimated fee is ${i} sats. Value left for change: ${c} sats.`
      ), c >= m.MINIMUM_DUST ? (this.feeOutput = { ...t, value: Number(c) }, this.overflowFees = c) : (this.feeOutput = null, this.overflowFees = 0n, i = await this.estimateTransactionFees(), this.debugFees && this.log(
        ` -> Change is less than dust. Final fee without change output: ${i} sats.`
      ));
    }
    const s = BigInt(e) - i;
    if (s < 0)
      throw new Error(
        `setFeeOutput: Insufficient funds to pay the fees. Required fee: ${i}, Available: ${e}. Total input: ${this.totalInputAmount} sat`
      );
    s >= m.MINIMUM_DUST ? (this.feeOutput = { ...t, value: Number(s) }, this.overflowFees = s, this.debugFees && this.log(
      `setFeeOutput: Final change output set to ${s} sats. Final fee: ${i} sats.`
    )) : (this.warn(
      `Amount to send back (${s} sat) is less than the minimum dust (${m.MINIMUM_DUST} sat), it will be consumed in fees instead.`
    ), this.feeOutput = null, this.overflowFees = 0n);
  }
  /*protected async setFeeOutput(output: PsbtOutputExtended): Promise<void> {
          const initialValue = output.value;
  
          const fee = await this.estimateTransactionFees();
          output.value = initialValue - Number(fee);
  
          if (output.value < TransactionBuilder.MINIMUM_DUST) {
              this.feeOutput = null;
  
              if (output.value < 0) {
                  throw new Error(
                      `setFeeOutput: Insufficient funds to pay the fees. Fee: ${fee} < Value: ${initialValue}. Total input: ${this.totalInputAmount} sat`,
                  );
              }
          } else {
              this.feeOutput = output;
  
              const fee = await this.estimateTransactionFees();
              if (fee > BigInt(initialValue)) {
                  throw new Error(
                      `estimateTransactionFees: Insufficient funds to pay the fees. Fee: ${fee} > Value: ${initialValue}. Total input: ${this.totalInputAmount} sat`,
                  );
              }
  
              const valueLeft = initialValue - Number(fee);
              if (valueLeft < TransactionBuilder.MINIMUM_DUST) {
                  this.feeOutput = null;
              } else {
                  this.feeOutput.value = valueLeft;
              }
  
              this.overflowFees = BigInt(valueLeft);
          }
      }*/
  /**
   * Builds the transaction.
   * @param {Psbt} transaction - The transaction to build
   * @param checkPartialSigs
   * @protected
   * @returns {Promise<boolean>}
   * @throws {Error} - If something went wrong while building the transaction
   */
  async internalBuildTransaction(t, e = !1) {
    if (t.data.inputs.length === 0) {
      const i = this.getInputs(), r = this.getOutputs();
      t.setMaximumFeeRate(this._maximumFeeRate), t.addInputs(i, e);
      for (let s = 0; s < this.updateInputs.length; s++)
        t.updateInput(s, this.updateInputs[s]);
      t.addOutputs(r);
    }
    try {
      return await this.signInputs(t), this.finalized && (this.transactionFee = BigInt(t.getFee())), !0;
    } catch (i) {
      const r = i;
      this.error(
        `[internalBuildTransaction] Something went wrong while getting building the transaction: ${r.stack}`
      );
    }
    return !1;
  }
}
class Wt extends m {
  constructor(t) {
    if (super(t), this.type = y.CUSTOM_CODE, this.tapLeafScript = null, this.targetScriptRedeem = null, this.leftOverFundsScriptRedeem = null, this.customFinalizer = (e, i) => {
      if (!this.tapLeafScript)
        throw new Error("Tap leaf script is required");
      const s = this.getScriptSolution(i).concat(this.tapLeafScript.script).concat(this.tapLeafScript.controlBlock);
      if (this.annexData && this.annexData.length > 0) {
        const o = this.annexData[0] === 80 ? this.annexData : a.concat([a.from([80]), this.annexData]);
        s.push(o);
      }
      return {
        finalScriptWitness: m.witnessStackToScriptWitness(s)
      };
    }, !t.script) throw new Error("Bitcoin script is required");
    if (!t.witnesses) throw new Error("Witness(es) are required");
    this.witnesses = t.witnesses, this.randomBytes = t.randomBytes || K.rndBytes(), this.LOCK_LEAF_SCRIPT = this.defineLockScript(), this.scriptSeed = this.getContractSeed(), this.contractSigner = A.fromSeedKeyPair(this.scriptSeed, this.network), this.generator = new Re(this.internalPubKeyToXOnly(), this.network), this.compiledTargetScript = this.generator.compile(t.script), this.scriptTree = this.getScriptTree(), this.internalInit(), this._scriptAddress = ae.generatePKSH(this.scriptSeed, this.network);
  }
  /**
   * @description Get the contract address (PKSH)
   */
  get scriptAddress() {
    return this._scriptAddress;
  }
  /**
   * @description Get the P2TR address
   */
  get p2trAddress() {
    return this.to || this.getScriptAddress();
  }
  exportCompiledTargetScript() {
    return this.compiledTargetScript;
  }
  /**
   * Get the random bytes used for the interaction
   * @returns {Buffer} The random bytes
   */
  getRndBytes() {
    return this.randomBytes;
  }
  /**
   * Get the contract signer public key
   * @protected
   */
  contractSignerXOnlyPubKey() {
    return O(a.from(this.contractSigner.publicKey));
  }
  /**
   * Build the transaction
   * @protected
   */
  async buildTransaction() {
    this.to || (this.to = this.getScriptAddress());
    const t = this.contractSigner ? this.targetScriptRedeem : this.leftOverFundsScriptRedeem;
    if (!t)
      throw new Error("Left over funds script redeem is required");
    if (!t.redeemVersion)
      throw new Error("Left over funds script redeem version is required");
    if (!t.output)
      throw new Error("Left over funds script redeem output is required");
    this.tapLeafScript = {
      leafVersion: t.redeemVersion,
      script: t.output,
      controlBlock: this.getWitness()
    }, this.addInputsFromUTXO();
    const e = this.getTransactionOPNetFee();
    this.addOutput({
      value: Number(e),
      address: this.to
    }), await this.addRefundOutput(e + this.addOptionalOutputsAndGetAmount());
  }
  /**
   * Sign the inputs
   * @param {Psbt} transaction The transaction to sign
   * @protected
   */
  async signInputs(t) {
    if (!this.contractSigner) {
      await super.signInputs(t);
      return;
    }
    for (let e = 0; e < t.data.inputs.length; e++)
      if (e === 0) {
        try {
          t.signInput(0, this.contractSigner);
        } catch {
        }
        t.signInput(0, this.getSignerKey()), t.finalizeInput(0, this.customFinalizer);
      } else
        t.signInput(e, this.getSignerKey()), t.finalizeInput(e);
  }
  /**
   * Get the tap output
   * @protected
   */
  generateScriptAddress() {
    return {
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      scriptTree: this.scriptTree,
      name: v.P2TR
    };
  }
  /**
   * Generate the tap data
   * @protected
   */
  generateTapData() {
    const t = this.contractSigner ? this.targetScriptRedeem : this.leftOverFundsScriptRedeem;
    if (!t)
      throw new Error("Left over funds script redeem is required");
    if (!this.scriptTree)
      throw new Error("Script tree is required");
    return {
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      scriptTree: this.scriptTree,
      redeem: t,
      name: v.P2TR
    };
  }
  getScriptSolution(t) {
    if (!t.tapScriptSig)
      throw new Error("Tap script signature is required");
    const e = [...this.witnesses];
    if (t.tapScriptSig)
      for (const i of t.tapScriptSig)
        e.push(i.signature);
    return e;
  }
  /**
   * Generate the contract seed for the deployment
   * @private
   */
  getContractSeed() {
    return Y(this.randomBytes);
  }
  /**
   * Get the public keys for the redeem scripts
   * @private
   */
  getPubKeys() {
    const t = [a.from(this.signer.publicKey)];
    return this.contractSigner && t.push(a.from(this.contractSigner.publicKey)), t;
  }
  /**
   * Generate the redeem scripts
   * @private
   */
  generateRedeemScripts() {
    this.targetScriptRedeem = {
      name: v.P2TR,
      //pubkeys: this.getPubKeys(),
      output: this.compiledTargetScript,
      redeemVersion: 192
    }, this.leftOverFundsScriptRedeem = {
      name: v.P2TR,
      //pubkeys: this.getPubKeys(),
      output: this.getLeafScript(),
      redeemVersion: 192
    };
  }
  /**
   * Get the second leaf script
   * @private
   */
  getLeafScript() {
    return this.LOCK_LEAF_SCRIPT;
  }
  /**
   * Get the script tree
   * @private
   */
  getScriptTree() {
    return this.generateRedeemScripts(), [
      {
        output: this.compiledTargetScript,
        version: 192
      },
      {
        output: this.getLeafScript(),
        version: 192
      }
    ];
  }
}
class pe extends m {
  constructor(t) {
    if (super(t), this.targetScriptRedeem = null, this.leftOverFundsScriptRedeem = null, this.customFinalizer = (e, i) => {
      if (!this.tapLeafScript)
        throw new Error("Tap leaf script is required");
      if (!this.contractSecret)
        throw new Error("Contract secret is required");
      const s = this.getScriptSolution(i).concat(this.tapLeafScript.script).concat(this.tapLeafScript.controlBlock);
      return {
        finalScriptWitness: m.witnessStackToScriptWitness(s)
      };
    }, !t.calldata)
      throw new Error("Calldata is required");
    if (!t.challenge)
      throw new Error("Challenge solution is required");
    this.challenge = t.challenge, this.LOCK_LEAF_SCRIPT = this.defineLockScript(), this.disableAutoRefund = t.disableAutoRefund || !1, this.epochChallenge = M.generateTimeLockAddress(
      this.challenge.publicKey.originalPublicKeyBuffer(),
      this.network
    ), this.calldata = N.compress(t.calldata), this.randomBytes = t.randomBytes || K.rndBytes(), this.scriptSigner = this.generateKeyPairFromSeed(), this.calldataGenerator = new oe(
      a.from(this.signer.publicKey),
      this.scriptSignerXOnlyPubKey(),
      this.network
    );
  }
  static {
    this.MAXIMUM_CALLDATA_SIZE = 1024 * 1024;
  }
  exportCompiledTargetScript() {
    return this.compiledTargetScript;
  }
  /**
   * Get the contract secret
   * @returns {Buffer} The contract secret
   */
  getContractSecret() {
    return this.contractSecret;
  }
  /**
   * Get the random bytes used for the interaction
   * @returns {Buffer} The random bytes
   */
  getRndBytes() {
    return this.randomBytes;
  }
  /**
   * Get the preimage
   */
  getChallenge() {
    return this.challenge;
  }
  /**
   * Get the internal pubkey as an x-only key
   * @protected
   * @returns {Buffer} The internal pubkey as an x-only key
   */
  scriptSignerXOnlyPubKey() {
    return O(a.from(this.scriptSigner.publicKey));
  }
  /**
   * Generate a key pair from the seed
   * @protected
   *
   * @returns {ECPairInterface} The key pair
   */
  generateKeyPairFromSeed() {
    return A.fromSeedKeyPair(this.randomBytes, this.network);
  }
  /**
   * Build the transaction
   * @protected
   *
   * @throws {Error} If the left over funds script redeem is required
   * @throws {Error} If the left over funds script redeem version is required
   * @throws {Error} If the left over funds script redeem output is required
   * @throws {Error} If the to address is required
   */
  async buildTransaction() {
    const t = this.scriptSigner ? this.targetScriptRedeem : this.leftOverFundsScriptRedeem;
    if (!t)
      throw new Error("Left over funds script redeem is required");
    if (!t.redeemVersion)
      throw new Error("Left over funds script redeem version is required");
    if (!t.output)
      throw new Error("Left over funds script redeem output is required");
    this.tapLeafScript = {
      leafVersion: t.redeemVersion,
      script: t.output,
      controlBlock: this.getWitness()
    }, this.regenerated || this.addInputsFromUTXO(), await this.createMineableRewardOutputs();
  }
  /**
   * Sign the inputs
   * @param {Psbt} transaction The transaction to sign
   * @protected
   */
  async signInputs(t) {
    if (!this.scriptSigner) {
      await super.signInputs(t);
      return;
    }
    "multiSignPsbt" in this.signer ? await this.signInputsWalletBased(t) : await this.signInputsNonWalletBased(t);
  }
  generateScriptAddress() {
    return {
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      scriptTree: this.scriptTree,
      name: v.P2TR
    };
  }
  generateTapData() {
    const t = this.scriptSigner ? this.targetScriptRedeem : this.leftOverFundsScriptRedeem;
    if (!t)
      throw new Error("Left over funds script redeem is required");
    if (!this.scriptTree)
      throw new Error("Script tree is required");
    return {
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      scriptTree: this.scriptTree,
      redeem: t,
      name: v.P2TR
    };
  }
  /**
   * Generate the script solution
   * @param {PsbtInput} input The input
   * @protected
   *
   * @returns {Buffer[]} The script solution
   */
  getScriptSolution(t) {
    if (!t.tapScriptSig)
      throw new Error("Tap script signature is required");
    return [
      this.contractSecret,
      t.tapScriptSig[0].signature,
      t.tapScriptSig[1].signature
    ];
  }
  /**
   * Get the script tree
   * @private
   *
   * @returns {Taptree} The script tree
   */
  getScriptTree() {
    if (!this.calldata)
      throw new Error("Calldata is required");
    return this.generateRedeemScripts(), [
      {
        output: this.compiledTargetScript,
        version: 192
      },
      {
        output: this.LOCK_LEAF_SCRIPT,
        version: 192
      }
    ];
  }
  // custom for interactions
  async signInputsWalletBased(t) {
    const e = this.signer;
    await this.signInput(t, t.data.inputs[0], 0, this.scriptSigner), await e.multiSignPsbt([t]);
    for (let i = 0; i < t.data.inputs.length; i++)
      if (i === 0)
        t.finalizeInput(i, this.customFinalizer.bind(this));
      else
        try {
          t.finalizeInput(i, this.customFinalizerP2SH.bind(this));
        } catch {
          t.finalizeInput(i);
        }
  }
  async signInputsNonWalletBased(t) {
    for (let e = 0; e < t.data.inputs.length; e++)
      if (e === 0)
        await this.signInput(t, t.data.inputs[e], e, this.scriptSigner), await this.signInput(
          t,
          t.data.inputs[e],
          e,
          this.getSignerKey()
        ), t.finalizeInput(0, this.customFinalizer.bind(this));
      else {
        await this.signInput(t, t.data.inputs[e], e, this.signer);
        try {
          t.finalizeInput(e, this.customFinalizerP2SH.bind(this));
        } catch {
          t.finalizeInput(e);
        }
      }
  }
  async createMineableRewardOutputs() {
    if (!this.to) throw new Error("To address is required");
    const t = this.getTransactionOPNetFee();
    this.addFeeToOutput(t, this.to, this.epochChallenge, !1);
    const e = t < V ? V : t, i = this.addOptionalOutputsAndGetAmount();
    this.disableAutoRefund || await this.addRefundOutput(e + i);
  }
  /**
   * Get the public keys
   * @private
   *
   * @returns {Buffer[]} The public keys
   */
  getPubKeys() {
    const t = [a.from(this.signer.publicKey)];
    return this.scriptSigner && t.push(a.from(this.scriptSigner.publicKey)), t;
  }
  /**
   * Generate the redeem scripts
   * @private
   *
   * @throws {Error} If the public keys are required
   * @throws {Error} If the leaf script is required
   * @throws {Error} If the leaf script version is required
   * @throws {Error} If the leaf script output is required
   * @throws {Error} If the target script redeem is required
   */
  generateRedeemScripts() {
    this.targetScriptRedeem = {
      name: v.P2TR,
      output: this.compiledTargetScript,
      redeemVersion: 192
    }, this.leftOverFundsScriptRedeem = {
      name: v.P2TR,
      output: this.LOCK_LEAF_SCRIPT,
      redeemVersion: 192
    };
  }
}
class ft extends m {
  constructor(t) {
    if (super(t), this.type = y.DEPLOYMENT, this.tapLeafScript = null, this.deploymentVersion = 0, this.targetScriptRedeem = null, this.leftOverFundsScriptRedeem = null, this.customFinalizer = (e, i) => {
      if (!this.tapLeafScript)
        throw new Error("Tap leaf script is required");
      if (!i.tapScriptSig)
        throw new Error("Tap script signature is required");
      const s = [
        this.randomBytes,
        i.tapScriptSig[0].signature,
        i.tapScriptSig[1].signature
      ].concat(this.tapLeafScript.script).concat(this.tapLeafScript.controlBlock);
      return {
        finalScriptWitness: m.witnessStackToScriptWitness(s)
      };
    }, !this.hashedPublicKey)
      throw new Error("MLDSA signer must be defined to deploy a contract.");
    if (this.bytecode = N.compress(a.concat([Me, t.bytecode])), this.verifyBytecode(), t.calldata && (this.calldata = t.calldata, this.verifyCalldata()), !t.challenge) throw new Error("Challenge solution is required");
    if (this.randomBytes = t.randomBytes || K.rndBytes(), this.challenge = t.challenge, this.LOCK_LEAF_SCRIPT = this.defineLockScript(), this.epochChallenge = M.generateTimeLockAddress(
      this.challenge.publicKey.originalPublicKeyBuffer(),
      this.network
    ), this.contractSeed = this.getContractSeed(), this.contractSigner = A.fromSeedKeyPair(this.contractSeed, this.network), this.deploymentGenerator = new Ft(
      a.from(this.signer.publicKey),
      this.contractSignerXOnlyPubKey(),
      this.network
    ), t.compiledTargetScript)
      if (a.isBuffer(t.compiledTargetScript))
        this.compiledTargetScript = t.compiledTargetScript;
      else if (typeof t.compiledTargetScript == "string")
        this.compiledTargetScript = a.from(t.compiledTargetScript, "hex");
      else
        throw new Error("Invalid compiled target script format.");
    else
      this.compiledTargetScript = this.deploymentGenerator.compile(
        this.bytecode,
        this.randomBytes,
        this.challenge,
        this.priorityFee,
        this.calldata,
        this.generateFeatures(t)
      );
    this.scriptTree = this.getScriptTree(), this.internalInit(), this._contractPubKey = "0x" + this.contractSeed.toString("hex"), this._contractAddress = new k(this.contractSeed);
  }
  static {
    this.MAXIMUM_CONTRACT_SIZE = 128 * 1024;
  }
  /**
   * Get the contract public key
   */
  get contractPubKey() {
    return this._contractPubKey;
  }
  /**
   * @description Get the contract address (PKSH)
   */
  get contractAddress() {
    return this._contractAddress;
  }
  /**
   * @description Get the P2TR address
   */
  get p2trAddress() {
    return this.to || this.getScriptAddress();
  }
  exportCompiledTargetScript() {
    return this.compiledTargetScript;
  }
  /**
   * Get the random bytes used for the interaction
   * @returns {Buffer} The random bytes
   */
  getRndBytes() {
    return this.randomBytes;
  }
  /**
   * Get the contract bytecode
   * @returns {Buffer} The contract bytecode
   */
  getChallenge() {
    return this.challenge;
  }
  getContractAddress() {
    return this._computedAddress ? this._computedAddress : (this._computedAddress = A.p2op(
      this.contractSeed,
      this.network,
      this.deploymentVersion
    ), this._computedAddress);
  }
  /**
   * Get the contract signer public key
   * @protected
   */
  contractSignerXOnlyPubKey() {
    return O(a.from(this.contractSigner.publicKey));
  }
  /**
   * Build the transaction
   * @protected
   */
  async buildTransaction() {
    this.to || (this.to = this.getScriptAddress());
    const t = this.contractSigner ? this.targetScriptRedeem : this.leftOverFundsScriptRedeem;
    if (!t)
      throw new Error("Left over funds script redeem is required");
    if (!t.redeemVersion)
      throw new Error("Left over funds script redeem version is required");
    if (!t.output)
      throw new Error("Left over funds script redeem output is required");
    this.tapLeafScript = {
      leafVersion: t.redeemVersion,
      script: t.output,
      controlBlock: this.getWitness()
    }, this.addInputsFromUTXO();
    const e = this.getTransactionOPNetFee();
    this.addFeeToOutput(e, this.getContractAddress(), this.epochChallenge, !0), await this.addRefundOutput(e + this.addOptionalOutputsAndGetAmount());
  }
  async signInputsWalletBased(t) {
    const e = this.signer;
    await this.signInput(t, t.data.inputs[0], 0, this.contractSigner), await e.multiSignPsbt([t]);
    for (let i = 0; i < t.data.inputs.length; i++)
      if (i === 0)
        t.finalizeInput(i, this.customFinalizer.bind(this));
      else
        try {
          t.finalizeInput(i, this.customFinalizerP2SH.bind(this));
        } catch {
          t.finalizeInput(i);
        }
  }
  /**
   * Sign the inputs
   * @param {Psbt} transaction The transaction to sign
   * @protected
   */
  async signInputs(t) {
    if (!this.contractSigner) {
      await super.signInputs(t);
      return;
    }
    if ("multiSignPsbt" in this.signer) {
      await this.signInputsWalletBased(t);
      return;
    }
    for (let e = 0; e < t.data.inputs.length; e++)
      if (e === 0)
        t.signInput(0, this.contractSigner), t.signInput(0, this.getSignerKey()), t.finalizeInput(0, this.customFinalizer.bind(this));
      else {
        t.signInput(e, this.getSignerKey());
        try {
          t.finalizeInput(e, this.customFinalizerP2SH.bind(this));
        } catch {
          t.finalizeInput(e);
        }
      }
  }
  /**
   * Get the tap output
   * @protected
   */
  generateScriptAddress() {
    return {
      name: v.P2TR,
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      scriptTree: this.scriptTree
    };
  }
  /**
   * Generate the tap data
   * @protected
   */
  generateTapData() {
    const t = this.contractSigner ? this.targetScriptRedeem : this.leftOverFundsScriptRedeem;
    if (!t)
      throw new Error("Left over funds script redeem is required");
    if (!this.scriptTree)
      throw new Error("Script tree is required");
    return {
      name: v.P2TR,
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      scriptTree: this.scriptTree,
      redeem: t
    };
  }
  generateFeatures(t) {
    const e = [], i = t.challenge.getSubmission();
    if (i && e.push({
      priority: Q.MLDSA_LINK_PUBKEY,
      opcode: W.EPOCH_SUBMISSION,
      data: i
    }), t.revealMLDSAPublicKey && !t.linkMLDSAPublicKeyToAddress)
      throw new Error(
        "To reveal the MLDSA public key, you must set linkMLDSAPublicKeyToAddress to true."
      );
    return t.linkMLDSAPublicKeyToAddress && this.generateMLDSALinkRequest(t, e), e;
  }
  verifyCalldata() {
    if (this.calldata && this.calldata.length > pe.MAXIMUM_CALLDATA_SIZE)
      throw new Error("Calldata size overflow.");
  }
  verifyBytecode() {
    if (!this.bytecode) throw new Error("Bytecode is required");
    if (this.bytecode.length > ft.MAXIMUM_CONTRACT_SIZE)
      throw new Error("Contract size overflow.");
  }
  /**
   * Generate the contract seed for the deployment
   * @private
   */
  getContractSeed() {
    if (!this.bytecode)
      throw new Error("Bytecode is required");
    const t = this.internalPubKeyToXOnly(), e = Y(this.randomBytes), i = Y(this.bytecode), r = a.concat([t, e, i]);
    return Y(r);
  }
  /**
   * Get the public keys for the redeem scripts
   * @private
   */
  getPubKeys() {
    const t = [a.from(this.signer.publicKey)];
    return this.contractSigner && t.push(a.from(this.contractSigner.publicKey)), t;
  }
  /**
   * Generate the redeem scripts
   * @private
   */
  generateRedeemScripts() {
    this.targetScriptRedeem = {
      name: v.P2TR,
      //pubkeys: this.getPubKeys(),
      output: this.compiledTargetScript,
      redeemVersion: 192
    }, this.leftOverFundsScriptRedeem = {
      name: v.P2TR,
      //pubkeys: this.getPubKeys(),
      output: this.getLeafScript(),
      redeemVersion: 192
    };
  }
  /**
   * Get the second leaf script
   * @private
   */
  getLeafScript() {
    return this.LOCK_LEAF_SCRIPT;
  }
  /**
   * Get the script tree
   * @private
   */
  getScriptTree() {
    if (!this.bytecode)
      throw new Error("Contract bytecode is required");
    return this.generateRedeemScripts(), [
      {
        output: this.compiledTargetScript,
        version: 192
      },
      {
        output: this.getLeafScript(),
        version: 192
      }
    ];
  }
}
class Mt extends m {
  constructor(t) {
    super(t), this.type = y.FUNDING, this.amount = t.amount, this.splitInputsInto = t.splitInputsInto ?? 1, this.internalInit();
  }
  async buildTransaction() {
    if (!this.to)
      throw new Error("Recipient address is required");
    if (this.addInputsFromUTXO(), this.splitInputsInto > 1)
      this.splitInputs(this.amount);
    else if (this.isPubKeyDestination) {
      const e = L([
        a.from(this.to.replace("0x", ""), "hex"),
        g.OP_CHECKSIG
      ]);
      this.addOutput({
        value: Number(this.amount),
        script: e
      });
    } else
      this.addOutput({
        value: Number(this.amount),
        address: this.to
      });
    const t = this.amount + this.addOptionalOutputsAndGetAmount();
    await this.addRefundOutput(t);
  }
  splitInputs(t) {
    if (!this.to)
      throw new Error("Recipient address is required");
    const e = t / BigInt(this.splitInputsInto);
    for (let i = 0; i < this.splitInputsInto; i++)
      this.isPubKeyDestination ? this.addOutput({
        value: Number(e),
        script: a.from(this.to.slice(2), "hex")
      }) : this.addOutput({
        value: Number(e),
        address: this.to
      });
  }
  getSignerKey() {
    return this.signer;
  }
}
class Nt extends pe {
  constructor(t) {
    if (super(t), this.type = y.INTERACTION, this.tapLeafScript = null, !t.contract)
      throw new Error("parameters.contract is required for interaction transaction.");
    if (this.contractSecret = a.from(t.contract.replace("0x", ""), "hex"), this.contractSecret.length !== 32)
      throw new Error("Invalid contract secret length. Expected 32 bytes.");
    if (t.compiledTargetScript)
      if (a.isBuffer(t.compiledTargetScript))
        this.compiledTargetScript = t.compiledTargetScript;
      else if (typeof t.compiledTargetScript == "string")
        this.compiledTargetScript = a.from(t.compiledTargetScript, "hex");
      else
        throw new Error("Invalid compiled target script format.");
    else
      this.compiledTargetScript = this.calldataGenerator.compile(
        this.calldata,
        this.contractSecret,
        this.challenge,
        this.priorityFee,
        this.generateFeatures(t)
      );
    this.scriptTree = this.getScriptTree(), this.internalInit();
  }
  generateFeatures(t) {
    const e = [];
    t.loadedStorage && e.push({
      priority: Q.ACCESS_LIST,
      opcode: W.ACCESS_LIST,
      data: t.loadedStorage
    });
    const i = t.challenge.getSubmission();
    if (i && e.push({
      priority: Q.EPOCH_SUBMISSION,
      opcode: W.EPOCH_SUBMISSION,
      data: i
    }), t.revealMLDSAPublicKey && !t.linkMLDSAPublicKeyToAddress)
      throw new Error(
        "To reveal the MLDSA public key, you must set linkMLDSAPublicKeyToAddress to true."
      );
    return t.linkMLDSAPublicKeyToAddress && this.generateMLDSALinkRequest(t, e), e;
  }
}
class j extends m {
  constructor(t) {
    if (super(t), this.type = y.INTERACTION, this.p2wdaInputIndices = /* @__PURE__ */ new Set(), this.compiledOperationData = null, !t.to)
      throw new Error("Contract address (to) is required");
    if (!t.contract)
      throw new Error("Contract secret is required");
    if (!t.calldata)
      throw new Error("Calldata is required");
    if (!t.challenge)
      throw new Error("Challenge solution is required");
    if (this.disableAutoRefund = t.disableAutoRefund || !1, this.contractAddress = t.to, this.contractSecret = T.from(t.contract.replace("0x", ""), "hex"), this.calldata = N.compress(t.calldata), this.challenge = t.challenge, this.randomBytes = t.randomBytes || K.rndBytes(), this.scriptSigner = this.generateKeyPairFromSeed(), this.p2wdaGenerator = new Et(
      T.from(this.signer.publicKey),
      this.scriptSignerXOnlyPubKey(),
      this.network
    ), this.contractSecret.length !== 32)
      throw new Error("Invalid contract secret length. Expected 32 bytes.");
    if (this.epochChallenge = M.generateTimeLockAddress(
      this.challenge.publicKey.originalPublicKeyBuffer(),
      this.network
    ), this.validateP2WDAInputs(), t.compiledTargetScript)
      if (T.isBuffer(t.compiledTargetScript))
        this.compiledOperationData = t.compiledTargetScript;
      else if (typeof t.compiledTargetScript == "string")
        this.compiledOperationData = T.from(t.compiledTargetScript, "hex");
      else
        throw new Error("Invalid compiled target script format.");
    else
      this.compiledOperationData = this.p2wdaGenerator.compile(
        this.calldata,
        this.contractSecret,
        this.challenge,
        this.priorityFee,
        this.generateFeatures(t)
      );
    this.validateOperationDataSize(), this.internalInit();
  }
  static {
    this.MAX_WITNESS_FIELDS = 10;
  }
  static {
    this.MAX_BYTES_PER_WITNESS = 80;
  }
  /**
   * Get random bytes (for compatibility if needed elsewhere)
   */
  getRndBytes() {
    return this.randomBytes;
  }
  /**
   * Get the challenge (for compatibility if needed elsewhere)
   */
  getChallenge() {
    return this.challenge;
  }
  /**
   * Get contract secret (for compatibility if needed elsewhere)
   */
  getContractSecret() {
    return this.contractSecret;
  }
  /**
   * Build the transaction
   */
  async buildTransaction() {
    this.regenerated || this.addInputsFromUTXO(), await this.createMineableRewardOutputs();
  }
  async createMineableRewardOutputs() {
    if (!this.to) throw new Error("To address is required");
    const t = this.getTransactionOPNetFee();
    this.addFeeToOutput(t, this.to, this.epochChallenge, !1);
    const e = this.addOptionalOutputsAndGetAmount();
    this.disableAutoRefund || await this.addRefundOutput(t + e);
  }
  /**
   * Sign inputs with P2WDA-specific handling
   */
  async signInputs(t) {
    for (let e = 0; e < t.data.inputs.length; e++)
      await this.signInput(t, t.data.inputs[e], e, this.signer);
    for (let e = 0; e < t.data.inputs.length; e++)
      this.p2wdaInputIndices.has(e) ? e === 0 ? t.finalizeInput(e, this.finalizePrimaryP2WDA.bind(this)) : t.finalizeInput(e, this.finalizeSecondaryP2WDA.bind(this)) : t.finalizeInput(e, this.customFinalizerP2SH.bind(this));
    this.finalized = !0;
  }
  /**
   * Generate features array (same as InteractionTransaction)
   */
  generateFeatures(t) {
    const e = [];
    t.loadedStorage && e.push({
      priority: Q.ACCESS_LIST,
      opcode: W.ACCESS_LIST,
      data: t.loadedStorage
    });
    const i = t.challenge.getSubmission();
    return i && e.push({
      priority: Q.EPOCH_SUBMISSION,
      opcode: W.EPOCH_SUBMISSION,
      data: i
    }), e;
  }
  /**
   * Generate keypair from seed (same as SharedInteractionTransaction)
   */
  generateKeyPairFromSeed() {
    return A.fromSeedKeyPair(this.randomBytes, this.network);
  }
  /**
   * Get script signer x-only pubkey (same as SharedInteractionTransaction)
   */
  scriptSignerXOnlyPubKey() {
    return O(T.from(this.scriptSigner.publicKey));
  }
  /**
   * Validate that input 0 is P2WDA
   */
  validateP2WDAInputs() {
    if (this.utxos.length === 0 || !z.isP2WDAUTXO(this.utxos[0]))
      throw new Error("Input 0 must be a P2WDA UTXO");
    for (let t = 0; t < this.utxos.length; t++)
      z.isP2WDAUTXO(this.utxos[t]) && this.p2wdaInputIndices.add(t);
    for (let t = 0; t < this.optionalInputs.length; t++) {
      const e = this.utxos.length + t;
      z.isP2WDAUTXO(this.optionalInputs[t]) && this.p2wdaInputIndices.add(e);
    }
  }
  /**
   * Validate the compiled operation data will fit in witness fields
   */
  validateOperationDataSize() {
    if (!this.compiledOperationData)
      throw new Error("Operation data not compiled");
    const t = this.compiledOperationData.length;
    if (!Et.validateWitnessSize(t)) {
      const i = t + 64, r = Math.ceil(i * 0.7), s = Math.ceil(
        r / j.MAX_BYTES_PER_WITNESS
      );
      throw new Error(
        `Please dont use P2WDA for this operation. Data too large. Raw size: ${t} bytes, estimated compressed: ${r} bytes, needs ${s} witness fields, max is ${j.MAX_WITNESS_FIELDS}`
      );
    }
  }
  /**
   * Finalize primary P2WDA input with the operation data
   * This is where we create the signature and compress everything
   */
  finalizePrimaryP2WDA(t, e) {
    if (!e.partialSig || e.partialSig.length === 0)
      throw new Error(`No signature for P2WDA input #${t}`);
    if (!e.witnessScript)
      throw new Error(`No witness script for P2WDA input #${t}`);
    if (!this.compiledOperationData)
      throw new Error("Operation data not compiled");
    const i = e.partialSig[0].signature, r = T.concat([i, this.compiledOperationData]), s = st.signMessage(
      this.signer,
      r
    ), o = T.from(s.signature), c = T.concat([o, this.compiledOperationData]), u = N.compress(c), h = this.splitIntoWitnessChunks(u);
    if (h.length > j.MAX_WITNESS_FIELDS)
      throw new Error(
        `Compressed data needs ${h.length} witness fields, max is ${j.MAX_WITNESS_FIELDS}`
      );
    const l = [i];
    for (let d = 0; d < j.MAX_WITNESS_FIELDS; d++)
      l.push(d < h.length ? h[d] : T.alloc(0));
    return l.push(e.witnessScript), {
      finalScriptSig: void 0,
      finalScriptWitness: m.witnessStackToScriptWitness(l)
    };
  }
  /**
   * Split data into 80-byte chunks
   */
  splitIntoWitnessChunks(t) {
    const e = [];
    let i = 0;
    for (; i < t.length; ) {
      const r = Math.min(
        j.MAX_BYTES_PER_WITNESS,
        t.length - i
      );
      e.push(T.from(t.subarray(i, i + r))), i += r;
    }
    return e;
  }
}
class ge extends m {
  constructor(t) {
    super({
      ...t,
      gasSatFee: 1n,
      isCancellation: !0,
      priorityFee: 1n,
      calldata: a.alloc(0)
    }), this.type = y.CANCEL, this.tapLeafScript = null, this.leftOverFundsScriptRedeem = null, this.customFinalizer = (e, i) => {
      if (!this.tapLeafScript)
        throw new Error("Tap leaf script is required");
      if (!i.tapScriptSig || i.tapScriptSig.length === 0)
        throw new Error("Tap script signature is required");
      const s = [i.tapScriptSig[0].signature].concat(this.tapLeafScript.script).concat(this.tapLeafScript.controlBlock);
      return {
        finalScriptWitness: m.witnessStackToScriptWitness(s)
      };
    }, this.contractSecret = a.alloc(0), a.isBuffer(t.compiledTargetScript) ? this.compiledTargetScript = t.compiledTargetScript : this.compiledTargetScript = a.from(t.compiledTargetScript, "hex"), this.scriptTree = this.getMinimalScriptTree(), this.internalInit();
  }
  async buildTransaction() {
    if (!this.from)
      throw new Error("From address is required");
    if (!this.leftOverFundsScriptRedeem)
      throw new Error("Left over funds script redeem is required");
    if (!this.leftOverFundsScriptRedeem.redeemVersion)
      throw new Error("Left over funds script redeem version is required");
    if (!this.leftOverFundsScriptRedeem.output)
      throw new Error("Left over funds script redeem output is required");
    if (this.tapLeafScript = {
      leafVersion: this.leftOverFundsScriptRedeem.redeemVersion,
      script: this.leftOverFundsScriptRedeem.output,
      controlBlock: this.getWitness()
    }, this.addInputsFromUTXO(), await this.addRefundOutput(0n, !0), !this.feeOutput)
      throw new Error("Must add extra UTXOs to cancel this transaction");
  }
  /*protected override async buildTransaction(): Promise<void> {
          if (!this.from) {
              throw new Error('From address is required');
          }
  
          // For key-path spend, we don't need the tap leaf script
          this.tapLeafScript = null;
  
          this.addInputsFromUTXO();
          await this.addRefundOutput(0n);
      }*/
  /**
   * Sign the inputs
   * @param {Psbt} transaction The transaction to sign
   * @protected
   */
  /*protected async signInputs(transaction: Psbt): Promise<void> {
          for (let i = 0; i < transaction.data.inputs.length; i++) {
              if (i === 0) {
                  transaction.signInput(0, this.getSignerKey());
  
                  transaction.finalizeInput(0, this.customFinalizer.bind(this));
              } else {
                  await super.signInputs(transaction);
              }
          }
      }*/
  /**
   * Generate the script address (for verification purposes)
   */
  generateScriptAddress() {
    return {
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      scriptTree: this.scriptTree,
      name: v.P2TR
    };
  }
  /**
   * Generate the tap data for spending
   */
  /*protected override generateTapData(): P2TRPayment {
          const internalPubkey = this.internalPubKeyToXOnly();
  
          return {
              name: PaymentType.P2TR,
              internalPubkey: internalPubkey,
              network: this.network,
              scriptTree: this.scriptTree, // This is crucial for the tweak
          };
      }*/
  generateTapData() {
    const t = this.leftOverFundsScriptRedeem;
    if (!t)
      throw new Error("Left over funds script redeem is required");
    if (!this.scriptTree)
      throw new Error("Script tree is required");
    return {
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      scriptTree: this.scriptTree,
      redeem: t,
      name: v.P2TR
    };
  }
  async signInputs(t) {
    "multiSignPsbt" in this.signer ? await this.signInputsWalletBased(t) : await this.signInputsNonWalletBased(t);
  }
  async signInputsWalletBased(t) {
    await this.signer.multiSignPsbt([t]);
    for (let i = 0; i < t.data.inputs.length; i++)
      if (i === 0)
        t.finalizeInput(i, this.customFinalizer.bind(this));
      else
        try {
          t.finalizeInput(i, this.customFinalizerP2SH.bind(this));
        } catch {
          t.finalizeInput(i);
        }
  }
  async signInputsNonWalletBased(t) {
    for (let e = 0; e < t.data.inputs.length; e++)
      if (e === 0)
        await this.signInput(
          t,
          t.data.inputs[e],
          e,
          this.getSignerKey()
        ), t.finalizeInput(0, this.customFinalizer.bind(this));
      else {
        await this.signInput(t, t.data.inputs[e], e, this.signer);
        try {
          t.finalizeInput(e, this.customFinalizerP2SH.bind(this));
        } catch {
          t.finalizeInput(e);
        }
      }
  }
  /**
   * Generate the minimal script tree needed for recovery
   * This only includes the leftover funds script
   */
  getMinimalScriptTree() {
    if (this.generateLeftoverFundsRedeem(), !this.leftOverFundsScriptRedeem || !this.leftOverFundsScriptRedeem.output)
      throw new Error("Failed to generate leftover funds redeem script");
    return [
      {
        output: this.compiledTargetScript,
        version: 192
      },
      {
        output: this.leftOverFundsScriptRedeem.output,
        version: 192
      }
    ];
  }
  /**
   * Generate the leftover funds redeem script
   */
  generateLeftoverFundsRedeem() {
    this.leftOverFundsScriptRedeem = {
      name: v.P2TR,
      output: this.LOCK_LEAF_SCRIPT,
      redeemVersion: 192
    };
  }
}
class Ge extends m {
  constructor(t) {
    if (super(t), this.type = y.INTERACTION, this.cachedValuePerOutput = null, !t.to)
      throw new Error("Contract address (to) is required");
    if (!t.contract)
      throw new Error("Contract secret (contract) is required");
    if (!t.calldata)
      throw new Error("Calldata is required");
    if (!t.challenge)
      throw new Error("Challenge solution is required");
    if (this.contractAddress = t.to, this.contractSecret = T.from(t.contract.replace("0x", ""), "hex"), this.disableAutoRefund = t.disableAutoRefund || !1, this.maxChunkSize = t.maxChunkSize ?? E.MAX_CHUNK_SIZE, this.contractSecret.length !== 32)
      throw new Error("Invalid contract secret length. Expected 32 bytes.");
    if (this.calldata = N.compress(t.calldata), this.randomBytes = t.randomBytes || K.rndBytes(), this.scriptSigner = A.fromSeedKeyPair(this.randomBytes, this.network), this.challenge = t.challenge, this.epochChallenge = M.generateTimeLockAddress(
      this.challenge.publicKey.originalPublicKeyBuffer(),
      this.network
    ), this.calldataGenerator = new oe(
      T.from(this.signer.publicKey),
      O(T.from(this.scriptSigner.publicKey)),
      this.network
    ), t.compiledTargetScript)
      if (T.isBuffer(t.compiledTargetScript))
        this.compiledTargetScript = t.compiledTargetScript;
      else if (typeof t.compiledTargetScript == "string")
        this.compiledTargetScript = T.from(t.compiledTargetScript, "hex");
      else
        throw new Error("Invalid compiled target script format.");
    else
      this.compiledTargetScript = this.calldataGenerator.compile(
        this.calldata,
        this.contractSecret,
        this.challenge,
        this.priorityFee,
        this.generateFeatures(t)
      );
    this.hashCommitmentGenerator = new E(
      T.from(this.signer.publicKey),
      this.network
    ), this.commitmentOutputs = this.hashCommitmentGenerator.prepareChunks(
      this.compiledTargetScript,
      this.maxChunkSize
    ), this.validateOutputCount();
    const e = this.commitmentOutputs.reduce(
      (i, r) => i + r.dataChunks.length,
      0
    );
    this.log(
      `ConsolidatedInteractionTransaction: ${this.commitmentOutputs.length} outputs, ${e} chunks from ${this.compiledTargetScript.length} bytes compiled data`
    ), this.internalInit();
  }
  /**
   * Get the compiled target script (same as InteractionTransaction).
   */
  exportCompiledTargetScript() {
    return this.compiledTargetScript;
  }
  /**
   * Get the contract secret (same as InteractionTransaction).
   */
  getContractSecret() {
    return this.contractSecret;
  }
  /**
   * Get the random bytes (same as InteractionTransaction).
   */
  getRndBytes() {
    return this.randomBytes;
  }
  /**
   * Get the challenge solution (same as InteractionTransaction).
   */
  getChallenge() {
    return this.challenge;
  }
  /**
   * Get the commitment outputs for the setup transaction.
   */
  getCommitmentOutputs() {
    return this.commitmentOutputs;
  }
  /**
   * Get the number of P2WSH outputs.
   */
  getOutputCount() {
    return this.commitmentOutputs.length;
  }
  /**
   * Get the total number of 80-byte chunks across all outputs.
   */
  getTotalChunkCount() {
    return this.commitmentOutputs.reduce((t, e) => t + e.dataChunks.length, 0);
  }
  /**
   * Build both setup and reveal transactions.
   *
   * @returns Complete result with both transactions
   */
  async build() {
    const t = await this.signTransaction(), e = t.getId(), i = {
      txHex: t.toHex(),
      txId: e,
      outputs: this.commitmentOutputs,
      feesPaid: this.transactionFee,
      chunkCount: this.getTotalChunkCount(),
      totalDataSize: this.compiledTargetScript.length
    };
    this.log(`Setup transaction: ${i.txId}`);
    const r = this.buildRevealTransaction(e);
    return {
      setup: i,
      reveal: r,
      totalFees: i.feesPaid + r.feesPaid
    };
  }
  /**
   * Build the reveal transaction.
   * Spends the P2WSH commitment outputs, revealing the compiled data in witnesses.
   *
   * Output structure matches InteractionTransaction:
   * - Output to epochChallenge.address (miner reward)
   * - Change output (if any)
   *
   * @param setupTxId The transaction ID of the setup transaction
   */
  buildRevealTransaction(t) {
    const e = new F({ network: this.network }), i = this.calculateValuePerOutput();
    for (let p = 0; p < this.commitmentOutputs.length; p++) {
      const f = this.commitmentOutputs[p];
      e.addInput({
        hash: t,
        index: p,
        witnessUtxo: {
          script: f.scriptPubKey,
          value: Number(i)
        },
        witnessScript: f.witnessScript
      });
    }
    const r = BigInt(this.commitmentOutputs.length) * i, s = this.getTransactionOPNetFee(), o = s < V ? V : s;
    e.addOutput({
      address: this.epochChallenge.address,
      value: Number(o)
    });
    const c = this.estimateRevealVBytes(), u = BigInt(Math.ceil(c * this.feeRate)), h = r - o - u;
    if (h > m.MINIMUM_DUST) {
      const p = this.getRefundAddress();
      e.addOutput({
        address: p,
        value: Number(h)
      });
    }
    for (let p = 0; p < this.commitmentOutputs.length; p++)
      e.signInput(p, this.signer);
    for (let p = 0; p < this.commitmentOutputs.length; p++) {
      const f = this.commitmentOutputs[p];
      e.finalizeInput(p, (w, S) => this.finalizeCommitmentInput(S, f));
    }
    const l = e.extractTransaction(), d = {
      txHex: l.toHex(),
      txId: l.getId(),
      dataSize: this.compiledTargetScript.length,
      feesPaid: u,
      inputCount: this.commitmentOutputs.length
    };
    return this.log(`Reveal transaction: ${d.txId}`), d;
  }
  /**
   * Get the value per commitment output (for external access).
   */
  getValuePerOutput() {
    return this.calculateValuePerOutput();
  }
  /**
   * Build the setup transaction.
   * Creates P2WSH outputs with hash commitments to the compiled data chunks.
   * This is called by signTransaction() in the base class.
   */
  async buildTransaction() {
    this.addInputsFromUTXO();
    const t = this.calculateValuePerOutput();
    for (const r of this.commitmentOutputs)
      this.addOutput({
        value: Number(t),
        address: r.address
      });
    const e = BigInt(this.commitmentOutputs.length) * t, i = this.addOptionalOutputsAndGetAmount();
    await this.addRefundOutput(e + i);
  }
  /**
   * Finalize a commitment input.
   *
   * Witness stack: [signature, data_1, data_2, ..., data_N, witnessScript]
   *
   * The witness script verifies each data chunk against its committed hash.
   * If any data is wrong or missing, the transaction is INVALID at consensus level.
   */
  finalizeCommitmentInput(t, e) {
    if (!t.partialSig || t.partialSig.length === 0)
      throw new Error("No signature for commitment input");
    if (!t.witnessScript)
      throw new Error("No witness script for commitment input");
    const i = [
      t.partialSig[0].signature,
      // Signature for OP_CHECKSIG
      ...e.dataChunks,
      // All data chunks for OP_HASH160 verification
      t.witnessScript
      // The witness script
    ];
    return {
      finalScriptSig: void 0,
      finalScriptWitness: m.witnessStackToScriptWitness(i)
    };
  }
  /**
   * Estimate reveal transaction vBytes.
   */
  estimateRevealVBytes() {
    this.commitmentOutputs.length;
    let t = 0;
    for (const i of this.commitmentOutputs) {
      const r = i.dataChunks.length, s = r * 80, o = r * 23 + 35;
      t += 164 + s + o + 72 + 20;
    }
    const e = 40 + t + 200;
    return Math.ceil(e / 4);
  }
  /**
   * Calculate the required value per commitment output.
   * This must cover: dust minimum + share of reveal fee + share of OPNet fee
   */
  calculateValuePerOutput() {
    if (this.cachedValuePerOutput !== null)
      return this.cachedValuePerOutput;
    const t = this.commitmentOutputs.length, e = this.getTransactionOPNetFee(), i = e < V ? V : e, r = this.estimateRevealVBytes(), s = BigInt(Math.ceil(r * this.feeRate)), o = i + s + m.MINIMUM_DUST, c = BigInt(Math.ceil(Number(o) / t)), u = E.MIN_OUTPUT_VALUE;
    return this.cachedValuePerOutput = c > u ? c : u, this.cachedValuePerOutput;
  }
  /**
   * Get refund address.
   */
  getRefundAddress() {
    return this.from ? this.from : ae.generatePKSH(this.signer.publicKey, this.network);
  }
  /**
   * Generate features (same as InteractionTransaction).
   */
  generateFeatures(t) {
    const e = [];
    t.loadedStorage && e.push({
      priority: Q.ACCESS_LIST,
      opcode: W.ACCESS_LIST,
      data: t.loadedStorage
    });
    const i = t.challenge.getSubmission();
    if (i && e.push({
      priority: Q.EPOCH_SUBMISSION,
      opcode: W.EPOCH_SUBMISSION,
      data: i
    }), t.revealMLDSAPublicKey && !t.linkMLDSAPublicKeyToAddress)
      throw new Error(
        "To reveal the MLDSA public key, you must set linkMLDSAPublicKeyToAddress to true."
      );
    return t.linkMLDSAPublicKeyToAddress && this.generateMLDSALinkRequest(t, e), e;
  }
  /**
   * Validate output count is within standard tx limits.
   */
  validateOutputCount() {
    const t = E.calculateMaxInputsPerTx();
    if (this.commitmentOutputs.length > t) {
      const e = E.calculateMaxDataPerTx();
      throw new Error(
        `Data too large: ${this.commitmentOutputs.length} P2WSH outputs needed, max ${t} per standard transaction (~${Math.floor(e / 1024)}KB). Compiled data: ${this.compiledTargetScript.length} bytes.`
      );
    }
  }
}
class Qe {
  constructor() {
    this.debug = !1, this.DUMMY_PUBKEY = a.alloc(32, 1), this.P2TR_SCRIPT = a.concat([a.from([81, 32]), this.DUMMY_PUBKEY]), this.INITIAL_FUNDING_ESTIMATE = 2000n, this.MAX_ITERATIONS = 10;
  }
  /**
   * @description Creates a cancellable transaction.
   * @param {ICancelTransactionParameters | ICancelTransactionParametersWithoutSigner} params - The cancel transaction parameters
   * @returns {Promise<CancelledTransaction>} - The cancelled transaction result
   */
  async createCancellableTransaction(t) {
    if (!t.to)
      throw new Error('Field "to" not provided.');
    if (!t.from)
      throw new Error('Field "from" not provided.');
    if (!t.utxos[0])
      throw new Error("Missing at least one UTXO.");
    const e = await this.detectCancelOPWallet(t);
    if (e)
      return e;
    if (!("signer" in t))
      throw new Error('Field "signer" not provided, OP_WALLET not detected.');
    const r = await new ge(t).signTransaction();
    return {
      transaction: r.toHex(),
      nextUTXOs: this.getUTXOAsTransaction(r, t.from, 0),
      inputUtxos: t.utxos
    };
  }
  /**
   * @description Generate a transaction with a custom script.
   * @param {ICustomTransactionParameters | ICustomTransactionWithoutSigner} interactionParameters - The custom transaction parameters
   * @returns {Promise<[string, string, UTXO[], UTXO[]]>} - The signed transaction tuple [fundingTx, customTx, nextUTXOs, inputUtxos]
   */
  async createCustomScriptTransaction(t) {
    if (!t.to)
      throw new Error('Field "to" not provided.');
    if (!t.from)
      throw new Error('Field "from" not provided.');
    if (!t.utxos[0])
      throw new Error("Missing at least one UTXO.");
    if (!("signer" in t))
      throw new Error('Field "signer" not provided, OP_WALLET not detected.');
    const e = this.parseOptionalInputs(t.optionalInputs), { finalTransaction: i, estimatedAmount: r, challenge: s } = await this.iterateFundingAmount(
      { ...t, optionalInputs: e },
      Wt,
      async (p) => {
        const f = await p.estimateTransactionFees(), w = this.getPriorityFee(t), S = p.getOptionalOutputValue();
        return f + w + S;
      },
      "CustomScript"
    ), o = await i.getFundingTransactionParameters();
    o.utxos = t.utxos, o.amount = r;
    const c = await this.createFundTransaction({
      ...o,
      optionalOutputs: [],
      optionalInputs: []
    });
    if (!c)
      throw new Error("Could not sign funding transaction.");
    o.estimatedFees = c.estimatedFees;
    const u = await this.createFundTransaction({
      ...o,
      optionalOutputs: [],
      optionalInputs: []
    });
    if (!u)
      throw new Error("Could not sign funding transaction.");
    const h = {
      ...t,
      utxos: this.getUTXOAsTransaction(u.tx, t.to, 0),
      randomBytes: i.getRndBytes(),
      nonWitnessUtxo: u.tx.toBuffer(),
      estimatedFees: i.estimatedFees,
      compiledTargetScript: i.exportCompiledTargetScript(),
      optionalInputs: e
    }, d = await new Wt(h).signTransaction();
    return [
      u.tx.toHex(),
      d.toHex(),
      this.getUTXOAsTransaction(u.tx, t.from, 1),
      t.utxos
    ];
  }
  /**
   * @description Generates the required transactions.
   * @param {IInteractionParameters | InteractionParametersWithoutSigner} interactionParameters - The interaction parameters
   * @returns {Promise<InteractionResponse>} - The signed transaction
   */
  async signInteraction(t) {
    if (!t.to)
      throw new Error('Field "to" not provided.');
    if (!t.from)
      throw new Error('Field "from" not provided.');
    if (!t.utxos[0])
      throw new Error("Missing at least one UTXO.");
    const e = await this.detectInteractionOPWallet(t);
    if (e)
      return e;
    if (!("signer" in t))
      throw new Error('Field "signer" not provided, OP_WALLET not detected.');
    if (this.hasP2WDAInputs(t.utxos))
      return this.signP2WDAInteraction(t);
    const r = this.parseOptionalInputs(t.optionalInputs), { finalTransaction: s, estimatedAmount: o, challenge: c } = await this.iterateFundingAmount(
      { ...t, optionalInputs: r },
      Nt,
      async (S) => {
        const b = await S.estimateTransactionFees(), _ = S.getTotalOutputValue();
        return b + _;
      },
      "Interaction"
    );
    if (!c)
      throw new Error("Failed to get challenge from interaction transaction");
    const u = await s.getFundingTransactionParameters();
    u.utxos = t.utxos, u.amount = o;
    const h = await this.createFundTransaction({
      ...u,
      optionalOutputs: [],
      optionalInputs: []
    });
    if (!h)
      throw new Error("Could not sign funding transaction.");
    u.estimatedFees = h.estimatedFees;
    const l = await this.createFundTransaction({
      ...u,
      optionalOutputs: [],
      optionalInputs: []
    });
    if (!l)
      throw new Error("Could not sign funding transaction.");
    const d = this.getUTXOAsTransaction(
      l.tx,
      s.getScriptAddress(),
      0
    ), p = {
      ...t,
      utxos: d,
      randomBytes: s.getRndBytes(),
      challenge: c,
      compiledTargetScript: s.exportCompiledTargetScript(),
      nonWitnessUtxo: l.tx.toBuffer(),
      estimatedFees: s.estimatedFees,
      optionalInputs: r
    }, f = new Nt(p), w = await f.signTransaction();
    return {
      interactionAddress: s.getScriptAddress(),
      fundingTransaction: l.tx.toHex(),
      interactionTransaction: w.toHex(),
      estimatedFees: f.transactionFee,
      nextUTXOs: this.getUTXOAsTransaction(
        l.tx,
        t.from,
        1
      ),
      challenge: c.toRaw(),
      fundingUTXOs: d,
      fundingInputUtxos: t.utxos,
      compiledTargetScript: f.exportCompiledTargetScript().toString("hex")
    };
  }
  /**
   * @description Generates a consolidated interaction transaction (CHCT system).
   *
   * Drop-in replacement for signInteraction that bypasses BIP110/Bitcoin Knots censorship.
   * Uses P2WSH with HASH160 commitments instead of Tapscript (which uses OP_IF and gets censored).
   *
   * Returns two transactions:
   * - Setup: Creates P2WSH outputs with hash commitments to data chunks
   * - Reveal: Spends those outputs, revealing data in witnesses
   *
   * Data integrity is consensus-enforced - if data is stripped/modified,
   * HASH160(data) != committed_hash and the transaction is INVALID.
   *
   * @param {IConsolidatedInteractionParameters} interactionParameters - Same parameters as signInteraction
   * @returns {Promise<ConsolidatedInteractionResponse>} - Both setup and reveal transactions
   */
  async signConsolidatedInteraction(t) {
    if (!t.to)
      throw new Error('Field "to" not provided.');
    if (!t.from)
      throw new Error('Field "from" not provided.');
    if (!t.utxos[0])
      throw new Error("Missing at least one UTXO.");
    if (!("signer" in t))
      throw new Error('Field "signer" not provided.');
    if (!t.challenge)
      throw new Error('Field "challenge" not provided.');
    const e = this.parseOptionalInputs(t.optionalInputs), i = new Ge({
      ...t,
      optionalInputs: e
    }), r = await i.build();
    return {
      setupTransaction: r.setup.txHex,
      revealTransaction: r.reveal.txHex,
      setupTxId: r.setup.txId,
      revealTxId: r.reveal.txId,
      totalFees: r.totalFees,
      chunkCount: r.setup.chunkCount,
      dataSize: r.setup.totalDataSize,
      challenge: i.getChallenge().toRaw(),
      inputUtxos: t.utxos,
      compiledTargetScript: i.exportCompiledTargetScript().toString("hex")
    };
  }
  /**
   * @description Generates the required transactions.
   * @param {IDeploymentParameters} deploymentParameters - The deployment parameters
   * @returns {Promise<DeploymentResult>} - The signed transaction
   */
  async signDeployment(t) {
    const e = await this.detectDeploymentOPWallet(t);
    if (e)
      return e;
    if (!("signer" in t))
      throw new Error('Field "signer" not provided, OP_WALLET not detected.');
    const i = this.parseOptionalInputs(t.optionalInputs), { finalTransaction: r, estimatedAmount: s, challenge: o } = await this.iterateFundingAmount(
      { ...t, optionalInputs: i },
      ft,
      async (xt) => {
        const vt = await xt.estimateTransactionFees(), kt = this.getPriorityFee(t), li = xt.getOptionalOutputValue();
        return vt + kt + li;
      },
      "Deployment"
    );
    if (!o)
      throw new Error("Failed to get challenge from deployment transaction");
    const c = await r.getFundingTransactionParameters();
    c.utxos = t.utxos, c.amount = s;
    const u = await this.createFundTransaction({
      ...c,
      optionalOutputs: [],
      optionalInputs: []
    });
    if (!u)
      throw new Error("Could not sign funding transaction.");
    c.estimatedFees = u.estimatedFees;
    const l = await new Mt({
      ...c,
      optionalInputs: [],
      optionalOutputs: []
    }).signTransaction();
    if (!l)
      throw new Error("Could not sign funding transaction.");
    const d = l.outs[0], p = {
      transactionId: l.getId(),
      outputIndex: 0,
      scriptPubKey: {
        hex: d.script.toString("hex"),
        address: r.getScriptAddress()
      },
      value: BigInt(d.value)
    }, f = {
      ...t,
      utxos: [p],
      randomBytes: r.getRndBytes(),
      compiledTargetScript: r.exportCompiledTargetScript(),
      challenge: o,
      nonWitnessUtxo: l.toBuffer(),
      estimatedFees: r.estimatedFees,
      optionalInputs: i
    }, w = new ft(f), S = await w.signTransaction(), b = l.outs[1], _ = {
      transactionId: l.getId(),
      outputIndex: 1,
      scriptPubKey: {
        hex: b.script.toString("hex"),
        address: t.from
      },
      value: BigInt(b.value)
    };
    return {
      transaction: [l.toHex(), S.toHex()],
      contractAddress: w.getContractAddress(),
      contractPubKey: w.contractPubKey,
      utxos: [_],
      challenge: o.toRaw(),
      inputUtxos: t.utxos
    };
  }
  /**
   * @description Creates a funding transaction.
   * @param {IFundingTransactionParameters} parameters - The funding transaction parameters
   * @returns {Promise<BitcoinTransferResponse>} - The signed transaction
   */
  async createBTCTransfer(t) {
    if (!t.from)
      throw new Error('Field "from" not provided.');
    const e = await this.createFundTransaction(t);
    return {
      estimatedFees: e.estimatedFees,
      original: e.original,
      tx: e.tx.toHex(),
      nextUTXOs: this.getAllNewUTXOs(e.original, e.tx, t.from),
      inputUtxos: t.utxos
    };
  }
  /**
   * Get all new UTXOs of a generated transaction.
   * @param {TransactionBuilder<TransactionType>} original - The original transaction
   * @param {Transaction} tx - The transaction
   * @param {string} to - The address to filter
   * @returns {UTXO[]} - The new UTXOs belonging to the specified address
   */
  getAllNewUTXOs(t, e, i) {
    const r = t.getOutputs(), s = [];
    for (let o = 0; o < e.outs.length; o++) {
      const c = r[o];
      if ("address" in c) {
        if (c.address !== i) continue;
      } else
        continue;
      s.push(...this.getUTXOAsTransaction(e, i, o));
    }
    return s;
  }
  /**
   * Parse optional inputs and normalize nonWitnessUtxo format.
   * @param {UTXO[]} optionalInputs - The optional inputs to parse
   * @returns {UTXO[]} - The parsed inputs with normalized nonWitnessUtxo
   */
  parseOptionalInputs(t) {
    return (t || []).map((e) => {
      let i = e.nonWitnessUtxo;
      return i && !(i instanceof Uint8Array) && typeof i == "object" && (i = a.from(
        Uint8Array.from(
          Object.values(e.nonWitnessUtxo)
        )
      )), {
        ...e,
        nonWitnessUtxo: i
      };
    });
  }
  /**
   * Detect and use OP_WALLET for cancel transactions if available.
   * @param {ICancelTransactionParameters | ICancelTransactionParametersWithoutSigner} interactionParameters - The cancel parameters
   * @returns {Promise<CancelledTransaction | null>} - The cancelled transaction or null if OP_WALLET not available
   */
  async detectCancelOPWallet(t) {
    if (typeof window > "u")
      return null;
    const e = window;
    if (!e || !e.opnet || !e.opnet.web3)
      return null;
    const r = await e.opnet.web3.cancelTransaction({
      ...t,
      // @ts-expect-error no, this is ok
      signer: void 0
    });
    if (!r)
      throw new Error("Could not sign interaction transaction.");
    return {
      ...r,
      inputUtxos: r.inputUtxos ?? t.utxos
    };
  }
  /**
   * Detect and use OP_WALLET for interaction transactions if available.
   * @param {IInteractionParameters | InteractionParametersWithoutSigner} interactionParameters - The interaction parameters
   * @returns {Promise<InteractionResponse | null>} - The interaction response or null if OP_WALLET not available
   */
  async detectInteractionOPWallet(t) {
    if (typeof window > "u")
      return null;
    const e = window;
    if (!e || !e.opnet || !e.opnet.web3)
      return null;
    const r = await e.opnet.web3.signInteraction({
      ...t,
      // @ts-expect-error no, this is ok
      signer: void 0
    });
    if (!r)
      throw new Error("Could not sign interaction transaction.");
    return {
      ...r,
      fundingInputUtxos: r.fundingInputUtxos ?? t.utxos
    };
  }
  /**
   * Detect and use OP_WALLET for deployment transactions if available.
   * @param {IDeploymentParameters | IDeploymentParametersWithoutSigner} deploymentParameters - The deployment parameters
   * @returns {Promise<DeploymentResult | null>} - The deployment result or null if OP_WALLET not available
   */
  async detectDeploymentOPWallet(t) {
    if (typeof window > "u")
      return null;
    const e = window;
    if (!e || !e.opnet || !e.opnet.web3)
      return null;
    const r = await e.opnet.web3.deployContract({
      ...t,
      // @ts-expect-error no, this is ok
      signer: void 0
    });
    if (!r)
      throw new Error("Could not sign interaction transaction.");
    return {
      ...r,
      inputUtxos: r.inputUtxos ?? t.utxos
    };
  }
  /**
   * Create and sign a funding transaction.
   * @param {IFundingTransactionParameters} parameters - The funding transaction parameters
   * @returns {Promise<FundingTransactionResponse>} - The funding transaction response
   */
  async createFundTransaction(t) {
    if (!t.to) throw new Error('Field "to" not provided.');
    const e = new Mt(t), i = await e.signTransaction();
    if (!i)
      throw new Error("Could not sign funding transaction.");
    return {
      tx: i,
      original: e,
      estimatedFees: e.estimatedFees,
      nextUTXOs: this.getUTXOAsTransaction(i, t.to, 0),
      inputUtxos: t.utxos
    };
  }
  /**
   * Check if the UTXOs contain any P2WDA inputs
   *
   * This method examines both main UTXOs and optional inputs to determine
   * if any of them are P2WDA addresses. P2WDA detection is based on the
   * witness script pattern: (OP_2DROP * 5) <pubkey> OP_CHECKSIG
   *
   * @param {UTXO[]} utxos - The main UTXOs to check
   * @returns {boolean} - true if any UTXO is P2WDA, false otherwise
   */
  hasP2WDAInputs(t) {
    return t.some((e) => z.isP2WDAUTXO(e));
  }
  /**
   * Write PSBT header with type and consensus version.
   * @param {PSBTTypes} type - The PSBT type
   * @param {string} psbt - The base64 encoded PSBT
   * @returns {string} - The hex encoded PSBT with header
   */
  writePSBTHeader(t, e) {
    const i = a.from(e, "base64"), r = a.alloc(2);
    return r.writeUInt8(t, 0), r.writeUInt8($t, 1), a.concat([r, i]).toString("hex");
  }
  /**
   * Sign a P2WDA interaction transaction
   *
   * P2WDA interactions are fundamentally different from standard OP_NET interactions.
   * Instead of using a two-transaction model (funding + interaction), P2WDA embeds
   * the operation data directly in the witness field of a single transaction.
   * This achieves significant cost savings through the witness discount.
   *
   * Key differences:
   * - Single transaction instead of two
   * - Operation data in witness field instead of taproot script
   * - 75% cost reduction for data storage
   * - No separate funding transaction needed
   *
   * @param {IInteractionParameters | InteractionParametersWithoutSigner} interactionParameters - The interaction parameters
   * @returns {Promise<InteractionResponse>} - The signed P2WDA interaction response
   */
  async signP2WDAInteraction(t) {
    if (!t.from)
      throw new Error('Field "from" not provided.');
    if (!("signer" in t))
      throw new Error(
        "P2WDA interactions require a signer. OP_WALLET is not supported for P2WDA."
      );
    const e = this.parseOptionalInputs(t.optionalInputs), i = new j({
      ...t,
      optionalInputs: e
    }), r = await i.signTransaction();
    return {
      interactionAddress: null,
      fundingTransaction: null,
      interactionTransaction: r.toHex(),
      estimatedFees: i.estimatedFees,
      nextUTXOs: this.getUTXOAsTransaction(
        r,
        t.from,
        r.outs.length - 1
      ),
      fundingUTXOs: [...t.utxos, ...e],
      fundingInputUtxos: t.utxos,
      challenge: t.challenge.toRaw(),
      compiledTargetScript: null
    };
  }
  /**
   * Get the priority fee from transaction parameters.
   * @param {ITransactionParameters} params - The transaction parameters
   * @returns {bigint} - The priority fee, minimum dust if below threshold
   */
  getPriorityFee(t) {
    const e = t.priorityFee + t.gasSatFee;
    return e < m.MINIMUM_DUST ? m.MINIMUM_DUST : e;
  }
  /**
   * Common iteration logic for finding the correct funding amount.
   *
   * This method iteratively estimates the required funding amount by simulating
   * transactions until the amount converges or max iterations is reached.
   *
   * @param {P} params - The transaction parameters
   * @param {new (params: P) => T} TransactionClass - The transaction class constructor
   * @param {(tx: T) => Promise<bigint>} calculateAmount - Function to calculate required amount
   * @param {string} debugPrefix - Prefix for debug logging
   * @returns {Promise<{finalTransaction: T, estimatedAmount: bigint, challenge: IChallengeSolution | null}>} - The final transaction and estimated amount
   */
  async iterateFundingAmount(t, e, i, r) {
    const s = "randomBytes" in t ? t.randomBytes ?? K.rndBytes() : K.rndBytes(), o = k.dead().p2tr(t.network);
    let c = this.INITIAL_FUNDING_ESTIMATE, u = 0n, h = 0, l = null, d = null;
    for (; h < this.MAX_ITERATIONS && c !== u; ) {
      u = c;
      const p = new Jt();
      p.addOutput(this.P2TR_SCRIPT, Number(c));
      const f = {
        transactionId: a.alloc(32, 0).toString("hex"),
        outputIndex: 0,
        scriptPubKey: {
          hex: this.P2TR_SCRIPT.toString("hex"),
          address: o
        },
        value: c,
        nonWitnessUtxo: p.toBuffer()
      };
      let w;
      "challenge" in t && t.challenge ? w = {
        ...t,
        utxos: [f],
        randomBytes: s,
        challenge: d ?? t.challenge
      } : w = {
        ...t,
        utxos: [f],
        randomBytes: s
      };
      const S = new e(w);
      try {
        await S.generateTransactionMinimalSignatures(), c = await i(S);
      } catch (b) {
        if (b instanceof Error) {
          const _ = b.message.match(/need (\d+) sats but only have (\d+) sats/);
          if (_)
            c = BigInt(_[1]), this.debug && console.log(
              `${r}: Caught insufficient funds, updating to ${c}`
            );
          else
            throw b;
        } else
          throw new Error("Unknown error during fee estimation");
      }
      l = S, "getChallenge" in S && typeof S.getChallenge == "function" && (d = S.getChallenge()), h++, this.debug && console.log(
        `${r} Iteration ${h}: Previous=${u}, New=${c}`
      );
    }
    if (!l)
      throw new Error(`Failed to converge on ${r} funding amount`);
    return {
      finalTransaction: l,
      estimatedAmount: c,
      challenge: d
    };
  }
  /**
   * Convert a transaction output to a UTXO.
   * @param {Transaction} tx - The transaction
   * @param {string} to - The address
   * @param {number} index - The output index
   * @returns {UTXO[]} - The UTXO array (empty if output doesn't exist)
   */
  getUTXOAsTransaction(t, e, i) {
    if (!t.outs[i]) return [];
    const r = t.outs[i];
    return [{
      transactionId: t.getId(),
      outputIndex: i,
      scriptPubKey: {
        hex: r.script.toString("hex"),
        address: e
      },
      value: BigInt(r.value)
    }];
  }
}
class x extends m {
  constructor(t) {
    if (!t.refundVault)
      throw new Error("Refund vault is required");
    if (!t.requestedAmount)
      throw new Error("Requested amount is required");
    if (!t.receiver)
      throw new Error("Receiver is required");
    if (super({
      ...t,
      signer: A.fromPrivateKey(
        Ue(a.from("aaaaaaaa", "utf-8"))
      ),
      priorityFee: 0n,
      gasSatFee: 0n
    }), this.type = y.MULTI_SIG, this.targetScriptRedeem = null, this.leftOverFundsScriptRedeem = null, this.originalInputCount = 0, this.sighashTypes = x.signHashTypesArray, this.customFinalizer = (e, i) => {
      if (!this.tapLeafScript)
        throw new Error("Tap leaf script is required");
      const s = this.getScriptSolution(i).concat(this.tapLeafScript.script).concat(this.tapLeafScript.controlBlock);
      return {
        finalScriptWitness: m.witnessStackToScriptWitness(s)
      };
    }, !t.pubkeys)
      throw new Error("Pubkeys are required");
    t.psbt && (this.log("Using provided PSBT."), this.transaction = t.psbt, this.originalInputCount = this.transaction.data.inputs.length), this.refundVault = t.refundVault, this.requestedAmount = t.requestedAmount, this.receiver = t.receiver, this.publicKeys = t.pubkeys, this.minimumSignatures = t.minimumSignatures, this.compiledTargetScript = Pt.compile(
      t.pubkeys,
      this.minimumSignatures
    ), this.scriptTree = this.getScriptTree(), this.internalInit();
  }
  static {
    this.LOCK_LEAF_SCRIPT = L([
      g.OP_XOR,
      g.OP_NOP,
      g.OP_CODESEPARATOR
    ]);
  }
  static {
    this.signHashTypesArray = [
      //Transaction.SIGHASH_ALL,
      //Transaction.SIGHASH_ANYONECANPAY,
    ];
  }
  static {
    this.numsPoint = a.from(
      "50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0",
      "hex"
    );
  }
  /**
   * Generate a multisig transaction from a base64 psbt.
   * @param {MultiSignFromBase64Params} params The parameters
   * @returns {MultiSignTransaction} The multisig transaction
   */
  static fromBase64(t) {
    const e = F.fromBase64(t.psbt, { network: t.network });
    return new x({
      ...t,
      psbt: e
    });
  }
  /**
   * Verify if that public key already signed the transaction
   * @param {Psbt} psbt The psbt
   * @param {Buffer} signerPubKey The signer public key
   * @returns {boolean} True if the public key signed the transaction
   */
  static verifyIfSigned(t, e) {
    let i = !1;
    for (let r = 1; r < t.data.inputs.length; r++) {
      const s = t.data.inputs[r];
      if (!s.finalScriptWitness)
        continue;
      const o = m.readScriptWitnessToWitnessStack(
        s.finalScriptWitness
      );
      if (!(o.length < 3)) {
        for (let c = 0; c < o.length - 2; c += 3)
          if (o[c + 2].equals(e)) {
            i = !0;
            break;
          }
      }
    }
    return i;
  }
  /**
   * Partially sign the transaction
   * @returns {boolean} True if the transaction was signed
   * @public
   */
  static signPartial(t, e, i, r) {
    let s = !1, o = !0;
    for (let c = i; c < t.data.inputs.length; c++) {
      const u = t.data.inputs[c];
      u.tapInternalKey || (u.tapInternalKey = O(x.numsPoint));
      const h = [];
      if (u.finalScriptWitness) {
        const d = m.readScriptWitnessToWitnessStack(
          u.finalScriptWitness
        );
        u.tapLeafScript = [
          {
            leafVersion: 192,
            script: d[d.length - 2],
            controlBlock: d[d.length - 1]
          }
        ];
        for (let p = 0; p < d.length - 2; p += 3)
          h.push({
            signature: d[p],
            leafHash: d[p + 1],
            pubkey: d[p + 2]
          });
        u.tapScriptSig = (u.tapScriptSig || []).concat(h);
      }
      delete u.finalScriptWitness;
      const l = x.signHashTypesArray ? [x.calculateSignHash(x.signHashTypesArray)] : [];
      try {
        x.signInput(t, u, c, e, l), s = !0;
      } catch (d) {
        console.log(d);
      }
      if (s) {
        if (!u.tapScriptSig) throw new Error("No new signatures for input");
        u.tapScriptSig.length !== r[c - i] && (o = !1);
      }
    }
    return {
      signed: s,
      final: s ? o : !1
    };
  }
  static {
    this.partialFinalizer = (t, e, i, r, s) => {
      if (!e.tapLeafScript || !e.tapLeafScript[0].script || !e.tapLeafScript[0].controlBlock)
        throw new Error("Tap leaf script is required");
      if (!e.tapScriptSig)
        throw new Error(`No new signatures for input ${t}.`);
      let o = [];
      if (!s)
        o = e.tapScriptSig.map((u) => [u.signature, u.leafHash, u.pubkey]).flat();
      else {
        for (const u of r) {
          let h = !1;
          for (const l of e.tapScriptSig)
            l.pubkey.equals(O(u)) && (o.push(l.signature), h = !0);
          h || o.push(a.alloc(0));
        }
        o = o.reverse();
      }
      i.length > 0 && (o = o.concat(i));
      const c = o.concat(e.tapLeafScript[0].script).concat(e.tapLeafScript[0].controlBlock);
      return {
        finalScriptWitness: m.witnessStackToScriptWitness(c)
      };
    };
  }
  /**
   * Dedupe signatures
   * @param {TapScriptSig[]} original The original signatures
   * @param {TapScriptSig[]} partial The partial signatures
   * @returns {TapScriptSig[]} The deduped signatures
   */
  static dedupeSignatures(t, e) {
    const i = /* @__PURE__ */ new Map();
    for (const r of t)
      i.set(r.pubkey.toString("hex"), r);
    for (const r of e)
      i.has(r.pubkey.toString("hex")) || i.set(r.pubkey.toString("hex"), r);
    return Array.from(i.values());
  }
  /**
   * Attempt to finalize the inputs
   * @param {Psbt} psbt The psbt
   * @param {number} startIndex The start index
   * @param {Buffer[]} orderedPubKeys The ordered public keys
   * @param {boolean} isFinal If the transaction is final
   * @returns {boolean} True if the inputs were finalized
   */
  static attemptFinalizeInputs(t, e, i, r) {
    let s = 0;
    for (let o = e; o < t.data.inputs.length; o++)
      try {
        const c = t.data.inputs[o];
        c.tapInternalKey || (c.tapInternalKey = O(x.numsPoint));
        const u = [];
        if (c.finalScriptWitness) {
          const h = m.readScriptWitnessToWitnessStack(
            c.finalScriptWitness
          );
          for (let l = 0; l < h.length - 2; l += 3)
            u.push({
              signature: h[l],
              leafHash: h[l + 1],
              pubkey: h[l + 2]
            });
          c.tapLeafScript = [
            {
              leafVersion: 192,
              script: h[h.length - 2],
              controlBlock: h[h.length - 1]
            }
          ], c.tapScriptSig = x.dedupeSignatures(
            c.tapScriptSig || [],
            u
          );
        }
        delete c.finalScriptWitness, t.finalizeInput(
          o,
          (h, l) => x.partialFinalizer(
            h,
            l,
            [],
            i[o - e],
            r
          )
        ), s++;
      } catch {
      }
    return s === t.data.inputs.length - e;
  }
  /**
   * Finalize the psbt multisig transaction
   */
  finalizeTransactionInputs() {
    let t = !1;
    try {
      for (let e = this.originalInputCount; e < this.transaction.data.inputs.length; e++)
        this.transaction.finalizeInput(e, this.customFinalizer.bind(this));
      t = !0;
    } catch (e) {
      this.error(`Error finalizing transaction inputs: ${e.stack}`);
    }
    return t;
  }
  /**
   * @description Signs the transaction
   * @public
   * @returns {Promise<Psbt>} - The signed transaction in hex format
   * @throws {Error} - If something went wrong
   */
  async signPSBT() {
    if (await this.signTransaction())
      return this.transaction;
    throw new Error("Could not sign transaction");
  }
  /**
   * Build the transaction
   * @protected
   *
   * @throws {Error} If the left over funds script redeem is required
   * @throws {Error} If the left over funds script redeem version is required
   * @throws {Error} If the left over funds script redeem output is required
   */
  // eslint-disable-next-line @typescript-eslint/require-await
  async buildTransaction() {
    const t = this.targetScriptRedeem;
    if (!t)
      throw new Error("Left over funds script redeem is required");
    if (!t.redeemVersion)
      throw new Error("Left over funds script redeem version is required");
    if (!t.output)
      throw new Error("Left over funds script redeem output is required");
    this.tapLeafScript = {
      leafVersion: t.redeemVersion,
      script: t.output,
      controlBlock: this.getWitness()
    }, this.addInputsFromUTXO();
    const e = this.calculateOutputLeftAmountFromVaults(this.utxos);
    if (e < 0)
      throw new Error(`Output value left is negative ${e}.`);
    this.addOutput({
      address: this.refundVault,
      value: Number(e)
    }), this.addOutput({
      address: this.receiver,
      value: Number(this.requestedAmount)
    });
  }
  /**
   * Builds the transaction.
   * @param {Psbt} transaction - The transaction to build
   * @param checkPartialSigs
   * @protected
   * @returns {Promise<boolean>}
   * @throws {Error} - If something went wrong while building the transaction
   */
  async internalBuildTransaction(t, e = !1) {
    const i = this.getInputs(), r = this.getOutputs();
    t.setMaximumFeeRate(this._maximumFeeRate), t.addInputs(i, e);
    for (let s = 0; s < this.updateInputs.length; s++)
      t.updateInput(s, this.updateInputs[s]);
    t.addOutputs(r);
    try {
      return await this.signInputs(t), this.finalizeTransactionInputs();
    } catch (s) {
      const o = s;
      this.error(
        `[internalBuildTransaction] Something went wrong while getting building the transaction: ${o.stack}`
      );
    }
    return !1;
  }
  /**
   * Sign the inputs
   * @protected
   */
  async signInputs(t) {
  }
  generateScriptAddress() {
    return {
      internalPubkey: O(x.numsPoint),
      //this.internalPubKeyToXOnly(),
      network: this.network,
      scriptTree: this.scriptTree,
      name: v.P2TR
    };
  }
  generateTapData() {
    const t = this.targetScriptRedeem;
    if (!t)
      throw new Error("Left over funds script redeem is required");
    if (!this.scriptTree)
      throw new Error("Script tree is required");
    return {
      internalPubkey: O(x.numsPoint),
      //this.internalPubKeyToXOnly(),
      network: this.network,
      scriptTree: this.scriptTree,
      redeem: t,
      name: v.P2TR
    };
  }
  /**
   * Generate the script solution
   * @param {PsbtInput} input The input
   * @protected
   *
   * @returns {Buffer[]} The script solution
   */
  getScriptSolution(t) {
    return t.tapScriptSig ? t.tapScriptSig.map((e) => e.signature) : [];
  }
  /**
   * Get the script tree
   * @private
   *
   * @returns {Taptree} The script tree
   */
  getScriptTree() {
    return this.generateRedeemScripts(), [
      {
        output: this.compiledTargetScript,
        version: 192
      },
      {
        output: x.LOCK_LEAF_SCRIPT,
        version: 192
      }
    ];
  }
  getTotalOutputAmount(t) {
    let e = 0n;
    for (const i of t)
      e += i.value;
    return e;
  }
  /**
   * @description Calculate the amount left to refund to the first vault.
   * @private
   * @returns {bigint} The amount left
   */
  calculateOutputLeftAmountFromVaults(t) {
    return this.getTotalOutputAmount(t) - this.requestedAmount;
  }
  /**
   * Generate the redeem scripts
   * @private
   *
   * @throws {Error} If the public keys are required
   * @throws {Error} If the leaf script is required
   * @throws {Error} If the leaf script version is required
   * @throws {Error} If the leaf script output is required
   * @throws {Error} If the target script redeem is required
   */
  generateRedeemScripts() {
    this.targetScriptRedeem = {
      name: v.P2TR,
      output: this.compiledTargetScript,
      redeemVersion: 192
    }, this.leftOverFundsScriptRedeem = {
      name: v.P2TR,
      output: x.LOCK_LEAF_SCRIPT,
      redeemVersion: 192
    };
  }
}
const Se = 1, _t = 66;
function je(n) {
  return n.type === y.FUNDING;
}
function Ze(n) {
  return n.type === y.DEPLOYMENT;
}
function Je(n) {
  return n.type === y.INTERACTION;
}
function et(n) {
  return n.type === y.MULTI_SIG;
}
function ti(n) {
  return n.type === y.CUSTOM_CODE;
}
function ei(n) {
  return n.type === y.CANCEL;
}
class B {
  /**
   * Serialize transaction state to binary format
   * @param state - The transaction state to serialize
   * @returns Buffer containing serialized state with checksum
   */
  static serialize(t) {
    const e = new D();
    this.writeHeader(e, t.header), this.writeBaseParams(e, t.baseParams), this.writeUTXOArray(e, t.utxos), this.writeUTXOArray(e, t.optionalInputs), this.writeOutputArray(e, t.optionalOutputs), e.writeBoolean(t.addressRotationEnabled), this.writeSignerMappings(e, t.signerMappings), this.writeTypeSpecificData(e, t.typeSpecificData), this.writePrecomputedData(e, t.precomputedData);
    const i = a.from(e.getBuffer()), r = this.calculateChecksum(i);
    return a.concat([i, r]);
  }
  /**
   * Deserialize binary format to transaction state
   * @param data - Buffer containing serialized state
   * @returns Deserialized transaction state
   * @throws Error if checksum validation fails or format is invalid
   */
  static deserialize(t) {
    if (t.length < 32)
      throw new Error("Invalid serialized data: too short");
    const e = t.subarray(-32), i = t.subarray(0, -32), r = this.calculateChecksum(i);
    if (!e.equals(r))
      throw new Error("Invalid checksum - data may be corrupted");
    const s = new qt(i), o = this.readHeader(s);
    if (o.formatVersion > Se)
      throw new Error(`Unsupported format version: ${o.formatVersion}`);
    const c = this.readBaseParams(s), u = this.readUTXOArray(s), h = this.readUTXOArray(s), l = this.readOutputArray(s), d = s.readBoolean(), p = this.readSignerMappings(s), f = this.readTypeSpecificData(s, o.transactionType), w = this.readPrecomputedData(s);
    return {
      header: o,
      baseParams: c,
      utxos: u,
      optionalInputs: h,
      optionalOutputs: l,
      addressRotationEnabled: d,
      signerMappings: p,
      typeSpecificData: f,
      precomputedData: w
    };
  }
  /**
   * Export state as base64 string (for transport)
   * @param state - Transaction state to export
   * @returns Base64-encoded string
   */
  static toBase64(t) {
    return this.serialize(t).toString("base64");
  }
  /**
   * Import state from base64 string
   * @param base64 - Base64-encoded state
   * @returns Deserialized transaction state
   */
  static fromBase64(t) {
    return this.deserialize(a.from(t, "base64"));
  }
  /**
   * Export state as hex string
   * @param state - Transaction state to export
   * @returns Hex-encoded string
   */
  static toHex(t) {
    return this.serialize(t).toString("hex");
  }
  /**
   * Import state from hex string
   * @param hex - Hex-encoded state
   * @returns Deserialized transaction state
   */
  static fromHex(t) {
    return this.deserialize(a.from(t, "hex"));
  }
  static writeHeader(t, e) {
    t.writeU8(_t), t.writeU8(e.formatVersion), t.writeU8(e.consensusVersion), t.writeU8(e.transactionType), t.writeU32(e.chainId), t.writeU64(BigInt(e.timestamp));
  }
  static readHeader(t) {
    const e = t.readU8();
    if (e !== _t)
      throw new Error(
        `Invalid magic byte: expected 0x${_t.toString(16)}, got 0x${e.toString(16)}`
      );
    return {
      formatVersion: t.readU8(),
      consensusVersion: t.readU8(),
      transactionType: t.readU8(),
      chainId: t.readU32(),
      timestamp: Number(t.readU64())
    };
  }
  static writeBaseParams(t, e) {
    t.writeStringWithLength(e.from), t.writeBoolean(e.to !== void 0), e.to !== void 0 && t.writeStringWithLength(e.to), t.writeU32(Math.floor(e.feeRate * 1e3)), t.writeU64(BigInt(e.priorityFee)), t.writeU64(BigInt(e.gasSatFee)), t.writeU8(this.networkNameToU8(e.networkName)), t.writeU8(e.txVersion), t.writeBoolean(e.note !== void 0), e.note !== void 0 && t.writeBytesWithLength(a.from(e.note, "hex")), t.writeBoolean(e.anchor), t.writeBoolean(e.debugFees ?? !1);
  }
  static readBaseParams(t) {
    const e = t.readStringWithLength(), r = t.readBoolean() ? t.readStringWithLength() : void 0, s = t.readU32() / 1e3, o = t.readU64().toString(), c = t.readU64().toString(), u = this.u8ToNetworkName(t.readU8()), h = t.readU8(), d = t.readBoolean() ? a.from(t.readBytesWithLength()).toString("hex") : void 0, p = t.readBoolean(), f = t.readBoolean();
    return {
      from: e,
      to: r,
      feeRate: s,
      priorityFee: o,
      gasSatFee: c,
      networkName: u,
      txVersion: h,
      note: d,
      anchor: p,
      debugFees: f
    };
  }
  static writeUTXOArray(t, e) {
    t.writeU16(e.length);
    for (const i of e)
      this.writeUTXO(t, i);
  }
  static writeUTXO(t, e) {
    t.writeBytes(a.from(e.transactionId, "hex")), t.writeU32(e.outputIndex), t.writeU64(BigInt(e.value)), t.writeBytesWithLength(a.from(e.scriptPubKeyHex, "hex")), t.writeBoolean(e.scriptPubKeyAddress !== void 0), e.scriptPubKeyAddress !== void 0 && t.writeStringWithLength(e.scriptPubKeyAddress), t.writeBoolean(e.redeemScript !== void 0), e.redeemScript !== void 0 && t.writeBytesWithLength(a.from(e.redeemScript, "hex")), t.writeBoolean(e.witnessScript !== void 0), e.witnessScript !== void 0 && t.writeBytesWithLength(a.from(e.witnessScript, "hex")), t.writeBoolean(e.nonWitnessUtxo !== void 0), e.nonWitnessUtxo !== void 0 && t.writeBytesWithLength(a.from(e.nonWitnessUtxo, "hex"));
  }
  static readUTXOArray(t) {
    const e = t.readU16(), i = [];
    for (let r = 0; r < e; r++)
      i.push(this.readUTXO(t));
    return i;
  }
  static readUTXO(t) {
    const e = a.from(t.readBytes(32)).toString("hex"), i = t.readU32(), r = t.readU64().toString(), s = a.from(t.readBytesWithLength()).toString("hex"), c = t.readBoolean() ? t.readStringWithLength() : void 0, h = t.readBoolean() ? a.from(t.readBytesWithLength()).toString("hex") : void 0, d = t.readBoolean() ? a.from(t.readBytesWithLength()).toString("hex") : void 0, f = t.readBoolean() ? a.from(t.readBytesWithLength()).toString("hex") : void 0;
    return {
      transactionId: e,
      outputIndex: i,
      value: r,
      scriptPubKeyHex: s,
      scriptPubKeyAddress: c,
      redeemScript: h,
      witnessScript: d,
      nonWitnessUtxo: f
    };
  }
  static writeOutputArray(t, e) {
    t.writeU16(e.length);
    for (const i of e)
      this.writeOutput(t, i);
  }
  static writeOutput(t, e) {
    t.writeU64(BigInt(e.value)), t.writeBoolean(e.address !== void 0), e.address !== void 0 && t.writeStringWithLength(e.address), t.writeBoolean(e.script !== void 0), e.script !== void 0 && t.writeBytesWithLength(a.from(e.script, "hex")), t.writeBoolean(e.tapInternalKey !== void 0), e.tapInternalKey !== void 0 && t.writeBytesWithLength(a.from(e.tapInternalKey, "hex"));
  }
  static readOutputArray(t) {
    const e = t.readU16(), i = [];
    for (let r = 0; r < e; r++)
      i.push(this.readOutput(t));
    return i;
  }
  static readOutput(t) {
    const e = Number(t.readU64()), r = t.readBoolean() ? t.readStringWithLength() : void 0, o = t.readBoolean() ? a.from(t.readBytesWithLength()).toString("hex") : void 0, u = t.readBoolean() ? a.from(t.readBytesWithLength()).toString("hex") : void 0;
    return { value: e, address: r, script: o, tapInternalKey: u };
  }
  static writeSignerMappings(t, e) {
    t.writeU16(e.length);
    for (const i of e) {
      t.writeStringWithLength(i.address), t.writeU16(i.inputIndices.length);
      for (const r of i.inputIndices)
        t.writeU16(r);
    }
  }
  static readSignerMappings(t) {
    const e = t.readU16(), i = [];
    for (let r = 0; r < e; r++) {
      const s = t.readStringWithLength(), o = t.readU16(), c = [];
      for (let u = 0; u < o; u++)
        c.push(t.readU16());
      i.push({ address: s, inputIndices: c });
    }
    return i;
  }
  static writeTypeSpecificData(t, e) {
    switch (e.type) {
      case y.FUNDING:
        this.writeFundingData(t, e);
        break;
      case y.DEPLOYMENT:
        this.writeDeploymentData(t, e);
        break;
      case y.INTERACTION:
        this.writeInteractionData(t, e);
        break;
      case y.MULTI_SIG:
        this.writeMultiSigData(t, e);
        break;
      case y.CUSTOM_CODE:
        this.writeCustomScriptData(t, e);
        break;
      case y.CANCEL:
        this.writeCancelData(t, e);
        break;
      default:
        throw new Error(`Unsupported transaction type: ${e.type}`);
    }
  }
  static readTypeSpecificData(t, e) {
    switch (e) {
      case y.FUNDING:
        return this.readFundingData(t);
      case y.DEPLOYMENT:
        return this.readDeploymentData(t);
      case y.INTERACTION:
        return this.readInteractionData(t);
      case y.MULTI_SIG:
        return this.readMultiSigData(t);
      case y.CUSTOM_CODE:
        return this.readCustomScriptData(t);
      case y.CANCEL:
        return this.readCancelData(t);
      default:
        throw new Error(`Unsupported transaction type: ${e}`);
    }
  }
  // Funding
  static writeFundingData(t, e) {
    t.writeU64(BigInt(e.amount)), t.writeU16(e.splitInputsInto);
  }
  static readFundingData(t) {
    return {
      type: y.FUNDING,
      amount: t.readU64().toString(),
      splitInputsInto: t.readU16()
    };
  }
  // Deployment
  static writeDeploymentData(t, e) {
    t.writeBytesWithLength(a.from(e.bytecode, "hex")), t.writeBoolean(e.calldata !== void 0), e.calldata !== void 0 && t.writeBytesWithLength(a.from(e.calldata, "hex")), this.writeChallenge(t, e.challenge), t.writeBoolean(e.revealMLDSAPublicKey ?? !1), t.writeBoolean(e.linkMLDSAPublicKeyToAddress ?? !1), t.writeBoolean(e.hashedPublicKey !== void 0), e.hashedPublicKey !== void 0 && t.writeBytesWithLength(a.from(e.hashedPublicKey, "hex"));
  }
  static readDeploymentData(t) {
    const e = a.from(t.readBytesWithLength()).toString("hex"), r = t.readBoolean() ? a.from(t.readBytesWithLength()).toString("hex") : void 0, s = this.readChallenge(t), o = t.readBoolean(), c = t.readBoolean(), h = t.readBoolean() ? a.from(t.readBytesWithLength()).toString("hex") : void 0;
    return {
      type: y.DEPLOYMENT,
      bytecode: e,
      calldata: r,
      challenge: s,
      revealMLDSAPublicKey: o,
      linkMLDSAPublicKeyToAddress: c,
      hashedPublicKey: h
    };
  }
  // Interaction
  static writeInteractionData(t, e) {
    t.writeBytesWithLength(a.from(e.calldata, "hex")), t.writeBoolean(e.contract !== void 0), e.contract !== void 0 && t.writeStringWithLength(e.contract), this.writeChallenge(t, e.challenge), t.writeBoolean(e.loadedStorage !== void 0), e.loadedStorage !== void 0 && this.writeLoadedStorage(t, e.loadedStorage), t.writeBoolean(e.isCancellation ?? !1), t.writeBoolean(e.disableAutoRefund ?? !1), t.writeBoolean(e.revealMLDSAPublicKey ?? !1), t.writeBoolean(e.linkMLDSAPublicKeyToAddress ?? !1), t.writeBoolean(e.hashedPublicKey !== void 0), e.hashedPublicKey !== void 0 && t.writeBytesWithLength(a.from(e.hashedPublicKey, "hex"));
  }
  static readInteractionData(t) {
    const e = a.from(t.readBytesWithLength()).toString("hex"), r = t.readBoolean() ? t.readStringWithLength() : void 0, s = this.readChallenge(t), c = t.readBoolean() ? this.readLoadedStorage(t) : void 0, u = t.readBoolean(), h = t.readBoolean(), l = t.readBoolean(), d = t.readBoolean(), f = t.readBoolean() ? a.from(t.readBytesWithLength()).toString("hex") : void 0;
    return {
      type: y.INTERACTION,
      calldata: e,
      contract: r,
      challenge: s,
      loadedStorage: c,
      isCancellation: u,
      disableAutoRefund: h,
      revealMLDSAPublicKey: l,
      linkMLDSAPublicKeyToAddress: d,
      hashedPublicKey: f
    };
  }
  // MultiSig
  static writeMultiSigData(t, e) {
    t.writeU16(e.pubkeys.length);
    for (const i of e.pubkeys)
      t.writeBytesWithLength(a.from(i, "hex"));
    t.writeU8(e.minimumSignatures), t.writeStringWithLength(e.receiver), t.writeU64(BigInt(e.requestedAmount)), t.writeStringWithLength(e.refundVault), t.writeU16(e.originalInputCount), t.writeBoolean(e.existingPsbtBase64 !== void 0), e.existingPsbtBase64 !== void 0 && t.writeStringWithLength(e.existingPsbtBase64);
  }
  static readMultiSigData(t) {
    const e = t.readU16(), i = [];
    for (let d = 0; d < e; d++)
      i.push(a.from(t.readBytesWithLength()).toString("hex"));
    const r = t.readU8(), s = t.readStringWithLength(), o = t.readU64().toString(), c = t.readStringWithLength(), u = t.readU16(), l = t.readBoolean() ? t.readStringWithLength() : void 0;
    return {
      type: y.MULTI_SIG,
      pubkeys: i,
      minimumSignatures: r,
      receiver: s,
      requestedAmount: o,
      refundVault: c,
      originalInputCount: u,
      existingPsbtBase64: l
    };
  }
  // Custom Script
  static writeCustomScriptData(t, e) {
    t.writeU16(e.scriptElements.length);
    for (const i of e.scriptElements)
      this.writeScriptElement(t, i);
    t.writeU16(e.witnesses.length);
    for (const i of e.witnesses)
      t.writeBytesWithLength(a.from(i, "hex"));
    t.writeBoolean(e.annex !== void 0), e.annex !== void 0 && t.writeBytesWithLength(a.from(e.annex, "hex"));
  }
  static writeScriptElement(t, e) {
    t.writeU8(e.elementType === "buffer" ? 0 : 1), e.elementType === "buffer" ? t.writeBytesWithLength(a.from(e.value, "hex")) : t.writeU32(e.value);
  }
  static readCustomScriptData(t) {
    const e = t.readU16(), i = [];
    for (let u = 0; u < e; u++)
      i.push(this.readScriptElement(t));
    const r = t.readU16(), s = [];
    for (let u = 0; u < r; u++)
      s.push(a.from(t.readBytesWithLength()).toString("hex"));
    const c = t.readBoolean() ? a.from(t.readBytesWithLength()).toString("hex") : void 0;
    return {
      type: y.CUSTOM_CODE,
      scriptElements: i,
      witnesses: s,
      annex: c
    };
  }
  static readScriptElement(t) {
    return t.readU8() === 0 ? {
      elementType: "buffer",
      value: a.from(t.readBytesWithLength()).toString("hex")
    } : {
      elementType: "opcode",
      value: t.readU32()
    };
  }
  // Cancel
  static writeCancelData(t, e) {
    t.writeBytesWithLength(a.from(e.compiledTargetScript, "hex"));
  }
  static readCancelData(t) {
    return {
      type: y.CANCEL,
      compiledTargetScript: a.from(t.readBytesWithLength()).toString("hex")
    };
  }
  static writeChallenge(t, e) {
    t.writeU64(BigInt(e.epochNumber)), t.writeStringWithLength(e.mldsaPublicKey), t.writeStringWithLength(e.legacyPublicKey), t.writeBytesWithLength(a.from(e.solution.replace("0x", ""), "hex")), t.writeBytesWithLength(a.from(e.salt.replace("0x", ""), "hex")), t.writeBytesWithLength(a.from(e.graffiti.replace("0x", ""), "hex")), t.writeU8(e.difficulty), this.writeChallengeVerification(t, e.verification), t.writeBoolean(e.submission !== void 0), e.submission !== void 0 && (t.writeStringWithLength(e.submission.mldsaPublicKey), t.writeStringWithLength(e.submission.legacyPublicKey), t.writeBytesWithLength(
      a.from(e.submission.solution.replace("0x", ""), "hex")
    ), t.writeBoolean(e.submission.graffiti !== void 0), e.submission.graffiti !== void 0 && t.writeBytesWithLength(
      a.from(e.submission.graffiti.replace("0x", ""), "hex")
    ), t.writeBytesWithLength(
      a.from(e.submission.signature.replace("0x", ""), "hex")
    ));
  }
  static writeChallengeVerification(t, e) {
    t.writeBytesWithLength(a.from(e.epochHash.replace("0x", ""), "hex")), t.writeBytesWithLength(a.from(e.epochRoot.replace("0x", ""), "hex")), t.writeBytesWithLength(a.from(e.targetHash.replace("0x", ""), "hex")), t.writeBytesWithLength(
      a.from(e.targetChecksum.replace("0x", ""), "hex")
    ), t.writeU64(BigInt(e.startBlock)), t.writeU64(BigInt(e.endBlock)), t.writeU16(e.proofs.length);
    for (const i of e.proofs)
      t.writeBytesWithLength(a.from(i.replace("0x", ""), "hex"));
  }
  static readChallenge(t) {
    const e = t.readU64().toString(), i = t.readStringWithLength(), r = t.readStringWithLength(), s = "0x" + a.from(t.readBytesWithLength()).toString("hex"), o = "0x" + a.from(t.readBytesWithLength()).toString("hex"), c = "0x" + a.from(t.readBytesWithLength()).toString("hex"), u = t.readU8(), h = this.readChallengeVerification(t), l = t.readBoolean();
    let d;
    if (l) {
      const p = t.readStringWithLength(), f = t.readStringWithLength(), w = "0x" + a.from(t.readBytesWithLength()).toString("hex"), b = t.readBoolean() ? "0x" + a.from(t.readBytesWithLength()).toString("hex") : void 0, _ = "0x" + a.from(t.readBytesWithLength()).toString("hex");
      d = {
        mldsaPublicKey: p,
        legacyPublicKey: f,
        solution: w,
        graffiti: b,
        signature: _
      };
    }
    return {
      epochNumber: e,
      mldsaPublicKey: i,
      legacyPublicKey: r,
      solution: s,
      salt: o,
      graffiti: c,
      difficulty: u,
      verification: h,
      submission: d
    };
  }
  static readChallengeVerification(t) {
    const e = "0x" + a.from(t.readBytesWithLength()).toString("hex"), i = "0x" + a.from(t.readBytesWithLength()).toString("hex"), r = "0x" + a.from(t.readBytesWithLength()).toString("hex"), s = "0x" + a.from(t.readBytesWithLength()).toString("hex"), o = t.readU64().toString(), c = t.readU64().toString(), u = t.readU16(), h = [];
    for (let l = 0; l < u; l++)
      h.push("0x" + a.from(t.readBytesWithLength()).toString("hex"));
    return {
      epochHash: e,
      epochRoot: i,
      targetHash: r,
      targetChecksum: s,
      startBlock: o,
      endBlock: c,
      proofs: h
    };
  }
  static writeLoadedStorage(t, e) {
    const i = Object.keys(e);
    t.writeU16(i.length);
    for (const r of i)
      t.writeStringWithLength(r), t.writeStringArray(e[r]);
  }
  static readLoadedStorage(t) {
    const e = t.readU16(), i = {};
    for (let r = 0; r < e; r++) {
      const s = t.readStringWithLength();
      i[s] = t.readStringArray();
    }
    return i;
  }
  static writePrecomputedData(t, e) {
    t.writeBoolean(e.compiledTargetScript !== void 0), e.compiledTargetScript !== void 0 && t.writeBytesWithLength(a.from(e.compiledTargetScript, "hex")), t.writeBoolean(e.randomBytes !== void 0), e.randomBytes !== void 0 && t.writeBytesWithLength(a.from(e.randomBytes, "hex")), t.writeBoolean(e.estimatedFees !== void 0), e.estimatedFees !== void 0 && t.writeU64(BigInt(e.estimatedFees)), t.writeBoolean(e.contractSeed !== void 0), e.contractSeed !== void 0 && t.writeStringWithLength(e.contractSeed), t.writeBoolean(e.contractAddress !== void 0), e.contractAddress !== void 0 && t.writeStringWithLength(e.contractAddress);
  }
  static readPrecomputedData(t) {
    const i = t.readBoolean() ? a.from(t.readBytesWithLength()).toString("hex") : void 0, s = t.readBoolean() ? a.from(t.readBytesWithLength()).toString("hex") : void 0, c = t.readBoolean() ? t.readU64().toString() : void 0, h = t.readBoolean() ? t.readStringWithLength() : void 0, d = t.readBoolean() ? t.readStringWithLength() : void 0;
    return {
      compiledTargetScript: i,
      randomBytes: s,
      estimatedFees: c,
      contractSeed: h,
      contractAddress: d
    };
  }
  /**
   * Calculate double SHA256 checksum (Bitcoin standard)
   */
  static calculateChecksum(t) {
    const e = Qt("sha256").update(t).digest();
    return Qt("sha256").update(e).digest();
  }
  static networkNameToU8(t) {
    switch (t) {
      case "mainnet":
        return 0;
      case "testnet":
        return 1;
      case "regtest":
        return 2;
      default:
        throw new Error(`Unknown network: ${t}`);
    }
  }
  static u8ToNetworkName(t) {
    switch (t) {
      case 0:
        return "mainnet";
      case 1:
        return "testnet";
      case 2:
        return "regtest";
      default:
        throw new Error(`Unknown network value: ${t}`);
    }
  }
}
class $ {
  /**
   * Capture state from a FundingTransaction
   */
  static fromFunding(t, e) {
    return this.captureState({
      params: t,
      type: y.FUNDING,
      precomputed: e
    });
  }
  /**
   * Capture state from a DeploymentTransaction
   */
  static fromDeployment(t, e) {
    return this.captureState({
      params: t,
      type: y.DEPLOYMENT,
      precomputed: e
    });
  }
  /**
   * Capture state from an InteractionTransaction
   */
  static fromInteraction(t, e) {
    return this.captureState({
      params: t,
      type: y.INTERACTION,
      precomputed: e
    });
  }
  /**
   * Capture state from a MultiSignTransaction
   */
  static fromMultiSig(t, e) {
    return this.captureState({
      params: t,
      type: y.MULTI_SIG,
      precomputed: e
    });
  }
  /**
   * Capture state from a CustomScriptTransaction
   */
  static fromCustomScript(t, e) {
    return this.captureState({
      params: t,
      type: y.CUSTOM_CODE,
      precomputed: e
    });
  }
  /**
   * Capture state from a CancelTransaction
   */
  static fromCancel(t, e) {
    return this.captureState({
      params: t,
      type: y.CANCEL,
      precomputed: e
    });
  }
  /**
   * Main state capture method
   */
  static captureState(t) {
    const { params: e, type: i, precomputed: r } = t;
    return {
      header: this.createHeader(i, e.network, e.chainId),
      baseParams: this.extractBaseParams(e),
      utxos: this.serializeUTXOs(e.utxos),
      optionalInputs: this.serializeUTXOs(e.optionalInputs || []),
      optionalOutputs: this.serializeOutputs(e.optionalOutputs || []),
      addressRotationEnabled: e.addressRotation?.enabled ?? !1,
      signerMappings: this.extractSignerMappings(e),
      typeSpecificData: this.extractTypeSpecificData(i, e),
      precomputedData: this.buildPrecomputedData(r)
    };
  }
  /**
   * Create serialization header
   */
  static createHeader(t, e, i) {
    return {
      formatVersion: Se,
      consensusVersion: $t,
      transactionType: t,
      chainId: i ?? this.networkToChainId(e),
      timestamp: Date.now()
    };
  }
  /**
   * Extract base parameters common to all transaction types
   */
  static extractBaseParams(t) {
    const e = t.note ? a.isBuffer(t.note) ? t.note.toString("hex") : a.from(t.note).toString("hex") : void 0, i = t.priorityFee ?? 0n, r = t.gasSatFee ?? 0n;
    return {
      from: t.from || "",
      to: t.to,
      feeRate: t.feeRate,
      priorityFee: i.toString(),
      gasSatFee: r.toString(),
      networkName: this.networkToName(t.network),
      txVersion: t.txVersion ?? 2,
      note: e,
      anchor: t.anchor ?? !1,
      debugFees: t.debugFees
    };
  }
  /**
   * Extract signer mappings for address rotation mode
   */
  static extractSignerMappings(t) {
    if (!t.addressRotation?.enabled)
      return [];
    const e = [], i = /* @__PURE__ */ new Map();
    t.utxos.forEach((s, o) => {
      const c = s.scriptPubKey?.address;
      if (c) {
        const u = i.get(c);
        u ? u.push(o) : i.set(c, [o]);
      }
    });
    const r = t.utxos.length;
    return (t.optionalInputs || []).forEach((s, o) => {
      const c = s.scriptPubKey?.address;
      if (c) {
        const u = i.get(c);
        u ? u.push(r + o) : i.set(c, [r + o]);
      }
    }), i.forEach((s, o) => {
      e.push({ address: o, inputIndices: s });
    }), e;
  }
  /**
   * Extract type-specific data based on transaction type
   */
  static extractTypeSpecificData(t, e) {
    switch (t) {
      case y.FUNDING:
        return this.extractFundingData(e);
      case y.DEPLOYMENT:
        return this.extractDeploymentData(e);
      case y.INTERACTION:
        return this.extractInteractionData(e);
      case y.MULTI_SIG:
        return this.extractMultiSigData(e);
      case y.CUSTOM_CODE:
        return this.extractCustomScriptData(e);
      case y.CANCEL:
        return this.extractCancelData(e);
      default:
        throw new Error(`Unsupported transaction type: ${t}`);
    }
  }
  static extractFundingData(t) {
    return {
      type: y.FUNDING,
      amount: t.amount.toString(),
      splitInputsInto: t.splitInputsInto ?? 1
    };
  }
  static extractDeploymentData(t) {
    return {
      type: y.DEPLOYMENT,
      bytecode: t.bytecode.toString("hex"),
      calldata: t.calldata?.toString("hex"),
      challenge: t.challenge.toRaw(),
      revealMLDSAPublicKey: t.revealMLDSAPublicKey,
      linkMLDSAPublicKeyToAddress: t.linkMLDSAPublicKeyToAddress
    };
  }
  static extractInteractionData(t) {
    return {
      type: y.INTERACTION,
      calldata: t.calldata.toString("hex"),
      contract: t.contract,
      challenge: t.challenge.toRaw(),
      loadedStorage: t.loadedStorage,
      isCancellation: t.isCancellation,
      disableAutoRefund: t.disableAutoRefund,
      revealMLDSAPublicKey: t.revealMLDSAPublicKey,
      linkMLDSAPublicKeyToAddress: t.linkMLDSAPublicKeyToAddress
    };
  }
  static extractMultiSigData(t) {
    return {
      type: y.MULTI_SIG,
      pubkeys: (t.pubkeys || []).map((e) => e.toString("hex")),
      minimumSignatures: t.minimumSignatures || 0,
      receiver: t.receiver || "",
      requestedAmount: (t.requestedAmount || 0n).toString(),
      refundVault: t.refundVault || "",
      originalInputCount: t.originalInputCount || t.utxos.length,
      existingPsbtBase64: t.existingPsbtBase64
    };
  }
  static extractCustomScriptData(t) {
    const e = (t.scriptElements || []).map(
      (i) => a.isBuffer(i) ? {
        elementType: "buffer",
        value: i.toString("hex")
      } : {
        elementType: "opcode",
        value: i
      }
    );
    return {
      type: y.CUSTOM_CODE,
      scriptElements: e,
      witnesses: (t.witnesses || []).map((i) => i.toString("hex")),
      annex: t.annex?.toString("hex")
    };
  }
  static extractCancelData(t) {
    const e = t.compiledTargetScript, i = e ? a.isBuffer(e) ? e.toString("hex") : e : "";
    return {
      type: y.CANCEL,
      compiledTargetScript: i
    };
  }
  /**
   * Build precomputed data object
   */
  static buildPrecomputedData(t) {
    return {
      compiledTargetScript: t?.compiledTargetScript,
      randomBytes: t?.randomBytes,
      estimatedFees: t?.estimatedFees,
      contractSeed: t?.contractSeed,
      contractAddress: t?.contractAddress
    };
  }
  /**
   * Serialize UTXOs array
   */
  static serializeUTXOs(t) {
    return t.map((e) => ({
      transactionId: e.transactionId,
      outputIndex: e.outputIndex,
      value: e.value.toString(),
      scriptPubKeyHex: e.scriptPubKey.hex,
      scriptPubKeyAddress: e.scriptPubKey.address,
      redeemScript: e.redeemScript ? a.isBuffer(e.redeemScript) ? e.redeemScript.toString("hex") : e.redeemScript : void 0,
      witnessScript: e.witnessScript ? a.isBuffer(e.witnessScript) ? e.witnessScript.toString("hex") : e.witnessScript : void 0,
      nonWitnessUtxo: e.nonWitnessUtxo ? a.isBuffer(e.nonWitnessUtxo) ? e.nonWitnessUtxo.toString("hex") : e.nonWitnessUtxo : void 0
    }));
  }
  /**
   * Serialize outputs array
   */
  static serializeOutputs(t) {
    return t.map((e) => {
      const i = "address" in e ? e.address : void 0, r = "script" in e ? e.script : void 0;
      return {
        value: e.value,
        address: i,
        script: r ? r.toString("hex") : void 0,
        tapInternalKey: e.tapInternalKey ? e.tapInternalKey.toString("hex") : void 0
      };
    });
  }
  /**
   * Convert network to name string
   */
  static networkToName(t) {
    return t.bech32 === "bc" ? "mainnet" : t.bech32 === "tb" ? "testnet" : "regtest";
  }
  /**
   * Convert network to chain ID
   */
  static networkToChainId(t) {
    return he.Bitcoin;
  }
}
function U(n) {
  return a.from(n.replace("0x", ""), "hex");
}
class ct {
  static {
    this.BLOCKS_PER_EPOCH = 5n;
  }
  /**
   * Convert Buffer to Uint8Array
   */
  static bufferToUint8Array(t) {
    return new Uint8Array(t);
  }
  /**
   * Convert Uint8Array to Buffer
   */
  static uint8ArrayToBuffer(t) {
    return a.from(t);
  }
  /**
   * Calculate SHA-1 hash
   */
  static sha1(t) {
    return vi(a.isBuffer(t) ? t : a.from(t));
  }
  /**
   * Calculate mining preimage
   */
  static calculatePreimage(t, e, i) {
    if (t.length !== 32 || e.length !== 32 || i.length !== 32)
      throw new Error("All inputs must be 32 bytes");
    const r = a.alloc(32);
    for (let s = 0; s < 32; s++)
      r[s] = t[s] ^ e[s] ^ i[s];
    return r;
  }
  /**
   * Count matching bits between two hashes
   */
  static countMatchingBits(t, e) {
    let i = 0;
    if (t.length !== e.length)
      throw new Error("Hashes must be of the same length");
    const r = Math.min(t.length, e.length);
    for (let s = 0; s < r; s++) {
      const o = t[s], c = e[s];
      if (o === c)
        i += 8;
      else
        for (let u = 7; u >= 0; u--)
          if ((o >> u & 1) === (c >> u & 1))
            i++;
          else
            return i;
    }
    return i;
  }
  /**
   * Verify an epoch solution using IPreimage
   */
  static verifySolution(t, e = !1) {
    try {
      const i = t.verification, r = this.calculatePreimage(
        i.targetChecksum,
        t.publicKey.toBuffer(),
        t.salt
      ), s = this.sha1(r), o = this.uint8ArrayToBuffer(s);
      if (!o.equals(t.solution) || this.countMatchingBits(
        o,
        i.targetHash
      ) !== t.difficulty)
        return !1;
      const u = t.epochNumber * this.BLOCKS_PER_EPOCH, h = u + this.BLOCKS_PER_EPOCH - 1n;
      return !(i.startBlock !== u || i.endBlock !== h);
    } catch (i) {
      return e && console.error("Verification error:", i), !1;
    }
  }
  /**
   * Get the mining target block for an epoch
   */
  static getMiningTargetBlock(t) {
    return t === 0n ? null : t * this.BLOCKS_PER_EPOCH - 1n;
  }
  /**
   * Validate epoch winner from raw data
   */
  static validateEpochWinner(t) {
    try {
      const e = BigInt(t.epochNumber), i = k.fromString(
        t.mldsaPublicKey,
        t.legacyPublicKey
      ), r = U(t.solution), s = U(t.salt), o = t.difficulty, c = {
        epochHash: U(t.verification.epochHash),
        epochRoot: U(t.verification.epochRoot),
        targetHash: U(t.verification.targetHash),
        targetChecksum: U(t.verification.targetChecksum),
        startBlock: BigInt(t.verification.startBlock),
        endBlock: BigInt(t.verification.endBlock),
        proofs: Object.freeze(t.verification.proofs.map((w) => U(w)))
      }, u = this.calculatePreimage(
        c.targetChecksum,
        i.toBuffer(),
        s
      ), h = this.sha1(u), l = this.uint8ArrayToBuffer(h);
      if (!l.equals(r) || this.countMatchingBits(
        l,
        c.targetHash
      ) !== o)
        return !1;
      const p = e * this.BLOCKS_PER_EPOCH, f = p + this.BLOCKS_PER_EPOCH - 1n;
      return !(c.startBlock !== p || c.endBlock !== f);
    } catch {
      return !1;
    }
  }
  /**
   * Validate epoch winner from Preimage instance
   */
  static validateChallengeSolution(t) {
    return this.verifySolution(t);
  }
  /**
   * Calculate solution hash from preimage components
   * @param targetChecksum The target checksum (32 bytes)
   * @param publicKey The public key buffer (32 bytes)
   * @param salt The salt buffer (32 bytes)
   * @returns The SHA-1 hash of the preimage
   */
  static calculateSolution(t, e, i) {
    const r = this.calculatePreimage(t, e, i), s = this.sha1(this.bufferToUint8Array(r));
    return this.uint8ArrayToBuffer(s);
  }
  /**
   * Check if a solution meets the minimum difficulty requirement
   */
  static checkDifficulty(t, e, i) {
    const r = this.countMatchingBits(t, e);
    return {
      valid: r >= i,
      difficulty: r
    };
  }
}
class ii {
  constructor(t) {
    this.epochHash = U(t.epochHash), this.epochRoot = U(t.epochRoot), this.targetHash = U(t.targetHash), this.targetChecksum = U(t.targetChecksum), this.startBlock = BigInt(t.startBlock), this.endBlock = BigInt(t.endBlock), this.proofs = Object.freeze(t.proofs.map((e) => U(e)));
  }
}
class ri {
  constructor(t, e) {
    this.epochNumber = e, this.publicKey = k.fromString(t.mldsaPublicKey, t.legacyPublicKey), this.solution = U(t.solution), this.graffiti = t.graffiti ? U(t.graffiti) : void 0, this.signature = U(t.signature);
  }
  verifySignature() {
    const t = new D();
    t.writeAddress(this.publicKey), t.writeU64(this.epochNumber), t.writeBytes(this.solution), this.graffiti && t.writeBytes(this.graffiti);
    const e = t.getBuffer();
    return st.verifySignature(
      this.publicKey.tweakedPublicKeyToBuffer(),
      e,
      this.signature
    );
  }
}
class se {
  constructor(t) {
    this.epochNumber = BigInt(t.epochNumber), this.publicKey = k.fromString(t.mldsaPublicKey, t.legacyPublicKey), this.solution = U(t.solution), this.salt = U(t.salt), this.graffiti = U(t.graffiti), this.difficulty = t.difficulty, this.verification = new ii(t.verification), this.submission = t.submission ? new ri(t.submission, this.epochNumber + 2n) : t.submission;
  }
  /**
   * Static method to validate from raw data directly
   */
  static validateRaw(t) {
    return ct.validateEpochWinner(t);
  }
  verifySubmissionSignature() {
    if (!this.submission)
      throw new Error("No submission provided in request.");
    return this.submission.verifySignature();
  }
  getSubmission() {
    if (this.submission) {
      if (!this.verifySubmissionSignature())
        throw new Error("Invalid submission signature.");
      return this.submission;
    }
  }
  /**
   * Verify this challenge
   * @returns {boolean} True if the challenge is valid
   */
  verify() {
    return ct.validateChallengeSolution(this);
  }
  /**
   * Get the preimage challenge
   * @returns {Buffer} The solution/challenge as a buffer
   */
  toBuffer() {
    return this.solution;
  }
  /**
   * Get the solution as a hex string
   * @returns {string} The solution as a hex string with 0x prefix
   */
  toHex() {
    return "0x" + this.solution.toString("hex");
  }
  /**
   * Convert to raw format for serialization
   */
  toRaw() {
    return {
      epochNumber: this.epochNumber.toString(),
      mldsaPublicKey: this.publicKey.toHex(),
      legacyPublicKey: this.publicKey.tweakedToHex(),
      solution: this.toHex(),
      salt: "0x" + this.salt.toString("hex"),
      graffiti: "0x" + this.graffiti.toString("hex"),
      difficulty: this.difficulty,
      verification: {
        epochHash: "0x" + this.verification.epochHash.toString("hex"),
        epochRoot: "0x" + this.verification.epochRoot.toString("hex"),
        targetHash: "0x" + this.verification.targetHash.toString("hex"),
        targetChecksum: "0x" + this.verification.targetChecksum.toString("hex"),
        startBlock: this.verification.startBlock.toString(),
        endBlock: this.verification.endBlock.toString(),
        proofs: this.verification.proofs.map((t) => "0x" + t.toString("hex"))
      }
    };
  }
  /**
   * Calculate the expected solution hash for this challenge
   * @returns {Promise<Buffer>} The calculated solution hash
   */
  calculateSolution() {
    return ct.calculateSolution(
      this.verification.targetChecksum,
      this.publicKey.toBuffer(),
      this.salt
    );
  }
  /**
   * Check if the challenge meets a specific difficulty requirement
   * @param {number} minDifficulty The minimum difficulty required
   * @returns {Promise<{valid: boolean; difficulty: number}>} Validation result
   */
  checkDifficulty(t) {
    return ct.checkDifficulty(
      this.solution,
      this.verification.targetHash,
      t
    );
  }
  /**
   * Get the mining target block for this epoch
   * @returns {bigint | null} The target block number or null if epoch 0
   */
  getMiningTargetBlock() {
    return ct.getMiningTargetBlock(this.epochNumber);
  }
}
class ut {
  /**
   * Reconstruct and optionally rebuild transaction with new parameters
   * @param state - Serialized transaction state
   * @param options - Signer(s) and optional fee overrides
   * @returns Reconstructed transaction builder ready for signing
   */
  static reconstruct(t, e) {
    const i = this.nameToNetwork(t.baseParams.networkName), r = this.deserializeUTXOs(t.utxos), s = this.deserializeUTXOs(t.optionalInputs), o = this.deserializeOutputs(t.optionalOutputs), c = this.buildAddressRotationConfig(
      t.addressRotationEnabled,
      e.signerMap
    ), u = e.newFeeRate ?? t.baseParams.feeRate, h = e.newPriorityFee ?? BigInt(t.baseParams.priorityFee), l = e.newGasSatFee ?? BigInt(t.baseParams.gasSatFee), d = {
      signer: e.signer,
      mldsaSigner: e.mldsaSigner ?? null,
      network: i,
      chainId: t.header.chainId,
      utxos: r,
      optionalInputs: s,
      optionalOutputs: o,
      from: t.baseParams.from,
      to: t.baseParams.to,
      feeRate: u,
      priorityFee: h,
      gasSatFee: l,
      txVersion: t.baseParams.txVersion,
      note: t.baseParams.note ? a.from(t.baseParams.note, "hex") : void 0,
      anchor: t.baseParams.anchor,
      debugFees: t.baseParams.debugFees,
      addressRotation: c,
      estimatedFees: t.precomputedData.estimatedFees ? BigInt(t.precomputedData.estimatedFees) : void 0,
      compiledTargetScript: t.precomputedData.compiledTargetScript ? a.from(t.precomputedData.compiledTargetScript, "hex") : void 0
    }, p = t.typeSpecificData;
    if (je(p))
      return this.reconstructFunding(d, p);
    if (Ze(p))
      return this.reconstructDeployment(d, p, t);
    if (Je(p))
      return this.reconstructInteraction(d, p, t);
    if (et(p))
      return this.reconstructMultiSig(d, p);
    if (ti(p))
      return this.reconstructCustomScript(d, p, t);
    if (ei(p))
      return this.reconstructCancel(d, p);
    throw new Error(`Unsupported transaction type: ${t.header.transactionType}`);
  }
  /**
   * Reconstruct a FundingTransaction
   */
  static reconstructFunding(t, e) {
    const i = {
      ...t,
      amount: BigInt(e.amount),
      splitInputsInto: e.splitInputsInto
    };
    return new Mt(i);
  }
  /**
   * Reconstruct a DeploymentTransaction
   */
  static reconstructDeployment(t, e, i) {
    const r = new se(e.challenge), s = {
      ...t,
      bytecode: a.from(e.bytecode, "hex"),
      calldata: e.calldata ? a.from(e.calldata, "hex") : void 0,
      challenge: r,
      randomBytes: i.precomputedData.randomBytes ? a.from(i.precomputedData.randomBytes, "hex") : void 0,
      revealMLDSAPublicKey: e.revealMLDSAPublicKey,
      linkMLDSAPublicKeyToAddress: e.linkMLDSAPublicKeyToAddress
    };
    return new ft(s);
  }
  /**
   * Reconstruct an InteractionTransaction
   */
  static reconstructInteraction(t, e, i) {
    const r = new se(e.challenge);
    if (!t.to)
      throw new Error('InteractionTransaction requires a "to" address');
    const s = {
      ...t,
      to: t.to,
      calldata: a.from(e.calldata, "hex"),
      contract: e.contract,
      challenge: r,
      randomBytes: i.precomputedData.randomBytes ? a.from(i.precomputedData.randomBytes, "hex") : void 0,
      loadedStorage: e.loadedStorage,
      isCancellation: e.isCancellation,
      disableAutoRefund: e.disableAutoRefund,
      revealMLDSAPublicKey: e.revealMLDSAPublicKey,
      linkMLDSAPublicKeyToAddress: e.linkMLDSAPublicKeyToAddress
    };
    return new Nt(s);
  }
  /**
   * Reconstruct a MultiSignTransaction
   */
  static reconstructMultiSig(t, e) {
    const i = e.pubkeys.map((s) => a.from(s, "hex"));
    if (e.existingPsbtBase64)
      return x.fromBase64({
        mldsaSigner: t.mldsaSigner,
        network: t.network,
        chainId: t.chainId,
        utxos: t.utxos,
        optionalInputs: t.optionalInputs,
        optionalOutputs: t.optionalOutputs,
        feeRate: t.feeRate,
        pubkeys: i,
        minimumSignatures: e.minimumSignatures,
        receiver: e.receiver,
        requestedAmount: BigInt(e.requestedAmount),
        refundVault: e.refundVault,
        psbt: e.existingPsbtBase64
      });
    const r = {
      mldsaSigner: t.mldsaSigner,
      network: t.network,
      chainId: t.chainId,
      utxos: t.utxos,
      optionalInputs: t.optionalInputs,
      optionalOutputs: t.optionalOutputs,
      feeRate: t.feeRate,
      pubkeys: i,
      minimumSignatures: e.minimumSignatures,
      receiver: e.receiver,
      requestedAmount: BigInt(e.requestedAmount),
      refundVault: e.refundVault
    };
    return new x(r);
  }
  /**
   * Reconstruct a CustomScriptTransaction
   */
  static reconstructCustomScript(t, e, i) {
    const r = e.scriptElements.map((u) => u.elementType === "buffer" ? a.from(u.value, "hex") : [u.value]), s = e.witnesses.map((u) => a.from(u, "hex")), o = e.annex ? a.from(e.annex, "hex") : void 0;
    if (!t.to)
      throw new Error('CustomScriptTransaction requires a "to" address');
    const c = {
      ...t,
      to: t.to,
      script: r,
      witnesses: s,
      annex: o,
      randomBytes: i.precomputedData.randomBytes ? a.from(i.precomputedData.randomBytes, "hex") : void 0
    };
    return new Wt(c);
  }
  /**
   * Reconstruct a CancelTransaction
   */
  static reconstructCancel(t, e) {
    const i = {
      ...t,
      compiledTargetScript: a.from(e.compiledTargetScript, "hex")
    };
    return new ge(i);
  }
  /**
   * Build address rotation config from options
   */
  static buildAddressRotationConfig(t, e) {
    if (t) {
      if (!e || e.size === 0)
        throw new Error(
          "Address rotation enabled but no signerMap provided in reconstruction options"
        );
      return {
        enabled: !0,
        signerMap: e
      };
    }
  }
  /**
   * Deserialize UTXOs from serialized format
   */
  static deserializeUTXOs(t) {
    return t.map((e) => ({
      transactionId: e.transactionId,
      outputIndex: e.outputIndex,
      value: BigInt(e.value),
      scriptPubKey: {
        hex: e.scriptPubKeyHex,
        address: e.scriptPubKeyAddress
      },
      redeemScript: e.redeemScript ? a.from(e.redeemScript, "hex") : void 0,
      witnessScript: e.witnessScript ? a.from(e.witnessScript, "hex") : void 0,
      nonWitnessUtxo: e.nonWitnessUtxo ? a.from(e.nonWitnessUtxo, "hex") : void 0
    }));
  }
  /**
   * Deserialize outputs from serialized format
   */
  static deserializeOutputs(t) {
    return t.map((e) => {
      const i = e.tapInternalKey ? a.from(e.tapInternalKey, "hex") : void 0;
      return e.address ? {
        value: e.value,
        address: e.address,
        tapInternalKey: i
      } : e.script ? {
        value: e.value,
        script: a.from(e.script, "hex"),
        tapInternalKey: i
      } : {
        value: e.value,
        address: "",
        tapInternalKey: i
      };
    });
  }
  /**
   * Convert network name to Network object
   */
  static nameToNetwork(t) {
    switch (t) {
      case "mainnet":
        return I;
      case "testnet":
        return At;
      case "regtest":
        return zt;
      default:
        throw new Error(`Unknown network: ${t}`);
    }
  }
}
class ur {
  /**
   * Export a FundingTransaction for offline signing
   * @param params - Funding transaction parameters
   * @param precomputed - Optional precomputed data
   * @returns Base64-encoded serialized state
   */
  static exportFunding(t, e) {
    const i = $.fromFunding(t, e);
    return B.toBase64(i);
  }
  /**
   * Export a DeploymentTransaction for offline signing
   * @param params - Deployment transaction parameters
   * @param precomputed - Required precomputed data (randomBytes, compiledTargetScript)
   * @returns Base64-encoded serialized state
   */
  static exportDeployment(t, e) {
    const i = $.fromDeployment(t, e);
    return B.toBase64(i);
  }
  /**
   * Export an InteractionTransaction for offline signing
   * @param params - Interaction transaction parameters
   * @param precomputed - Required precomputed data (randomBytes, compiledTargetScript)
   * @returns Base64-encoded serialized state
   */
  static exportInteraction(t, e) {
    const i = $.fromInteraction(t, e);
    return B.toBase64(i);
  }
  /**
   * Export a MultiSignTransaction for offline signing
   * @param params - MultiSig transaction parameters
   * @param precomputed - Optional precomputed data
   * @returns Base64-encoded serialized state
   */
  static exportMultiSig(t, e) {
    const i = $.fromMultiSig(t, e);
    return B.toBase64(i);
  }
  /**
   * Export a CustomScriptTransaction for offline signing
   * @param params - Custom script transaction parameters
   * @param precomputed - Optional precomputed data
   * @returns Base64-encoded serialized state
   */
  static exportCustomScript(t, e) {
    const i = $.fromCustomScript(t, e);
    return B.toBase64(i);
  }
  /**
   * Export a CancelTransaction for offline signing
   * @param params - Cancel transaction parameters
   * @param precomputed - Optional precomputed data
   * @returns Base64-encoded serialized state
   */
  static exportCancel(t, e) {
    const i = $.fromCancel(t, e);
    return B.toBase64(i);
  }
  /**
   * Export transaction state from a builder instance.
   * The builder must have been built but not yet signed.
   * @param builder - Transaction builder instance
   * @param params - Original construction parameters
   * @param precomputed - Precomputed data from the builder
   * @returns Base64-encoded serialized state
   */
  static exportFromBuilder(t, e, i) {
    const r = t.type;
    let s;
    switch (r) {
      case y.FUNDING:
        s = $.fromFunding(
          e,
          i
        );
        break;
      case y.DEPLOYMENT:
        s = $.fromDeployment(
          e,
          i
        );
        break;
      case y.INTERACTION:
        s = $.fromInteraction(
          e,
          i
        );
        break;
      default:
        throw new Error(`Unsupported transaction type for export: ${r}`);
    }
    return B.toBase64(s);
  }
  /**
   * Import and reconstruct transaction for signing
   * @param serializedState - Base64-encoded state from Phase 1
   * @param options - Signer(s) and optional fee overrides
   * @returns Reconstructed transaction builder ready for signing
   */
  static importForSigning(t, e) {
    const i = B.fromBase64(t);
    return ut.reconstruct(i, e);
  }
  /**
   * Complete signing and export signed transaction
   * @param builder - Reconstructed builder from importForSigning
   * @returns Signed transaction hex ready for broadcast
   */
  static async signAndExport(t) {
    return (await t.signTransaction()).toHex();
  }
  /**
   * Convenience: Full Phase 2 in one call - import, sign, and export
   * @param serializedState - Base64-encoded state
   * @param options - Signer(s) and optional fee overrides
   * @returns Signed transaction hex ready for broadcast
   */
  static async importSignAndExport(t, e) {
    const i = this.importForSigning(t, e);
    return this.signAndExport(i);
  }
  /**
   * Rebuild transaction with new fee rate (fee bumping)
   * @param serializedState - Original state
   * @param newFeeRate - New fee rate in sat/vB
   * @returns New serialized state with updated fees (not signed yet)
   */
  static rebuildWithNewFees(t, e) {
    const i = B.fromBase64(t), r = {
      ...i,
      baseParams: {
        ...i.baseParams,
        feeRate: e
      }
    };
    return B.toBase64(r);
  }
  /**
   * Rebuild and immediately sign with new fee rate
   * @param serializedState - Original state
   * @param newFeeRate - New fee rate in sat/vB
   * @param options - Signer options
   * @returns Signed transaction hex with new fees
   */
  static async rebuildSignAndExport(t, e, i) {
    const r = this.importForSigning(t, {
      ...i,
      newFeeRate: e
    });
    return this.signAndExport(r);
  }
  /**
   * Inspect serialized state without signing
   * @param serializedState - Base64-encoded state
   * @returns Parsed state object for inspection
   */
  static inspect(t) {
    return B.fromBase64(t);
  }
  /**
   * Validate serialized state integrity
   * @param serializedState - Base64-encoded state
   * @returns True if checksum and format are valid
   */
  static validate(t) {
    try {
      return B.fromBase64(t), !0;
    } catch {
      return !1;
    }
  }
  /**
   * Get transaction type from serialized state
   * @param serializedState - Base64-encoded state
   * @returns Transaction type enum value
   */
  static getType(t) {
    return B.fromBase64(t).header.transactionType;
  }
  /**
   * Parse base64-encoded state into state object
   * @param base64State - Base64-encoded state
   * @returns Parsed state object
   */
  static fromBase64(t) {
    return B.fromBase64(t);
  }
  /**
   * Serialize state object to base64
   * @param state - State object to serialize
   * @returns Base64-encoded state
   */
  static toBase64(t) {
    return B.toBase64(t);
  }
  /**
   * Convert serialized state to hex format
   * @param serializedState - Base64-encoded state
   * @returns Hex-encoded state
   */
  static toHex(t) {
    const e = B.fromBase64(t);
    return B.toHex(e);
  }
  /**
   * Convert hex format back to base64
   * @param hexState - Hex-encoded state
   * @returns Base64-encoded state
   */
  static fromHex(t) {
    const e = B.fromHex(t);
    return B.toBase64(e);
  }
  /**
   * Add a partial signature to a multisig transaction state.
   * This method signs the transaction with the provided signer and returns
   * updated state with the new signature included.
   *
   * @param serializedState - Base64-encoded multisig state
   * @param signer - The signer to add a signature with
   * @returns Updated state with new signature, and signing result
   */
  static async multiSigAddSignature(t, e) {
    const i = B.fromBase64(t);
    if (!et(i.typeSpecificData))
      throw new Error("State is not a multisig transaction");
    const r = i.typeSpecificData, s = r.pubkeys.map((f) => a.from(f, "hex"));
    let o;
    const c = ut.nameToNetwork(i.baseParams.networkName);
    r.existingPsbtBase64 ? o = F.fromBase64(r.existingPsbtBase64, { network: c }) : o = await this.importForSigning(t, {
      signer: e
    }).signPSBT();
    const u = [];
    for (let f = r.originalInputCount; f < o.data.inputs.length; f++)
      u.push(r.minimumSignatures);
    const h = x.signPartial(
      o,
      e,
      r.originalInputCount,
      u
    ), l = [];
    for (let f = r.originalInputCount; f < o.data.inputs.length; f++)
      l.push(s);
    x.attemptFinalizeInputs(
      o,
      r.originalInputCount,
      l,
      h.final
    );
    const d = o.toBase64(), p = {
      ...i,
      typeSpecificData: {
        ...r,
        existingPsbtBase64: d
      }
    };
    return {
      state: B.toBase64(p),
      signed: h.signed,
      final: h.final,
      psbtBase64: d
    };
  }
  /**
   * Check if a public key has already signed a multisig transaction
   *
   * @param serializedState - Base64-encoded multisig state
   * @param signerPubKey - Public key to check (Buffer or hex string)
   * @returns True if the public key has already signed
   */
  static multiSigHasSigned(t, e) {
    const i = B.fromBase64(t);
    if (!et(i.typeSpecificData))
      throw new Error("State is not a multisig transaction");
    const r = i.typeSpecificData;
    if (!r.existingPsbtBase64)
      return !1;
    const s = ut.nameToNetwork(i.baseParams.networkName), o = F.fromBase64(r.existingPsbtBase64, { network: s }), c = a.isBuffer(e) ? e : a.from(e, "hex");
    return x.verifyIfSigned(o, c);
  }
  /**
   * Get the current signature count for a multisig transaction
   *
   * @param serializedState - Base64-encoded multisig state
   * @returns Object with signature count info
   */
  static multiSigGetSignatureStatus(t) {
    const e = B.fromBase64(t);
    if (!et(e.typeSpecificData))
      throw new Error("State is not a multisig transaction");
    const i = e.typeSpecificData, r = i.minimumSignatures;
    if (!i.existingPsbtBase64)
      return {
        required: r,
        collected: 0,
        isComplete: !1,
        signers: []
      };
    const s = ut.nameToNetwork(e.baseParams.networkName), o = F.fromBase64(i.existingPsbtBase64, { network: s }), c = /* @__PURE__ */ new Set();
    for (let h = i.originalInputCount; h < o.data.inputs.length; h++) {
      const l = o.data.inputs[h];
      if (l.tapScriptSig)
        for (const d of l.tapScriptSig)
          c.add(d.pubkey.toString("hex"));
      if (l.finalScriptWitness) {
        const d = m.readScriptWitnessToWitnessStack(
          l.finalScriptWitness
        );
        for (let p = 0; p < d.length - 2; p += 3) {
          const f = d[p + 2];
          c.add(f.toString("hex"));
        }
      }
    }
    const u = Array.from(c);
    return {
      required: r,
      collected: u.length,
      isComplete: u.length >= r,
      signers: u
    };
  }
  /**
   * Finalize a multisig transaction and extract the signed transaction hex.
   * Only call this when all required signatures have been collected.
   *
   * @param serializedState - Base64-encoded multisig state with all signatures
   * @returns Signed transaction hex ready for broadcast
   */
  static multiSigFinalize(t) {
    const e = B.fromBase64(t);
    if (!et(e.typeSpecificData))
      throw new Error("State is not a multisig transaction");
    const i = e.typeSpecificData;
    if (!i.existingPsbtBase64)
      throw new Error("No PSBT found in state - transaction has not been signed");
    const r = ut.nameToNetwork(e.baseParams.networkName), s = F.fromBase64(i.existingPsbtBase64, { network: r }), o = i.pubkeys.map((h) => a.from(h, "hex")), c = [];
    for (let h = i.originalInputCount; h < s.data.inputs.length; h++)
      c.push(o);
    if (!x.attemptFinalizeInputs(
      s,
      i.originalInputCount,
      c,
      !0
      // isFinal = true
    ))
      throw new Error("Failed to finalize multisig transaction - not enough signatures");
    return s.extractTransaction(!0, !0).toHex();
  }
  /**
   * Get the PSBT from a multisig state (for external signing tools)
   *
   * @param serializedState - Base64-encoded multisig state
   * @returns PSBT in base64 format, or null if not yet built
   */
  static multiSigGetPsbt(t) {
    const e = B.fromBase64(t);
    if (!et(e.typeSpecificData))
      throw new Error("State is not a multisig transaction");
    return e.typeSpecificData.existingPsbtBase64 || null;
  }
  /**
   * Update the PSBT in a multisig state (after external signing)
   *
   * @param serializedState - Base64-encoded multisig state
   * @param psbtBase64 - New PSBT with additional signatures
   * @returns Updated state
   */
  static multiSigUpdatePsbt(t, e) {
    const i = B.fromBase64(t);
    if (!et(i.typeSpecificData))
      throw new Error("State is not a multisig transaction");
    const r = {
      ...i,
      typeSpecificData: {
        ...i.typeSpecificData,
        existingPsbtBase64: e
      }
    };
    return B.toBase64(r);
  }
}
class hr {
  constructor(t) {
    this.opnetAPIUrl = t, this.utxoPath = "address/utxos", this.rpc = "json-rpc";
  }
  /**
   * Fetches UTXO data from the OPNET node
   * @param {FetchUTXOParams} settings - The settings to fetch UTXO data
   * @returns {Promise<UTXO[]>} - The UTXOs fetched
   * @throws {Error} - If UTXOs could not be fetched
   */
  async fetchUTXO(t) {
    t.usePendingUTXO === void 0 && (t.usePendingUTXO = !0), t.optimized === void 0 && (t.optimized = !0);
    const e = {
      method: "GET",
      headers: {
        "Content-Type": "application/json"
      }
    }, i = `${this.opnetAPIUrl}/api/v1/${this.utxoPath}?address=${t.address}&optimize=${t.optimized ?? !1}`, r = await fetch(i, e);
    if (!r.ok)
      throw new Error(`Failed to fetch UTXO data: ${r.statusText}`);
    const s = await r.json(), o = s.raw ?? [], c = t.usePendingUTXO ? [...s.confirmed, ...s.pending] : s.confirmed, u = [];
    for (const f of c)
      s.spentTransactions.some(
        (w) => w.transactionId === f.transactionId && w.outputIndex === f.outputIndex
      ) || u.push(f);
    if (u.length === 0)
      throw new Error("No UTXO found");
    const h = u.filter((f) => BigInt(f.value) >= t.minAmount);
    if (h.length === 0)
      throw new Error("No UTXO found (minAmount)");
    const l = [];
    let d = 0n;
    const p = t.requestedAmount;
    for (const f of h) {
      const w = BigInt(f.value);
      if (w <= 0n)
        continue;
      const S = f.raw;
      if (S == null)
        throw new Error(
          `Missing raw index for UTXO ${f.transactionId}:${f.outputIndex}`
        );
      const b = o[S];
      if (!b)
        throw new Error(
          `Invalid raw index ${S} - not found in raw transactions array`
        );
      if (d += w, l.push({
        transactionId: f.transactionId,
        outputIndex: f.outputIndex,
        value: w,
        scriptPubKey: f.scriptPubKey,
        nonWitnessUtxo: a.from(b, "base64")
      }), d > p)
        break;
    }
    return l;
  }
  /**
   * Fetches UTXO data from the OPNET node for multiple addresses
   * @param {FetchUTXOParamsMultiAddress} settings - The settings to fetch UTXO data
   * @returns {Promise<UTXO[]>} - The UTXOs fetched
   * @throws {Error} - If UTXOs could not be fetched
   */
  async fetchUTXOMultiAddr(t) {
    const e = [];
    for (const c of t.addresses) {
      const u = {
        address: c,
        minAmount: t.minAmount,
        requestedAmount: t.requestedAmount,
        optimized: t.optimized,
        usePendingUTXO: t.usePendingUTXO
      }, h = this.fetchUTXO(u).catch(() => []);
      e.push(h);
    }
    const r = (await Promise.all(e)).flat(), s = [];
    let o = 0n;
    for (let c = 0; c < r.length; c++) {
      const u = r[c];
      if (o >= t.requestedAmount)
        break;
      o += u.value, s.push(u);
    }
    return s;
  }
  /**
   * Broadcasts a transaction to the OPNET node
   * @param {string} transaction - The transaction to broadcast
   * @param {boolean} psbt - Whether the transaction is a PSBT
   * @returns {Promise<BroadcastResponse>} - The response from the OPNET node
   */
  async broadcastTransaction(t, e) {
    const i = [t, e], r = await this.rpcMethod("btc_sendRawTransaction", i);
    if (r)
      return r;
  }
  /**
   * Splits UTXOs into smaller UTXOs
   * @param {Wallet} wallet - The wallet to split UTXOs
   * @param {Network} network - The network to split UTXOs
   * @param {number} splitInputsInto - The number of UTXOs to split into
   * @param {bigint} amountPerUTXO - The amount per UTXO
   * @returns {Promise<BroadcastResponse | { error: string }>} - The response from the OPNET node or an error
   */
  async splitUTXOs(t, e, i, r) {
    const s = {
      addresses: [t.p2wpkh, t.p2tr],
      minAmount: 330n,
      requestedAmount: 1000000000000000n
    }, o = await this.fetchUTXOMultiAddr(s);
    if (!o || !o.length) return { error: "No UTXOs found" };
    const u = {
      amount: BigInt(i) * r,
      feeRate: 500,
      from: t.p2tr,
      utxos: o,
      signer: t.keypair,
      network: e,
      to: t.p2tr,
      splitInputsInto: i,
      priorityFee: 0n,
      gasSatFee: 330n,
      mldsaSigner: null
    }, l = await new Qe().createBTCTransfer(u), d = await this.broadcastTransaction(l.tx, !1);
    return d || { error: "Could not broadcast transaction" };
  }
  /**
   * Fetches to the OPNET node
   * @param {string} method
   * @param {unknown[]} paramsMethod
   * @returns {Promise<unknown>}
   */
  async rpcMethod(t, e) {
    const i = {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        jsonrpc: "2.0",
        method: t,
        params: e,
        id: 1
      })
    }, r = `${this.opnetAPIUrl}/api/v1/${this.rpc}`, s = await fetch(r, i);
    if (!s.ok)
      throw new Error(`Failed to fetch to rpc: ${s.statusText}`);
    const o = await s.json();
    if (!o)
      throw new Error("No data fetched");
    const c = o.result;
    if (!c)
      throw new Error("No rpc parameters found");
    if ("error" in c)
      throw new Error(`Error in fetching to rpc ${c.error}`);
    return c;
  }
  /**
   * Fetches the wrap parameters from the OPNET node
   * @param {bigint} amount - The amount to wrap
   * @returns {Promise<WrappedGeneration | undefined>} - The wrap parameters fetched
   * @throws {Error} - If wrap parameters could not be fetched
   */
  /*public async fetchWrapParameters(amount: bigint): Promise<WrappedGeneration | undefined> {
          if (amount < currentConsensusConfig.VAULT_MINIMUM_AMOUNT) {
              throw new Error(
                  `Amount must be greater than the minimum consolidation amount ${currentConsensusConfig.VAULT_MINIMUM_AMOUNT}sat.`,
              );
          }
  
          const params = [0, amount.toString()];
          const result = await this.rpcMethod('btc_generate', params);
  
          if (!result) {
              return;
          }
  
          return new WrappedGeneration(result as WrappedGenerationParameters);
      }*/
  /**
   * Fetches the wrap parameters from the OPNET node
   * @param {bigint} amount - The amount to wrap
   * @param {string} receiver - The receiver address
   * @returns {Promise<UnwrapGeneration | undefined>} - The wrap parameters fetched
   * @throws {Error} - If wrap parameters could not be fetched
   */
  /*public async fetchUnWrapParameters(
          amount: bigint,
          receiver: Address,
      ): Promise<UnwrapGeneration | undefined> {
          if (amount < 330n) {
              throw new Error(
                  `Amount must be greater than the minimum consolidation amount ${currentConsensusConfig.VAULT_MINIMUM_AMOUNT}sat.`,
              );
          }
  
          if (receiver.length < 50) {
              throw new Error('Invalid receiver address');
          }
  
          const params = [1, amount.toString(), receiver.toHex()];
          const result = await this.rpcMethod('btc_generate', params);
  
          if (!result) {
              return;
          }
  
          return new UnwrapGeneration(result as UnwrappedGenerationParameters);
      }*/
}
var si = /* @__PURE__ */ ((n) => (n[n.UNWRAP = 0] = "UNWRAP", n))(si || {});
class lr {
  /**
   * Generate a multi-sig address
   * @param {Buffer[]} pubKeys - The public keys to use
   * @param {number} minimumSignatureRequired - The minimum number of signatures required
   * @param {Network} network - The network to use
   * @returns {string} - The generated address
   * @throws {Error} - If the address cannot be generated
   */
  static generateMultiSigAddress(t, e, i = I) {
    if (A.verifyPubKeys(t, i).length !== t.length) throw new Error("Contains invalid public keys");
    const s = {
      network: i,
      utxos: [],
      pubkeys: t,
      minimumSignatures: e,
      feeRate: 100,
      receiver: "a",
      requestedAmount: 1n,
      refundVault: "a",
      mldsaSigner: null
    }, o = new x(s).getScriptAddress();
    if (!o)
      throw new Error("Failed to generate address");
    return o;
  }
}
var ni = /* @__PURE__ */ ((n) => (n.UINT8 = "UINT8", n.UINT16 = "UINT16", n.UINT32 = "UINT32", n.UINT64 = "UINT64", n.UINT128 = "UINT128", n.UINT256 = "UINT256", n.INT128 = "INT128", n.BOOL = "BOOL", n.ADDRESS = "ADDRESS", n.STRING = "STRING", n.BYTES4 = "BYTES4", n.BYTES32 = "BYTES32", n.BYTES = "BYTES", n.ADDRESS_UINT256_TUPLE = "ADDRESS_UINT256_TUPLE", n.ARRAY_OF_ADDRESSES = "ARRAY_OF_ADDRESSES", n.ARRAY_OF_UINT256 = "ARRAY_OF_UINT256", n.ARRAY_OF_UINT128 = "ARRAY_OF_UINT128", n.ARRAY_OF_UINT64 = "ARRAY_OF_UINT64", n.ARRAY_OF_UINT32 = "ARRAY_OF_UINT32", n.ARRAY_OF_UINT16 = "ARRAY_OF_UINT16", n.ARRAY_OF_UINT8 = "ARRAY_OF_UINT8", n.ARRAY_OF_STRING = "ARRAY_OF_STRING", n.ARRAY_OF_BYTES = "ARRAY_OF_BYTES", n.ARRAY_OF_BUFFERS = "ARRAY_OF_BUFFERS", n))(ni || {});
class dr {
  decodeData(t, e) {
    const i = new qt(t), r = [];
    for (let s = 0; s < e.length; s++)
      switch (e[s]) {
        case "UINT8":
          r.push(i.readU8());
          break;
        case "UINT16":
          r.push(i.readU16());
          break;
        case "UINT32":
          r.push(i.readU32());
          break;
        case "BYTES4":
          r.push(i.readBytes(4));
          break;
        case "BYTES32":
          r.push(i.readBytes(32));
          break;
        case "BOOL":
          r.push(i.readBoolean());
          break;
        case "ADDRESS":
          r.push(i.readAddress());
          break;
        case "STRING":
          r.push(i.readStringWithLength());
          break;
        case "UINT128":
          r.push(i.readU128());
          break;
        case "UINT256":
          r.push(i.readU256());
          break;
        case "INT128":
          r.push(i.readI128());
          break;
        case "ADDRESS_UINT256_TUPLE":
          r.push(i.readAddressValueTuple());
          break;
        case "BYTES":
          r.push(i.readBytesWithLength());
          break;
        case "UINT64":
          r.push(i.readU64());
          break;
        case "ARRAY_OF_ADDRESSES":
          r.push(i.readAddressArray());
          break;
        case "ARRAY_OF_UINT256":
          r.push(i.readU256Array());
          break;
        case "ARRAY_OF_UINT128":
          r.push(i.readU128Array());
          break;
        case "ARRAY_OF_UINT64":
          r.push(i.readU64Array());
          break;
        case "ARRAY_OF_UINT32":
          r.push(i.readU32Array());
          break;
        case "ARRAY_OF_UINT16":
          r.push(i.readU16Array());
          break;
        case "ARRAY_OF_UINT8":
          r.push(i.readU8Array());
          break;
        case "ARRAY_OF_STRING":
          r.push(i.readStringArray());
          break;
        case "ARRAY_OF_BYTES":
          r.push(i.readBytesArray());
          break;
        case "ARRAY_OF_BUFFERS":
          r.push(i.readArrayOfBuffer());
          break;
      }
    return r;
  }
  encodeSelector(t) {
    const e = this.sha256(t);
    return a.from(e.subarray(0, 4)).toString("hex");
  }
  numericSelectorToHex(t) {
    return t.toString(16);
  }
  bigIntToUint8Array(t, e) {
    const i = new Uint8Array(e), r = X.valueToUint8Array(t);
    for (let s = 0; s < e; s++)
      i[s] = r[s] || 0;
    return i;
  }
  sha256(t) {
    return new Si.sha256().update(t).digest();
  }
}
class we {
  constructor(t = []) {
    this.items = /* @__PURE__ */ new Set(), this.keys = [];
    for (const e of t)
      this.add(e);
  }
  get size() {
    return this.keys.length;
  }
  add(t) {
    const e = t.toBigInt();
    this.items.has(e) || (this.items.add(e), this.keys.push(t));
  }
  has(t) {
    return this.items.has(t.toBigInt());
  }
  remove(t) {
    const e = t.toBigInt();
    this.items.delete(e) && (this.keys = this.keys.filter((i) => i.toBigInt() !== e));
  }
  clone() {
    return new we(this.keys);
  }
  clear() {
    this.items.clear(), this.keys = [];
  }
  combine(t) {
    const e = this.clone();
    for (const i of t.keys)
      e.add(i);
    return e;
  }
  *[Symbol.iterator]() {
    yield* this.keys;
  }
}
class ye {
  constructor(t) {
    this.compareFn = t, this.map = new Ot(), this.#t = [];
  }
  #t;
  get size() {
    return this.map.size;
  }
  static fromMap(t, e) {
    const i = new ye(e);
    for (const [r, s] of t)
      i.set(r, s);
    return i;
  }
  set(t, e) {
    if (!this.map.has(t)) {
      let i = 0, r = this.#t.length;
      for (; i < r; ) {
        const s = Math.floor((i + r) / 2);
        this.compareFn(this.#t[s], t) < 0 ? i = s + 1 : r = s;
      }
      this.#t.splice(i, 0, t);
    }
    this.map.set(t, e);
  }
  get(t) {
    return this.map.get(t);
  }
  *entries() {
    for (const t of this.#t)
      yield [t, this.map.get(t)];
  }
  *keys() {
    yield* this.#t;
  }
  *values() {
    for (const t of this.#t) {
      const e = this.map.get(t);
      if (e === void 0 && !this.map.has(t))
        throw new Error("Value not found");
      yield e;
    }
  }
  has(t) {
    return this.map.has(t);
  }
  delete(t) {
    if (this.map.has(t)) {
      this.map.delete(t);
      let e = 0, i = this.#t.length - 1;
      for (; e <= i; ) {
        const r = Math.floor((e + i) / 2), s = this.compareFn(this.#t[r], t);
        if (s === 0)
          return this.#t.splice(r, 1), !0;
        s < 0 ? e = r + 1 : i = r - 1;
      }
    }
    return !1;
  }
  clear() {
    this.map.clear(), this.#t = [];
  }
  forEach(t) {
    for (const e of this.#t) {
      const i = this.map.get(e);
      t(i, e, this);
    }
  }
  *[Symbol.iterator]() {
    for (const t of this.#t)
      yield [t, this.map.get(t)];
  }
}
class me {
  constructor(t) {
    this.compareFn = t, this.elements = [];
  }
  get size() {
    return this.elements.length;
  }
  static fromSet(t, e) {
    const i = new me(e);
    for (const r of t)
      i.add(r);
    return i;
  }
  add(t) {
    const { found: e, index: i } = this.binarySearch(t);
    e || this.elements.splice(i, 0, t);
  }
  delete(t) {
    const { found: e, index: i } = this.binarySearch(t);
    return e ? (this.elements.splice(i, 1), !0) : !1;
  }
  has(t) {
    return this.binarySearch(t).found;
  }
  clear() {
    this.elements = [];
  }
  forEach(t) {
    for (const e of this.elements)
      t(e, this);
  }
  *values() {
    yield* this.elements;
  }
  *[Symbol.iterator]() {
    yield* this.elements;
  }
  binarySearch(t) {
    let e = 0, i = this.elements.length;
    for (; e < i; ) {
      const r = Math.floor((e + i) / 2), s = this.compareFn(this.elements[r], t);
      if (s === 0)
        return { found: !0, index: r };
      s < 0 ? e = r + 1 : i = r;
    }
    return { found: !1, index: e };
  }
}
class fr {
  constructor(t, e) {
    this.type = t, this.data = e;
  }
}
class be {
  constructor() {
  }
}
var bt = /* @__PURE__ */ ((n) => (n.testnet = "testnet", n.mainnet = "mainnet", n.regtest = "regtest", n))(bt || {}), oi = /* @__PURE__ */ ((n) => (n.BITCOIN_MAINNET = "BITCOIN_MAINNET", n.BITCOIN_TESTNET = "BITCOIN_TESTNET", n.BITCOIN_TESTNET4 = "BITCOIN_TESTNET4", n.BITCOIN_REGTEST = "BITCOIN_REGTEST", n.BITCOIN_SIGNET = "BITCOIN_SIGNET", n.FRACTAL_BITCOIN_MAINNET = "FRACTAL_BITCOIN_MAINNET", n.FRACTAL_BITCOIN_TESTNET = "FRACTAL_BITCOIN_TESTNET", n))(oi || {});
class pr extends be {
  constructor() {
    if (super(), this.isInitialized = !1, !window)
      throw new Error("UnisatSigner can only be used in a browser environment");
  }
  get p2tr() {
    if (!this._p2tr)
      throw new Error("P2TR address not set");
    return this._p2tr;
  }
  get p2wpkh() {
    if (!this._p2wpkh)
      throw new Error("P2PKH address not set");
    return this._p2wpkh;
  }
  get addresses() {
    if (!this._addresses)
      throw new Error("Addresses not set");
    return this._addresses;
  }
  get publicKey() {
    if (!this._publicKey)
      throw new Error("Public key not set");
    return this._publicKey;
  }
  get network() {
    if (!this._network)
      throw new Error("Network not set");
    return this._network;
  }
  get unisat() {
    if (!window) throw new Error("Window not found");
    const t = window.unisat;
    if (!t)
      throw new Error("Unisat extension not found");
    return t;
  }
  async signData(t, e) {
    const i = t.toString("hex"), r = await this.unisat.signData(i, e);
    return a.from(r, "hex");
  }
  async init() {
    if (this.isInitialized)
      return;
    const t = await this.unisat.getNetwork();
    switch (t) {
      case bt.mainnet:
        this._network = I;
        break;
      case bt.testnet:
        this._network = At;
        break;
      case bt.regtest:
        this._network = zt;
        break;
      default:
        throw new Error(`Invalid network: ${t}`);
    }
    const e = await this.unisat.getPublicKey();
    if (e === "")
      throw new Error("Unlock your wallet first");
    this._publicKey = a.from(e, "hex"), this._p2wpkh = A.getP2WPKHAddress(this, this.network), this._p2tr = A.getTaprootAddress(this, this.network), this._addresses = [this._p2wpkh, this._p2tr], this.isInitialized = !0;
  }
  getPublicKey() {
    if (!this.isInitialized)
      throw new Error("UnisatSigner not initialized");
    return this.publicKey;
  }
  sign(t, e) {
    throw new Error("Not implemented: sign");
  }
  signSchnorr(t) {
    throw new Error("Not implemented: signSchnorr");
  }
  verify(t, e) {
    throw new Error("Not implemented: verify");
  }
  async signTaprootInput(t, e, i) {
    const r = t.data.inputs[e];
    if (r.tapKeySig || r.finalScriptSig || Array.isArray(r.partialSig) && r.partialSig.length && this.hasAlreadyPartialSig(r.partialSig) || Array.isArray(r.tapScriptSig) && r.tapScriptSig.length && this.hasAlreadySignedTapScriptSig(r.tapScriptSig))
      return;
    const s = await this.signAllTweaked(t, i, !1);
    this.combine(t, s, e);
  }
  async signInput(t, e, i) {
    const r = t.data.inputs[e];
    if (r.tapKeySig || r.finalScriptSig || Array.isArray(r.partialSig) && r.partialSig.length && this.hasAlreadyPartialSig(r.partialSig) || Array.isArray(r.tapScriptSig) && r.tapScriptSig.length && this.hasAlreadySignedTapScriptSig(r.tapScriptSig))
      return;
    const s = await this.signAllTweaked(t, i, !0);
    this.combine(t, s, e);
  }
  async multiSignPsbt(t) {
    const e = [], i = [];
    for (const o of t) {
      const c = o.toHex();
      e.push(c);
      const u = o.data.inputs.map((h, l) => {
        let d = !1, p = !1;
        if (le(h)) {
          if (h.tapLeafScript && h.tapLeafScript.length > 0) {
            for (const f of h.tapLeafScript)
              if (gr(this.publicKey, f.script)) {
                d = !0, p = !1;
                break;
              }
          }
          if (!d && h.tapInternalKey) {
            const f = h.tapInternalKey, w = O(this.publicKey);
            f.equals(w) && (d = !0, p = !0);
          }
        } else de(h, this.publicKey) && (d = !0, p = !1);
        return d ? {
          index: l,
          publicKey: this.publicKey.toString("hex"),
          disableTweakSigner: !p
        } : null;
      }).filter((h) => h !== null);
      i.push({
        autoFinalized: !1,
        toSignInputs: u
      });
    }
    const r = await this.unisat.signPsbt(e[0], i[0]), s = F.fromHex(r);
    t[0].combine(s);
  }
  hasAlreadySignedTapScriptSig(t) {
    for (let e = 0; e < t.length; e++) {
      const i = t[e];
      if (a.from(i.pubkey).equals(this.publicKey) && i.signature)
        return !0;
    }
    return !1;
  }
  hasAlreadyPartialSig(t) {
    for (let e = 0; e < t.length; e++) {
      const i = t[e];
      if (a.from(i.pubkey).equals(this.publicKey) && i.signature)
        return !0;
    }
    return !1;
  }
  combine(t, e, i) {
    const r = e.data.inputs[i], s = t.data.inputs[i];
    if (r.partialSig && t.updateInput(i, { partialSig: r.partialSig }), r.tapKeySig && !s.tapKeySig && t.updateInput(i, { tapKeySig: r.tapKeySig }), r.tapScriptSig?.length) {
      const o = s.tapScriptSig;
      if (o) {
        const c = this.getNonDuplicateScriptSig(
          o,
          r.tapScriptSig
        );
        c.length && t.updateInput(i, { tapScriptSig: c });
      } else
        t.updateInput(i, { tapScriptSig: r.tapScriptSig });
    }
  }
  async signAllTweaked(t, e, i = !1) {
    const r = this.publicKey.toString("hex"), o = {
      autoFinalized: !1,
      toSignInputs: t.data.inputs.map((h, l) => [
        {
          index: l,
          publicKey: r,
          sighashTypes: e,
          disableTweakSigner: i
        }
      ]).flat()
    }, c = t.toHex(), u = await this.unisat.signPsbt(c, o);
    return F.fromHex(u);
  }
  getNonDuplicateScriptSig(t, e) {
    const i = [];
    for (let r = 0; r < e.length; r++)
      t.find((o) => o.pubkey.equals(e[r].pubkey)) || i.push(e[r]);
    return i;
  }
}
function gr(n, t) {
  return Sr(n, t) !== -1;
}
function Sr(n, t) {
  const e = dt(n), i = O(n), r = R(t);
  if (r === null) throw new Error("Unknown script error");
  return r.findIndex((s) => typeof s == "number" ? !1 : a.isBuffer(s) && (s.equals(n) || s.equals(e) || s.equals(i)));
}
class wr extends be {
  constructor() {
    if (super(), this.isInitialized = !1, !window)
      throw new Error("XverseSigner can only be used in a browser environment");
  }
  get p2tr() {
    if (!this._p2tr)
      throw new Error("P2TR address not set");
    return this._p2tr;
  }
  get p2wpkh() {
    if (!this._p2wpkh)
      throw new Error("P2PKH address not set");
    return this._p2wpkh;
  }
  get addresses() {
    if (!this._addresses)
      throw new Error("Addresses not set");
    return this._addresses;
  }
  get publicKey() {
    if (!this._publicKey)
      throw new Error("Public key not set");
    return this._publicKey;
  }
  get network() {
    if (!this._network)
      throw new Error("Network not set");
    return this._network;
  }
  get BitcoinProvider() {
    const t = window.BitcoinProvider;
    if (!t)
      throw new Error("Xverse Wallet extension not found");
    return t;
  }
  async init() {
    if (this.isInitialized) return;
    const t = await this.BitcoinProvider.request("wallet_connect", null);
    if ("error" in t) throw new Error(t.error.message);
    const e = t.result.addresses.find(
      (r) => r.purpose === "payment"
    );
    if (!e)
      throw new Error("Payment address not found");
    const i = e.address.startsWith("tb") ? At : e.address.startsWith("bc") ? I : null;
    if (!i) throw new Error("Network not supported");
    this._network = i, this._publicKey = a.from(e.publicKey, "hex"), this._p2wpkh = A.getP2WPKHAddress(this, this.network), this._p2tr = A.getTaprootAddress(this, this.network), this._addresses = [this._p2wpkh, this._p2tr], this.isInitialized = !0;
  }
  async signData(t, e, i) {
    if (!this.isInitialized)
      throw new Error("UnisatSigner not initialized");
    const r = await this.BitcoinProvider.request("signMessage", {
      address: e,
      message: t.toString(),
      protocol: i
    });
    if ("error" in r) throw new Error(r.error.message);
    const s = r.result;
    if (!s.signature)
      throw new Error("Signature not found");
    return a.from(s.signature, "hex");
  }
  getPublicKey() {
    if (!this.isInitialized)
      throw new Error("UnisatSigner not initialized");
    return this.publicKey;
  }
  sign(t, e) {
    throw new Error("Not implemented: sign");
  }
  signSchnorr(t) {
    throw new Error("Not implemented: signSchnorr");
  }
  verify(t, e) {
    throw new Error("Not implemented: verify");
  }
  async signTaprootInput(t, e, i) {
    const r = t.data.inputs[e];
    if (r.tapKeySig || r.finalScriptSig || Array.isArray(r.partialSig) && r.partialSig.length && this.hasAlreadyPartialSig(r.partialSig) || Array.isArray(r.tapScriptSig) && r.tapScriptSig.length && this.hasAlreadySignedTapScriptSig(r.tapScriptSig))
      return;
    const s = await this.signAllTweaked(t, i, !1);
    this.combine(t, s, e);
  }
  async signInput(t, e, i) {
    const r = t.data.inputs[e];
    if (r.tapKeySig || r.finalScriptSig || Array.isArray(r.partialSig) && r.partialSig.length && this.hasAlreadyPartialSig(r.partialSig) || Array.isArray(r.tapScriptSig) && r.tapScriptSig.length && this.hasAlreadySignedTapScriptSig(r.tapScriptSig))
      return;
    const s = await this.signAllTweaked(t, i, !0);
    this.combine(t, s, e);
  }
  async multiSignPsbt(t) {
    const e = [], i = [];
    for (const c of t) {
      const u = c.toBase64();
      e.push(u);
      const h = c.data.inputs.map((l, d) => {
        let p = !1, f = !1;
        if (le(l)) {
          if (l.tapLeafScript && l.tapLeafScript.length > 0) {
            for (const w of l.tapLeafScript)
              if (fe(this.publicKey, w.script)) {
                p = !0, f = !1;
                break;
              }
          }
          if (!p && l.tapInternalKey) {
            const w = l.tapInternalKey, S = O(this.publicKey);
            w.equals(S) && (p = !0, f = !0);
          }
        } else de(l, this.publicKey) && (p = !0, f = !1);
        return p ? {
          index: d,
          publicKey: this.publicKey.toString("hex"),
          disableTweakSigner: !f
        } : null;
      }).filter((l) => l !== null);
      i.push({
        autoFinalized: !1,
        toSignInputs: h
      });
    }
    const r = {
      [this.p2wpkh]: i[0].toSignInputs?.map((c) => c.index) || []
    }, s = await this.BitcoinProvider.request("signPsbt", {
      psbt: e[0],
      signInputs: r
    });
    if ("error" in s) throw new Error(s.error.message);
    const o = F.fromBase64(s.result.psbt);
    t[0].combine(o);
  }
  hasAlreadySignedTapScriptSig(t) {
    for (let e = 0; e < t.length; e++) {
      const i = t[e];
      if (a.from(i.pubkey).equals(this.publicKey) && i.signature)
        return !0;
    }
    return !1;
  }
  hasAlreadyPartialSig(t) {
    for (let e = 0; e < t.length; e++) {
      const i = t[e];
      if (a.from(i.pubkey).equals(this.publicKey) && i.signature)
        return !0;
    }
    return !1;
  }
  combine(t, e, i) {
    const r = e.data.inputs[i], s = t.data.inputs[i];
    if (r.partialSig && t.updateInput(i, { partialSig: r.partialSig }), r.tapKeySig && !s.tapKeySig && t.updateInput(i, { tapKeySig: r.tapKeySig }), r.tapScriptSig?.length) {
      const o = s.tapScriptSig;
      if (o) {
        const c = this.getNonDuplicateScriptSig(
          o,
          r.tapScriptSig
        );
        c.length && t.updateInput(i, { tapScriptSig: c });
      } else
        t.updateInput(i, { tapScriptSig: r.tapScriptSig });
    }
  }
  async signAllTweaked(t, e, i = !1) {
    const r = this.publicKey.toString("hex"), o = {
      toSignInputs: t.data.inputs.map((l, d) => [
        {
          index: d,
          publicKey: r,
          sighashTypes: e,
          disableTweakSigner: i
        }
      ]).flat()
    }, c = t.toBase64(), u = {
      [this.p2wpkh]: o.toSignInputs?.map((l) => l.index) || []
    }, h = await this.BitcoinProvider.request("signPsbt", {
      psbt: c,
      signInputs: u
    });
    if ("error" in h) throw new Error(h.error.message);
    return F.fromBase64(h.result.psbt);
  }
  getNonDuplicateScriptSig(t, e) {
    const i = [];
    for (let r = 0; r < e.length; r++)
      t.find((o) => o.pubkey.equals(e[r].pubkey)) || i.push(e[r]);
    return i;
  }
}
var ai = /* @__PURE__ */ ((n) => (n.ecdsa = "ecdsa", n.bip322 = "bip322-simple", n))(ai || {}), ci = /* @__PURE__ */ ((n) => (n.ecdsa = "ecdsa", n.schnorr = "schnorr", n))(ci || {}), ui = /* @__PURE__ */ ((n) => (n.mainnet = "mainnet", n.testnet = "testnet", n.signet = "Signet", n))(ui || {}), hi = /* @__PURE__ */ ((n) => (n.ECDSA = "ECDSA", n.BIP322 = "BIP322", n))(hi || {});
class Ht {
  constructor() {
    this._size = 0, this.capacity = Ht.INITIAL_CAPACITY, this.#t = new Array(this.capacity), this.#e = new Array(this.capacity), this.deleted = new Array(this.capacity).fill(!1);
  }
  static {
    this.INITIAL_CAPACITY = 16;
  }
  static {
    this.LOAD_FACTOR = 0.75;
  }
  #t;
  #e;
  get size() {
    return this._size;
  }
  set(t, e) {
    let i = !0;
    const r = this.findInsertIndex(t);
    return (this.#t[r] === void 0 || this.deleted[r]) && (this._size++, i = !1), this.#t[r] = t, this.#e[r] = e, this.deleted[r] = !1, this._size > this.capacity * Ht.LOAD_FACTOR && this.resize(), i;
  }
  get(t) {
    const e = this.findIndex(t);
    return e === -1 ? void 0 : this.#e[e];
  }
  has(t) {
    return this.findIndex(t) !== -1;
  }
  indexOf(t) {
    return this.findIndex(t);
  }
  delete(t) {
    const e = this.findIndex(t);
    return e === -1 ? !1 : (this.#t[e] = void 0, this.#e[e] = void 0, this.deleted[e] = !0, this._size--, !0);
  }
  clear() {
    this.#t = new Array(this.capacity), this.#e = new Array(this.capacity), this.deleted = new Array(this.capacity).fill(!1), this._size = 0;
  }
  *entries() {
    for (let t = 0; t < this.capacity; t++)
      this.#t[t] !== void 0 && !this.deleted[t] && (yield [this.#t[t], this.#e[t]]);
  }
  *keys() {
    for (let t = 0; t < this.capacity; t++)
      this.#t[t] !== void 0 && !this.deleted[t] && (yield this.#t[t]);
  }
  *values() {
    for (let t = 0; t < this.capacity; t++)
      this.#t[t] !== void 0 && !this.deleted[t] && (yield this.#e[t]);
  }
  *[Symbol.iterator]() {
    yield* this.entries();
  }
  hashBigInt(t) {
    if (t >= -2147483648n && t <= 2147483647n)
      return Number(t) | 0;
    let e = 2166136261, i = t < 0n ? -t : t;
    for (; i > 0n; ) {
      const r = Number(i & 0xffffffffn);
      e ^= r, e = Math.imul(e, 16777619), i = i >> 32n;
    }
    return t < 0n && (e ^= 2147483648, e = Math.imul(e, 16777619)), Math.abs(e);
  }
  hash(t) {
    let e = 0;
    switch (typeof t) {
      case "number":
        if (t !== t) return 9221120237041091e3;
        if (!isFinite(t)) return t > 0 ? 9218868437227405e3 : 18442240474082181e3;
        e = t | 0;
        break;
      case "string":
        e = 2166136261;
        for (let i = 0; i < t.length; i++)
          e ^= t.charCodeAt(i), e = Math.imul(e, 16777619);
        break;
      case "boolean":
        e = t ? 1231 : 1237;
        break;
      case "symbol": {
        const i = t.description || "";
        e = this.hash(i);
        break;
      }
      case "bigint":
        e = this.hashBigInt(t);
        break;
      case "undefined":
        e = 0;
        break;
      case "object":
        if (t === null)
          e = 0;
        else if (t instanceof Date)
          e = t.getTime() | 0;
        else if (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)
          e = this.hashBuffer(t);
        else if (Array.isArray(t)) {
          e = 1;
          for (const i of t)
            e = Math.imul(e, 31) + this.hash(i);
        } else
          throw new Error("Raw object not supported.");
        break;
      case "function":
        e = this.hash(t.toString());
        break;
    }
    return Math.abs(e) % this.capacity;
  }
  hashBuffer(t) {
    let e;
    if (t instanceof ArrayBuffer)
      e = new Uint8Array(t);
    else if (ArrayBuffer.isView(t))
      e = new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
    else
      return 0;
    let i = 2166136261;
    for (let r = 0; r < Math.min(e.length, 100); r++)
      i ^= e[r], i = Math.imul(i, 16777619);
    return i;
  }
  equals(t, e) {
    return t === e || typeof t == "number" && typeof e == "number" && t !== t && e !== e ? !0 : (ArrayBuffer.isView(t) || t instanceof ArrayBuffer) && (ArrayBuffer.isView(e) || e instanceof ArrayBuffer) ? this.buffersEqual(t, e) : !1;
  }
  buffersEqual(t, e) {
    const i = this.getBytes(t), r = this.getBytes(e);
    if (i.length !== r.length) return !1;
    for (let s = 0; s < i.length; s++)
      if (i[s] !== r[s]) return !1;
    return !0;
  }
  getBytes(t) {
    return t instanceof ArrayBuffer ? new Uint8Array(t) : ArrayBuffer.isView(t) ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : new Uint8Array(0);
  }
  findIndex(t) {
    let e = this.hash(t);
    for (; this.#t[e] !== void 0 || this.deleted[e]; ) {
      if (this.#t[e] !== void 0 && this.equals(this.#t[e], t))
        return e;
      e = (e + 1) % this.capacity;
    }
    return -1;
  }
  findInsertIndex(t) {
    let e = this.hash(t);
    for (; this.#t[e] !== void 0 && !this.deleted[e]; ) {
      if (this.equals(this.#t[e], t))
        return e;
      e = (e + 1) % this.capacity;
    }
    return e;
  }
  resize() {
    const t = this.#t, e = this.#e;
    this.capacity *= 2, this.#t = new Array(this.capacity), this.#e = new Array(this.capacity), this.deleted = new Array(this.capacity).fill(!1), this._size = 0;
    for (let i = 0; i < t.length; i++)
      t[i] !== void 0 && !this.deleted[i] && this.set(t[i], e[i]);
  }
}
const Tr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ABICoder: dr,
  ABIDataTypes: ni,
  ADDRESS_BYTE_LENGTH: C,
  ANCHOR_SCRIPT: re,
  Address: k,
  AddressGenerator: ae,
  AddressMap: Fe,
  AddressSet: we,
  AddressTypes: J,
  AddressVerificator: H,
  BIPStandard: mt,
  BOOLEAN_BYTE_LENGTH: Qi,
  BinaryReader: qt,
  BinaryWriter: D,
  BitcoinUtils: K,
  BufferHelper: X,
  CSVModes: Ye,
  CalldataGenerator: oe,
  CancelTransaction: ge,
  ChainId: he,
  ChallengeSolution: se,
  ChallengeSubmission: ri,
  ChallengeVerification: ii,
  Compressor: N,
  Consensus: Bt,
  ConsolidatedInteractionTransaction: Ge,
  ContractAddress: te,
  ContractBaseMetadata: rr,
  CustomGenerator: Re,
  CustomKeypair: be,
  CustomMap: Ht,
  CustomScriptTransaction: Wt,
  DeploymentGenerator: Ft,
  DeploymentTransaction: ft,
  DeterministicMap: ye,
  DeterministicSet: me,
  EcKeyPair: A,
  EpochValidator: ct,
  FastMap: Ot,
  FeaturePriority: Q,
  Features: W,
  FundingTransaction: Mt,
  Generator: q,
  HashCommitmentGenerator: E,
  I128_BYTE_LENGTH: yt,
  I16_BYTE_LENGTH: Yi,
  I256_BYTE_LENGTH: qi,
  I64_BYTE_LENGTH: $i,
  I8_BYTE_LENGTH: Gi,
  InteractionTransaction: Nt,
  InteractionTransactionP2WDA: j,
  LegacyCalldataGenerator: Ji,
  MINIMUM_AMOUNT_CA: St,
  MINIMUM_AMOUNT_REWARD: V,
  MLDSAKeyPair: P.MLDSAKeyPair,
  MLDSAPublicKeyMetadata: Ve,
  MLDSASecurityLevel: P.MLDSASecurityLevel,
  MessageSigner: st,
  MessageType: ai,
  Mnemonic: ue,
  MnemonicStrength: Rt,
  MultiSignGenerator: Pt,
  MultiSignTransaction: x,
  NetEvent: fr,
  OPNET_DEPLOYMENT_VERSION: We,
  OPNetConsensusConfig: $e,
  OPNetLimitedProvider: hr,
  OfflineTransactionManager: ur,
  P2TR_MS: lr,
  P2WDADetector: z,
  P2WDAGenerator: Et,
  PSBTTypes: si,
  QuantumBIP32API: P.QuantumBIP32API,
  QuantumBIP32Factory: P.QuantumBIP32Factory,
  QuantumBIP32Interface: P.QuantumBIP32Interface,
  QuantumDerivationPath: P.QuantumDerivationPath,
  QuantumSigner: P.QuantumSigner,
  RoswellConsensus: qe,
  SELECTOR_BYTE_LENGTH: zi,
  SERIALIZATION_FORMAT_VERSION: Se,
  SERIALIZATION_MAGIC_BYTE: _t,
  Secp256k1PointDeriver: De,
  SharedInteractionTransaction: pe,
  SignatureType: ci,
  SigningProtocol: hi,
  TapscriptVerificator: tt,
  TimeLockGenerator: M,
  TransactionBuilder: m,
  TransactionFactory: Qe,
  TransactionReconstructor: ut,
  TransactionSequence: Xe,
  TransactionSerializer: B,
  TransactionStateCapture: $,
  TransactionType: y,
  TweakedSigner: ce,
  TweakedTransaction: Xt,
  U128_BYTE_LENGTH: wt,
  U16_BYTE_LENGTH: Tt,
  U256_BYTE_LENGTH: It,
  U32_BYTE_LENGTH: ht,
  U64_BYTE_LENGTH: Ct,
  U8_BYTE_LENGTH: Dt,
  UnisatChainType: oi,
  UnisatSigner: pr,
  Wallet: Z,
  WalletNetworks: bt,
  XverseNetwork: ui,
  XverseSigner: wr,
  buildBIPPath: He,
  createAddressRotation: sr,
  createSignerMap: ze,
  currentConsensus: $t,
  currentConsensusConfig: or,
  disabledAddressRotation: nr,
  getBIPDescription: er,
  getLevelFromPublicKeyLength: ee,
  isCancelSpecificData: ei,
  isCustomScriptSpecificData: ti,
  isDeploymentSpecificData: Ze,
  isFundingSpecificData: je,
  isInteractionSpecificData: Je,
  isMultiSigSpecificData: et,
  isOPWallet: Ne,
  number_BYTE_LENGTH: Xi,
  version: Di,
  versionBuffer: Me
}, Symbol.toStringTag, { value: "Module" })), Pr = P.MLDSAKeyPair, Er = P.MLDSASecurityLevel, Ar = P.QuantumBIP32API, Or = P.QuantumBIP32Factory, Br = P.QuantumBIP32Interface, xr = P.QuantumDerivationPath, vr = P.QuantumSigner;
export {
  dr as ABICoder,
  ni as ABIDataTypes,
  C as ADDRESS_BYTE_LENGTH,
  re as ANCHOR_SCRIPT,
  k as Address,
  ae as AddressGenerator,
  Fe as AddressMap,
  we as AddressSet,
  J as AddressTypes,
  H as AddressVerificator,
  mt as BIPStandard,
  Qi as BOOLEAN_BYTE_LENGTH,
  qt as BinaryReader,
  D as BinaryWriter,
  K as BitcoinUtils,
  X as BufferHelper,
  Ye as CSVModes,
  oe as CalldataGenerator,
  ge as CancelTransaction,
  he as ChainId,
  se as ChallengeSolution,
  ri as ChallengeSubmission,
  ii as ChallengeVerification,
  N as Compressor,
  Bt as Consensus,
  Ge as ConsolidatedInteractionTransaction,
  te as ContractAddress,
  rr as ContractBaseMetadata,
  Re as CustomGenerator,
  be as CustomKeypair,
  Ht as CustomMap,
  Wt as CustomScriptTransaction,
  Ft as DeploymentGenerator,
  ft as DeploymentTransaction,
  ye as DeterministicMap,
  me as DeterministicSet,
  A as EcKeyPair,
  ct as EpochValidator,
  Ot as FastMap,
  Q as FeaturePriority,
  W as Features,
  Mt as FundingTransaction,
  q as Generator,
  E as HashCommitmentGenerator,
  yt as I128_BYTE_LENGTH,
  Yi as I16_BYTE_LENGTH,
  qi as I256_BYTE_LENGTH,
  $i as I64_BYTE_LENGTH,
  Gi as I8_BYTE_LENGTH,
  Nt as InteractionTransaction,
  j as InteractionTransactionP2WDA,
  Ji as LegacyCalldataGenerator,
  St as MINIMUM_AMOUNT_CA,
  V as MINIMUM_AMOUNT_REWARD,
  Pr as MLDSAKeyPair,
  Ve as MLDSAPublicKeyMetadata,
  Er as MLDSASecurityLevel,
  st as MessageSigner,
  ai as MessageType,
  ue as Mnemonic,
  Rt as MnemonicStrength,
  Pt as MultiSignGenerator,
  x as MultiSignTransaction,
  fr as NetEvent,
  We as OPNET_DEPLOYMENT_VERSION,
  $e as OPNetConsensusConfig,
  hr as OPNetLimitedProvider,
  ur as OfflineTransactionManager,
  lr as P2TR_MS,
  z as P2WDADetector,
  Et as P2WDAGenerator,
  si as PSBTTypes,
  Ar as QuantumBIP32API,
  Or as QuantumBIP32Factory,
  Br as QuantumBIP32Interface,
  xr as QuantumDerivationPath,
  vr as QuantumSigner,
  qe as RoswellConsensus,
  zi as SELECTOR_BYTE_LENGTH,
  Se as SERIALIZATION_FORMAT_VERSION,
  _t as SERIALIZATION_MAGIC_BYTE,
  De as Secp256k1PointDeriver,
  pe as SharedInteractionTransaction,
  ci as SignatureType,
  hi as SigningProtocol,
  tt as TapscriptVerificator,
  M as TimeLockGenerator,
  m as TransactionBuilder,
  Qe as TransactionFactory,
  ut as TransactionReconstructor,
  Xe as TransactionSequence,
  B as TransactionSerializer,
  $ as TransactionStateCapture,
  y as TransactionType,
  ce as TweakedSigner,
  Xt as TweakedTransaction,
  wt as U128_BYTE_LENGTH,
  Tt as U16_BYTE_LENGTH,
  It as U256_BYTE_LENGTH,
  ht as U32_BYTE_LENGTH,
  Ct as U64_BYTE_LENGTH,
  Dt as U8_BYTE_LENGTH,
  oi as UnisatChainType,
  pr as UnisatSigner,
  Z as Wallet,
  bt as WalletNetworks,
  ui as XverseNetwork,
  wr as XverseSigner,
  He as buildBIPPath,
  sr as createAddressRotation,
  ze as createSignerMap,
  $t as currentConsensus,
  or as currentConsensusConfig,
  nr as disabledAddressRotation,
  er as getBIPDescription,
  ee as getLevelFromPublicKeyLength,
  ei as isCancelSpecificData,
  ti as isCustomScriptSpecificData,
  Ze as isDeploymentSpecificData,
  je as isFundingSpecificData,
  Je as isInteractionSpecificData,
  et as isMultiSigSpecificData,
  Ne as isOPWallet,
  Xi as number_BYTE_LENGTH,
  Tr as opnet,
  Di as version,
  Me as versionBuffer
};
