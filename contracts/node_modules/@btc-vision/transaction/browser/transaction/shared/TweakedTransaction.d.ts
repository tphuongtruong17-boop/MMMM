import { Logger } from '@btc-vision/logger';
import { Network, P2TRPayment, Psbt, PsbtInput, PsbtInputExtended, Signer, Transaction } from '../../../node_modules/@btc-vision/bitcoin/build/index.js';
import { ECPairInterface } from 'ecpair';
import { UTXO } from '../../utxo/interfaces/IUTXO.js';
import { TapLeafScript } from '../interfaces/Tap.js';
import { UnisatSigner } from '../browser/extensions/UnisatSigner.js';
import { Buffer } from '../../../buffer';
import { QuantumBIP32Interface } from '../../../node_modules/@btc-vision/bip32/src/cjs/index.cjs';
import { RotationSigner, SignerMap } from '../../signer/AddressRotation.js';
import { ITweakedTransactionData, SupportedTransactionVersion } from '../interfaces/ITweakedTransactionData.js';
export declare enum TransactionSequence {
    REPLACE_BY_FEE = 4294967293,
    FINAL = 4294967295
}
export declare enum CSVModes {
    BLOCKS = 0,
    TIMESTAMPS = 1
}
export declare abstract class TweakedTransaction extends Logger {
    readonly logColor: string;
    finalized: boolean;
    protected signer: Signer | ECPairInterface | UnisatSigner;
    protected tweakedSigner?: ECPairInterface;
    protected network: Network;
    protected signed: boolean;
    protected abstract readonly transaction: Psbt;
    protected sighashTypes: number[] | undefined;
    protected scriptData: P2TRPayment | null;
    protected tapData: P2TRPayment | null;
    protected readonly inputs: PsbtInputExtended[];
    protected sequence: number;
    protected tapLeafScript: TapLeafScript | null;
    protected nonWitnessUtxo?: Buffer;
    protected readonly isBrowser: boolean;
    protected csvInputIndices: Set<number>;
    protected anchorInputIndices: Set<number>;
    protected regenerated: boolean;
    protected ignoreSignatureErrors: boolean;
    protected noSignatures: boolean;
    protected unlockScript: Buffer[] | undefined;
    protected txVersion: SupportedTransactionVersion;
    protected readonly _mldsaSigner: QuantumBIP32Interface | null;
    protected readonly _hashedPublicKey: Buffer | null;
    protected readonly addressRotationEnabled: boolean;
    protected readonly signerMap: SignerMap;
    protected readonly inputSignerMap: Map<number, RotationSigner>;
    protected readonly tweakedSignerCache: Map<number, ECPairInterface | undefined>;
    protected constructor(data: ITweakedTransactionData);
    protected get mldsaSigner(): QuantumBIP32Interface;
    protected get hashedPublicKey(): Buffer;
    static readScriptWitnessToWitnessStack(buffer: Buffer): Buffer[];
    static preEstimateTaprootTransactionFees(feeRate: bigint, numInputs: bigint, numOutputs: bigint, numWitnessElements: bigint, witnessElementSize: bigint, emptyWitness: bigint, taprootControlWitnessSize?: bigint, taprootScriptSize?: bigint): bigint;
    protected static signInput(transaction: Psbt, input: PsbtInput, i: number, signer: Signer | ECPairInterface, sighashTypes: number[]): void;
    protected static calculateSignHash(sighashTypes: number[]): number;
    isAddressRotationEnabled(): boolean;
    ignoreSignatureError(): void;
    getScriptAddress(): string;
    getTransaction(): Transaction;
    getTapAddress(): string;
    disableRBF(): void;
    getTweakerHash(): Buffer | undefined;
    preEstimateTransactionFees(feeRate: bigint, numInputs: bigint, numOutputs: bigint, numSignatures: bigint, numPubkeys: bigint): bigint;
    protected getSignerForInput(inputIndex: number): RotationSigner;
    protected registerInputSigner(inputIndex: number, utxo: UTXO): void;
    protected internalPubKeyToXOnlyForInput(inputIndex: number): Buffer;
    protected getTweakedSignerForInput(inputIndex: number, useTweakedHash?: boolean): ECPairInterface | undefined;
    protected generateTapData(): P2TRPayment;
    protected generateScriptAddress(): P2TRPayment;
    protected getSignerKey(): Signer | ECPairInterface;
    protected signInput(transaction: Psbt, input: PsbtInput, i: number, signer: Signer | ECPairInterface, reverse?: boolean, errored?: boolean): Promise<void>;
    protected splitArray<T>(arr: T[], chunkSize: number): T[][];
    protected signInputs(transaction: Psbt): Promise<void>;
    protected signInputsNonWalletBased(transaction: Psbt): Promise<void>;
    protected internalPubKeyToXOnly(): Buffer;
    protected internalInit(): void;
    protected tweakSigner(): void;
    protected getTweakedSigner(useTweakedHash?: boolean, signer?: Signer | ECPairInterface): ECPairInterface | undefined;
    protected generateP2SHRedeemScript(customWitnessScript: Buffer): Buffer | undefined;
    protected generateP2SHRedeemScriptLegacy(inputAddr: string): {
        redeemScript: Buffer;
        outputScript: Buffer;
    } | undefined;
    protected generateP2SHP2PKHRedeemScript(inputAddr: string, inputIndex?: number): {
        redeemScript: Buffer;
        outputScript: Buffer;
    } | undefined;
    protected generatePsbtInputExtended(utxo: UTXO, i: number, _extra?: boolean): PsbtInputExtended;
    protected processP2WSHInput(utxo: UTXO, input: PsbtInputExtended, i: number): void;
    protected secondsToCSVTimeUnits(seconds: number): number;
    protected createTimeBasedCSV(seconds: number): number;
    protected isCSVEnabled(sequence: number): boolean;
    protected extractCSVValue(sequence: number): number;
    protected customFinalizerP2SH: (inputIndex: number, input: PsbtInput, scriptA: Buffer, isSegwit: boolean, isP2SH: boolean, isP2WSH: boolean) => {
        finalScriptSig: Buffer | undefined;
        finalScriptWitness: Buffer | undefined;
    };
    protected finalizeSecondaryP2WDA(inputIndex: number, input: PsbtInput): {
        finalScriptWitness: Buffer | undefined;
        finalScriptSig: Buffer | undefined;
    };
    protected signInputsWalletBased(transaction: Psbt): Promise<void>;
    protected isCSVScript(decompiled: (number | Buffer)[]): boolean;
    protected setCSVSequence(csvBlocks: number, currentSequence: number): number;
    protected getCSVType(csvValue: number): CSVModes;
    private extractCSVBlocks;
    private attemptSignTaproot;
    private isTaprootScriptSpend;
    private signTaprootInput;
    private signNonTaprootInput;
}
