import { l as fn, m as th, n as kn, a as nh, o as hf, p as ar, q as ah, t as ts, u as oh, v as ih, w as sr, x as ns, k as sh, y as ch, z as uh, r as lh } from "./noble-hashes.js";
import { g as Ea, r as fh, a as dh, b as hh, c as En, F as js, d as ph, e as gh } from "./noble-curves.js";
import { r as as } from "./valibot.js";
function bh(e, t) {
  for (var r = 0; r < t.length; r++) {
    const n = t[r];
    if (typeof n != "string" && !Array.isArray(n)) {
      for (const o in n)
        if (o !== "default" && !(o in e)) {
          const a = Object.getOwnPropertyDescriptor(n, o);
          a && Object.defineProperty(e, o, a.get ? a : {
            enumerable: !0,
            get: () => n[o]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
var os = {}, xa = {};
xa.byteLength = vh;
xa.toByteArray = _h;
xa.fromByteArray = xh;
var kr = [], cr = [], mh = typeof Uint8Array < "u" ? Uint8Array : Array, ja = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var xt = 0, yh = ja.length; xt < yh; ++xt)
  kr[xt] = ja[xt], cr[ja.charCodeAt(xt)] = xt;
cr[45] = 62;
cr[95] = 63;
function pf(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var r = e.indexOf("=");
  r === -1 && (r = t);
  var n = r === t ? 0 : 4 - r % 4;
  return [r, n];
}
function vh(e) {
  var t = pf(e), r = t[0], n = t[1];
  return (r + n) * 3 / 4 - n;
}
function wh(e, t, r) {
  return (t + r) * 3 / 4 - r;
}
function _h(e) {
  var t, r = pf(e), n = r[0], o = r[1], a = new mh(wh(e, n, o)), s = 0, i = o > 0 ? n - 4 : n, h;
  for (h = 0; h < i; h += 4)
    t = cr[e.charCodeAt(h)] << 18 | cr[e.charCodeAt(h + 1)] << 12 | cr[e.charCodeAt(h + 2)] << 6 | cr[e.charCodeAt(h + 3)], a[s++] = t >> 16 & 255, a[s++] = t >> 8 & 255, a[s++] = t & 255;
  return o === 2 && (t = cr[e.charCodeAt(h)] << 2 | cr[e.charCodeAt(h + 1)] >> 4, a[s++] = t & 255), o === 1 && (t = cr[e.charCodeAt(h)] << 10 | cr[e.charCodeAt(h + 1)] << 4 | cr[e.charCodeAt(h + 2)] >> 2, a[s++] = t >> 8 & 255, a[s++] = t & 255), a;
}
function kh(e) {
  return kr[e >> 18 & 63] + kr[e >> 12 & 63] + kr[e >> 6 & 63] + kr[e & 63];
}
function Eh(e, t, r) {
  for (var n, o = [], a = t; a < r; a += 3)
    n = (e[a] << 16 & 16711680) + (e[a + 1] << 8 & 65280) + (e[a + 2] & 255), o.push(kh(n));
  return o.join("");
}
function xh(e) {
  for (var t, r = e.length, n = r % 3, o = [], a = 16383, s = 0, i = r - n; s < i; s += a)
    o.push(Eh(e, s, s + a > i ? i : s + a));
  return n === 1 ? (t = e[r - 1], o.push(
    kr[t >> 2] + kr[t << 4 & 63] + "=="
  )) : n === 2 && (t = (e[r - 2] << 8) + e[r - 1], o.push(
    kr[t >> 10] + kr[t >> 4 & 63] + kr[t << 2 & 63] + "="
  )), o.join("");
}
var is = {};
is.read = function(e, t, r, n, o) {
  var a, s, i = o * 8 - n - 1, h = (1 << i) - 1, l = h >> 1, c = -7, w = r ? o - 1 : 0, g = r ? -1 : 1, v = e[t + w];
  for (w += g, a = v & (1 << -c) - 1, v >>= -c, c += i; c > 0; a = a * 256 + e[t + w], w += g, c -= 8)
    ;
  for (s = a & (1 << -c) - 1, a >>= -c, c += n; c > 0; s = s * 256 + e[t + w], w += g, c -= 8)
    ;
  if (a === 0)
    a = 1 - l;
  else {
    if (a === h)
      return s ? NaN : (v ? -1 : 1) * (1 / 0);
    s = s + Math.pow(2, n), a = a - l;
  }
  return (v ? -1 : 1) * s * Math.pow(2, a - n);
};
is.write = function(e, t, r, n, o, a) {
  var s, i, h, l = a * 8 - o - 1, c = (1 << l) - 1, w = c >> 1, g = o === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, v = n ? 0 : a - 1, k = n ? 1 : -1, y = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (i = isNaN(t) ? 1 : 0, s = c) : (s = Math.floor(Math.log(t) / Math.LN2), t * (h = Math.pow(2, -s)) < 1 && (s--, h *= 2), s + w >= 1 ? t += g / h : t += g * Math.pow(2, 1 - w), t * h >= 2 && (s++, h /= 2), s + w >= c ? (i = 0, s = c) : s + w >= 1 ? (i = (t * h - 1) * Math.pow(2, o), s = s + w) : (i = t * Math.pow(2, w - 1) * Math.pow(2, o), s = 0)); o >= 8; e[r + v] = i & 255, v += k, i /= 256, o -= 8)
    ;
  for (s = s << o | i, l += o; l > 0; e[r + v] = s & 255, v += k, s /= 256, l -= 8)
    ;
  e[r + v - k] |= y * 128;
};
(function(e) {
  const t = xa, r = is, n = typeof Symbol == "function" && typeof Symbol.for == "function" ? /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = c, e.SlowBuffer = F, e.INSPECT_MAX_BYTES = 50;
  const o = 2147483647;
  e.kMaxLength = o;
  const { Uint8Array: a, ArrayBuffer: s, SharedArrayBuffer: i } = globalThis;
  c.TYPED_ARRAY_SUPPORT = h(), !c.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function h() {
    try {
      const b = new a(1), u = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(u, a.prototype), Object.setPrototypeOf(b, u), b.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(c.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (c.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(c.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (c.isBuffer(this))
        return this.byteOffset;
    }
  });
  function l(b) {
    if (b > o)
      throw new RangeError('The value "' + b + '" is invalid for option "size"');
    const u = new a(b);
    return Object.setPrototypeOf(u, c.prototype), u;
  }
  function c(b, u, d) {
    if (typeof b == "number") {
      if (typeof u == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return k(b);
    }
    return w(b, u, d);
  }
  c.poolSize = 8192;
  function w(b, u, d) {
    if (typeof b == "string")
      return y(b, u);
    if (s.isView(b))
      return A(b);
    if (b == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof b
      );
    if (Be(b, s) || b && Be(b.buffer, s) || typeof i < "u" && (Be(b, i) || b && Be(b.buffer, i)))
      return E(b, u, d);
    if (typeof b == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const S = b.valueOf && b.valueOf();
    if (S != null && S !== b)
      return c.from(S, u, d);
    const P = x(b);
    if (P) return P;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof b[Symbol.toPrimitive] == "function")
      return c.from(b[Symbol.toPrimitive]("string"), u, d);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof b
    );
  }
  c.from = function(b, u, d) {
    return w(b, u, d);
  }, Object.setPrototypeOf(c.prototype, a.prototype), Object.setPrototypeOf(c, a);
  function g(b) {
    if (typeof b != "number")
      throw new TypeError('"size" argument must be of type number');
    if (b < 0)
      throw new RangeError('The value "' + b + '" is invalid for option "size"');
  }
  function v(b, u, d) {
    return g(b), b <= 0 ? l(b) : u !== void 0 ? typeof d == "string" ? l(b).fill(u, d) : l(b).fill(u) : l(b);
  }
  c.alloc = function(b, u, d) {
    return v(b, u, d);
  };
  function k(b) {
    return g(b), l(b < 0 ? 0 : z(b) | 0);
  }
  c.allocUnsafe = function(b) {
    return k(b);
  }, c.allocUnsafeSlow = function(b) {
    return k(b);
  };
  function y(b, u) {
    if ((typeof u != "string" || u === "") && (u = "utf8"), !c.isEncoding(u))
      throw new TypeError("Unknown encoding: " + u);
    const d = j(b, u) | 0;
    let S = l(d);
    const P = S.write(b, u);
    return P !== d && (S = S.slice(0, P)), S;
  }
  function m(b) {
    const u = b.length < 0 ? 0 : z(b.length) | 0, d = l(u);
    for (let S = 0; S < u; S += 1)
      d[S] = b[S] & 255;
    return d;
  }
  function A(b) {
    if (Be(b, a)) {
      const u = new a(b);
      return E(u.buffer, u.byteOffset, u.byteLength);
    }
    return m(b);
  }
  function E(b, u, d) {
    if (u < 0 || b.byteLength < u)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (b.byteLength < u + (d || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let S;
    return u === void 0 && d === void 0 ? S = new a(b) : d === void 0 ? S = new a(b, u) : S = new a(b, u, d), Object.setPrototypeOf(S, c.prototype), S;
  }
  function x(b) {
    if (c.isBuffer(b)) {
      const u = z(b.length) | 0, d = l(u);
      return d.length === 0 || b.copy(d, 0, 0, u), d;
    }
    if (b.length !== void 0)
      return typeof b.length != "number" || Ye(b.length) ? l(0) : m(b);
    if (b.type === "Buffer" && Array.isArray(b.data))
      return m(b.data);
  }
  function z(b) {
    if (b >= o)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + o.toString(16) + " bytes");
    return b | 0;
  }
  function F(b) {
    return +b != b && (b = 0), c.alloc(+b);
  }
  c.isBuffer = function(u) {
    return u != null && u._isBuffer === !0 && u !== c.prototype;
  }, c.compare = function(u, d) {
    if (Be(u, a) && (u = c.from(u, u.offset, u.byteLength)), Be(d, a) && (d = c.from(d, d.offset, d.byteLength)), !c.isBuffer(u) || !c.isBuffer(d))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (u === d) return 0;
    let S = u.length, P = d.length;
    for (let D = 0, W = Math.min(S, P); D < W; ++D)
      if (u[D] !== d[D]) {
        S = u[D], P = d[D];
        break;
      }
    return S < P ? -1 : P < S ? 1 : 0;
  }, c.isEncoding = function(u) {
    switch (String(u).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, c.concat = function(u, d) {
    if (!Array.isArray(u))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (u.length === 0)
      return c.alloc(0);
    let S;
    if (d === void 0)
      for (d = 0, S = 0; S < u.length; ++S)
        d += u[S].length;
    const P = c.allocUnsafe(d);
    let D = 0;
    for (S = 0; S < u.length; ++S) {
      let W = u[S];
      if (Be(W, a))
        D + W.length > P.length ? (c.isBuffer(W) || (W = c.from(W)), W.copy(P, D)) : a.prototype.set.call(
          P,
          W,
          D
        );
      else if (c.isBuffer(W))
        W.copy(P, D);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      D += W.length;
    }
    return P;
  };
  function j(b, u) {
    if (c.isBuffer(b))
      return b.length;
    if (s.isView(b) || Be(b, s))
      return b.byteLength;
    if (typeof b != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof b
      );
    const d = b.length, S = arguments.length > 2 && arguments[2] === !0;
    if (!S && d === 0) return 0;
    let P = !1;
    for (; ; )
      switch (u) {
        case "ascii":
        case "latin1":
        case "binary":
          return d;
        case "utf8":
        case "utf-8":
          return Re(b).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return d * 2;
        case "hex":
          return d >>> 1;
        case "base64":
          return ge(b).length;
        default:
          if (P)
            return S ? -1 : Re(b).length;
          u = ("" + u).toLowerCase(), P = !0;
      }
  }
  c.byteLength = j;
  function I(b, u, d) {
    let S = !1;
    if ((u === void 0 || u < 0) && (u = 0), u > this.length || ((d === void 0 || d > this.length) && (d = this.length), d <= 0) || (d >>>= 0, u >>>= 0, d <= u))
      return "";
    for (b || (b = "utf8"); ; )
      switch (b) {
        case "hex":
          return q(this, u, d);
        case "utf8":
        case "utf-8":
          return ie(this, u, d);
        case "ascii":
          return Se(this, u, d);
        case "latin1":
        case "binary":
          return De(this, u, d);
        case "base64":
          return ue(this, u, d);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return H(this, u, d);
        default:
          if (S) throw new TypeError("Unknown encoding: " + b);
          b = (b + "").toLowerCase(), S = !0;
      }
  }
  c.prototype._isBuffer = !0;
  function N(b, u, d) {
    const S = b[u];
    b[u] = b[d], b[d] = S;
  }
  c.prototype.swap16 = function() {
    const u = this.length;
    if (u % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let d = 0; d < u; d += 2)
      N(this, d, d + 1);
    return this;
  }, c.prototype.swap32 = function() {
    const u = this.length;
    if (u % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let d = 0; d < u; d += 4)
      N(this, d, d + 3), N(this, d + 1, d + 2);
    return this;
  }, c.prototype.swap64 = function() {
    const u = this.length;
    if (u % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let d = 0; d < u; d += 8)
      N(this, d, d + 7), N(this, d + 1, d + 6), N(this, d + 2, d + 5), N(this, d + 3, d + 4);
    return this;
  }, c.prototype.toString = function() {
    const u = this.length;
    return u === 0 ? "" : arguments.length === 0 ? ie(this, 0, u) : I.apply(this, arguments);
  }, c.prototype.toLocaleString = c.prototype.toString, c.prototype.equals = function(u) {
    if (!c.isBuffer(u)) throw new TypeError("Argument must be a Buffer");
    return this === u ? !0 : c.compare(this, u) === 0;
  }, c.prototype.inspect = function() {
    let u = "";
    const d = e.INSPECT_MAX_BYTES;
    return u = this.toString("hex", 0, d).replace(/(.{2})/g, "$1 ").trim(), this.length > d && (u += " ... "), "<Buffer " + u + ">";
  }, n && (c.prototype[n] = c.prototype.inspect), c.prototype.compare = function(u, d, S, P, D) {
    if (Be(u, a) && (u = c.from(u, u.offset, u.byteLength)), !c.isBuffer(u))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof u
      );
    if (d === void 0 && (d = 0), S === void 0 && (S = u ? u.length : 0), P === void 0 && (P = 0), D === void 0 && (D = this.length), d < 0 || S > u.length || P < 0 || D > this.length)
      throw new RangeError("out of range index");
    if (P >= D && d >= S)
      return 0;
    if (P >= D)
      return -1;
    if (d >= S)
      return 1;
    if (d >>>= 0, S >>>= 0, P >>>= 0, D >>>= 0, this === u) return 0;
    let W = D - P, be = S - d;
    const Te = Math.min(W, be), ze = this.slice(P, D), Pe = u.slice(d, S);
    for (let Ae = 0; Ae < Te; ++Ae)
      if (ze[Ae] !== Pe[Ae]) {
        W = ze[Ae], be = Pe[Ae];
        break;
      }
    return W < be ? -1 : be < W ? 1 : 0;
  };
  function O(b, u, d, S, P) {
    if (b.length === 0) return -1;
    if (typeof d == "string" ? (S = d, d = 0) : d > 2147483647 ? d = 2147483647 : d < -2147483648 && (d = -2147483648), d = +d, Ye(d) && (d = P ? 0 : b.length - 1), d < 0 && (d = b.length + d), d >= b.length) {
      if (P) return -1;
      d = b.length - 1;
    } else if (d < 0)
      if (P) d = 0;
      else return -1;
    if (typeof u == "string" && (u = c.from(u, S)), c.isBuffer(u))
      return u.length === 0 ? -1 : R(b, u, d, S, P);
    if (typeof u == "number")
      return u = u & 255, typeof a.prototype.indexOf == "function" ? P ? a.prototype.indexOf.call(b, u, d) : a.prototype.lastIndexOf.call(b, u, d) : R(b, [u], d, S, P);
    throw new TypeError("val must be string, number or Buffer");
  }
  function R(b, u, d, S, P) {
    let D = 1, W = b.length, be = u.length;
    if (S !== void 0 && (S = String(S).toLowerCase(), S === "ucs2" || S === "ucs-2" || S === "utf16le" || S === "utf-16le")) {
      if (b.length < 2 || u.length < 2)
        return -1;
      D = 2, W /= 2, be /= 2, d /= 2;
    }
    function Te(Pe, Ae) {
      return D === 1 ? Pe[Ae] : Pe.readUInt16BE(Ae * D);
    }
    let ze;
    if (P) {
      let Pe = -1;
      for (ze = d; ze < W; ze++)
        if (Te(b, ze) === Te(u, Pe === -1 ? 0 : ze - Pe)) {
          if (Pe === -1 && (Pe = ze), ze - Pe + 1 === be) return Pe * D;
        } else
          Pe !== -1 && (ze -= ze - Pe), Pe = -1;
    } else
      for (d + be > W && (d = W - be), ze = d; ze >= 0; ze--) {
        let Pe = !0;
        for (let Ae = 0; Ae < be; Ae++)
          if (Te(b, ze + Ae) !== Te(u, Ae)) {
            Pe = !1;
            break;
          }
        if (Pe) return ze;
      }
    return -1;
  }
  c.prototype.includes = function(u, d, S) {
    return this.indexOf(u, d, S) !== -1;
  }, c.prototype.indexOf = function(u, d, S) {
    return O(this, u, d, S, !0);
  }, c.prototype.lastIndexOf = function(u, d, S) {
    return O(this, u, d, S, !1);
  };
  function U(b, u, d, S) {
    d = Number(d) || 0;
    const P = b.length - d;
    S ? (S = Number(S), S > P && (S = P)) : S = P;
    const D = u.length;
    S > D / 2 && (S = D / 2);
    let W;
    for (W = 0; W < S; ++W) {
      const be = parseInt(u.substr(W * 2, 2), 16);
      if (Ye(be)) return W;
      b[d + W] = be;
    }
    return W;
  }
  function T(b, u, d, S) {
    return xe(Re(u, b.length - d), b, d, S);
  }
  function Z(b, u, d, S) {
    return xe(ae(u), b, d, S);
  }
  function re(b, u, d, S) {
    return xe(ge(u), b, d, S);
  }
  function oe(b, u, d, S) {
    return xe(fe(u, b.length - d), b, d, S);
  }
  c.prototype.write = function(u, d, S, P) {
    if (d === void 0)
      P = "utf8", S = this.length, d = 0;
    else if (S === void 0 && typeof d == "string")
      P = d, S = this.length, d = 0;
    else if (isFinite(d))
      d = d >>> 0, isFinite(S) ? (S = S >>> 0, P === void 0 && (P = "utf8")) : (P = S, S = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const D = this.length - d;
    if ((S === void 0 || S > D) && (S = D), u.length > 0 && (S < 0 || d < 0) || d > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    P || (P = "utf8");
    let W = !1;
    for (; ; )
      switch (P) {
        case "hex":
          return U(this, u, d, S);
        case "utf8":
        case "utf-8":
          return T(this, u, d, S);
        case "ascii":
        case "latin1":
        case "binary":
          return Z(this, u, d, S);
        case "base64":
          return re(this, u, d, S);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return oe(this, u, d, S);
        default:
          if (W) throw new TypeError("Unknown encoding: " + P);
          P = ("" + P).toLowerCase(), W = !0;
      }
  }, c.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function ue(b, u, d) {
    return u === 0 && d === b.length ? t.fromByteArray(b) : t.fromByteArray(b.slice(u, d));
  }
  function ie(b, u, d) {
    d = Math.min(b.length, d);
    const S = [];
    let P = u;
    for (; P < d; ) {
      const D = b[P];
      let W = null, be = D > 239 ? 4 : D > 223 ? 3 : D > 191 ? 2 : 1;
      if (P + be <= d) {
        let Te, ze, Pe, Ae;
        switch (be) {
          case 1:
            D < 128 && (W = D);
            break;
          case 2:
            Te = b[P + 1], (Te & 192) === 128 && (Ae = (D & 31) << 6 | Te & 63, Ae > 127 && (W = Ae));
            break;
          case 3:
            Te = b[P + 1], ze = b[P + 2], (Te & 192) === 128 && (ze & 192) === 128 && (Ae = (D & 15) << 12 | (Te & 63) << 6 | ze & 63, Ae > 2047 && (Ae < 55296 || Ae > 57343) && (W = Ae));
            break;
          case 4:
            Te = b[P + 1], ze = b[P + 2], Pe = b[P + 3], (Te & 192) === 128 && (ze & 192) === 128 && (Pe & 192) === 128 && (Ae = (D & 15) << 18 | (Te & 63) << 12 | (ze & 63) << 6 | Pe & 63, Ae > 65535 && Ae < 1114112 && (W = Ae));
        }
      }
      W === null ? (W = 65533, be = 1) : W > 65535 && (W -= 65536, S.push(W >>> 10 & 1023 | 55296), W = 56320 | W & 1023), S.push(W), P += be;
    }
    return me(S);
  }
  const de = 4096;
  function me(b) {
    const u = b.length;
    if (u <= de)
      return String.fromCharCode.apply(String, b);
    let d = "", S = 0;
    for (; S < u; )
      d += String.fromCharCode.apply(
        String,
        b.slice(S, S += de)
      );
    return d;
  }
  function Se(b, u, d) {
    let S = "";
    d = Math.min(b.length, d);
    for (let P = u; P < d; ++P)
      S += String.fromCharCode(b[P] & 127);
    return S;
  }
  function De(b, u, d) {
    let S = "";
    d = Math.min(b.length, d);
    for (let P = u; P < d; ++P)
      S += String.fromCharCode(b[P]);
    return S;
  }
  function q(b, u, d) {
    const S = b.length;
    (!u || u < 0) && (u = 0), (!d || d < 0 || d > S) && (d = S);
    let P = "";
    for (let D = u; D < d; ++D)
      P += fr[b[D]];
    return P;
  }
  function H(b, u, d) {
    const S = b.slice(u, d);
    let P = "";
    for (let D = 0; D < S.length - 1; D += 2)
      P += String.fromCharCode(S[D] + S[D + 1] * 256);
    return P;
  }
  c.prototype.slice = function(u, d) {
    const S = this.length;
    u = ~~u, d = d === void 0 ? S : ~~d, u < 0 ? (u += S, u < 0 && (u = 0)) : u > S && (u = S), d < 0 ? (d += S, d < 0 && (d = 0)) : d > S && (d = S), d < u && (d = u);
    const P = this.subarray(u, d);
    return Object.setPrototypeOf(P, c.prototype), P;
  };
  function C(b, u, d) {
    if (b % 1 !== 0 || b < 0) throw new RangeError("offset is not uint");
    if (b + u > d) throw new RangeError("Trying to access beyond buffer length");
  }
  c.prototype.readUintLE = c.prototype.readUIntLE = function(u, d, S) {
    u = u >>> 0, d = d >>> 0, S || C(u, d, this.length);
    let P = this[u], D = 1, W = 0;
    for (; ++W < d && (D *= 256); )
      P += this[u + W] * D;
    return P;
  }, c.prototype.readUintBE = c.prototype.readUIntBE = function(u, d, S) {
    u = u >>> 0, d = d >>> 0, S || C(u, d, this.length);
    let P = this[u + --d], D = 1;
    for (; d > 0 && (D *= 256); )
      P += this[u + --d] * D;
    return P;
  }, c.prototype.readUint8 = c.prototype.readUInt8 = function(u, d) {
    return u = u >>> 0, d || C(u, 1, this.length), this[u];
  }, c.prototype.readUint16LE = c.prototype.readUInt16LE = function(u, d) {
    return u = u >>> 0, d || C(u, 2, this.length), this[u] | this[u + 1] << 8;
  }, c.prototype.readUint16BE = c.prototype.readUInt16BE = function(u, d) {
    return u = u >>> 0, d || C(u, 2, this.length), this[u] << 8 | this[u + 1];
  }, c.prototype.readUint32LE = c.prototype.readUInt32LE = function(u, d) {
    return u = u >>> 0, d || C(u, 4, this.length), (this[u] | this[u + 1] << 8 | this[u + 2] << 16) + this[u + 3] * 16777216;
  }, c.prototype.readUint32BE = c.prototype.readUInt32BE = function(u, d) {
    return u = u >>> 0, d || C(u, 4, this.length), this[u] * 16777216 + (this[u + 1] << 16 | this[u + 2] << 8 | this[u + 3]);
  }, c.prototype.readBigUInt64LE = M(function(u) {
    u = u >>> 0, pe(u, "offset");
    const d = this[u], S = this[u + 7];
    (d === void 0 || S === void 0) && we(u, this.length - 8);
    const P = d + this[++u] * 2 ** 8 + this[++u] * 2 ** 16 + this[++u] * 2 ** 24, D = this[++u] + this[++u] * 2 ** 8 + this[++u] * 2 ** 16 + S * 2 ** 24;
    return BigInt(P) + (BigInt(D) << BigInt(32));
  }), c.prototype.readBigUInt64BE = M(function(u) {
    u = u >>> 0, pe(u, "offset");
    const d = this[u], S = this[u + 7];
    (d === void 0 || S === void 0) && we(u, this.length - 8);
    const P = d * 2 ** 24 + this[++u] * 2 ** 16 + this[++u] * 2 ** 8 + this[++u], D = this[++u] * 2 ** 24 + this[++u] * 2 ** 16 + this[++u] * 2 ** 8 + S;
    return (BigInt(P) << BigInt(32)) + BigInt(D);
  }), c.prototype.readIntLE = function(u, d, S) {
    u = u >>> 0, d = d >>> 0, S || C(u, d, this.length);
    let P = this[u], D = 1, W = 0;
    for (; ++W < d && (D *= 256); )
      P += this[u + W] * D;
    return D *= 128, P >= D && (P -= Math.pow(2, 8 * d)), P;
  }, c.prototype.readIntBE = function(u, d, S) {
    u = u >>> 0, d = d >>> 0, S || C(u, d, this.length);
    let P = d, D = 1, W = this[u + --P];
    for (; P > 0 && (D *= 256); )
      W += this[u + --P] * D;
    return D *= 128, W >= D && (W -= Math.pow(2, 8 * d)), W;
  }, c.prototype.readInt8 = function(u, d) {
    return u = u >>> 0, d || C(u, 1, this.length), this[u] & 128 ? (255 - this[u] + 1) * -1 : this[u];
  }, c.prototype.readInt16LE = function(u, d) {
    u = u >>> 0, d || C(u, 2, this.length);
    const S = this[u] | this[u + 1] << 8;
    return S & 32768 ? S | 4294901760 : S;
  }, c.prototype.readInt16BE = function(u, d) {
    u = u >>> 0, d || C(u, 2, this.length);
    const S = this[u + 1] | this[u] << 8;
    return S & 32768 ? S | 4294901760 : S;
  }, c.prototype.readInt32LE = function(u, d) {
    return u = u >>> 0, d || C(u, 4, this.length), this[u] | this[u + 1] << 8 | this[u + 2] << 16 | this[u + 3] << 24;
  }, c.prototype.readInt32BE = function(u, d) {
    return u = u >>> 0, d || C(u, 4, this.length), this[u] << 24 | this[u + 1] << 16 | this[u + 2] << 8 | this[u + 3];
  }, c.prototype.readBigInt64LE = M(function(u) {
    u = u >>> 0, pe(u, "offset");
    const d = this[u], S = this[u + 7];
    (d === void 0 || S === void 0) && we(u, this.length - 8);
    const P = this[u + 4] + this[u + 5] * 2 ** 8 + this[u + 6] * 2 ** 16 + (S << 24);
    return (BigInt(P) << BigInt(32)) + BigInt(d + this[++u] * 2 ** 8 + this[++u] * 2 ** 16 + this[++u] * 2 ** 24);
  }), c.prototype.readBigInt64BE = M(function(u) {
    u = u >>> 0, pe(u, "offset");
    const d = this[u], S = this[u + 7];
    (d === void 0 || S === void 0) && we(u, this.length - 8);
    const P = (d << 24) + // Overflow
    this[++u] * 2 ** 16 + this[++u] * 2 ** 8 + this[++u];
    return (BigInt(P) << BigInt(32)) + BigInt(this[++u] * 2 ** 24 + this[++u] * 2 ** 16 + this[++u] * 2 ** 8 + S);
  }), c.prototype.readFloatLE = function(u, d) {
    return u = u >>> 0, d || C(u, 4, this.length), r.read(this, u, !0, 23, 4);
  }, c.prototype.readFloatBE = function(u, d) {
    return u = u >>> 0, d || C(u, 4, this.length), r.read(this, u, !1, 23, 4);
  }, c.prototype.readDoubleLE = function(u, d) {
    return u = u >>> 0, d || C(u, 8, this.length), r.read(this, u, !0, 52, 8);
  }, c.prototype.readDoubleBE = function(u, d) {
    return u = u >>> 0, d || C(u, 8, this.length), r.read(this, u, !1, 52, 8);
  };
  function G(b, u, d, S, P, D) {
    if (!c.isBuffer(b)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (u > P || u < D) throw new RangeError('"value" argument is out of bounds');
    if (d + S > b.length) throw new RangeError("Index out of range");
  }
  c.prototype.writeUintLE = c.prototype.writeUIntLE = function(u, d, S, P) {
    if (u = +u, d = d >>> 0, S = S >>> 0, !P) {
      const be = Math.pow(2, 8 * S) - 1;
      G(this, u, d, S, be, 0);
    }
    let D = 1, W = 0;
    for (this[d] = u & 255; ++W < S && (D *= 256); )
      this[d + W] = u / D & 255;
    return d + S;
  }, c.prototype.writeUintBE = c.prototype.writeUIntBE = function(u, d, S, P) {
    if (u = +u, d = d >>> 0, S = S >>> 0, !P) {
      const be = Math.pow(2, 8 * S) - 1;
      G(this, u, d, S, be, 0);
    }
    let D = S - 1, W = 1;
    for (this[d + D] = u & 255; --D >= 0 && (W *= 256); )
      this[d + D] = u / W & 255;
    return d + S;
  }, c.prototype.writeUint8 = c.prototype.writeUInt8 = function(u, d, S) {
    return u = +u, d = d >>> 0, S || G(this, u, d, 1, 255, 0), this[d] = u & 255, d + 1;
  }, c.prototype.writeUint16LE = c.prototype.writeUInt16LE = function(u, d, S) {
    return u = +u, d = d >>> 0, S || G(this, u, d, 2, 65535, 0), this[d] = u & 255, this[d + 1] = u >>> 8, d + 2;
  }, c.prototype.writeUint16BE = c.prototype.writeUInt16BE = function(u, d, S) {
    return u = +u, d = d >>> 0, S || G(this, u, d, 2, 65535, 0), this[d] = u >>> 8, this[d + 1] = u & 255, d + 2;
  }, c.prototype.writeUint32LE = c.prototype.writeUInt32LE = function(u, d, S) {
    return u = +u, d = d >>> 0, S || G(this, u, d, 4, 4294967295, 0), this[d + 3] = u >>> 24, this[d + 2] = u >>> 16, this[d + 1] = u >>> 8, this[d] = u & 255, d + 4;
  }, c.prototype.writeUint32BE = c.prototype.writeUInt32BE = function(u, d, S) {
    return u = +u, d = d >>> 0, S || G(this, u, d, 4, 4294967295, 0), this[d] = u >>> 24, this[d + 1] = u >>> 16, this[d + 2] = u >>> 8, this[d + 3] = u & 255, d + 4;
  };
  function V(b, u, d, S, P) {
    ye(u, S, P, b, d, 7);
    let D = Number(u & BigInt(4294967295));
    b[d++] = D, D = D >> 8, b[d++] = D, D = D >> 8, b[d++] = D, D = D >> 8, b[d++] = D;
    let W = Number(u >> BigInt(32) & BigInt(4294967295));
    return b[d++] = W, W = W >> 8, b[d++] = W, W = W >> 8, b[d++] = W, W = W >> 8, b[d++] = W, d;
  }
  function X(b, u, d, S, P) {
    ye(u, S, P, b, d, 7);
    let D = Number(u & BigInt(4294967295));
    b[d + 7] = D, D = D >> 8, b[d + 6] = D, D = D >> 8, b[d + 5] = D, D = D >> 8, b[d + 4] = D;
    let W = Number(u >> BigInt(32) & BigInt(4294967295));
    return b[d + 3] = W, W = W >> 8, b[d + 2] = W, W = W >> 8, b[d + 1] = W, W = W >> 8, b[d] = W, d + 8;
  }
  c.prototype.writeBigUInt64LE = M(function(u, d = 0) {
    return V(this, u, d, BigInt(0), BigInt("0xffffffffffffffff"));
  }), c.prototype.writeBigUInt64BE = M(function(u, d = 0) {
    return X(this, u, d, BigInt(0), BigInt("0xffffffffffffffff"));
  }), c.prototype.writeIntLE = function(u, d, S, P) {
    if (u = +u, d = d >>> 0, !P) {
      const Te = Math.pow(2, 8 * S - 1);
      G(this, u, d, S, Te - 1, -Te);
    }
    let D = 0, W = 1, be = 0;
    for (this[d] = u & 255; ++D < S && (W *= 256); )
      u < 0 && be === 0 && this[d + D - 1] !== 0 && (be = 1), this[d + D] = (u / W >> 0) - be & 255;
    return d + S;
  }, c.prototype.writeIntBE = function(u, d, S, P) {
    if (u = +u, d = d >>> 0, !P) {
      const Te = Math.pow(2, 8 * S - 1);
      G(this, u, d, S, Te - 1, -Te);
    }
    let D = S - 1, W = 1, be = 0;
    for (this[d + D] = u & 255; --D >= 0 && (W *= 256); )
      u < 0 && be === 0 && this[d + D + 1] !== 0 && (be = 1), this[d + D] = (u / W >> 0) - be & 255;
    return d + S;
  }, c.prototype.writeInt8 = function(u, d, S) {
    return u = +u, d = d >>> 0, S || G(this, u, d, 1, 127, -128), u < 0 && (u = 255 + u + 1), this[d] = u & 255, d + 1;
  }, c.prototype.writeInt16LE = function(u, d, S) {
    return u = +u, d = d >>> 0, S || G(this, u, d, 2, 32767, -32768), this[d] = u & 255, this[d + 1] = u >>> 8, d + 2;
  }, c.prototype.writeInt16BE = function(u, d, S) {
    return u = +u, d = d >>> 0, S || G(this, u, d, 2, 32767, -32768), this[d] = u >>> 8, this[d + 1] = u & 255, d + 2;
  }, c.prototype.writeInt32LE = function(u, d, S) {
    return u = +u, d = d >>> 0, S || G(this, u, d, 4, 2147483647, -2147483648), this[d] = u & 255, this[d + 1] = u >>> 8, this[d + 2] = u >>> 16, this[d + 3] = u >>> 24, d + 4;
  }, c.prototype.writeInt32BE = function(u, d, S) {
    return u = +u, d = d >>> 0, S || G(this, u, d, 4, 2147483647, -2147483648), u < 0 && (u = 4294967295 + u + 1), this[d] = u >>> 24, this[d + 1] = u >>> 16, this[d + 2] = u >>> 8, this[d + 3] = u & 255, d + 4;
  }, c.prototype.writeBigInt64LE = M(function(u, d = 0) {
    return V(this, u, d, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), c.prototype.writeBigInt64BE = M(function(u, d = 0) {
    return X(this, u, d, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Q(b, u, d, S, P, D) {
    if (d + S > b.length) throw new RangeError("Index out of range");
    if (d < 0) throw new RangeError("Index out of range");
  }
  function ee(b, u, d, S, P) {
    return u = +u, d = d >>> 0, P || Q(b, u, d, 4), r.write(b, u, d, S, 23, 4), d + 4;
  }
  c.prototype.writeFloatLE = function(u, d, S) {
    return ee(this, u, d, !0, S);
  }, c.prototype.writeFloatBE = function(u, d, S) {
    return ee(this, u, d, !1, S);
  };
  function ne(b, u, d, S, P) {
    return u = +u, d = d >>> 0, P || Q(b, u, d, 8), r.write(b, u, d, S, 52, 8), d + 8;
  }
  c.prototype.writeDoubleLE = function(u, d, S) {
    return ne(this, u, d, !0, S);
  }, c.prototype.writeDoubleBE = function(u, d, S) {
    return ne(this, u, d, !1, S);
  }, c.prototype.copy = function(u, d, S, P) {
    if (!c.isBuffer(u)) throw new TypeError("argument should be a Buffer");
    if (S || (S = 0), !P && P !== 0 && (P = this.length), d >= u.length && (d = u.length), d || (d = 0), P > 0 && P < S && (P = S), P === S || u.length === 0 || this.length === 0) return 0;
    if (d < 0)
      throw new RangeError("targetStart out of bounds");
    if (S < 0 || S >= this.length) throw new RangeError("Index out of range");
    if (P < 0) throw new RangeError("sourceEnd out of bounds");
    P > this.length && (P = this.length), u.length - d < P - S && (P = u.length - d + S);
    const D = P - S;
    return this === u && typeof a.prototype.copyWithin == "function" ? this.copyWithin(d, S, P) : a.prototype.set.call(
      u,
      this.subarray(S, P),
      d
    ), D;
  }, c.prototype.fill = function(u, d, S, P) {
    if (typeof u == "string") {
      if (typeof d == "string" ? (P = d, d = 0, S = this.length) : typeof S == "string" && (P = S, S = this.length), P !== void 0 && typeof P != "string")
        throw new TypeError("encoding must be a string");
      if (typeof P == "string" && !c.isEncoding(P))
        throw new TypeError("Unknown encoding: " + P);
      if (u.length === 1) {
        const W = u.charCodeAt(0);
        (P === "utf8" && W < 128 || P === "latin1") && (u = W);
      }
    } else typeof u == "number" ? u = u & 255 : typeof u == "boolean" && (u = Number(u));
    if (d < 0 || this.length < d || this.length < S)
      throw new RangeError("Out of range index");
    if (S <= d)
      return this;
    d = d >>> 0, S = S === void 0 ? this.length : S >>> 0, u || (u = 0);
    let D;
    if (typeof u == "number")
      for (D = d; D < S; ++D)
        this[D] = u;
    else {
      const W = c.isBuffer(u) ? u : c.from(u, P), be = W.length;
      if (be === 0)
        throw new TypeError('The value "' + u + '" is invalid for argument "value"');
      for (D = 0; D < S - d; ++D)
        this[D + d] = W[D % be];
    }
    return this;
  };
  const se = {};
  function ce(b, u, d) {
    se[b] = class extends d {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: u.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${b}]`, this.stack, delete this.name;
      }
      get code() {
        return b;
      }
      set code(P) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: P,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${b}]: ${this.message}`;
      }
    };
  }
  ce(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(b) {
      return b ? `${b} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), ce(
    "ERR_INVALID_ARG_TYPE",
    function(b, u) {
      return `The "${b}" argument must be of type number. Received type ${typeof u}`;
    },
    TypeError
  ), ce(
    "ERR_OUT_OF_RANGE",
    function(b, u, d) {
      let S = `The value of "${b}" is out of range.`, P = d;
      return Number.isInteger(d) && Math.abs(d) > 2 ** 32 ? P = le(String(d)) : typeof d == "bigint" && (P = String(d), (d > BigInt(2) ** BigInt(32) || d < -(BigInt(2) ** BigInt(32))) && (P = le(P)), P += "n"), S += ` It must be ${u}. Received ${P}`, S;
    },
    RangeError
  );
  function le(b) {
    let u = "", d = b.length;
    const S = b[0] === "-" ? 1 : 0;
    for (; d >= S + 4; d -= 3)
      u = `_${b.slice(d - 3, d)}${u}`;
    return `${b.slice(0, d)}${u}`;
  }
  function he(b, u, d) {
    pe(u, "offset"), (b[u] === void 0 || b[u + d] === void 0) && we(u, b.length - (d + 1));
  }
  function ye(b, u, d, S, P, D) {
    if (b > d || b < u) {
      const W = typeof u == "bigint" ? "n" : "";
      let be;
      throw u === 0 || u === BigInt(0) ? be = `>= 0${W} and < 2${W} ** ${(D + 1) * 8}${W}` : be = `>= -(2${W} ** ${(D + 1) * 8 - 1}${W}) and < 2 ** ${(D + 1) * 8 - 1}${W}`, new se.ERR_OUT_OF_RANGE("value", be, b);
    }
    he(S, P, D);
  }
  function pe(b, u) {
    if (typeof b != "number")
      throw new se.ERR_INVALID_ARG_TYPE(u, "number", b);
  }
  function we(b, u, d) {
    throw Math.floor(b) !== b ? (pe(b, d), new se.ERR_OUT_OF_RANGE("offset", "an integer", b)) : u < 0 ? new se.ERR_BUFFER_OUT_OF_BOUNDS() : new se.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${u}`,
      b
    );
  }
  const Oe = /[^+/0-9A-Za-z-_]/g;
  function $(b) {
    if (b = b.split("=")[0], b = b.trim().replace(Oe, ""), b.length < 2) return "";
    for (; b.length % 4 !== 0; )
      b = b + "=";
    return b;
  }
  function Re(b, u) {
    u = u || 1 / 0;
    let d;
    const S = b.length;
    let P = null;
    const D = [];
    for (let W = 0; W < S; ++W) {
      if (d = b.charCodeAt(W), d > 55295 && d < 57344) {
        if (!P) {
          if (d > 56319) {
            (u -= 3) > -1 && D.push(239, 191, 189);
            continue;
          } else if (W + 1 === S) {
            (u -= 3) > -1 && D.push(239, 191, 189);
            continue;
          }
          P = d;
          continue;
        }
        if (d < 56320) {
          (u -= 3) > -1 && D.push(239, 191, 189), P = d;
          continue;
        }
        d = (P - 55296 << 10 | d - 56320) + 65536;
      } else P && (u -= 3) > -1 && D.push(239, 191, 189);
      if (P = null, d < 128) {
        if ((u -= 1) < 0) break;
        D.push(d);
      } else if (d < 2048) {
        if ((u -= 2) < 0) break;
        D.push(
          d >> 6 | 192,
          d & 63 | 128
        );
      } else if (d < 65536) {
        if ((u -= 3) < 0) break;
        D.push(
          d >> 12 | 224,
          d >> 6 & 63 | 128,
          d & 63 | 128
        );
      } else if (d < 1114112) {
        if ((u -= 4) < 0) break;
        D.push(
          d >> 18 | 240,
          d >> 12 & 63 | 128,
          d >> 6 & 63 | 128,
          d & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return D;
  }
  function ae(b) {
    const u = [];
    for (let d = 0; d < b.length; ++d)
      u.push(b.charCodeAt(d) & 255);
    return u;
  }
  function fe(b, u) {
    let d, S, P;
    const D = [];
    for (let W = 0; W < b.length && !((u -= 2) < 0); ++W)
      d = b.charCodeAt(W), S = d >> 8, P = d % 256, D.push(P), D.push(S);
    return D;
  }
  function ge(b) {
    return t.toByteArray($(b));
  }
  function xe(b, u, d, S) {
    let P;
    for (P = 0; P < S && !(P + d >= u.length || P >= b.length); ++P)
      u[P + d] = b[P];
    return P;
  }
  function Be(b, u) {
    return b instanceof u || b != null && b.constructor != null && b.constructor.name != null && b.constructor.name === u.name;
  }
  function Ye(b) {
    return b !== b;
  }
  const fr = (function() {
    const b = "0123456789abcdef", u = new Array(256);
    for (let d = 0; d < 16; ++d) {
      const S = d * 16;
      for (let P = 0; P < 16; ++P)
        u[S + P] = b[d] + b[P];
    }
    return u;
  })();
  function M(b) {
    return typeof BigInt > "u" ? te : b;
  }
  function te() {
    throw new Error("BigInt not supported");
  }
})(os);
const J = os.Buffer, iv = os.Buffer;
const Ah = 4, Ps = 0, Us = 1, Sh = 2;
function Dt(e) {
  let t = e.length;
  for (; --t >= 0; )
    e[t] = 0;
}
const Ih = 0, gf = 1, Bh = 2, Th = 3, zh = 258, ss = 29, xn = 256, dn = xn + 1 + ss, Ut = 30, cs = 19, bf = 2 * dn + 1, dt = 15, Pa = 16, Oh = 7, us = 256, mf = 16, yf = 17, vf = 18, Bi = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
), Jn = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
), Rh = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
), wf = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), jh = 512, Pr = new Array((dn + 2) * 2);
Dt(Pr);
const cn = new Array(Ut * 2);
Dt(cn);
const hn = new Array(jh);
Dt(hn);
const pn = new Array(zh - Th + 1);
Dt(pn);
const ls = new Array(ss);
Dt(ls);
const la = new Array(Ut);
Dt(la);
function Ua(e, t, r, n, o) {
  this.static_tree = e, this.extra_bits = t, this.extra_base = r, this.elems = n, this.max_length = o, this.has_stree = e && e.length;
}
let _f, kf, Ef;
function Na(e, t) {
  this.dyn_tree = e, this.max_code = 0, this.stat_desc = t;
}
const xf = (e) => e < 256 ? hn[e] : hn[256 + (e >>> 7)], gn = (e, t) => {
  e.pending_buf[e.pending++] = t & 255, e.pending_buf[e.pending++] = t >>> 8 & 255;
}, Xe = (e, t, r) => {
  e.bi_valid > Pa - r ? (e.bi_buf |= t << e.bi_valid & 65535, gn(e, e.bi_buf), e.bi_buf = t >> Pa - e.bi_valid, e.bi_valid += r - Pa) : (e.bi_buf |= t << e.bi_valid & 65535, e.bi_valid += r);
}, Er = (e, t, r) => {
  Xe(
    e,
    r[t * 2],
    r[t * 2 + 1]
    /*.Len*/
  );
}, Af = (e, t) => {
  let r = 0;
  do
    r |= e & 1, e >>>= 1, r <<= 1;
  while (--t > 0);
  return r >>> 1;
}, Ph = (e) => {
  e.bi_valid === 16 ? (gn(e, e.bi_buf), e.bi_buf = 0, e.bi_valid = 0) : e.bi_valid >= 8 && (e.pending_buf[e.pending++] = e.bi_buf & 255, e.bi_buf >>= 8, e.bi_valid -= 8);
}, Uh = (e, t) => {
  const r = t.dyn_tree, n = t.max_code, o = t.stat_desc.static_tree, a = t.stat_desc.has_stree, s = t.stat_desc.extra_bits, i = t.stat_desc.extra_base, h = t.stat_desc.max_length;
  let l, c, w, g, v, k, y = 0;
  for (g = 0; g <= dt; g++)
    e.bl_count[g] = 0;
  for (r[e.heap[e.heap_max] * 2 + 1] = 0, l = e.heap_max + 1; l < bf; l++)
    c = e.heap[l], g = r[r[c * 2 + 1] * 2 + 1] + 1, g > h && (g = h, y++), r[c * 2 + 1] = g, !(c > n) && (e.bl_count[g]++, v = 0, c >= i && (v = s[c - i]), k = r[c * 2], e.opt_len += k * (g + v), a && (e.static_len += k * (o[c * 2 + 1] + v)));
  if (y !== 0) {
    do {
      for (g = h - 1; e.bl_count[g] === 0; )
        g--;
      e.bl_count[g]--, e.bl_count[g + 1] += 2, e.bl_count[h]--, y -= 2;
    } while (y > 0);
    for (g = h; g !== 0; g--)
      for (c = e.bl_count[g]; c !== 0; )
        w = e.heap[--l], !(w > n) && (r[w * 2 + 1] !== g && (e.opt_len += (g - r[w * 2 + 1]) * r[w * 2], r[w * 2 + 1] = g), c--);
  }
}, Sf = (e, t, r) => {
  const n = new Array(dt + 1);
  let o = 0, a, s;
  for (a = 1; a <= dt; a++)
    o = o + r[a - 1] << 1, n[a] = o;
  for (s = 0; s <= t; s++) {
    let i = e[s * 2 + 1];
    i !== 0 && (e[s * 2] = Af(n[i]++, i));
  }
}, Nh = () => {
  let e, t, r, n, o;
  const a = new Array(dt + 1);
  for (r = 0, n = 0; n < ss - 1; n++)
    for (ls[n] = r, e = 0; e < 1 << Bi[n]; e++)
      pn[r++] = n;
  for (pn[r - 1] = n, o = 0, n = 0; n < 16; n++)
    for (la[n] = o, e = 0; e < 1 << Jn[n]; e++)
      hn[o++] = n;
  for (o >>= 7; n < Ut; n++)
    for (la[n] = o << 7, e = 0; e < 1 << Jn[n] - 7; e++)
      hn[256 + o++] = n;
  for (t = 0; t <= dt; t++)
    a[t] = 0;
  for (e = 0; e <= 143; )
    Pr[e * 2 + 1] = 8, e++, a[8]++;
  for (; e <= 255; )
    Pr[e * 2 + 1] = 9, e++, a[9]++;
  for (; e <= 279; )
    Pr[e * 2 + 1] = 7, e++, a[7]++;
  for (; e <= 287; )
    Pr[e * 2 + 1] = 8, e++, a[8]++;
  for (Sf(Pr, dn + 1, a), e = 0; e < Ut; e++)
    cn[e * 2 + 1] = 5, cn[e * 2] = Af(e, 5);
  _f = new Ua(Pr, Bi, xn + 1, dn, dt), kf = new Ua(cn, Jn, 0, Ut, dt), Ef = new Ua(new Array(0), Rh, 0, cs, Oh);
}, If = (e) => {
  let t;
  for (t = 0; t < dn; t++)
    e.dyn_ltree[t * 2] = 0;
  for (t = 0; t < Ut; t++)
    e.dyn_dtree[t * 2] = 0;
  for (t = 0; t < cs; t++)
    e.bl_tree[t * 2] = 0;
  e.dyn_ltree[us * 2] = 1, e.opt_len = e.static_len = 0, e.sym_next = e.matches = 0;
}, Bf = (e) => {
  e.bi_valid > 8 ? gn(e, e.bi_buf) : e.bi_valid > 0 && (e.pending_buf[e.pending++] = e.bi_buf), e.bi_buf = 0, e.bi_valid = 0;
}, Ns = (e, t, r, n) => {
  const o = t * 2, a = r * 2;
  return e[o] < e[a] || e[o] === e[a] && n[t] <= n[r];
}, Ca = (e, t, r) => {
  const n = e.heap[r];
  let o = r << 1;
  for (; o <= e.heap_len && (o < e.heap_len && Ns(t, e.heap[o + 1], e.heap[o], e.depth) && o++, !Ns(t, n, e.heap[o], e.depth)); )
    e.heap[r] = e.heap[o], r = o, o <<= 1;
  e.heap[r] = n;
}, Cs = (e, t, r) => {
  let n, o, a = 0, s, i;
  if (e.sym_next !== 0)
    do
      n = e.pending_buf[e.sym_buf + a++] & 255, n += (e.pending_buf[e.sym_buf + a++] & 255) << 8, o = e.pending_buf[e.sym_buf + a++], n === 0 ? Er(e, o, t) : (s = pn[o], Er(e, s + xn + 1, t), i = Bi[s], i !== 0 && (o -= ls[s], Xe(e, o, i)), n--, s = xf(n), Er(e, s, r), i = Jn[s], i !== 0 && (n -= la[s], Xe(e, n, i)));
    while (a < e.sym_next);
  Er(e, us, t);
}, Ti = (e, t) => {
  const r = t.dyn_tree, n = t.stat_desc.static_tree, o = t.stat_desc.has_stree, a = t.stat_desc.elems;
  let s, i, h = -1, l;
  for (e.heap_len = 0, e.heap_max = bf, s = 0; s < a; s++)
    r[s * 2] !== 0 ? (e.heap[++e.heap_len] = h = s, e.depth[s] = 0) : r[s * 2 + 1] = 0;
  for (; e.heap_len < 2; )
    l = e.heap[++e.heap_len] = h < 2 ? ++h : 0, r[l * 2] = 1, e.depth[l] = 0, e.opt_len--, o && (e.static_len -= n[l * 2 + 1]);
  for (t.max_code = h, s = e.heap_len >> 1; s >= 1; s--)
    Ca(e, r, s);
  l = a;
  do
    s = e.heap[
      1
      /*SMALLEST*/
    ], e.heap[
      1
      /*SMALLEST*/
    ] = e.heap[e.heap_len--], Ca(
      e,
      r,
      1
      /*SMALLEST*/
    ), i = e.heap[
      1
      /*SMALLEST*/
    ], e.heap[--e.heap_max] = s, e.heap[--e.heap_max] = i, r[l * 2] = r[s * 2] + r[i * 2], e.depth[l] = (e.depth[s] >= e.depth[i] ? e.depth[s] : e.depth[i]) + 1, r[s * 2 + 1] = r[i * 2 + 1] = l, e.heap[
      1
      /*SMALLEST*/
    ] = l++, Ca(
      e,
      r,
      1
      /*SMALLEST*/
    );
  while (e.heap_len >= 2);
  e.heap[--e.heap_max] = e.heap[
    1
    /*SMALLEST*/
  ], Uh(e, t), Sf(r, h, e.bl_count);
}, Ls = (e, t, r) => {
  let n, o = -1, a, s = t[1], i = 0, h = 7, l = 4;
  for (s === 0 && (h = 138, l = 3), t[(r + 1) * 2 + 1] = 65535, n = 0; n <= r; n++)
    a = s, s = t[(n + 1) * 2 + 1], !(++i < h && a === s) && (i < l ? e.bl_tree[a * 2] += i : a !== 0 ? (a !== o && e.bl_tree[a * 2]++, e.bl_tree[mf * 2]++) : i <= 10 ? e.bl_tree[yf * 2]++ : e.bl_tree[vf * 2]++, i = 0, o = a, s === 0 ? (h = 138, l = 3) : a === s ? (h = 6, l = 3) : (h = 7, l = 4));
}, qs = (e, t, r) => {
  let n, o = -1, a, s = t[1], i = 0, h = 7, l = 4;
  for (s === 0 && (h = 138, l = 3), n = 0; n <= r; n++)
    if (a = s, s = t[(n + 1) * 2 + 1], !(++i < h && a === s)) {
      if (i < l)
        do
          Er(e, a, e.bl_tree);
        while (--i !== 0);
      else a !== 0 ? (a !== o && (Er(e, a, e.bl_tree), i--), Er(e, mf, e.bl_tree), Xe(e, i - 3, 2)) : i <= 10 ? (Er(e, yf, e.bl_tree), Xe(e, i - 3, 3)) : (Er(e, vf, e.bl_tree), Xe(e, i - 11, 7));
      i = 0, o = a, s === 0 ? (h = 138, l = 3) : a === s ? (h = 6, l = 3) : (h = 7, l = 4);
    }
}, Ch = (e) => {
  let t;
  for (Ls(e, e.dyn_ltree, e.l_desc.max_code), Ls(e, e.dyn_dtree, e.d_desc.max_code), Ti(e, e.bl_desc), t = cs - 1; t >= 3 && e.bl_tree[wf[t] * 2 + 1] === 0; t--)
    ;
  return e.opt_len += 3 * (t + 1) + 5 + 5 + 4, t;
}, Lh = (e, t, r, n) => {
  let o;
  for (Xe(e, t - 257, 5), Xe(e, r - 1, 5), Xe(e, n - 4, 4), o = 0; o < n; o++)
    Xe(e, e.bl_tree[wf[o] * 2 + 1], 3);
  qs(e, e.dyn_ltree, t - 1), qs(e, e.dyn_dtree, r - 1);
}, qh = (e) => {
  let t = 4093624447, r;
  for (r = 0; r <= 31; r++, t >>>= 1)
    if (t & 1 && e.dyn_ltree[r * 2] !== 0)
      return Ps;
  if (e.dyn_ltree[18] !== 0 || e.dyn_ltree[20] !== 0 || e.dyn_ltree[26] !== 0)
    return Us;
  for (r = 32; r < xn; r++)
    if (e.dyn_ltree[r * 2] !== 0)
      return Us;
  return Ps;
};
let Ms = !1;
const Mh = (e) => {
  Ms || (Nh(), Ms = !0), e.l_desc = new Na(e.dyn_ltree, _f), e.d_desc = new Na(e.dyn_dtree, kf), e.bl_desc = new Na(e.bl_tree, Ef), e.bi_buf = 0, e.bi_valid = 0, If(e);
}, Tf = (e, t, r, n) => {
  Xe(e, (Ih << 1) + (n ? 1 : 0), 3), Bf(e), gn(e, r), gn(e, ~r), r && e.pending_buf.set(e.window.subarray(t, t + r), e.pending), e.pending += r;
}, Dh = (e) => {
  Xe(e, gf << 1, 3), Er(e, us, Pr), Ph(e);
}, Fh = (e, t, r, n) => {
  let o, a, s = 0;
  e.level > 0 ? (e.strm.data_type === Sh && (e.strm.data_type = qh(e)), Ti(e, e.l_desc), Ti(e, e.d_desc), s = Ch(e), o = e.opt_len + 3 + 7 >>> 3, a = e.static_len + 3 + 7 >>> 3, a <= o && (o = a)) : o = a = r + 5, r + 4 <= o && t !== -1 ? Tf(e, t, r, n) : e.strategy === Ah || a === o ? (Xe(e, (gf << 1) + (n ? 1 : 0), 3), Cs(e, Pr, cn)) : (Xe(e, (Bh << 1) + (n ? 1 : 0), 3), Lh(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, s + 1), Cs(e, e.dyn_ltree, e.dyn_dtree)), If(e), n && Bf(e);
}, Kh = (e, t, r) => (e.pending_buf[e.sym_buf + e.sym_next++] = t, e.pending_buf[e.sym_buf + e.sym_next++] = t >> 8, e.pending_buf[e.sym_buf + e.sym_next++] = r, t === 0 ? e.dyn_ltree[r * 2]++ : (e.matches++, t--, e.dyn_ltree[(pn[r] + xn + 1) * 2]++, e.dyn_dtree[xf(t) * 2]++), e.sym_next === e.sym_end);
var Hh = Mh, $h = Tf, Gh = Fh, Wh = Kh, Vh = Dh, Zh = {
  _tr_init: Hh,
  _tr_stored_block: $h,
  _tr_flush_block: Gh,
  _tr_tally: Wh,
  _tr_align: Vh
};
const Yh = (e, t, r, n) => {
  let o = e & 65535 | 0, a = e >>> 16 & 65535 | 0, s = 0;
  for (; r !== 0; ) {
    s = r > 2e3 ? 2e3 : r, r -= s;
    do
      o = o + t[n++] | 0, a = a + o | 0;
    while (--s);
    o %= 65521, a %= 65521;
  }
  return o | a << 16 | 0;
};
var bn = Yh;
const Xh = () => {
  let e, t = [];
  for (var r = 0; r < 256; r++) {
    e = r;
    for (var n = 0; n < 8; n++)
      e = e & 1 ? 3988292384 ^ e >>> 1 : e >>> 1;
    t[r] = e;
  }
  return t;
}, Jh = new Uint32Array(Xh()), Qh = (e, t, r, n) => {
  const o = Jh, a = n + r;
  e ^= -1;
  for (let s = n; s < a; s++)
    e = e >>> 8 ^ o[(e ^ t[s]) & 255];
  return e ^ -1;
};
var Ke = Qh, yt = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
}, An = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
const { _tr_init: ep, _tr_stored_block: zi, _tr_flush_block: rp, _tr_tally: at, _tr_align: tp } = Zh, {
  Z_NO_FLUSH: ot,
  Z_PARTIAL_FLUSH: np,
  Z_FULL_FLUSH: ap,
  Z_FINISH: ur,
  Z_BLOCK: Ds,
  Z_OK: $e,
  Z_STREAM_END: Fs,
  Z_STREAM_ERROR: xr,
  Z_DATA_ERROR: op,
  Z_BUF_ERROR: La,
  Z_DEFAULT_COMPRESSION: ip,
  Z_FILTERED: sp,
  Z_HUFFMAN_ONLY: jn,
  Z_RLE: cp,
  Z_FIXED: up,
  Z_DEFAULT_STRATEGY: lp,
  Z_UNKNOWN: fp,
  Z_DEFLATED: Aa
} = An, dp = 9, hp = 15, pp = 8, gp = 29, bp = 256, Oi = bp + 1 + gp, mp = 30, yp = 19, vp = 2 * Oi + 1, wp = 15, ke = 3, tt = 258, Ar = tt + ke + 1, _p = 32, Ct = 42, fs = 57, Ri = 69, ji = 73, Pi = 91, Ui = 103, ht = 113, tn = 666, Ve = 1, Ft = 2, vt = 3, Kt = 4, kp = 3, pt = (e, t) => (e.msg = yt[t], t), Ks = (e) => e * 2 - (e > 4 ? 9 : 0), rt = (e) => {
  let t = e.length;
  for (; --t >= 0; )
    e[t] = 0;
}, Ep = (e) => {
  let t, r, n, o = e.w_size;
  t = e.hash_size, n = t;
  do
    r = e.head[--n], e.head[n] = r >= o ? r - o : 0;
  while (--t);
  t = o, n = t;
  do
    r = e.prev[--n], e.prev[n] = r >= o ? r - o : 0;
  while (--t);
};
let xp = (e, t, r) => (t << e.hash_shift ^ r) & e.hash_mask, it = xp;
const rr = (e) => {
  const t = e.state;
  let r = t.pending;
  r > e.avail_out && (r = e.avail_out), r !== 0 && (e.output.set(t.pending_buf.subarray(t.pending_out, t.pending_out + r), e.next_out), e.next_out += r, t.pending_out += r, e.total_out += r, e.avail_out -= r, t.pending -= r, t.pending === 0 && (t.pending_out = 0));
}, nr = (e, t) => {
  rp(e, e.block_start >= 0 ? e.block_start : -1, e.strstart - e.block_start, t), e.block_start = e.strstart, rr(e.strm);
}, Ee = (e, t) => {
  e.pending_buf[e.pending++] = t;
}, Yt = (e, t) => {
  e.pending_buf[e.pending++] = t >>> 8 & 255, e.pending_buf[e.pending++] = t & 255;
}, Ni = (e, t, r, n) => {
  let o = e.avail_in;
  return o > n && (o = n), o === 0 ? 0 : (e.avail_in -= o, t.set(e.input.subarray(e.next_in, e.next_in + o), r), e.state.wrap === 1 ? e.adler = bn(e.adler, t, o, r) : e.state.wrap === 2 && (e.adler = Ke(e.adler, t, o, r)), e.next_in += o, e.total_in += o, o);
}, zf = (e, t) => {
  let r = e.max_chain_length, n = e.strstart, o, a, s = e.prev_length, i = e.nice_match;
  const h = e.strstart > e.w_size - Ar ? e.strstart - (e.w_size - Ar) : 0, l = e.window, c = e.w_mask, w = e.prev, g = e.strstart + tt;
  let v = l[n + s - 1], k = l[n + s];
  e.prev_length >= e.good_match && (r >>= 2), i > e.lookahead && (i = e.lookahead);
  do
    if (o = t, !(l[o + s] !== k || l[o + s - 1] !== v || l[o] !== l[n] || l[++o] !== l[n + 1])) {
      n += 2, o++;
      do
        ;
      while (l[++n] === l[++o] && l[++n] === l[++o] && l[++n] === l[++o] && l[++n] === l[++o] && l[++n] === l[++o] && l[++n] === l[++o] && l[++n] === l[++o] && l[++n] === l[++o] && n < g);
      if (a = tt - (g - n), n = g - tt, a > s) {
        if (e.match_start = t, s = a, a >= i)
          break;
        v = l[n + s - 1], k = l[n + s];
      }
    }
  while ((t = w[t & c]) > h && --r !== 0);
  return s <= e.lookahead ? s : e.lookahead;
}, Lt = (e) => {
  const t = e.w_size;
  let r, n, o;
  do {
    if (n = e.window_size - e.lookahead - e.strstart, e.strstart >= t + (t - Ar) && (e.window.set(e.window.subarray(t, t + t - n), 0), e.match_start -= t, e.strstart -= t, e.block_start -= t, e.insert > e.strstart && (e.insert = e.strstart), Ep(e), n += t), e.strm.avail_in === 0)
      break;
    if (r = Ni(e.strm, e.window, e.strstart + e.lookahead, n), e.lookahead += r, e.lookahead + e.insert >= ke)
      for (o = e.strstart - e.insert, e.ins_h = e.window[o], e.ins_h = it(e, e.ins_h, e.window[o + 1]); e.insert && (e.ins_h = it(e, e.ins_h, e.window[o + ke - 1]), e.prev[o & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = o, o++, e.insert--, !(e.lookahead + e.insert < ke)); )
        ;
  } while (e.lookahead < Ar && e.strm.avail_in !== 0);
}, Of = (e, t) => {
  let r = e.pending_buf_size - 5 > e.w_size ? e.w_size : e.pending_buf_size - 5, n, o, a, s = 0, i = e.strm.avail_in;
  do {
    if (n = 65535, a = e.bi_valid + 42 >> 3, e.strm.avail_out < a || (a = e.strm.avail_out - a, o = e.strstart - e.block_start, n > o + e.strm.avail_in && (n = o + e.strm.avail_in), n > a && (n = a), n < r && (n === 0 && t !== ur || t === ot || n !== o + e.strm.avail_in)))
      break;
    s = t === ur && n === o + e.strm.avail_in ? 1 : 0, zi(e, 0, 0, s), e.pending_buf[e.pending - 4] = n, e.pending_buf[e.pending - 3] = n >> 8, e.pending_buf[e.pending - 2] = ~n, e.pending_buf[e.pending - 1] = ~n >> 8, rr(e.strm), o && (o > n && (o = n), e.strm.output.set(e.window.subarray(e.block_start, e.block_start + o), e.strm.next_out), e.strm.next_out += o, e.strm.avail_out -= o, e.strm.total_out += o, e.block_start += o, n -= o), n && (Ni(e.strm, e.strm.output, e.strm.next_out, n), e.strm.next_out += n, e.strm.avail_out -= n, e.strm.total_out += n);
  } while (s === 0);
  return i -= e.strm.avail_in, i && (i >= e.w_size ? (e.matches = 2, e.window.set(e.strm.input.subarray(e.strm.next_in - e.w_size, e.strm.next_in), 0), e.strstart = e.w_size, e.insert = e.strstart) : (e.window_size - e.strstart <= i && (e.strstart -= e.w_size, e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0), e.matches < 2 && e.matches++, e.insert > e.strstart && (e.insert = e.strstart)), e.window.set(e.strm.input.subarray(e.strm.next_in - i, e.strm.next_in), e.strstart), e.strstart += i, e.insert += i > e.w_size - e.insert ? e.w_size - e.insert : i), e.block_start = e.strstart), e.high_water < e.strstart && (e.high_water = e.strstart), s ? Kt : t !== ot && t !== ur && e.strm.avail_in === 0 && e.strstart === e.block_start ? Ft : (a = e.window_size - e.strstart, e.strm.avail_in > a && e.block_start >= e.w_size && (e.block_start -= e.w_size, e.strstart -= e.w_size, e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0), e.matches < 2 && e.matches++, a += e.w_size, e.insert > e.strstart && (e.insert = e.strstart)), a > e.strm.avail_in && (a = e.strm.avail_in), a && (Ni(e.strm, e.window, e.strstart, a), e.strstart += a, e.insert += a > e.w_size - e.insert ? e.w_size - e.insert : a), e.high_water < e.strstart && (e.high_water = e.strstart), a = e.bi_valid + 42 >> 3, a = e.pending_buf_size - a > 65535 ? 65535 : e.pending_buf_size - a, r = a > e.w_size ? e.w_size : a, o = e.strstart - e.block_start, (o >= r || (o || t === ur) && t !== ot && e.strm.avail_in === 0 && o <= a) && (n = o > a ? a : o, s = t === ur && e.strm.avail_in === 0 && n === o ? 1 : 0, zi(e, e.block_start, n, s), e.block_start += n, rr(e.strm)), s ? vt : Ve);
}, qa = (e, t) => {
  let r, n;
  for (; ; ) {
    if (e.lookahead < Ar) {
      if (Lt(e), e.lookahead < Ar && t === ot)
        return Ve;
      if (e.lookahead === 0)
        break;
    }
    if (r = 0, e.lookahead >= ke && (e.ins_h = it(e, e.ins_h, e.window[e.strstart + ke - 1]), r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), r !== 0 && e.strstart - r <= e.w_size - Ar && (e.match_length = zf(e, r)), e.match_length >= ke)
      if (n = at(e, e.strstart - e.match_start, e.match_length - ke), e.lookahead -= e.match_length, e.match_length <= e.max_lazy_match && e.lookahead >= ke) {
        e.match_length--;
        do
          e.strstart++, e.ins_h = it(e, e.ins_h, e.window[e.strstart + ke - 1]), r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart;
        while (--e.match_length !== 0);
        e.strstart++;
      } else
        e.strstart += e.match_length, e.match_length = 0, e.ins_h = e.window[e.strstart], e.ins_h = it(e, e.ins_h, e.window[e.strstart + 1]);
    else
      n = at(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++;
    if (n && (nr(e, !1), e.strm.avail_out === 0))
      return Ve;
  }
  return e.insert = e.strstart < ke - 1 ? e.strstart : ke - 1, t === ur ? (nr(e, !0), e.strm.avail_out === 0 ? vt : Kt) : e.sym_next && (nr(e, !1), e.strm.avail_out === 0) ? Ve : Ft;
}, At = (e, t) => {
  let r, n, o;
  for (; ; ) {
    if (e.lookahead < Ar) {
      if (Lt(e), e.lookahead < Ar && t === ot)
        return Ve;
      if (e.lookahead === 0)
        break;
    }
    if (r = 0, e.lookahead >= ke && (e.ins_h = it(e, e.ins_h, e.window[e.strstart + ke - 1]), r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), e.prev_length = e.match_length, e.prev_match = e.match_start, e.match_length = ke - 1, r !== 0 && e.prev_length < e.max_lazy_match && e.strstart - r <= e.w_size - Ar && (e.match_length = zf(e, r), e.match_length <= 5 && (e.strategy === sp || e.match_length === ke && e.strstart - e.match_start > 4096) && (e.match_length = ke - 1)), e.prev_length >= ke && e.match_length <= e.prev_length) {
      o = e.strstart + e.lookahead - ke, n = at(e, e.strstart - 1 - e.prev_match, e.prev_length - ke), e.lookahead -= e.prev_length - 1, e.prev_length -= 2;
      do
        ++e.strstart <= o && (e.ins_h = it(e, e.ins_h, e.window[e.strstart + ke - 1]), r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart);
      while (--e.prev_length !== 0);
      if (e.match_available = 0, e.match_length = ke - 1, e.strstart++, n && (nr(e, !1), e.strm.avail_out === 0))
        return Ve;
    } else if (e.match_available) {
      if (n = at(e, 0, e.window[e.strstart - 1]), n && nr(e, !1), e.strstart++, e.lookahead--, e.strm.avail_out === 0)
        return Ve;
    } else
      e.match_available = 1, e.strstart++, e.lookahead--;
  }
  return e.match_available && (n = at(e, 0, e.window[e.strstart - 1]), e.match_available = 0), e.insert = e.strstart < ke - 1 ? e.strstart : ke - 1, t === ur ? (nr(e, !0), e.strm.avail_out === 0 ? vt : Kt) : e.sym_next && (nr(e, !1), e.strm.avail_out === 0) ? Ve : Ft;
}, Ap = (e, t) => {
  let r, n, o, a;
  const s = e.window;
  for (; ; ) {
    if (e.lookahead <= tt) {
      if (Lt(e), e.lookahead <= tt && t === ot)
        return Ve;
      if (e.lookahead === 0)
        break;
    }
    if (e.match_length = 0, e.lookahead >= ke && e.strstart > 0 && (o = e.strstart - 1, n = s[o], n === s[++o] && n === s[++o] && n === s[++o])) {
      a = e.strstart + tt;
      do
        ;
      while (n === s[++o] && n === s[++o] && n === s[++o] && n === s[++o] && n === s[++o] && n === s[++o] && n === s[++o] && n === s[++o] && o < a);
      e.match_length = tt - (a - o), e.match_length > e.lookahead && (e.match_length = e.lookahead);
    }
    if (e.match_length >= ke ? (r = at(e, 1, e.match_length - ke), e.lookahead -= e.match_length, e.strstart += e.match_length, e.match_length = 0) : (r = at(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++), r && (nr(e, !1), e.strm.avail_out === 0))
      return Ve;
  }
  return e.insert = 0, t === ur ? (nr(e, !0), e.strm.avail_out === 0 ? vt : Kt) : e.sym_next && (nr(e, !1), e.strm.avail_out === 0) ? Ve : Ft;
}, Sp = (e, t) => {
  let r;
  for (; ; ) {
    if (e.lookahead === 0 && (Lt(e), e.lookahead === 0)) {
      if (t === ot)
        return Ve;
      break;
    }
    if (e.match_length = 0, r = at(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++, r && (nr(e, !1), e.strm.avail_out === 0))
      return Ve;
  }
  return e.insert = 0, t === ur ? (nr(e, !0), e.strm.avail_out === 0 ? vt : Kt) : e.sym_next && (nr(e, !1), e.strm.avail_out === 0) ? Ve : Ft;
};
function pr(e, t, r, n, o) {
  this.good_length = e, this.max_lazy = t, this.nice_length = r, this.max_chain = n, this.func = o;
}
const nn = [
  /*      good lazy nice chain */
  new pr(0, 0, 0, 0, Of),
  /* 0 store only */
  new pr(4, 4, 8, 4, qa),
  /* 1 max speed, no lazy matches */
  new pr(4, 5, 16, 8, qa),
  /* 2 */
  new pr(4, 6, 32, 32, qa),
  /* 3 */
  new pr(4, 4, 16, 16, At),
  /* 4 lazy matches */
  new pr(8, 16, 32, 32, At),
  /* 5 */
  new pr(8, 16, 128, 128, At),
  /* 6 */
  new pr(8, 32, 128, 256, At),
  /* 7 */
  new pr(32, 128, 258, 1024, At),
  /* 8 */
  new pr(32, 258, 258, 4096, At)
  /* 9 max compression */
], Ip = (e) => {
  e.window_size = 2 * e.w_size, rt(e.head), e.max_lazy_match = nn[e.level].max_lazy, e.good_match = nn[e.level].good_length, e.nice_match = nn[e.level].nice_length, e.max_chain_length = nn[e.level].max_chain, e.strstart = 0, e.block_start = 0, e.lookahead = 0, e.insert = 0, e.match_length = e.prev_length = ke - 1, e.match_available = 0, e.ins_h = 0;
};
function Bp() {
  this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = Aa, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(vp * 2), this.dyn_dtree = new Uint16Array((2 * mp + 1) * 2), this.bl_tree = new Uint16Array((2 * yp + 1) * 2), rt(this.dyn_ltree), rt(this.dyn_dtree), rt(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(wp + 1), this.heap = new Uint16Array(2 * Oi + 1), rt(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * Oi + 1), rt(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
}
const Sn = (e) => {
  if (!e)
    return 1;
  const t = e.state;
  return !t || t.strm !== e || t.status !== Ct && //#ifdef GZIP
  t.status !== fs && //#endif
  t.status !== Ri && t.status !== ji && t.status !== Pi && t.status !== Ui && t.status !== ht && t.status !== tn ? 1 : 0;
}, Rf = (e) => {
  if (Sn(e))
    return pt(e, xr);
  e.total_in = e.total_out = 0, e.data_type = fp;
  const t = e.state;
  return t.pending = 0, t.pending_out = 0, t.wrap < 0 && (t.wrap = -t.wrap), t.status = //#ifdef GZIP
  t.wrap === 2 ? fs : (
    //#endif
    t.wrap ? Ct : ht
  ), e.adler = t.wrap === 2 ? 0 : 1, t.last_flush = -2, ep(t), $e;
}, jf = (e) => {
  const t = Rf(e);
  return t === $e && Ip(e.state), t;
}, Tp = (e, t) => Sn(e) || e.state.wrap !== 2 ? xr : (e.state.gzhead = t, $e), Pf = (e, t, r, n, o, a) => {
  if (!e)
    return xr;
  let s = 1;
  if (t === ip && (t = 6), n < 0 ? (s = 0, n = -n) : n > 15 && (s = 2, n -= 16), o < 1 || o > dp || r !== Aa || n < 8 || n > 15 || t < 0 || t > 9 || a < 0 || a > up || n === 8 && s !== 1)
    return pt(e, xr);
  n === 8 && (n = 9);
  const i = new Bp();
  return e.state = i, i.strm = e, i.status = Ct, i.wrap = s, i.gzhead = null, i.w_bits = n, i.w_size = 1 << i.w_bits, i.w_mask = i.w_size - 1, i.hash_bits = o + 7, i.hash_size = 1 << i.hash_bits, i.hash_mask = i.hash_size - 1, i.hash_shift = ~~((i.hash_bits + ke - 1) / ke), i.window = new Uint8Array(i.w_size * 2), i.head = new Uint16Array(i.hash_size), i.prev = new Uint16Array(i.w_size), i.lit_bufsize = 1 << o + 6, i.pending_buf_size = i.lit_bufsize * 4, i.pending_buf = new Uint8Array(i.pending_buf_size), i.sym_buf = i.lit_bufsize, i.sym_end = (i.lit_bufsize - 1) * 3, i.level = t, i.strategy = a, i.method = r, jf(e);
}, zp = (e, t) => Pf(e, t, Aa, hp, pp, lp), Op = (e, t) => {
  if (Sn(e) || t > Ds || t < 0)
    return e ? pt(e, xr) : xr;
  const r = e.state;
  if (!e.output || e.avail_in !== 0 && !e.input || r.status === tn && t !== ur)
    return pt(e, e.avail_out === 0 ? La : xr);
  const n = r.last_flush;
  if (r.last_flush = t, r.pending !== 0) {
    if (rr(e), e.avail_out === 0)
      return r.last_flush = -1, $e;
  } else if (e.avail_in === 0 && Ks(t) <= Ks(n) && t !== ur)
    return pt(e, La);
  if (r.status === tn && e.avail_in !== 0)
    return pt(e, La);
  if (r.status === Ct && r.wrap === 0 && (r.status = ht), r.status === Ct) {
    let o = Aa + (r.w_bits - 8 << 4) << 8, a = -1;
    if (r.strategy >= jn || r.level < 2 ? a = 0 : r.level < 6 ? a = 1 : r.level === 6 ? a = 2 : a = 3, o |= a << 6, r.strstart !== 0 && (o |= _p), o += 31 - o % 31, Yt(r, o), r.strstart !== 0 && (Yt(r, e.adler >>> 16), Yt(r, e.adler & 65535)), e.adler = 1, r.status = ht, rr(e), r.pending !== 0)
      return r.last_flush = -1, $e;
  }
  if (r.status === fs) {
    if (e.adler = 0, Ee(r, 31), Ee(r, 139), Ee(r, 8), r.gzhead)
      Ee(
        r,
        (r.gzhead.text ? 1 : 0) + (r.gzhead.hcrc ? 2 : 0) + (r.gzhead.extra ? 4 : 0) + (r.gzhead.name ? 8 : 0) + (r.gzhead.comment ? 16 : 0)
      ), Ee(r, r.gzhead.time & 255), Ee(r, r.gzhead.time >> 8 & 255), Ee(r, r.gzhead.time >> 16 & 255), Ee(r, r.gzhead.time >> 24 & 255), Ee(r, r.level === 9 ? 2 : r.strategy >= jn || r.level < 2 ? 4 : 0), Ee(r, r.gzhead.os & 255), r.gzhead.extra && r.gzhead.extra.length && (Ee(r, r.gzhead.extra.length & 255), Ee(r, r.gzhead.extra.length >> 8 & 255)), r.gzhead.hcrc && (e.adler = Ke(e.adler, r.pending_buf, r.pending, 0)), r.gzindex = 0, r.status = Ri;
    else if (Ee(r, 0), Ee(r, 0), Ee(r, 0), Ee(r, 0), Ee(r, 0), Ee(r, r.level === 9 ? 2 : r.strategy >= jn || r.level < 2 ? 4 : 0), Ee(r, kp), r.status = ht, rr(e), r.pending !== 0)
      return r.last_flush = -1, $e;
  }
  if (r.status === Ri) {
    if (r.gzhead.extra) {
      let o = r.pending, a = (r.gzhead.extra.length & 65535) - r.gzindex;
      for (; r.pending + a > r.pending_buf_size; ) {
        let i = r.pending_buf_size - r.pending;
        if (r.pending_buf.set(r.gzhead.extra.subarray(r.gzindex, r.gzindex + i), r.pending), r.pending = r.pending_buf_size, r.gzhead.hcrc && r.pending > o && (e.adler = Ke(e.adler, r.pending_buf, r.pending - o, o)), r.gzindex += i, rr(e), r.pending !== 0)
          return r.last_flush = -1, $e;
        o = 0, a -= i;
      }
      let s = new Uint8Array(r.gzhead.extra);
      r.pending_buf.set(s.subarray(r.gzindex, r.gzindex + a), r.pending), r.pending += a, r.gzhead.hcrc && r.pending > o && (e.adler = Ke(e.adler, r.pending_buf, r.pending - o, o)), r.gzindex = 0;
    }
    r.status = ji;
  }
  if (r.status === ji) {
    if (r.gzhead.name) {
      let o = r.pending, a;
      do {
        if (r.pending === r.pending_buf_size) {
          if (r.gzhead.hcrc && r.pending > o && (e.adler = Ke(e.adler, r.pending_buf, r.pending - o, o)), rr(e), r.pending !== 0)
            return r.last_flush = -1, $e;
          o = 0;
        }
        r.gzindex < r.gzhead.name.length ? a = r.gzhead.name.charCodeAt(r.gzindex++) & 255 : a = 0, Ee(r, a);
      } while (a !== 0);
      r.gzhead.hcrc && r.pending > o && (e.adler = Ke(e.adler, r.pending_buf, r.pending - o, o)), r.gzindex = 0;
    }
    r.status = Pi;
  }
  if (r.status === Pi) {
    if (r.gzhead.comment) {
      let o = r.pending, a;
      do {
        if (r.pending === r.pending_buf_size) {
          if (r.gzhead.hcrc && r.pending > o && (e.adler = Ke(e.adler, r.pending_buf, r.pending - o, o)), rr(e), r.pending !== 0)
            return r.last_flush = -1, $e;
          o = 0;
        }
        r.gzindex < r.gzhead.comment.length ? a = r.gzhead.comment.charCodeAt(r.gzindex++) & 255 : a = 0, Ee(r, a);
      } while (a !== 0);
      r.gzhead.hcrc && r.pending > o && (e.adler = Ke(e.adler, r.pending_buf, r.pending - o, o));
    }
    r.status = Ui;
  }
  if (r.status === Ui) {
    if (r.gzhead.hcrc) {
      if (r.pending + 2 > r.pending_buf_size && (rr(e), r.pending !== 0))
        return r.last_flush = -1, $e;
      Ee(r, e.adler & 255), Ee(r, e.adler >> 8 & 255), e.adler = 0;
    }
    if (r.status = ht, rr(e), r.pending !== 0)
      return r.last_flush = -1, $e;
  }
  if (e.avail_in !== 0 || r.lookahead !== 0 || t !== ot && r.status !== tn) {
    let o = r.level === 0 ? Of(r, t) : r.strategy === jn ? Sp(r, t) : r.strategy === cp ? Ap(r, t) : nn[r.level].func(r, t);
    if ((o === vt || o === Kt) && (r.status = tn), o === Ve || o === vt)
      return e.avail_out === 0 && (r.last_flush = -1), $e;
    if (o === Ft && (t === np ? tp(r) : t !== Ds && (zi(r, 0, 0, !1), t === ap && (rt(r.head), r.lookahead === 0 && (r.strstart = 0, r.block_start = 0, r.insert = 0))), rr(e), e.avail_out === 0))
      return r.last_flush = -1, $e;
  }
  return t !== ur ? $e : r.wrap <= 0 ? Fs : (r.wrap === 2 ? (Ee(r, e.adler & 255), Ee(r, e.adler >> 8 & 255), Ee(r, e.adler >> 16 & 255), Ee(r, e.adler >> 24 & 255), Ee(r, e.total_in & 255), Ee(r, e.total_in >> 8 & 255), Ee(r, e.total_in >> 16 & 255), Ee(r, e.total_in >> 24 & 255)) : (Yt(r, e.adler >>> 16), Yt(r, e.adler & 65535)), rr(e), r.wrap > 0 && (r.wrap = -r.wrap), r.pending !== 0 ? $e : Fs);
}, Rp = (e) => {
  if (Sn(e))
    return xr;
  const t = e.state.status;
  return e.state = null, t === ht ? pt(e, op) : $e;
}, jp = (e, t) => {
  let r = t.length;
  if (Sn(e))
    return xr;
  const n = e.state, o = n.wrap;
  if (o === 2 || o === 1 && n.status !== Ct || n.lookahead)
    return xr;
  if (o === 1 && (e.adler = bn(e.adler, t, r, 0)), n.wrap = 0, r >= n.w_size) {
    o === 0 && (rt(n.head), n.strstart = 0, n.block_start = 0, n.insert = 0);
    let h = new Uint8Array(n.w_size);
    h.set(t.subarray(r - n.w_size, r), 0), t = h, r = n.w_size;
  }
  const a = e.avail_in, s = e.next_in, i = e.input;
  for (e.avail_in = r, e.next_in = 0, e.input = t, Lt(n); n.lookahead >= ke; ) {
    let h = n.strstart, l = n.lookahead - (ke - 1);
    do
      n.ins_h = it(n, n.ins_h, n.window[h + ke - 1]), n.prev[h & n.w_mask] = n.head[n.ins_h], n.head[n.ins_h] = h, h++;
    while (--l);
    n.strstart = h, n.lookahead = ke - 1, Lt(n);
  }
  return n.strstart += n.lookahead, n.block_start = n.strstart, n.insert = n.lookahead, n.lookahead = 0, n.match_length = n.prev_length = ke - 1, n.match_available = 0, e.next_in = s, e.input = i, e.avail_in = a, n.wrap = o, $e;
};
var Pp = zp, Up = Pf, Np = jf, Cp = Rf, Lp = Tp, qp = Op, Mp = Rp, Dp = jp, Fp = "pako deflate (from Nodeca project)", un = {
  deflateInit: Pp,
  deflateInit2: Up,
  deflateReset: Np,
  deflateResetKeep: Cp,
  deflateSetHeader: Lp,
  deflate: qp,
  deflateEnd: Mp,
  deflateSetDictionary: Dp,
  deflateInfo: Fp
};
const Kp = (e, t) => Object.prototype.hasOwnProperty.call(e, t);
var Hp = function(e) {
  const t = Array.prototype.slice.call(arguments, 1);
  for (; t.length; ) {
    const r = t.shift();
    if (r) {
      if (typeof r != "object")
        throw new TypeError(r + "must be non-object");
      for (const n in r)
        Kp(r, n) && (e[n] = r[n]);
    }
  }
  return e;
}, $p = (e) => {
  let t = 0;
  for (let n = 0, o = e.length; n < o; n++)
    t += e[n].length;
  const r = new Uint8Array(t);
  for (let n = 0, o = 0, a = e.length; n < a; n++) {
    let s = e[n];
    r.set(s, o), o += s.length;
  }
  return r;
}, Sa = {
  assign: Hp,
  flattenChunks: $p
};
let Uf = !0;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch {
  Uf = !1;
}
const mn = new Uint8Array(256);
for (let e = 0; e < 256; e++)
  mn[e] = e >= 252 ? 6 : e >= 248 ? 5 : e >= 240 ? 4 : e >= 224 ? 3 : e >= 192 ? 2 : 1;
mn[254] = mn[254] = 1;
var Gp = (e) => {
  if (typeof TextEncoder == "function" && TextEncoder.prototype.encode)
    return new TextEncoder().encode(e);
  let t, r, n, o, a, s = e.length, i = 0;
  for (o = 0; o < s; o++)
    r = e.charCodeAt(o), (r & 64512) === 55296 && o + 1 < s && (n = e.charCodeAt(o + 1), (n & 64512) === 56320 && (r = 65536 + (r - 55296 << 10) + (n - 56320), o++)), i += r < 128 ? 1 : r < 2048 ? 2 : r < 65536 ? 3 : 4;
  for (t = new Uint8Array(i), a = 0, o = 0; a < i; o++)
    r = e.charCodeAt(o), (r & 64512) === 55296 && o + 1 < s && (n = e.charCodeAt(o + 1), (n & 64512) === 56320 && (r = 65536 + (r - 55296 << 10) + (n - 56320), o++)), r < 128 ? t[a++] = r : r < 2048 ? (t[a++] = 192 | r >>> 6, t[a++] = 128 | r & 63) : r < 65536 ? (t[a++] = 224 | r >>> 12, t[a++] = 128 | r >>> 6 & 63, t[a++] = 128 | r & 63) : (t[a++] = 240 | r >>> 18, t[a++] = 128 | r >>> 12 & 63, t[a++] = 128 | r >>> 6 & 63, t[a++] = 128 | r & 63);
  return t;
};
const Wp = (e, t) => {
  if (t < 65534 && e.subarray && Uf)
    return String.fromCharCode.apply(null, e.length === t ? e : e.subarray(0, t));
  let r = "";
  for (let n = 0; n < t; n++)
    r += String.fromCharCode(e[n]);
  return r;
};
var Vp = (e, t) => {
  const r = t || e.length;
  if (typeof TextDecoder == "function" && TextDecoder.prototype.decode)
    return new TextDecoder().decode(e.subarray(0, t));
  let n, o;
  const a = new Array(r * 2);
  for (o = 0, n = 0; n < r; ) {
    let s = e[n++];
    if (s < 128) {
      a[o++] = s;
      continue;
    }
    let i = mn[s];
    if (i > 4) {
      a[o++] = 65533, n += i - 1;
      continue;
    }
    for (s &= i === 2 ? 31 : i === 3 ? 15 : 7; i > 1 && n < r; )
      s = s << 6 | e[n++] & 63, i--;
    if (i > 1) {
      a[o++] = 65533;
      continue;
    }
    s < 65536 ? a[o++] = s : (s -= 65536, a[o++] = 55296 | s >> 10 & 1023, a[o++] = 56320 | s & 1023);
  }
  return Wp(a, o);
}, Zp = (e, t) => {
  t = t || e.length, t > e.length && (t = e.length);
  let r = t - 1;
  for (; r >= 0 && (e[r] & 192) === 128; )
    r--;
  return r < 0 || r === 0 ? t : r + mn[e[r]] > t ? r : t;
}, yn = {
  string2buf: Gp,
  buf2string: Vp,
  utf8border: Zp
};
function Yp() {
  this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
}
var Nf = Yp;
const Cf = Object.prototype.toString, {
  Z_NO_FLUSH: Xp,
  Z_SYNC_FLUSH: Jp,
  Z_FULL_FLUSH: Qp,
  Z_FINISH: e0,
  Z_OK: fa,
  Z_STREAM_END: r0,
  Z_DEFAULT_COMPRESSION: t0,
  Z_DEFAULT_STRATEGY: n0,
  Z_DEFLATED: a0
} = An;
function In(e) {
  this.options = Sa.assign({
    level: t0,
    method: a0,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: n0
  }, e || {});
  let t = this.options;
  t.raw && t.windowBits > 0 ? t.windowBits = -t.windowBits : t.gzip && t.windowBits > 0 && t.windowBits < 16 && (t.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new Nf(), this.strm.avail_out = 0;
  let r = un.deflateInit2(
    this.strm,
    t.level,
    t.method,
    t.windowBits,
    t.memLevel,
    t.strategy
  );
  if (r !== fa)
    throw new Error(yt[r]);
  if (t.header && un.deflateSetHeader(this.strm, t.header), t.dictionary) {
    let n;
    if (typeof t.dictionary == "string" ? n = yn.string2buf(t.dictionary) : Cf.call(t.dictionary) === "[object ArrayBuffer]" ? n = new Uint8Array(t.dictionary) : n = t.dictionary, r = un.deflateSetDictionary(this.strm, n), r !== fa)
      throw new Error(yt[r]);
    this._dict_set = !0;
  }
}
In.prototype.push = function(e, t) {
  const r = this.strm, n = this.options.chunkSize;
  let o, a;
  if (this.ended)
    return !1;
  for (t === ~~t ? a = t : a = t === !0 ? e0 : Xp, typeof e == "string" ? r.input = yn.string2buf(e) : Cf.call(e) === "[object ArrayBuffer]" ? r.input = new Uint8Array(e) : r.input = e, r.next_in = 0, r.avail_in = r.input.length; ; ) {
    if (r.avail_out === 0 && (r.output = new Uint8Array(n), r.next_out = 0, r.avail_out = n), (a === Jp || a === Qp) && r.avail_out <= 6) {
      this.onData(r.output.subarray(0, r.next_out)), r.avail_out = 0;
      continue;
    }
    if (o = un.deflate(r, a), o === r0)
      return r.next_out > 0 && this.onData(r.output.subarray(0, r.next_out)), o = un.deflateEnd(this.strm), this.onEnd(o), this.ended = !0, o === fa;
    if (r.avail_out === 0) {
      this.onData(r.output);
      continue;
    }
    if (a > 0 && r.next_out > 0) {
      this.onData(r.output.subarray(0, r.next_out)), r.avail_out = 0;
      continue;
    }
    if (r.avail_in === 0) break;
  }
  return !0;
};
In.prototype.onData = function(e) {
  this.chunks.push(e);
};
In.prototype.onEnd = function(e) {
  e === fa && (this.result = Sa.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
};
function ds(e, t) {
  const r = new In(t);
  if (r.push(e, !0), r.err)
    throw r.msg || yt[r.err];
  return r.result;
}
function o0(e, t) {
  return t = t || {}, t.raw = !0, ds(e, t);
}
function i0(e, t) {
  return t = t || {}, t.gzip = !0, ds(e, t);
}
var s0 = In, c0 = ds, u0 = o0, l0 = i0, f0 = {
  Deflate: s0,
  deflate: c0,
  deflateRaw: u0,
  gzip: l0
};
const Pn = 16209, d0 = 16191;
var h0 = function(t, r) {
  let n, o, a, s, i, h, l, c, w, g, v, k, y, m, A, E, x, z, F, j, I, N, O, R;
  const U = t.state;
  n = t.next_in, O = t.input, o = n + (t.avail_in - 5), a = t.next_out, R = t.output, s = a - (r - t.avail_out), i = a + (t.avail_out - 257), h = U.dmax, l = U.wsize, c = U.whave, w = U.wnext, g = U.window, v = U.hold, k = U.bits, y = U.lencode, m = U.distcode, A = (1 << U.lenbits) - 1, E = (1 << U.distbits) - 1;
  e:
    do {
      k < 15 && (v += O[n++] << k, k += 8, v += O[n++] << k, k += 8), x = y[v & A];
      r:
        for (; ; ) {
          if (z = x >>> 24, v >>>= z, k -= z, z = x >>> 16 & 255, z === 0)
            R[a++] = x & 65535;
          else if (z & 16) {
            F = x & 65535, z &= 15, z && (k < z && (v += O[n++] << k, k += 8), F += v & (1 << z) - 1, v >>>= z, k -= z), k < 15 && (v += O[n++] << k, k += 8, v += O[n++] << k, k += 8), x = m[v & E];
            t:
              for (; ; ) {
                if (z = x >>> 24, v >>>= z, k -= z, z = x >>> 16 & 255, z & 16) {
                  if (j = x & 65535, z &= 15, k < z && (v += O[n++] << k, k += 8, k < z && (v += O[n++] << k, k += 8)), j += v & (1 << z) - 1, j > h) {
                    t.msg = "invalid distance too far back", U.mode = Pn;
                    break e;
                  }
                  if (v >>>= z, k -= z, z = a - s, j > z) {
                    if (z = j - z, z > c && U.sane) {
                      t.msg = "invalid distance too far back", U.mode = Pn;
                      break e;
                    }
                    if (I = 0, N = g, w === 0) {
                      if (I += l - z, z < F) {
                        F -= z;
                        do
                          R[a++] = g[I++];
                        while (--z);
                        I = a - j, N = R;
                      }
                    } else if (w < z) {
                      if (I += l + w - z, z -= w, z < F) {
                        F -= z;
                        do
                          R[a++] = g[I++];
                        while (--z);
                        if (I = 0, w < F) {
                          z = w, F -= z;
                          do
                            R[a++] = g[I++];
                          while (--z);
                          I = a - j, N = R;
                        }
                      }
                    } else if (I += w - z, z < F) {
                      F -= z;
                      do
                        R[a++] = g[I++];
                      while (--z);
                      I = a - j, N = R;
                    }
                    for (; F > 2; )
                      R[a++] = N[I++], R[a++] = N[I++], R[a++] = N[I++], F -= 3;
                    F && (R[a++] = N[I++], F > 1 && (R[a++] = N[I++]));
                  } else {
                    I = a - j;
                    do
                      R[a++] = R[I++], R[a++] = R[I++], R[a++] = R[I++], F -= 3;
                    while (F > 2);
                    F && (R[a++] = R[I++], F > 1 && (R[a++] = R[I++]));
                  }
                } else if ((z & 64) === 0) {
                  x = m[(x & 65535) + (v & (1 << z) - 1)];
                  continue t;
                } else {
                  t.msg = "invalid distance code", U.mode = Pn;
                  break e;
                }
                break;
              }
          } else if ((z & 64) === 0) {
            x = y[(x & 65535) + (v & (1 << z) - 1)];
            continue r;
          } else if (z & 32) {
            U.mode = d0;
            break e;
          } else {
            t.msg = "invalid literal/length code", U.mode = Pn;
            break e;
          }
          break;
        }
    } while (n < o && a < i);
  F = k >> 3, n -= F, k -= F << 3, v &= (1 << k) - 1, t.next_in = n, t.next_out = a, t.avail_in = n < o ? 5 + (o - n) : 5 - (n - o), t.avail_out = a < i ? 257 + (i - a) : 257 - (a - i), U.hold = v, U.bits = k;
};
const St = 15, Hs = 852, $s = 592, Gs = 0, Ma = 1, Ws = 2, p0 = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]), g0 = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]), b0 = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]), m0 = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]), y0 = (e, t, r, n, o, a, s, i) => {
  const h = i.bits;
  let l = 0, c = 0, w = 0, g = 0, v = 0, k = 0, y = 0, m = 0, A = 0, E = 0, x, z, F, j, I, N = null, O;
  const R = new Uint16Array(St + 1), U = new Uint16Array(St + 1);
  let T = null, Z, re, oe;
  for (l = 0; l <= St; l++)
    R[l] = 0;
  for (c = 0; c < n; c++)
    R[t[r + c]]++;
  for (v = h, g = St; g >= 1 && R[g] === 0; g--)
    ;
  if (v > g && (v = g), g === 0)
    return o[a++] = 1 << 24 | 64 << 16 | 0, o[a++] = 1 << 24 | 64 << 16 | 0, i.bits = 1, 0;
  for (w = 1; w < g && R[w] === 0; w++)
    ;
  for (v < w && (v = w), m = 1, l = 1; l <= St; l++)
    if (m <<= 1, m -= R[l], m < 0)
      return -1;
  if (m > 0 && (e === Gs || g !== 1))
    return -1;
  for (U[1] = 0, l = 1; l < St; l++)
    U[l + 1] = U[l] + R[l];
  for (c = 0; c < n; c++)
    t[r + c] !== 0 && (s[U[t[r + c]]++] = c);
  if (e === Gs ? (N = T = s, O = 20) : e === Ma ? (N = p0, T = g0, O = 257) : (N = b0, T = m0, O = 0), E = 0, c = 0, l = w, I = a, k = v, y = 0, F = -1, A = 1 << v, j = A - 1, e === Ma && A > Hs || e === Ws && A > $s)
    return 1;
  for (; ; ) {
    Z = l - y, s[c] + 1 < O ? (re = 0, oe = s[c]) : s[c] >= O ? (re = T[s[c] - O], oe = N[s[c] - O]) : (re = 96, oe = 0), x = 1 << l - y, z = 1 << k, w = z;
    do
      z -= x, o[I + (E >> y) + z] = Z << 24 | re << 16 | oe | 0;
    while (z !== 0);
    for (x = 1 << l - 1; E & x; )
      x >>= 1;
    if (x !== 0 ? (E &= x - 1, E += x) : E = 0, c++, --R[l] === 0) {
      if (l === g)
        break;
      l = t[r + s[c]];
    }
    if (l > v && (E & j) !== F) {
      for (y === 0 && (y = v), I += w, k = l - y, m = 1 << k; k + y < g && (m -= R[k + y], !(m <= 0)); )
        k++, m <<= 1;
      if (A += 1 << k, e === Ma && A > Hs || e === Ws && A > $s)
        return 1;
      F = E & j, o[F] = v << 24 | k << 16 | I - a | 0;
    }
  }
  return E !== 0 && (o[I + E] = l - y << 24 | 64 << 16 | 0), i.bits = v, 0;
};
var ln = y0;
const v0 = 0, Lf = 1, qf = 2, {
  Z_FINISH: Vs,
  Z_BLOCK: w0,
  Z_TREES: Un,
  Z_OK: wt,
  Z_STREAM_END: _0,
  Z_NEED_DICT: k0,
  Z_STREAM_ERROR: lr,
  Z_DATA_ERROR: Mf,
  Z_MEM_ERROR: Df,
  Z_BUF_ERROR: E0,
  Z_DEFLATED: Zs
} = An, Ia = 16180, Ys = 16181, Xs = 16182, Js = 16183, Qs = 16184, ec = 16185, rc = 16186, tc = 16187, nc = 16188, ac = 16189, da = 16190, Ir = 16191, Da = 16192, oc = 16193, Fa = 16194, ic = 16195, sc = 16196, cc = 16197, uc = 16198, Nn = 16199, Cn = 16200, lc = 16201, fc = 16202, dc = 16203, hc = 16204, pc = 16205, Ka = 16206, gc = 16207, bc = 16208, Ne = 16209, Ff = 16210, Kf = 16211, x0 = 852, A0 = 592, S0 = 15, I0 = S0, mc = (e) => (e >>> 24 & 255) + (e >>> 8 & 65280) + ((e & 65280) << 8) + ((e & 255) << 24);
function B0() {
  this.strm = null, this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
}
const kt = (e) => {
  if (!e)
    return 1;
  const t = e.state;
  return !t || t.strm !== e || t.mode < Ia || t.mode > Kf ? 1 : 0;
}, Hf = (e) => {
  if (kt(e))
    return lr;
  const t = e.state;
  return e.total_in = e.total_out = t.total = 0, e.msg = "", t.wrap && (e.adler = t.wrap & 1), t.mode = Ia, t.last = 0, t.havedict = 0, t.flags = -1, t.dmax = 32768, t.head = null, t.hold = 0, t.bits = 0, t.lencode = t.lendyn = new Int32Array(x0), t.distcode = t.distdyn = new Int32Array(A0), t.sane = 1, t.back = -1, wt;
}, $f = (e) => {
  if (kt(e))
    return lr;
  const t = e.state;
  return t.wsize = 0, t.whave = 0, t.wnext = 0, Hf(e);
}, Gf = (e, t) => {
  let r;
  if (kt(e))
    return lr;
  const n = e.state;
  return t < 0 ? (r = 0, t = -t) : (r = (t >> 4) + 5, t < 48 && (t &= 15)), t && (t < 8 || t > 15) ? lr : (n.window !== null && n.wbits !== t && (n.window = null), n.wrap = r, n.wbits = t, $f(e));
}, Wf = (e, t) => {
  if (!e)
    return lr;
  const r = new B0();
  e.state = r, r.strm = e, r.window = null, r.mode = Ia;
  const n = Gf(e, t);
  return n !== wt && (e.state = null), n;
}, T0 = (e) => Wf(e, I0);
let yc = !0, Ha, $a;
const z0 = (e) => {
  if (yc) {
    Ha = new Int32Array(512), $a = new Int32Array(32);
    let t = 0;
    for (; t < 144; )
      e.lens[t++] = 8;
    for (; t < 256; )
      e.lens[t++] = 9;
    for (; t < 280; )
      e.lens[t++] = 7;
    for (; t < 288; )
      e.lens[t++] = 8;
    for (ln(Lf, e.lens, 0, 288, Ha, 0, e.work, { bits: 9 }), t = 0; t < 32; )
      e.lens[t++] = 5;
    ln(qf, e.lens, 0, 32, $a, 0, e.work, { bits: 5 }), yc = !1;
  }
  e.lencode = Ha, e.lenbits = 9, e.distcode = $a, e.distbits = 5;
}, Vf = (e, t, r, n) => {
  let o;
  const a = e.state;
  return a.window === null && (a.wsize = 1 << a.wbits, a.wnext = 0, a.whave = 0, a.window = new Uint8Array(a.wsize)), n >= a.wsize ? (a.window.set(t.subarray(r - a.wsize, r), 0), a.wnext = 0, a.whave = a.wsize) : (o = a.wsize - a.wnext, o > n && (o = n), a.window.set(t.subarray(r - n, r - n + o), a.wnext), n -= o, n ? (a.window.set(t.subarray(r - n, r), 0), a.wnext = n, a.whave = a.wsize) : (a.wnext += o, a.wnext === a.wsize && (a.wnext = 0), a.whave < a.wsize && (a.whave += o))), 0;
}, O0 = (e, t) => {
  let r, n, o, a, s, i, h, l, c, w, g, v, k, y, m = 0, A, E, x, z, F, j, I, N;
  const O = new Uint8Array(4);
  let R, U;
  const T = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (kt(e) || !e.output || !e.input && e.avail_in !== 0)
    return lr;
  r = e.state, r.mode === Ir && (r.mode = Da), s = e.next_out, o = e.output, h = e.avail_out, a = e.next_in, n = e.input, i = e.avail_in, l = r.hold, c = r.bits, w = i, g = h, N = wt;
  e:
    for (; ; )
      switch (r.mode) {
        case Ia:
          if (r.wrap === 0) {
            r.mode = Da;
            break;
          }
          for (; c < 16; ) {
            if (i === 0)
              break e;
            i--, l += n[a++] << c, c += 8;
          }
          if (r.wrap & 2 && l === 35615) {
            r.wbits === 0 && (r.wbits = 15), r.check = 0, O[0] = l & 255, O[1] = l >>> 8 & 255, r.check = Ke(r.check, O, 2, 0), l = 0, c = 0, r.mode = Ys;
            break;
          }
          if (r.head && (r.head.done = !1), !(r.wrap & 1) || /* check if zlib header allowed */
          (((l & 255) << 8) + (l >> 8)) % 31) {
            e.msg = "incorrect header check", r.mode = Ne;
            break;
          }
          if ((l & 15) !== Zs) {
            e.msg = "unknown compression method", r.mode = Ne;
            break;
          }
          if (l >>>= 4, c -= 4, I = (l & 15) + 8, r.wbits === 0 && (r.wbits = I), I > 15 || I > r.wbits) {
            e.msg = "invalid window size", r.mode = Ne;
            break;
          }
          r.dmax = 1 << r.wbits, r.flags = 0, e.adler = r.check = 1, r.mode = l & 512 ? ac : Ir, l = 0, c = 0;
          break;
        case Ys:
          for (; c < 16; ) {
            if (i === 0)
              break e;
            i--, l += n[a++] << c, c += 8;
          }
          if (r.flags = l, (r.flags & 255) !== Zs) {
            e.msg = "unknown compression method", r.mode = Ne;
            break;
          }
          if (r.flags & 57344) {
            e.msg = "unknown header flags set", r.mode = Ne;
            break;
          }
          r.head && (r.head.text = l >> 8 & 1), r.flags & 512 && r.wrap & 4 && (O[0] = l & 255, O[1] = l >>> 8 & 255, r.check = Ke(r.check, O, 2, 0)), l = 0, c = 0, r.mode = Xs;
        /* falls through */
        case Xs:
          for (; c < 32; ) {
            if (i === 0)
              break e;
            i--, l += n[a++] << c, c += 8;
          }
          r.head && (r.head.time = l), r.flags & 512 && r.wrap & 4 && (O[0] = l & 255, O[1] = l >>> 8 & 255, O[2] = l >>> 16 & 255, O[3] = l >>> 24 & 255, r.check = Ke(r.check, O, 4, 0)), l = 0, c = 0, r.mode = Js;
        /* falls through */
        case Js:
          for (; c < 16; ) {
            if (i === 0)
              break e;
            i--, l += n[a++] << c, c += 8;
          }
          r.head && (r.head.xflags = l & 255, r.head.os = l >> 8), r.flags & 512 && r.wrap & 4 && (O[0] = l & 255, O[1] = l >>> 8 & 255, r.check = Ke(r.check, O, 2, 0)), l = 0, c = 0, r.mode = Qs;
        /* falls through */
        case Qs:
          if (r.flags & 1024) {
            for (; c < 16; ) {
              if (i === 0)
                break e;
              i--, l += n[a++] << c, c += 8;
            }
            r.length = l, r.head && (r.head.extra_len = l), r.flags & 512 && r.wrap & 4 && (O[0] = l & 255, O[1] = l >>> 8 & 255, r.check = Ke(r.check, O, 2, 0)), l = 0, c = 0;
          } else r.head && (r.head.extra = null);
          r.mode = ec;
        /* falls through */
        case ec:
          if (r.flags & 1024 && (v = r.length, v > i && (v = i), v && (r.head && (I = r.head.extra_len - r.length, r.head.extra || (r.head.extra = new Uint8Array(r.head.extra_len)), r.head.extra.set(
            n.subarray(
              a,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              a + v
            ),
            /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
            I
          )), r.flags & 512 && r.wrap & 4 && (r.check = Ke(r.check, n, v, a)), i -= v, a += v, r.length -= v), r.length))
            break e;
          r.length = 0, r.mode = rc;
        /* falls through */
        case rc:
          if (r.flags & 2048) {
            if (i === 0)
              break e;
            v = 0;
            do
              I = n[a + v++], r.head && I && r.length < 65536 && (r.head.name += String.fromCharCode(I));
            while (I && v < i);
            if (r.flags & 512 && r.wrap & 4 && (r.check = Ke(r.check, n, v, a)), i -= v, a += v, I)
              break e;
          } else r.head && (r.head.name = null);
          r.length = 0, r.mode = tc;
        /* falls through */
        case tc:
          if (r.flags & 4096) {
            if (i === 0)
              break e;
            v = 0;
            do
              I = n[a + v++], r.head && I && r.length < 65536 && (r.head.comment += String.fromCharCode(I));
            while (I && v < i);
            if (r.flags & 512 && r.wrap & 4 && (r.check = Ke(r.check, n, v, a)), i -= v, a += v, I)
              break e;
          } else r.head && (r.head.comment = null);
          r.mode = nc;
        /* falls through */
        case nc:
          if (r.flags & 512) {
            for (; c < 16; ) {
              if (i === 0)
                break e;
              i--, l += n[a++] << c, c += 8;
            }
            if (r.wrap & 4 && l !== (r.check & 65535)) {
              e.msg = "header crc mismatch", r.mode = Ne;
              break;
            }
            l = 0, c = 0;
          }
          r.head && (r.head.hcrc = r.flags >> 9 & 1, r.head.done = !0), e.adler = r.check = 0, r.mode = Ir;
          break;
        case ac:
          for (; c < 32; ) {
            if (i === 0)
              break e;
            i--, l += n[a++] << c, c += 8;
          }
          e.adler = r.check = mc(l), l = 0, c = 0, r.mode = da;
        /* falls through */
        case da:
          if (r.havedict === 0)
            return e.next_out = s, e.avail_out = h, e.next_in = a, e.avail_in = i, r.hold = l, r.bits = c, k0;
          e.adler = r.check = 1, r.mode = Ir;
        /* falls through */
        case Ir:
          if (t === w0 || t === Un)
            break e;
        /* falls through */
        case Da:
          if (r.last) {
            l >>>= c & 7, c -= c & 7, r.mode = Ka;
            break;
          }
          for (; c < 3; ) {
            if (i === 0)
              break e;
            i--, l += n[a++] << c, c += 8;
          }
          switch (r.last = l & 1, l >>>= 1, c -= 1, l & 3) {
            case 0:
              r.mode = oc;
              break;
            case 1:
              if (z0(r), r.mode = Nn, t === Un) {
                l >>>= 2, c -= 2;
                break e;
              }
              break;
            case 2:
              r.mode = sc;
              break;
            case 3:
              e.msg = "invalid block type", r.mode = Ne;
          }
          l >>>= 2, c -= 2;
          break;
        case oc:
          for (l >>>= c & 7, c -= c & 7; c < 32; ) {
            if (i === 0)
              break e;
            i--, l += n[a++] << c, c += 8;
          }
          if ((l & 65535) !== (l >>> 16 ^ 65535)) {
            e.msg = "invalid stored block lengths", r.mode = Ne;
            break;
          }
          if (r.length = l & 65535, l = 0, c = 0, r.mode = Fa, t === Un)
            break e;
        /* falls through */
        case Fa:
          r.mode = ic;
        /* falls through */
        case ic:
          if (v = r.length, v) {
            if (v > i && (v = i), v > h && (v = h), v === 0)
              break e;
            o.set(n.subarray(a, a + v), s), i -= v, a += v, h -= v, s += v, r.length -= v;
            break;
          }
          r.mode = Ir;
          break;
        case sc:
          for (; c < 14; ) {
            if (i === 0)
              break e;
            i--, l += n[a++] << c, c += 8;
          }
          if (r.nlen = (l & 31) + 257, l >>>= 5, c -= 5, r.ndist = (l & 31) + 1, l >>>= 5, c -= 5, r.ncode = (l & 15) + 4, l >>>= 4, c -= 4, r.nlen > 286 || r.ndist > 30) {
            e.msg = "too many length or distance symbols", r.mode = Ne;
            break;
          }
          r.have = 0, r.mode = cc;
        /* falls through */
        case cc:
          for (; r.have < r.ncode; ) {
            for (; c < 3; ) {
              if (i === 0)
                break e;
              i--, l += n[a++] << c, c += 8;
            }
            r.lens[T[r.have++]] = l & 7, l >>>= 3, c -= 3;
          }
          for (; r.have < 19; )
            r.lens[T[r.have++]] = 0;
          if (r.lencode = r.lendyn, r.lenbits = 7, R = { bits: r.lenbits }, N = ln(v0, r.lens, 0, 19, r.lencode, 0, r.work, R), r.lenbits = R.bits, N) {
            e.msg = "invalid code lengths set", r.mode = Ne;
            break;
          }
          r.have = 0, r.mode = uc;
        /* falls through */
        case uc:
          for (; r.have < r.nlen + r.ndist; ) {
            for (; m = r.lencode[l & (1 << r.lenbits) - 1], A = m >>> 24, E = m >>> 16 & 255, x = m & 65535, !(A <= c); ) {
              if (i === 0)
                break e;
              i--, l += n[a++] << c, c += 8;
            }
            if (x < 16)
              l >>>= A, c -= A, r.lens[r.have++] = x;
            else {
              if (x === 16) {
                for (U = A + 2; c < U; ) {
                  if (i === 0)
                    break e;
                  i--, l += n[a++] << c, c += 8;
                }
                if (l >>>= A, c -= A, r.have === 0) {
                  e.msg = "invalid bit length repeat", r.mode = Ne;
                  break;
                }
                I = r.lens[r.have - 1], v = 3 + (l & 3), l >>>= 2, c -= 2;
              } else if (x === 17) {
                for (U = A + 3; c < U; ) {
                  if (i === 0)
                    break e;
                  i--, l += n[a++] << c, c += 8;
                }
                l >>>= A, c -= A, I = 0, v = 3 + (l & 7), l >>>= 3, c -= 3;
              } else {
                for (U = A + 7; c < U; ) {
                  if (i === 0)
                    break e;
                  i--, l += n[a++] << c, c += 8;
                }
                l >>>= A, c -= A, I = 0, v = 11 + (l & 127), l >>>= 7, c -= 7;
              }
              if (r.have + v > r.nlen + r.ndist) {
                e.msg = "invalid bit length repeat", r.mode = Ne;
                break;
              }
              for (; v--; )
                r.lens[r.have++] = I;
            }
          }
          if (r.mode === Ne)
            break;
          if (r.lens[256] === 0) {
            e.msg = "invalid code -- missing end-of-block", r.mode = Ne;
            break;
          }
          if (r.lenbits = 9, R = { bits: r.lenbits }, N = ln(Lf, r.lens, 0, r.nlen, r.lencode, 0, r.work, R), r.lenbits = R.bits, N) {
            e.msg = "invalid literal/lengths set", r.mode = Ne;
            break;
          }
          if (r.distbits = 6, r.distcode = r.distdyn, R = { bits: r.distbits }, N = ln(qf, r.lens, r.nlen, r.ndist, r.distcode, 0, r.work, R), r.distbits = R.bits, N) {
            e.msg = "invalid distances set", r.mode = Ne;
            break;
          }
          if (r.mode = Nn, t === Un)
            break e;
        /* falls through */
        case Nn:
          r.mode = Cn;
        /* falls through */
        case Cn:
          if (i >= 6 && h >= 258) {
            e.next_out = s, e.avail_out = h, e.next_in = a, e.avail_in = i, r.hold = l, r.bits = c, h0(e, g), s = e.next_out, o = e.output, h = e.avail_out, a = e.next_in, n = e.input, i = e.avail_in, l = r.hold, c = r.bits, r.mode === Ir && (r.back = -1);
            break;
          }
          for (r.back = 0; m = r.lencode[l & (1 << r.lenbits) - 1], A = m >>> 24, E = m >>> 16 & 255, x = m & 65535, !(A <= c); ) {
            if (i === 0)
              break e;
            i--, l += n[a++] << c, c += 8;
          }
          if (E && (E & 240) === 0) {
            for (z = A, F = E, j = x; m = r.lencode[j + ((l & (1 << z + F) - 1) >> z)], A = m >>> 24, E = m >>> 16 & 255, x = m & 65535, !(z + A <= c); ) {
              if (i === 0)
                break e;
              i--, l += n[a++] << c, c += 8;
            }
            l >>>= z, c -= z, r.back += z;
          }
          if (l >>>= A, c -= A, r.back += A, r.length = x, E === 0) {
            r.mode = pc;
            break;
          }
          if (E & 32) {
            r.back = -1, r.mode = Ir;
            break;
          }
          if (E & 64) {
            e.msg = "invalid literal/length code", r.mode = Ne;
            break;
          }
          r.extra = E & 15, r.mode = lc;
        /* falls through */
        case lc:
          if (r.extra) {
            for (U = r.extra; c < U; ) {
              if (i === 0)
                break e;
              i--, l += n[a++] << c, c += 8;
            }
            r.length += l & (1 << r.extra) - 1, l >>>= r.extra, c -= r.extra, r.back += r.extra;
          }
          r.was = r.length, r.mode = fc;
        /* falls through */
        case fc:
          for (; m = r.distcode[l & (1 << r.distbits) - 1], A = m >>> 24, E = m >>> 16 & 255, x = m & 65535, !(A <= c); ) {
            if (i === 0)
              break e;
            i--, l += n[a++] << c, c += 8;
          }
          if ((E & 240) === 0) {
            for (z = A, F = E, j = x; m = r.distcode[j + ((l & (1 << z + F) - 1) >> z)], A = m >>> 24, E = m >>> 16 & 255, x = m & 65535, !(z + A <= c); ) {
              if (i === 0)
                break e;
              i--, l += n[a++] << c, c += 8;
            }
            l >>>= z, c -= z, r.back += z;
          }
          if (l >>>= A, c -= A, r.back += A, E & 64) {
            e.msg = "invalid distance code", r.mode = Ne;
            break;
          }
          r.offset = x, r.extra = E & 15, r.mode = dc;
        /* falls through */
        case dc:
          if (r.extra) {
            for (U = r.extra; c < U; ) {
              if (i === 0)
                break e;
              i--, l += n[a++] << c, c += 8;
            }
            r.offset += l & (1 << r.extra) - 1, l >>>= r.extra, c -= r.extra, r.back += r.extra;
          }
          if (r.offset > r.dmax) {
            e.msg = "invalid distance too far back", r.mode = Ne;
            break;
          }
          r.mode = hc;
        /* falls through */
        case hc:
          if (h === 0)
            break e;
          if (v = g - h, r.offset > v) {
            if (v = r.offset - v, v > r.whave && r.sane) {
              e.msg = "invalid distance too far back", r.mode = Ne;
              break;
            }
            v > r.wnext ? (v -= r.wnext, k = r.wsize - v) : k = r.wnext - v, v > r.length && (v = r.length), y = r.window;
          } else
            y = o, k = s - r.offset, v = r.length;
          v > h && (v = h), h -= v, r.length -= v;
          do
            o[s++] = y[k++];
          while (--v);
          r.length === 0 && (r.mode = Cn);
          break;
        case pc:
          if (h === 0)
            break e;
          o[s++] = r.length, h--, r.mode = Cn;
          break;
        case Ka:
          if (r.wrap) {
            for (; c < 32; ) {
              if (i === 0)
                break e;
              i--, l |= n[a++] << c, c += 8;
            }
            if (g -= h, e.total_out += g, r.total += g, r.wrap & 4 && g && (e.adler = r.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
            r.flags ? Ke(r.check, o, g, s - g) : bn(r.check, o, g, s - g)), g = h, r.wrap & 4 && (r.flags ? l : mc(l)) !== r.check) {
              e.msg = "incorrect data check", r.mode = Ne;
              break;
            }
            l = 0, c = 0;
          }
          r.mode = gc;
        /* falls through */
        case gc:
          if (r.wrap && r.flags) {
            for (; c < 32; ) {
              if (i === 0)
                break e;
              i--, l += n[a++] << c, c += 8;
            }
            if (r.wrap & 4 && l !== (r.total & 4294967295)) {
              e.msg = "incorrect length check", r.mode = Ne;
              break;
            }
            l = 0, c = 0;
          }
          r.mode = bc;
        /* falls through */
        case bc:
          N = _0;
          break e;
        case Ne:
          N = Mf;
          break e;
        case Ff:
          return Df;
        case Kf:
        /* falls through */
        default:
          return lr;
      }
  return e.next_out = s, e.avail_out = h, e.next_in = a, e.avail_in = i, r.hold = l, r.bits = c, (r.wsize || g !== e.avail_out && r.mode < Ne && (r.mode < Ka || t !== Vs)) && Vf(e, e.output, e.next_out, g - e.avail_out), w -= e.avail_in, g -= e.avail_out, e.total_in += w, e.total_out += g, r.total += g, r.wrap & 4 && g && (e.adler = r.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
  r.flags ? Ke(r.check, o, g, e.next_out - g) : bn(r.check, o, g, e.next_out - g)), e.data_type = r.bits + (r.last ? 64 : 0) + (r.mode === Ir ? 128 : 0) + (r.mode === Nn || r.mode === Fa ? 256 : 0), (w === 0 && g === 0 || t === Vs) && N === wt && (N = E0), N;
}, R0 = (e) => {
  if (kt(e))
    return lr;
  let t = e.state;
  return t.window && (t.window = null), e.state = null, wt;
}, j0 = (e, t) => {
  if (kt(e))
    return lr;
  const r = e.state;
  return (r.wrap & 2) === 0 ? lr : (r.head = t, t.done = !1, wt);
}, P0 = (e, t) => {
  const r = t.length;
  let n, o, a;
  return kt(e) || (n = e.state, n.wrap !== 0 && n.mode !== da) ? lr : n.mode === da && (o = 1, o = bn(o, t, r, 0), o !== n.check) ? Mf : (a = Vf(e, t, r, r), a ? (n.mode = Ff, Df) : (n.havedict = 1, wt));
};
var U0 = $f, N0 = Gf, C0 = Hf, L0 = T0, q0 = Wf, M0 = O0, D0 = R0, F0 = j0, K0 = P0, H0 = "pako inflate (from Nodeca project)", Ur = {
  inflateReset: U0,
  inflateReset2: N0,
  inflateResetKeep: C0,
  inflateInit: L0,
  inflateInit2: q0,
  inflate: M0,
  inflateEnd: D0,
  inflateGetHeader: F0,
  inflateSetDictionary: K0,
  inflateInfo: H0
};
function $0() {
  this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
}
var G0 = $0;
const Zf = Object.prototype.toString, {
  Z_NO_FLUSH: W0,
  Z_FINISH: V0,
  Z_OK: vn,
  Z_STREAM_END: Ga,
  Z_NEED_DICT: Wa,
  Z_STREAM_ERROR: Z0,
  Z_DATA_ERROR: vc,
  Z_MEM_ERROR: Y0
} = An;
function Bn(e) {
  this.options = Sa.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, e || {});
  const t = this.options;
  t.raw && t.windowBits >= 0 && t.windowBits < 16 && (t.windowBits = -t.windowBits, t.windowBits === 0 && (t.windowBits = -15)), t.windowBits >= 0 && t.windowBits < 16 && !(e && e.windowBits) && (t.windowBits += 32), t.windowBits > 15 && t.windowBits < 48 && (t.windowBits & 15) === 0 && (t.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new Nf(), this.strm.avail_out = 0;
  let r = Ur.inflateInit2(
    this.strm,
    t.windowBits
  );
  if (r !== vn)
    throw new Error(yt[r]);
  if (this.header = new G0(), Ur.inflateGetHeader(this.strm, this.header), t.dictionary && (typeof t.dictionary == "string" ? t.dictionary = yn.string2buf(t.dictionary) : Zf.call(t.dictionary) === "[object ArrayBuffer]" && (t.dictionary = new Uint8Array(t.dictionary)), t.raw && (r = Ur.inflateSetDictionary(this.strm, t.dictionary), r !== vn)))
    throw new Error(yt[r]);
}
Bn.prototype.push = function(e, t) {
  const r = this.strm, n = this.options.chunkSize, o = this.options.dictionary;
  let a, s, i;
  if (this.ended) return !1;
  for (t === ~~t ? s = t : s = t === !0 ? V0 : W0, Zf.call(e) === "[object ArrayBuffer]" ? r.input = new Uint8Array(e) : r.input = e, r.next_in = 0, r.avail_in = r.input.length; ; ) {
    for (r.avail_out === 0 && (r.output = new Uint8Array(n), r.next_out = 0, r.avail_out = n), a = Ur.inflate(r, s), a === Wa && o && (a = Ur.inflateSetDictionary(r, o), a === vn ? a = Ur.inflate(r, s) : a === vc && (a = Wa)); r.avail_in > 0 && a === Ga && r.state.wrap > 0 && e[r.next_in] !== 0; )
      Ur.inflateReset(r), a = Ur.inflate(r, s);
    switch (a) {
      case Z0:
      case vc:
      case Wa:
      case Y0:
        return this.onEnd(a), this.ended = !0, !1;
    }
    if (i = r.avail_out, r.next_out && (r.avail_out === 0 || a === Ga))
      if (this.options.to === "string") {
        let h = yn.utf8border(r.output, r.next_out), l = r.next_out - h, c = yn.buf2string(r.output, h);
        r.next_out = l, r.avail_out = n - l, l && r.output.set(r.output.subarray(h, h + l), 0), this.onData(c);
      } else
        this.onData(r.output.length === r.next_out ? r.output : r.output.subarray(0, r.next_out));
    if (!(a === vn && i === 0)) {
      if (a === Ga)
        return a = Ur.inflateEnd(this.strm), this.onEnd(a), this.ended = !0, !0;
      if (r.avail_in === 0) break;
    }
  }
  return !0;
};
Bn.prototype.onData = function(e) {
  this.chunks.push(e);
};
Bn.prototype.onEnd = function(e) {
  e === vn && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = Sa.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
};
function hs(e, t) {
  const r = new Bn(t);
  if (r.push(e), r.err) throw r.msg || yt[r.err];
  return r.result;
}
function X0(e, t) {
  return t = t || {}, t.raw = !0, hs(e, t);
}
var J0 = Bn, Q0 = hs, eg = X0, rg = hs, tg = {
  Inflate: J0,
  inflate: Q0,
  inflateRaw: eg,
  ungzip: rg
};
const { Deflate: ng, deflate: ag, deflateRaw: og, gzip: ig } = f0, { Inflate: sg, inflate: cg, inflateRaw: ug, ungzip: lg } = tg;
var fg = ng, dg = ag, hg = og, pg = ig, gg = sg, bg = cg, mg = ug, yg = lg, vg = An, sv = {
  Deflate: fg,
  deflate: dg,
  deflateRaw: hg,
  gzip: pg,
  Inflate: gg,
  inflate: bg,
  inflateRaw: mg,
  ungzip: yg,
  constants: vg
}, ct = {}, wc;
function wg() {
  if (wc) return ct;
  wc = 1, Object.defineProperty(ct, "__esModule", { value: !0 }), ct.bech32m = ct.bech32 = void 0;
  const e = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", t = {};
  for (let l = 0; l < e.length; l++) {
    const c = e.charAt(l);
    t[c] = l;
  }
  function r(l) {
    const c = l >> 25;
    return (l & 33554431) << 5 ^ -(c >> 0 & 1) & 996825010 ^ -(c >> 1 & 1) & 642813549 ^ -(c >> 2 & 1) & 513874426 ^ -(c >> 3 & 1) & 1027748829 ^ -(c >> 4 & 1) & 705979059;
  }
  function n(l) {
    let c = 1;
    for (let w = 0; w < l.length; ++w) {
      const g = l.charCodeAt(w);
      if (g < 33 || g > 126)
        return "Invalid prefix (" + l + ")";
      c = r(c) ^ g >> 5;
    }
    c = r(c);
    for (let w = 0; w < l.length; ++w) {
      const g = l.charCodeAt(w);
      c = r(c) ^ g & 31;
    }
    return c;
  }
  function o(l, c, w, g) {
    let v = 0, k = 0;
    const y = (1 << w) - 1, m = [];
    for (let A = 0; A < l.length; ++A)
      for (v = v << c | l[A], k += c; k >= w; )
        k -= w, m.push(v >> k & y);
    if (g)
      k > 0 && m.push(v << w - k & y);
    else {
      if (k >= c)
        return "Excess padding";
      if (v << w - k & y)
        return "Non-zero padding";
    }
    return m;
  }
  function a(l) {
    return o(l, 8, 5, !0);
  }
  function s(l) {
    const c = o(l, 5, 8, !1);
    if (Array.isArray(c))
      return c;
  }
  function i(l) {
    const c = o(l, 5, 8, !1);
    if (Array.isArray(c))
      return c;
    throw new Error(c);
  }
  function h(l) {
    let c;
    l === "bech32" ? c = 1 : c = 734539939;
    function w(y, m, A) {
      if (A = A || 90, y.length + 7 + m.length > A)
        throw new TypeError("Exceeds length limit");
      y = y.toLowerCase();
      let E = n(y);
      if (typeof E == "string")
        throw new Error(E);
      let x = y + "1";
      for (let z = 0; z < m.length; ++z) {
        const F = m[z];
        if (F >> 5 !== 0)
          throw new Error("Non 5-bit word");
        E = r(E) ^ F, x += e.charAt(F);
      }
      for (let z = 0; z < 6; ++z)
        E = r(E);
      E ^= c;
      for (let z = 0; z < 6; ++z) {
        const F = E >> (5 - z) * 5 & 31;
        x += e.charAt(F);
      }
      return x;
    }
    function g(y, m) {
      if (m = m || 90, y.length < 8)
        return y + " too short";
      if (y.length > m)
        return "Exceeds length limit";
      const A = y.toLowerCase(), E = y.toUpperCase();
      if (y !== A && y !== E)
        return "Mixed-case string " + y;
      y = A;
      const x = y.lastIndexOf("1");
      if (x === -1)
        return "No separator character for " + y;
      if (x === 0)
        return "Missing prefix for " + y;
      const z = y.slice(0, x), F = y.slice(x + 1);
      if (F.length < 6)
        return "Data too short";
      let j = n(z);
      if (typeof j == "string")
        return j;
      const I = [];
      for (let N = 0; N < F.length; ++N) {
        const O = F.charAt(N), R = t[O];
        if (R === void 0)
          return "Unknown character " + O;
        j = r(j) ^ R, !(N + 6 >= F.length) && I.push(R);
      }
      return j !== c ? "Invalid checksum for " + y : { prefix: z, words: I };
    }
    function v(y, m) {
      const A = g(y, m);
      if (typeof A == "object")
        return A;
    }
    function k(y, m) {
      const A = g(y, m);
      if (typeof A == "object")
        return A;
      throw new Error(A);
    }
    return {
      decodeUnsafe: v,
      decode: k,
      encode: w,
      toWords: a,
      fromWordsUnsafe: s,
      fromWords: i
    };
  }
  return ct.bech32 = h("bech32"), ct.bech32m = h("bech32m"), ct;
}
var cv = wg();
function _g(e) {
  if (e.length >= 255)
    throw new TypeError("Alphabet too long");
  const t = new Uint8Array(256);
  for (let l = 0; l < t.length; l++)
    t[l] = 255;
  for (let l = 0; l < e.length; l++) {
    const c = e.charAt(l), w = c.charCodeAt(0);
    if (t[w] !== 255)
      throw new TypeError(c + " is ambiguous");
    t[w] = l;
  }
  const r = e.length, n = e.charAt(0), o = Math.log(r) / Math.log(256), a = Math.log(256) / Math.log(r);
  function s(l) {
    if (l instanceof Uint8Array || (ArrayBuffer.isView(l) ? l = new Uint8Array(l.buffer, l.byteOffset, l.byteLength) : Array.isArray(l) && (l = Uint8Array.from(l))), !(l instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (l.length === 0)
      return "";
    let c = 0, w = 0, g = 0;
    const v = l.length;
    for (; g !== v && l[g] === 0; )
      g++, c++;
    const k = (v - g) * a + 1 >>> 0, y = new Uint8Array(k);
    for (; g !== v; ) {
      let E = l[g], x = 0;
      for (let z = k - 1; (E !== 0 || x < w) && z !== -1; z--, x++)
        E += 256 * y[z] >>> 0, y[z] = E % r >>> 0, E = E / r >>> 0;
      if (E !== 0)
        throw new Error("Non-zero carry");
      w = x, g++;
    }
    let m = k - w;
    for (; m !== k && y[m] === 0; )
      m++;
    let A = n.repeat(c);
    for (; m < k; ++m)
      A += e.charAt(y[m]);
    return A;
  }
  function i(l) {
    if (typeof l != "string")
      throw new TypeError("Expected String");
    if (l.length === 0)
      return new Uint8Array();
    let c = 0, w = 0, g = 0;
    for (; l[c] === n; )
      w++, c++;
    const v = (l.length - c) * o + 1 >>> 0, k = new Uint8Array(v);
    for (; c < l.length; ) {
      const E = l.charCodeAt(c);
      if (E > 255)
        return;
      let x = t[E];
      if (x === 255)
        return;
      let z = 0;
      for (let F = v - 1; (x !== 0 || z < g) && F !== -1; F--, z++)
        x += r * k[F] >>> 0, k[F] = x % 256 >>> 0, x = x / 256 >>> 0;
      if (x !== 0)
        throw new Error("Non-zero carry");
      g = z, c++;
    }
    let y = v - g;
    for (; y !== v && k[y] === 0; )
      y++;
    const m = new Uint8Array(w + (v - y));
    let A = w;
    for (; y !== v; )
      m[A++] = k[y++];
    return m;
  }
  function h(l) {
    const c = i(l);
    if (c)
      return c;
    throw new Error("Non-base" + r + " character");
  }
  return {
    encode: s,
    decodeUnsafe: i,
    decode: h
  };
}
var kg = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
const Va = _g(kg);
function Eg(e) {
  function t(a) {
    var s = Uint8Array.from(a), i = e(s), h = s.length + 4, l = new Uint8Array(h);
    return l.set(s, 0), l.set(i.subarray(0, 4), s.length), Va.encode(l);
  }
  function r(a) {
    var s = a.slice(0, -4), i = a.slice(-4), h = e(s);
    if (!(i[0] ^ h[0] | i[1] ^ h[1] | i[2] ^ h[2] | i[3] ^ h[3]))
      return s;
  }
  function n(a) {
    var s = Va.decodeUnsafe(a);
    if (s != null)
      return r(s);
  }
  function o(a) {
    var s = Va.decode(a), i = r(s);
    if (i == null)
      throw new Error("Invalid checksum");
    return i;
  }
  return {
    encode: t,
    decode: o,
    decodeUnsafe: n
  };
}
function xg(e) {
  return fn(fn(e));
}
const uv = Eg(xg);
var Za, _c;
function ps() {
  if (_c) return Za;
  _c = 1;
  var e = {
    Array: function(r) {
      return r != null && r.constructor === Array;
    },
    Boolean: function(r) {
      return typeof r == "boolean";
    },
    Function: function(r) {
      return typeof r == "function";
    },
    Nil: function(r) {
      return r == null;
    },
    Number: function(r) {
      return typeof r == "number";
    },
    Object: function(r) {
      return typeof r == "object";
    },
    String: function(r) {
      return typeof r == "string";
    },
    "": function() {
      return !0;
    }
  };
  e.Null = e.Nil;
  for (var t in e)
    e[t].toJSON = function(r) {
      return r;
    }.bind(null, t);
  return Za = e, Za;
}
var Ya, kc;
function Yf() {
  if (kc) return Ya;
  kc = 1;
  var e = ps();
  function t(g) {
    return g.name || g.toString().match(/function (.*?)\s*\(/)[1];
  }
  function r(g) {
    return e.Nil(g) ? "" : t(g.constructor);
  }
  function n(g) {
    return e.Function(g) ? "" : e.String(g) ? JSON.stringify(g) : g && e.Object(g) ? "" : g;
  }
  function o(g, v) {
    Error.captureStackTrace && Error.captureStackTrace(g, v);
  }
  function a(g) {
    return e.Function(g) ? g.toJSON ? g.toJSON() : t(g) : e.Array(g) ? "Array" : g && e.Object(g) ? "Object" : g !== void 0 ? g : "";
  }
  function s(g, v, k) {
    var y = n(v);
    return "Expected " + a(g) + ", got" + (k !== "" ? " " + k : "") + (y !== "" ? " " + y : "");
  }
  function i(g, v, k) {
    k = k || r(v), this.message = s(g, v, k), o(this, i), this.__type = g, this.__value = v, this.__valueTypeName = k;
  }
  i.prototype = Object.create(Error.prototype), i.prototype.constructor = i;
  function h(g, v, k, y, m) {
    var A = '" of type ';
    return v === "key" && (A = '" with key type '), s('property "' + a(k) + A + a(g), y, m);
  }
  function l(g, v, k, y, m) {
    g ? (m = m || r(y), this.message = h(g, k, v, y, m)) : this.message = 'Unexpected property "' + v + '"', o(this, i), this.__label = k, this.__property = v, this.__type = g, this.__value = y, this.__valueTypeName = m;
  }
  l.prototype = Object.create(Error.prototype), l.prototype.constructor = i;
  function c(g, v) {
    return new i(g, {}, v);
  }
  function w(g, v, k) {
    return g instanceof l ? (v = v + "." + g.__property, g = new l(
      g.__type,
      v,
      g.__label,
      g.__value,
      g.__valueTypeName
    )) : g instanceof i && (g = new l(
      g.__type,
      v,
      k,
      g.__value,
      g.__valueTypeName
    )), o(g), g;
  }
  return Ya = {
    TfTypeError: i,
    TfPropertyTypeError: l,
    tfCustomError: c,
    tfSubError: w,
    tfJSON: a,
    getValueTypeName: r
  }, Ya;
}
var Xa, Ec;
function Ag() {
  if (Ec) return Xa;
  Ec = 1;
  var e = ps(), t = Yf();
  function r(j) {
    return J.isBuffer(j);
  }
  function n(j) {
    return typeof j == "string" && /^([0-9a-f]{2})+$/i.test(j);
  }
  function o(j, I) {
    var N = j.toJSON();
    function O(R) {
      if (!j(R)) return !1;
      if (R.length === I) return !0;
      throw t.tfCustomError(N + "(Length: " + I + ")", N + "(Length: " + R.length + ")");
    }
    return O.toJSON = function() {
      return N;
    }, O;
  }
  var a = o.bind(null, e.Array), s = o.bind(null, r), i = o.bind(null, n), h = o.bind(null, e.String);
  function l(j, I, N) {
    N = N || e.Number;
    function O(R, U) {
      return N(R, U) && R > j && R < I;
    }
    return O.toJSON = function() {
      return `${N.toJSON()} between [${j}, ${I}]`;
    }, O;
  }
  var c = Math.pow(2, 53) - 1;
  function w(j) {
    return typeof j == "number" && isFinite(j);
  }
  function g(j) {
    return j << 24 >> 24 === j;
  }
  function v(j) {
    return j << 16 >> 16 === j;
  }
  function k(j) {
    return (j | 0) === j;
  }
  function y(j) {
    return typeof j == "number" && j >= -c && j <= c && Math.floor(j) === j;
  }
  function m(j) {
    return (j & 255) === j;
  }
  function A(j) {
    return (j & 65535) === j;
  }
  function E(j) {
    return j >>> 0 === j;
  }
  function x(j) {
    return typeof j == "number" && j >= 0 && j <= c && Math.floor(j) === j;
  }
  var z = {
    ArrayN: a,
    Buffer: r,
    BufferN: s,
    Finite: w,
    Hex: n,
    HexN: i,
    Int8: g,
    Int16: v,
    Int32: k,
    Int53: y,
    Range: l,
    StringN: h,
    UInt8: m,
    UInt16: A,
    UInt32: E,
    UInt53: x
  };
  for (var F in z)
    z[F].toJSON = function(j) {
      return j;
    }.bind(null, F);
  return Xa = z, Xa;
}
var Ja, xc;
function Xf() {
  if (xc) return Ja;
  xc = 1;
  var e = Yf(), t = ps(), r = e.tfJSON, n = e.TfTypeError, o = e.TfPropertyTypeError, a = e.tfSubError, s = e.getValueTypeName, i = {
    arrayOf: function(v, k) {
      v = h(v), k = k || {};
      function y(m, A) {
        return !t.Array(m) || t.Nil(m) || k.minLength !== void 0 && m.length < k.minLength || k.maxLength !== void 0 && m.length > k.maxLength || k.length !== void 0 && m.length !== k.length ? !1 : m.every(function(E, x) {
          try {
            return l(v, E, A);
          } catch (z) {
            throw a(z, x);
          }
        });
      }
      return y.toJSON = function() {
        var m = "[" + r(v) + "]";
        return k.length !== void 0 ? m += "{" + k.length + "}" : (k.minLength !== void 0 || k.maxLength !== void 0) && (m += "{" + (k.minLength === void 0 ? 0 : k.minLength) + "," + (k.maxLength === void 0 ? 1 / 0 : k.maxLength) + "}"), m;
      }, y;
    },
    maybe: function g(v) {
      v = h(v);
      function k(y, m) {
        return t.Nil(y) || v(y, m, g);
      }
      return k.toJSON = function() {
        return "?" + r(v);
      }, k;
    },
    map: function(v, k) {
      v = h(v), k && (k = h(k));
      function y(m, A) {
        if (!t.Object(m) || t.Nil(m)) return !1;
        for (var E in m) {
          try {
            k && l(k, E, A);
          } catch (z) {
            throw a(z, E, "key");
          }
          try {
            var x = m[E];
            l(v, x, A);
          } catch (z) {
            throw a(z, E);
          }
        }
        return !0;
      }
      return k ? y.toJSON = function() {
        return "{" + r(k) + ": " + r(v) + "}";
      } : y.toJSON = function() {
        return "{" + r(v) + "}";
      }, y;
    },
    object: function(v) {
      var k = {};
      for (var y in v)
        k[y] = h(v[y]);
      function m(A, E) {
        if (!t.Object(A) || t.Nil(A)) return !1;
        var x;
        try {
          for (x in k) {
            var z = k[x], F = A[x];
            l(z, F, E);
          }
        } catch (j) {
          throw a(j, x);
        }
        if (E) {
          for (x in A)
            if (!k[x])
              throw new o(void 0, x);
        }
        return !0;
      }
      return m.toJSON = function() {
        return r(k);
      }, m;
    },
    anyOf: function() {
      var v = [].slice.call(arguments).map(h);
      function k(y, m) {
        return v.some(function(A) {
          try {
            return l(A, y, m);
          } catch {
            return !1;
          }
        });
      }
      return k.toJSON = function() {
        return v.map(r).join("|");
      }, k;
    },
    allOf: function() {
      var v = [].slice.call(arguments).map(h);
      function k(y, m) {
        return v.every(function(A) {
          try {
            return l(A, y, m);
          } catch {
            return !1;
          }
        });
      }
      return k.toJSON = function() {
        return v.map(r).join(" & ");
      }, k;
    },
    quacksLike: function(v) {
      function k(y) {
        return v === s(y);
      }
      return k.toJSON = function() {
        return v;
      }, k;
    },
    tuple: function() {
      var v = [].slice.call(arguments).map(h);
      function k(y, m) {
        return t.Nil(y) || t.Nil(y.length) || m && y.length !== v.length ? !1 : v.every(function(A, E) {
          try {
            return l(A, y[E], m);
          } catch (x) {
            throw a(x, E);
          }
        });
      }
      return k.toJSON = function() {
        return "(" + v.map(r).join(", ") + ")";
      }, k;
    },
    value: function(v) {
      function k(y) {
        return y === v;
      }
      return k.toJSON = function() {
        return v;
      }, k;
    }
  };
  i.oneOf = i.anyOf;
  function h(g) {
    if (t.String(g))
      return g[0] === "?" ? i.maybe(g.slice(1)) : t[g] || i.quacksLike(g);
    if (g && t.Object(g)) {
      if (t.Array(g)) {
        if (g.length !== 1) throw new TypeError("Expected compile() parameter of type Array of length 1");
        return i.arrayOf(g[0]);
      }
      return i.object(g);
    } else if (t.Function(g))
      return g;
    return i.value(g);
  }
  function l(g, v, k, y) {
    if (t.Function(g)) {
      if (g(v, k)) return !0;
      throw new n(y || g, v);
    }
    return l(h(g), v, k);
  }
  for (var c in t)
    l[c] = t[c];
  for (c in i)
    l[c] = i[c];
  var w = Ag();
  for (c in w)
    l[c] = w[c];
  return l.compile = h, l.TfTypeError = n, l.TfPropertyTypeError = o, Ja = l, Ja;
}
var Sg = Xf();
const lv = /* @__PURE__ */ Ea(Sg), Jf = "0123456789abcdefABCDEF";
Jf.split("").map((e) => e.codePointAt(0));
Array(256).fill(!0).map((e, t) => {
  const r = String.fromCodePoint(t), n = Jf.indexOf(r);
  return n < 0 ? void 0 : n < 16 ? n : n - 6;
});
new TextEncoder();
new TextDecoder();
function Ig(e, t, r, n) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 65535)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 65535. Received ${r}`);
  n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255) : (e[t] = r >> 8 & 255, e[t + 1] = r & 255);
}
function Bg(e, t, r, n) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 4294967295)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${4294967295}. Received ${r}`);
  n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255, e[t + 2] = r >> 16 & 255, e[t + 3] = r >> 24 & 255) : (e[t] = r >> 24 & 255, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = r & 255);
}
function Tg(e, t, r, n) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 0xffffffffffffffffn)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffffffffffffffffn}. Received ${r}`);
  n === "LE" ? (e[t] = Number(r & 0xffn), e[t + 1] = Number(r >> 8n & 0xffn), e[t + 2] = Number(r >> 16n & 0xffn), e[t + 3] = Number(r >> 24n & 0xffn), e[t + 4] = Number(r >> 32n & 0xffn), e[t + 5] = Number(r >> 40n & 0xffn), e[t + 6] = Number(r >> 48n & 0xffn), e[t + 7] = Number(r >> 56n & 0xffn)) : (e[t] = Number(r >> 56n & 0xffn), e[t + 1] = Number(r >> 48n & 0xffn), e[t + 2] = Number(r >> 40n & 0xffn), e[t + 3] = Number(r >> 32n & 0xffn), e[t + 4] = Number(r >> 24n & 0xffn), e[t + 5] = Number(r >> 16n & 0xffn), e[t + 6] = Number(r >> 8n & 0xffn), e[t + 7] = Number(r & 0xffn));
}
function zg(e, t, r) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0;
    return n = (n << 8) + e[t + 1], n = (n << 8) + e[t], n;
  } else {
    let n = 0;
    return n = (n << 8) + e[t], n = (n << 8) + e[t + 1], n;
  }
}
function Og(e, t, r) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0;
    return n = (n << 8) + e[t + 3] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t] >>> 0, n;
  } else {
    let n = 0;
    return n = (n << 8) + e[t] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 3] >>> 0, n;
  }
}
function Rg(e, t, r) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0n;
    return n = (n << 8n) + BigInt(e[t + 7]), n = (n << 8n) + BigInt(e[t + 6]), n = (n << 8n) + BigInt(e[t + 5]), n = (n << 8n) + BigInt(e[t + 4]), n = (n << 8n) + BigInt(e[t + 3]), n = (n << 8n) + BigInt(e[t + 2]), n = (n << 8n) + BigInt(e[t + 1]), n = (n << 8n) + BigInt(e[t]), n;
  } else {
    let n = 0n;
    return n = (n << 8n) + BigInt(e[t]), n = (n << 8n) + BigInt(e[t + 1]), n = (n << 8n) + BigInt(e[t + 2]), n = (n << 8n) + BigInt(e[t + 3]), n = (n << 8n) + BigInt(e[t + 4]), n = (n << 8n) + BigInt(e[t + 5]), n = (n << 8n) + BigInt(e[t + 6]), n = (n << 8n) + BigInt(e[t + 7]), n;
  }
}
const jg = (e) => {
  if (e < 0 || e > 0xffffffffffffffffn)
    throw new RangeError("value out of range");
};
function Pg(e) {
  if (e < 0 || e > Number.MAX_SAFE_INTEGER || e % 1 !== 0)
    throw new RangeError("value out of range");
}
function Qf(e) {
  typeof e == "number" ? Pg(e) : jg(e);
}
function fv(e, t, r) {
  Qf(e), r === void 0 && (r = 0), t === void 0 && (t = new Uint8Array(Ug(e)));
  let n = 0;
  return e < 253 ? (t.set([Number(e)], r), n = 1) : e <= 65535 ? (t.set([253], r), Ig(t, r + 1, Number(e), "LE"), n = 3) : e <= 4294967295 ? (t.set([254], r), Bg(t, r + 1, Number(e), "LE"), n = 5) : (t.set([255], r), Tg(t, r + 1, BigInt(e), "LE"), n = 9), { buffer: t, bytes: n };
}
function dv(e, t) {
  t === void 0 && (t = 0);
  const r = e.at(t);
  if (r === void 0)
    throw new Error("buffer too small");
  if (r < 253)
    return { numberValue: r, bigintValue: BigInt(r), bytes: 1 };
  if (r === 253) {
    const n = zg(e, t + 1, "LE");
    return {
      numberValue: n,
      bigintValue: BigInt(n),
      bytes: 3
    };
  } else if (r === 254) {
    const n = Og(e, t + 1, "LE");
    return {
      numberValue: n,
      bigintValue: BigInt(n),
      bytes: 5
    };
  } else {
    const n = Rg(e, t + 1, "LE");
    return { numberValue: n <= Number.MAX_SAFE_INTEGER ? Number(n) : null, bigintValue: n, bytes: 9 };
  }
}
function Ug(e) {
  return Qf(e), e < 253 ? 1 : e <= 65535 ? 3 : e <= 4294967295 ? 5 : 9;
}
var Ln = {}, qn = {}, Qa = {}, It = {}, Bt = {}, eo = {}, Ac;
function Ge() {
  return Ac || (Ac = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), (function(t) {
      t[t.UNSIGNED_TX = 0] = "UNSIGNED_TX", t[t.GLOBAL_XPUB = 1] = "GLOBAL_XPUB";
    })(e.GlobalTypes || (e.GlobalTypes = {})), e.GLOBAL_TYPE_NAMES = ["unsignedTx", "globalXpub"], (function(t) {
      t[t.NON_WITNESS_UTXO = 0] = "NON_WITNESS_UTXO", t[t.WITNESS_UTXO = 1] = "WITNESS_UTXO", t[t.PARTIAL_SIG = 2] = "PARTIAL_SIG", t[t.SIGHASH_TYPE = 3] = "SIGHASH_TYPE", t[t.REDEEM_SCRIPT = 4] = "REDEEM_SCRIPT", t[t.WITNESS_SCRIPT = 5] = "WITNESS_SCRIPT", t[t.BIP32_DERIVATION = 6] = "BIP32_DERIVATION", t[t.FINAL_SCRIPTSIG = 7] = "FINAL_SCRIPTSIG", t[t.FINAL_SCRIPTWITNESS = 8] = "FINAL_SCRIPTWITNESS", t[t.POR_COMMITMENT = 9] = "POR_COMMITMENT", t[t.TAP_KEY_SIG = 19] = "TAP_KEY_SIG", t[t.TAP_SCRIPT_SIG = 20] = "TAP_SCRIPT_SIG", t[t.TAP_LEAF_SCRIPT = 21] = "TAP_LEAF_SCRIPT", t[t.TAP_BIP32_DERIVATION = 22] = "TAP_BIP32_DERIVATION", t[t.TAP_INTERNAL_KEY = 23] = "TAP_INTERNAL_KEY", t[t.TAP_MERKLE_ROOT = 24] = "TAP_MERKLE_ROOT";
    })(e.InputTypes || (e.InputTypes = {})), e.INPUT_TYPE_NAMES = [
      "nonWitnessUtxo",
      "witnessUtxo",
      "partialSig",
      "sighashType",
      "redeemScript",
      "witnessScript",
      "bip32Derivation",
      "finalScriptSig",
      "finalScriptWitness",
      "porCommitment",
      "tapKeySig",
      "tapScriptSig",
      "tapLeafScript",
      "tapBip32Derivation",
      "tapInternalKey",
      "tapMerkleRoot"
    ], (function(t) {
      t[t.REDEEM_SCRIPT = 0] = "REDEEM_SCRIPT", t[t.WITNESS_SCRIPT = 1] = "WITNESS_SCRIPT", t[t.BIP32_DERIVATION = 2] = "BIP32_DERIVATION", t[t.TAP_INTERNAL_KEY = 5] = "TAP_INTERNAL_KEY", t[t.TAP_TREE = 6] = "TAP_TREE", t[t.TAP_BIP32_DERIVATION = 7] = "TAP_BIP32_DERIVATION";
    })(e.OutputTypes || (e.OutputTypes = {})), e.OUTPUT_TYPE_NAMES = [
      "redeemScript",
      "witnessScript",
      "bip32Derivation",
      "tapInternalKey",
      "tapTree",
      "tapBip32Derivation"
    ];
  })(eo)), eo;
}
var qr = {}, Sc;
function Ng() {
  if (Sc) return qr;
  Sc = 1, Object.defineProperty(qr, "__esModule", { value: !0 });
  const e = Ge(), t = (s) => [...Array(s).keys()];
  function r(s) {
    if (s.key[0] !== e.GlobalTypes.GLOBAL_XPUB)
      throw new Error(
        "Decode Error: could not decode globalXpub with key 0x" + s.key.toString("hex")
      );
    if (s.key.length !== 79 || ![2, 3].includes(s.key[46]))
      throw new Error(
        "Decode Error: globalXpub has invalid extended pubkey in key 0x" + s.key.toString("hex")
      );
    if (s.value.length / 4 % 1 !== 0)
      throw new Error(
        "Decode Error: Global GLOBAL_XPUB value length should be multiple of 4"
      );
    const i = s.key.slice(1), h = {
      masterFingerprint: s.value.slice(0, 4),
      extendedPubkey: i,
      path: "m"
    };
    for (const l of t(s.value.length / 4 - 1)) {
      const c = s.value.readUInt32LE(l * 4 + 4), w = !!(c & 2147483648), g = c & 2147483647;
      h.path += "/" + g.toString(10) + (w ? "'" : "");
    }
    return h;
  }
  qr.decode = r;
  function n(s) {
    const i = J.from([e.GlobalTypes.GLOBAL_XPUB]), h = J.concat([i, s.extendedPubkey]), l = s.path.split("/"), c = J.allocUnsafe(l.length * 4);
    s.masterFingerprint.copy(c, 0);
    let w = 4;
    return l.slice(1).forEach((g) => {
      const v = g.slice(-1) === "'";
      let k = 2147483647 & parseInt(v ? g.slice(0, -1) : g, 10);
      v && (k += 2147483648), c.writeUInt32LE(k, w), w += 4;
    }), {
      key: h,
      value: c
    };
  }
  qr.encode = n, qr.expected = "{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }";
  function o(s) {
    const i = s.extendedPubkey, h = s.masterFingerprint, l = s.path;
    return J.isBuffer(i) && i.length === 78 && [2, 3].indexOf(i[45]) > -1 && J.isBuffer(h) && h.length === 4 && typeof l == "string" && !!l.match(/^m(\/\d+'?)*$/);
  }
  qr.check = o;
  function a(s, i, h) {
    const l = i.extendedPubkey.toString("hex");
    return h.has(l) ? !1 : (h.add(l), s.filter((c) => c.extendedPubkey.equals(i.extendedPubkey)).length === 0);
  }
  return qr.canAddToArray = a, qr;
}
var Mn = {}, Ic;
function Cg() {
  if (Ic) return Mn;
  Ic = 1, Object.defineProperty(Mn, "__esModule", { value: !0 });
  const e = Ge();
  function t(r) {
    return {
      key: J.from([e.GlobalTypes.UNSIGNED_TX]),
      value: r.toBuffer()
    };
  }
  return Mn.encode = t, Mn;
}
var Mr = {}, Bc;
function Lg() {
  if (Bc) return Mr;
  Bc = 1, Object.defineProperty(Mr, "__esModule", { value: !0 });
  const e = Ge();
  function t(a) {
    if (a.key[0] !== e.InputTypes.FINAL_SCRIPTSIG)
      throw new Error(
        "Decode Error: could not decode finalScriptSig with key 0x" + a.key.toString("hex")
      );
    return a.value;
  }
  Mr.decode = t;
  function r(a) {
    return {
      key: J.from([e.InputTypes.FINAL_SCRIPTSIG]),
      value: a
    };
  }
  Mr.encode = r, Mr.expected = "Buffer";
  function n(a) {
    return J.isBuffer(a);
  }
  Mr.check = n;
  function o(a, s) {
    return !!a && !!s && a.finalScriptSig === void 0;
  }
  return Mr.canAdd = o, Mr;
}
var Dr = {}, Tc;
function qg() {
  if (Tc) return Dr;
  Tc = 1, Object.defineProperty(Dr, "__esModule", { value: !0 });
  const e = Ge();
  function t(a) {
    if (a.key[0] !== e.InputTypes.FINAL_SCRIPTWITNESS)
      throw new Error(
        "Decode Error: could not decode finalScriptWitness with key 0x" + a.key.toString("hex")
      );
    return a.value;
  }
  Dr.decode = t;
  function r(a) {
    return {
      key: J.from([e.InputTypes.FINAL_SCRIPTWITNESS]),
      value: a
    };
  }
  Dr.encode = r, Dr.expected = "Buffer";
  function n(a) {
    return J.isBuffer(a);
  }
  Dr.check = n;
  function o(a, s) {
    return !!a && !!s && a.finalScriptWitness === void 0;
  }
  return Dr.canAdd = o, Dr;
}
var Fr = {}, zc;
function Mg() {
  if (zc) return Fr;
  zc = 1, Object.defineProperty(Fr, "__esModule", { value: !0 });
  const e = Ge();
  function t(a) {
    if (a.key[0] !== e.InputTypes.NON_WITNESS_UTXO)
      throw new Error(
        "Decode Error: could not decode nonWitnessUtxo with key 0x" + a.key.toString("hex")
      );
    return a.value;
  }
  Fr.decode = t;
  function r(a) {
    return {
      key: J.from([e.InputTypes.NON_WITNESS_UTXO]),
      value: a
    };
  }
  Fr.encode = r, Fr.expected = "Buffer";
  function n(a) {
    return J.isBuffer(a);
  }
  Fr.check = n;
  function o(a, s) {
    return !!a && !!s && a.nonWitnessUtxo === void 0;
  }
  return Fr.canAdd = o, Fr;
}
var Kr = {}, Oc;
function Dg() {
  if (Oc) return Kr;
  Oc = 1, Object.defineProperty(Kr, "__esModule", { value: !0 });
  const e = Ge();
  function t(s) {
    if (s.key[0] !== e.InputTypes.PARTIAL_SIG)
      throw new Error(
        "Decode Error: could not decode partialSig with key 0x" + s.key.toString("hex")
      );
    if (!(s.key.length === 34 || s.key.length === 66) || ![2, 3, 4].includes(s.key[1]))
      throw new Error(
        "Decode Error: partialSig has invalid pubkey in key 0x" + s.key.toString("hex")
      );
    return {
      pubkey: s.key.slice(1),
      signature: s.value
    };
  }
  Kr.decode = t;
  function r(s) {
    const i = J.from([e.InputTypes.PARTIAL_SIG]);
    return {
      key: J.concat([i, s.pubkey]),
      value: s.signature
    };
  }
  Kr.encode = r, Kr.expected = "{ pubkey: Buffer; signature: Buffer; }";
  function n(s) {
    return J.isBuffer(s.pubkey) && J.isBuffer(s.signature) && [33, 65].includes(s.pubkey.length) && [2, 3, 4].includes(s.pubkey[0]) && o(s.signature);
  }
  Kr.check = n;
  function o(s) {
    if (!J.isBuffer(s) || s.length < 9 || s[0] !== 48 || s.length !== s[1] + 3 || s[2] !== 2) return !1;
    const i = s[3];
    if (i > 33 || i < 1 || s[3 + i + 1] !== 2) return !1;
    const h = s[3 + i + 2];
    return !(h > 33 || h < 1 || s.length !== 3 + i + 2 + h + 2);
  }
  function a(s, i, h) {
    const l = i.pubkey.toString("hex");
    return h.has(l) ? !1 : (h.add(l), s.filter((c) => c.pubkey.equals(i.pubkey)).length === 0);
  }
  return Kr.canAddToArray = a, Kr;
}
var Hr = {}, Rc;
function Fg() {
  if (Rc) return Hr;
  Rc = 1, Object.defineProperty(Hr, "__esModule", { value: !0 });
  const e = Ge();
  function t(a) {
    if (a.key[0] !== e.InputTypes.POR_COMMITMENT)
      throw new Error(
        "Decode Error: could not decode porCommitment with key 0x" + a.key.toString("hex")
      );
    return a.value.toString("utf8");
  }
  Hr.decode = t;
  function r(a) {
    return {
      key: J.from([e.InputTypes.POR_COMMITMENT]),
      value: J.from(a, "utf8")
    };
  }
  Hr.encode = r, Hr.expected = "string";
  function n(a) {
    return typeof a == "string";
  }
  Hr.check = n;
  function o(a, s) {
    return !!a && !!s && a.porCommitment === void 0;
  }
  return Hr.canAdd = o, Hr;
}
var $r = {}, jc;
function Kg() {
  if (jc) return $r;
  jc = 1, Object.defineProperty($r, "__esModule", { value: !0 });
  const e = Ge();
  function t(a) {
    if (a.key[0] !== e.InputTypes.SIGHASH_TYPE)
      throw new Error(
        "Decode Error: could not decode sighashType with key 0x" + a.key.toString("hex")
      );
    return a.value.readUInt32LE(0);
  }
  $r.decode = t;
  function r(a) {
    const s = J.from([e.InputTypes.SIGHASH_TYPE]), i = J.allocUnsafe(4);
    return i.writeUInt32LE(a, 0), {
      key: s,
      value: i
    };
  }
  $r.encode = r, $r.expected = "number";
  function n(a) {
    return typeof a == "number";
  }
  $r.check = n;
  function o(a, s) {
    return !!a && !!s && a.sighashType === void 0;
  }
  return $r.canAdd = o, $r;
}
var Gr = {}, Pc;
function Hg() {
  if (Pc) return Gr;
  Pc = 1, Object.defineProperty(Gr, "__esModule", { value: !0 });
  const e = Ge();
  function t(a) {
    if (a.key[0] !== e.InputTypes.TAP_KEY_SIG || a.key.length !== 1)
      throw new Error(
        "Decode Error: could not decode tapKeySig with key 0x" + a.key.toString("hex")
      );
    if (!n(a.value))
      throw new Error(
        "Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature"
      );
    return a.value;
  }
  Gr.decode = t;
  function r(a) {
    return { key: J.from([e.InputTypes.TAP_KEY_SIG]), value: a };
  }
  Gr.encode = r, Gr.expected = "Buffer";
  function n(a) {
    return J.isBuffer(a) && (a.length === 64 || a.length === 65);
  }
  Gr.check = n;
  function o(a, s) {
    return !!a && !!s && a.tapKeySig === void 0;
  }
  return Gr.canAdd = o, Gr;
}
var Wr = {}, Uc;
function $g() {
  if (Uc) return Wr;
  Uc = 1, Object.defineProperty(Wr, "__esModule", { value: !0 });
  const e = Ge();
  function t(a) {
    if (a.key[0] !== e.InputTypes.TAP_LEAF_SCRIPT)
      throw new Error(
        "Decode Error: could not decode tapLeafScript with key 0x" + a.key.toString("hex")
      );
    if ((a.key.length - 2) % 32 !== 0)
      throw new Error(
        "Decode Error: tapLeafScript has invalid control block in key 0x" + a.key.toString("hex")
      );
    const s = a.value[a.value.length - 1];
    if ((a.key[1] & 254) !== s)
      throw new Error(
        "Decode Error: tapLeafScript bad leaf version in key 0x" + a.key.toString("hex")
      );
    const i = a.value.slice(0, -1);
    return { controlBlock: a.key.slice(1), script: i, leafVersion: s };
  }
  Wr.decode = t;
  function r(a) {
    const s = J.from([e.InputTypes.TAP_LEAF_SCRIPT]), i = J.from([a.leafVersion]);
    return {
      key: J.concat([s, a.controlBlock]),
      value: J.concat([a.script, i])
    };
  }
  Wr.encode = r, Wr.expected = "{ controlBlock: Buffer; leafVersion: number, script: Buffer; }";
  function n(a) {
    return J.isBuffer(a.controlBlock) && (a.controlBlock.length - 1) % 32 === 0 && (a.controlBlock[0] & 254) === a.leafVersion && J.isBuffer(a.script);
  }
  Wr.check = n;
  function o(a, s, i) {
    const h = s.controlBlock.toString("hex");
    return i.has(h) ? !1 : (i.add(h), a.filter((l) => l.controlBlock.equals(s.controlBlock)).length === 0);
  }
  return Wr.canAddToArray = o, Wr;
}
var Vr = {}, Nc;
function Gg() {
  if (Nc) return Vr;
  Nc = 1, Object.defineProperty(Vr, "__esModule", { value: !0 });
  const e = Ge();
  function t(a) {
    if (a.key[0] !== e.InputTypes.TAP_MERKLE_ROOT || a.key.length !== 1)
      throw new Error(
        "Decode Error: could not decode tapMerkleRoot with key 0x" + a.key.toString("hex")
      );
    if (!n(a.value))
      throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
    return a.value;
  }
  Vr.decode = t;
  function r(a) {
    return { key: J.from([e.InputTypes.TAP_MERKLE_ROOT]), value: a };
  }
  Vr.encode = r, Vr.expected = "Buffer";
  function n(a) {
    return J.isBuffer(a) && a.length === 32;
  }
  Vr.check = n;
  function o(a, s) {
    return !!a && !!s && a.tapMerkleRoot === void 0;
  }
  return Vr.canAdd = o, Vr;
}
var Zr = {}, Cc;
function Wg() {
  if (Cc) return Zr;
  Cc = 1, Object.defineProperty(Zr, "__esModule", { value: !0 });
  const e = Ge();
  function t(a) {
    if (a.key[0] !== e.InputTypes.TAP_SCRIPT_SIG)
      throw new Error(
        "Decode Error: could not decode tapScriptSig with key 0x" + a.key.toString("hex")
      );
    if (a.key.length !== 65)
      throw new Error(
        "Decode Error: tapScriptSig has invalid key 0x" + a.key.toString("hex")
      );
    if (a.value.length !== 64 && a.value.length !== 65)
      throw new Error(
        "Decode Error: tapScriptSig has invalid signature in key 0x" + a.key.toString("hex")
      );
    const s = a.key.slice(1, 33), i = a.key.slice(33);
    return {
      pubkey: s,
      leafHash: i,
      signature: a.value
    };
  }
  Zr.decode = t;
  function r(a) {
    const s = J.from([e.InputTypes.TAP_SCRIPT_SIG]);
    return {
      key: J.concat([s, a.pubkey, a.leafHash]),
      value: a.signature
    };
  }
  Zr.encode = r, Zr.expected = "{ pubkey: Buffer; leafHash: Buffer; signature: Buffer; }";
  function n(a) {
    return J.isBuffer(a.pubkey) && J.isBuffer(a.leafHash) && J.isBuffer(a.signature) && a.pubkey.length === 32 && a.leafHash.length === 32 && (a.signature.length === 64 || a.signature.length === 65);
  }
  Zr.check = n;
  function o(a, s, i) {
    const h = s.pubkey.toString("hex") + s.leafHash.toString("hex");
    return i.has(h) ? !1 : (i.add(h), a.filter(
      (l) => l.pubkey.equals(s.pubkey) && l.leafHash.equals(s.leafHash)
    ).length === 0);
  }
  return Zr.canAddToArray = o, Zr;
}
var Yr = {}, Br = {}, Tt = {}, Lc;
function Ht() {
  if (Lc) return Tt;
  Lc = 1, Object.defineProperty(Tt, "__esModule", { value: !0 });
  const e = 9007199254740991;
  function t(a) {
    if (a < 0 || a > e || a % 1 !== 0)
      throw new RangeError("value out of range");
  }
  function r(a, s, i) {
    if (t(a), s || (s = J.allocUnsafe(o(a))), !J.isBuffer(s))
      throw new TypeError("buffer must be a Buffer instance");
    return i || (i = 0), a < 253 ? (s.writeUInt8(a, i), Object.assign(r, { bytes: 1 })) : a <= 65535 ? (s.writeUInt8(253, i), s.writeUInt16LE(a, i + 1), Object.assign(r, { bytes: 3 })) : a <= 4294967295 ? (s.writeUInt8(254, i), s.writeUInt32LE(a, i + 1), Object.assign(r, { bytes: 5 })) : (s.writeUInt8(255, i), s.writeUInt32LE(a >>> 0, i + 1), s.writeUInt32LE(a / 4294967296 | 0, i + 5), Object.assign(r, { bytes: 9 })), s;
  }
  Tt.encode = r;
  function n(a, s) {
    if (!J.isBuffer(a))
      throw new TypeError("buffer must be a Buffer instance");
    s || (s = 0);
    const i = a.readUInt8(s);
    if (i < 253)
      return Object.assign(n, { bytes: 1 }), i;
    if (i === 253)
      return Object.assign(n, { bytes: 3 }), a.readUInt16LE(s + 1);
    if (i === 254)
      return Object.assign(n, { bytes: 5 }), a.readUInt32LE(s + 1);
    {
      Object.assign(n, { bytes: 9 });
      const h = a.readUInt32LE(s + 1), c = a.readUInt32LE(s + 5) * 4294967296 + h;
      return t(c), c;
    }
  }
  Tt.decode = n;
  function o(a) {
    return t(a), a < 253 ? 1 : a <= 65535 ? 3 : a <= 4294967295 ? 5 : 9;
  }
  return Tt.encodingLength = o, Tt;
}
var qc;
function gs() {
  if (qc) return Br;
  qc = 1, Object.defineProperty(Br, "__esModule", { value: !0 });
  const e = Ht();
  Br.range = (i) => [...Array(i).keys()];
  function t(i) {
    if (i.length < 1) return i;
    let h = i.length - 1, l = 0;
    for (let c = 0; c < i.length / 2; c++)
      l = i[c], i[c] = i[h], i[h] = l, h--;
    return i;
  }
  Br.reverseBuffer = t;
  function r(i) {
    const h = i.map(n);
    return h.push(J.from([0])), J.concat(h);
  }
  Br.keyValsToBuffer = r;
  function n(i) {
    const h = i.key.length, l = i.value.length, c = e.encodingLength(h), w = e.encodingLength(l), g = J.allocUnsafe(
      c + h + w + l
    );
    return e.encode(h, g, 0), i.key.copy(g, c), e.encode(l, g, c + h), i.value.copy(g, c + h + w), g;
  }
  Br.keyValToBuffer = n;
  function o(i, h) {
    if (typeof i != "number")
      throw new Error("cannot write a non-number as a number");
    if (i < 0)
      throw new Error("specified a negative value for writing an unsigned value");
    if (i > h) throw new Error("RangeError: value out of range");
    if (Math.floor(i) !== i)
      throw new Error("value has a fractional component");
  }
  function a(i, h) {
    const l = i.readUInt32LE(h);
    let c = i.readUInt32LE(h + 4);
    return c *= 4294967296, o(c + l, 9007199254740991), c + l;
  }
  Br.readUInt64LE = a;
  function s(i, h, l) {
    return o(h, 9007199254740991), i.writeInt32LE(h & -1, l), i.writeUInt32LE(Math.floor(h / 4294967296), l + 4), l + 8;
  }
  return Br.writeUInt64LE = s, Br;
}
var Mc;
function Vg() {
  if (Mc) return Yr;
  Mc = 1, Object.defineProperty(Yr, "__esModule", { value: !0 });
  const e = Ge(), t = gs(), r = Ht();
  function n(i) {
    if (i.key[0] !== e.InputTypes.WITNESS_UTXO)
      throw new Error(
        "Decode Error: could not decode witnessUtxo with key 0x" + i.key.toString("hex")
      );
    const h = t.readUInt64LE(i.value, 0);
    let l = 8;
    const c = r.decode(i.value, l);
    l += r.encodingLength(c);
    const w = i.value.slice(l);
    if (w.length !== c)
      throw new Error("Decode Error: WITNESS_UTXO script is not proper length");
    return {
      script: w,
      value: h
    };
  }
  Yr.decode = n;
  function o(i) {
    const { script: h, value: l } = i, c = r.encodingLength(h.length), w = J.allocUnsafe(8 + c + h.length);
    return t.writeUInt64LE(w, l, 0), r.encode(h.length, w, 8), h.copy(w, 8 + c), {
      key: J.from([e.InputTypes.WITNESS_UTXO]),
      value: w
    };
  }
  Yr.encode = o, Yr.expected = "{ script: Buffer; value: number; }";
  function a(i) {
    return J.isBuffer(i.script) && typeof i.value == "number";
  }
  Yr.check = a;
  function s(i, h) {
    return !!i && !!h && i.witnessUtxo === void 0;
  }
  return Yr.canAdd = s, Yr;
}
var Xr = {}, Dc;
function Zg() {
  if (Dc) return Xr;
  Dc = 1, Object.defineProperty(Xr, "__esModule", { value: !0 });
  const e = Ge(), t = Ht();
  function r(s) {
    if (s.key[0] !== e.OutputTypes.TAP_TREE || s.key.length !== 1)
      throw new Error(
        "Decode Error: could not decode tapTree with key 0x" + s.key.toString("hex")
      );
    let i = 0;
    const h = [];
    for (; i < s.value.length; ) {
      const l = s.value[i++], c = s.value[i++], w = t.decode(s.value, i);
      i += t.encodingLength(w), h.push({
        depth: l,
        leafVersion: c,
        script: s.value.slice(i, i + w)
      }), i += w;
    }
    return { leaves: h };
  }
  Xr.decode = r;
  function n(s) {
    const i = J.from([e.OutputTypes.TAP_TREE]), h = [].concat(
      ...s.leaves.map((l) => [
        J.of(l.depth, l.leafVersion),
        t.encode(l.script.length),
        l.script
      ])
    );
    return {
      key: i,
      value: J.concat(h)
    };
  }
  Xr.encode = n, Xr.expected = "{ leaves: [{ depth: number; leafVersion: number, script: Buffer; }] }";
  function o(s) {
    return Array.isArray(s.leaves) && s.leaves.every(
      (i) => i.depth >= 0 && i.depth <= 128 && (i.leafVersion & 254) === i.leafVersion && J.isBuffer(i.script)
    );
  }
  Xr.check = o;
  function a(s, i) {
    return !!s && !!i && s.tapTree === void 0;
  }
  return Xr.canAdd = a, Xr;
}
var Dn = {}, Fc;
function ed() {
  if (Fc) return Dn;
  Fc = 1, Object.defineProperty(Dn, "__esModule", { value: !0 });
  const e = (n) => [...Array(n).keys()], t = (n) => n.length === 33 && [2, 3].includes(n[0]) || n.length === 65 && n[0] === 4;
  function r(n, o = t) {
    function a(c) {
      if (c.key[0] !== n)
        throw new Error(
          "Decode Error: could not decode bip32Derivation with key 0x" + c.key.toString("hex")
        );
      const w = c.key.slice(1);
      if (!o(w))
        throw new Error(
          "Decode Error: bip32Derivation has invalid pubkey in key 0x" + c.key.toString("hex")
        );
      if (c.value.length / 4 % 1 !== 0)
        throw new Error(
          "Decode Error: Input BIP32_DERIVATION value length should be multiple of 4"
        );
      const g = {
        masterFingerprint: c.value.slice(0, 4),
        pubkey: w,
        path: "m"
      };
      for (const v of e(c.value.length / 4 - 1)) {
        const k = c.value.readUInt32LE(v * 4 + 4), y = !!(k & 2147483648), m = k & 2147483647;
        g.path += "/" + m.toString(10) + (y ? "'" : "");
      }
      return g;
    }
    function s(c) {
      const w = J.from([n]), g = J.concat([w, c.pubkey]), v = c.path.split("/"), k = J.allocUnsafe(v.length * 4);
      c.masterFingerprint.copy(k, 0);
      let y = 4;
      return v.slice(1).forEach((m) => {
        const A = m.slice(-1) === "'";
        let E = 2147483647 & parseInt(A ? m.slice(0, -1) : m, 10);
        A && (E += 2147483648), k.writeUInt32LE(E, y), y += 4;
      }), {
        key: g,
        value: k
      };
    }
    const i = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }";
    function h(c) {
      return J.isBuffer(c.pubkey) && J.isBuffer(c.masterFingerprint) && typeof c.path == "string" && o(c.pubkey) && c.masterFingerprint.length === 4;
    }
    function l(c, w, g) {
      const v = w.pubkey.toString("hex");
      return g.has(v) ? !1 : (g.add(v), c.filter((k) => k.pubkey.equals(w.pubkey)).length === 0);
    }
    return {
      decode: a,
      encode: s,
      check: h,
      expected: i,
      canAddToArray: l
    };
  }
  return Dn.makeConverter = r, Dn;
}
var Fn = {}, Kc;
function Yg() {
  if (Kc) return Fn;
  Kc = 1, Object.defineProperty(Fn, "__esModule", { value: !0 });
  function e(t) {
    return r;
    function r(n) {
      let o;
      if (t.includes(n.key[0]) && (o = n.key.slice(1), !(o.length === 33 || o.length === 65) || ![2, 3, 4].includes(o[0])))
        throw new Error(
          "Format Error: invalid pubkey in key 0x" + n.key.toString("hex")
        );
      return o;
    }
  }
  return Fn.makeChecker = e, Fn;
}
var Kn = {}, Hc;
function Xg() {
  if (Hc) return Kn;
  Hc = 1, Object.defineProperty(Kn, "__esModule", { value: !0 });
  function e(t) {
    function r(i) {
      if (i.key[0] !== t)
        throw new Error(
          "Decode Error: could not decode redeemScript with key 0x" + i.key.toString("hex")
        );
      return i.value;
    }
    function n(i) {
      return {
        key: J.from([t]),
        value: i
      };
    }
    const o = "Buffer";
    function a(i) {
      return J.isBuffer(i);
    }
    function s(i, h) {
      return !!i && !!h && i.redeemScript === void 0;
    }
    return {
      decode: r,
      encode: n,
      check: a,
      expected: o,
      canAdd: s
    };
  }
  return Kn.makeConverter = e, Kn;
}
var Hn = {}, $c;
function Jg() {
  if ($c) return Hn;
  $c = 1, Object.defineProperty(Hn, "__esModule", { value: !0 });
  const e = Ht(), t = ed(), r = (o) => o.length === 32;
  function n(o) {
    const a = t.makeConverter(o, r);
    function s(c) {
      const w = e.decode(c.value), g = e.encodingLength(w), v = a.decode({
        key: c.key,
        value: c.value.slice(g + w * 32)
      }), k = new Array(w);
      for (let y = 0, m = g; y < w; y++, m += 32)
        k[y] = c.value.slice(m, m + 32);
      return Object.assign({}, v, { leafHashes: k });
    }
    function i(c) {
      const w = a.encode(c), g = e.encodingLength(c.leafHashes.length), v = J.allocUnsafe(g);
      e.encode(c.leafHashes.length, v);
      const k = J.concat([v, ...c.leafHashes, w.value]);
      return Object.assign({}, w, { value: k });
    }
    const h = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; leafHashes: Buffer[]; }";
    function l(c) {
      return Array.isArray(c.leafHashes) && c.leafHashes.every(
        (w) => J.isBuffer(w) && w.length === 32
      ) && a.check(c);
    }
    return {
      decode: s,
      encode: i,
      check: l,
      expected: h,
      canAddToArray: a.canAddToArray
    };
  }
  return Hn.makeConverter = n, Hn;
}
var $n = {}, Gc;
function Qg() {
  if (Gc) return $n;
  Gc = 1, Object.defineProperty($n, "__esModule", { value: !0 });
  function e(t) {
    function r(i) {
      if (i.key[0] !== t || i.key.length !== 1)
        throw new Error(
          "Decode Error: could not decode tapInternalKey with key 0x" + i.key.toString("hex")
        );
      if (i.value.length !== 32)
        throw new Error(
          "Decode Error: tapInternalKey not a 32-byte x-only pubkey"
        );
      return i.value;
    }
    function n(i) {
      return { key: J.from([t]), value: i };
    }
    const o = "Buffer";
    function a(i) {
      return J.isBuffer(i) && i.length === 32;
    }
    function s(i, h) {
      return !!i && !!h && i.tapInternalKey === void 0;
    }
    return {
      decode: r,
      encode: n,
      check: a,
      expected: o,
      canAdd: s
    };
  }
  return $n.makeConverter = e, $n;
}
var Gn = {}, Wc;
function eb() {
  if (Wc) return Gn;
  Wc = 1, Object.defineProperty(Gn, "__esModule", { value: !0 });
  function e(t) {
    function r(i) {
      if (i.key[0] !== t)
        throw new Error(
          "Decode Error: could not decode witnessScript with key 0x" + i.key.toString("hex")
        );
      return i.value;
    }
    function n(i) {
      return {
        key: J.from([t]),
        value: i
      };
    }
    const o = "Buffer";
    function a(i) {
      return J.isBuffer(i);
    }
    function s(i, h) {
      return !!i && !!h && i.witnessScript === void 0;
    }
    return {
      decode: r,
      encode: n,
      check: a,
      expected: o,
      canAdd: s
    };
  }
  return Gn.makeConverter = e, Gn;
}
var Vc;
function bs() {
  if (Vc) return Bt;
  Vc = 1, Object.defineProperty(Bt, "__esModule", { value: !0 });
  const e = Ge(), t = Ng(), r = Cg(), n = Lg(), o = qg(), a = Mg(), s = Dg(), i = Fg(), h = Kg(), l = Hg(), c = $g(), w = Gg(), g = Wg(), v = Vg(), k = Zg(), y = ed(), m = Yg(), A = Xg(), E = Jg(), x = Qg(), z = eb(), F = {
    unsignedTx: r,
    globalXpub: t,
    // pass an Array of key bytes that require pubkey beside the key
    checkPubkey: m.makeChecker([])
  };
  Bt.globals = F;
  const j = {
    nonWitnessUtxo: a,
    partialSig: s,
    sighashType: h,
    finalScriptSig: n,
    finalScriptWitness: o,
    porCommitment: i,
    witnessUtxo: v,
    bip32Derivation: y.makeConverter(
      e.InputTypes.BIP32_DERIVATION
    ),
    redeemScript: A.makeConverter(
      e.InputTypes.REDEEM_SCRIPT
    ),
    witnessScript: z.makeConverter(
      e.InputTypes.WITNESS_SCRIPT
    ),
    checkPubkey: m.makeChecker([
      e.InputTypes.PARTIAL_SIG,
      e.InputTypes.BIP32_DERIVATION
    ]),
    tapKeySig: l,
    tapScriptSig: g,
    tapLeafScript: c,
    tapBip32Derivation: E.makeConverter(
      e.InputTypes.TAP_BIP32_DERIVATION
    ),
    tapInternalKey: x.makeConverter(
      e.InputTypes.TAP_INTERNAL_KEY
    ),
    tapMerkleRoot: w
  };
  Bt.inputs = j;
  const I = {
    bip32Derivation: y.makeConverter(
      e.OutputTypes.BIP32_DERIVATION
    ),
    redeemScript: A.makeConverter(
      e.OutputTypes.REDEEM_SCRIPT
    ),
    witnessScript: z.makeConverter(
      e.OutputTypes.WITNESS_SCRIPT
    ),
    checkPubkey: m.makeChecker([
      e.OutputTypes.BIP32_DERIVATION
    ]),
    tapBip32Derivation: E.makeConverter(
      e.OutputTypes.TAP_BIP32_DERIVATION
    ),
    tapTree: k,
    tapInternalKey: x.makeConverter(
      e.OutputTypes.TAP_INTERNAL_KEY
    )
  };
  return Bt.outputs = I, Bt;
}
var Zc;
function rb() {
  if (Zc) return It;
  Zc = 1, Object.defineProperty(It, "__esModule", { value: !0 });
  const e = bs(), t = gs(), r = Ht(), n = Ge();
  function o(i, h) {
    let l = 0;
    function c() {
      const I = r.decode(i, l);
      l += r.encodingLength(I);
      const N = i.slice(l, l + I);
      return l += I, N;
    }
    function w() {
      const I = i.readUInt32BE(l);
      return l += 4, I;
    }
    function g() {
      const I = i.readUInt8(l);
      return l += 1, I;
    }
    function v() {
      const I = c(), N = c();
      return {
        key: I,
        value: N
      };
    }
    function k() {
      if (l >= i.length)
        throw new Error("Format Error: Unexpected End of PSBT");
      const I = i.readUInt8(l) === 0;
      return I && l++, I;
    }
    if (w() !== 1886610036)
      throw new Error("Format Error: Invalid Magic Number");
    if (g() !== 255)
      throw new Error(
        "Format Error: Magic Number must be followed by 0xff separator"
      );
    const y = [], m = {};
    for (; !k(); ) {
      const I = v(), N = I.key.toString("hex");
      if (m[N])
        throw new Error(
          "Format Error: Keys must be unique for global keymap: key " + N
        );
      m[N] = 1, y.push(I);
    }
    const A = y.filter(
      (I) => I.key[0] === n.GlobalTypes.UNSIGNED_TX
    );
    if (A.length !== 1)
      throw new Error("Format Error: Only one UNSIGNED_TX allowed");
    const E = h(A[0].value), { inputCount: x, outputCount: z } = E.getInputOutputCounts(), F = [], j = [];
    for (const I of t.range(x)) {
      const N = {}, O = [];
      for (; !k(); ) {
        const R = v(), U = R.key.toString("hex");
        if (N[U])
          throw new Error(
            "Format Error: Keys must be unique for each input: input index " + I + " key " + U
          );
        N[U] = 1, O.push(R);
      }
      F.push(O);
    }
    for (const I of t.range(z)) {
      const N = {}, O = [];
      for (; !k(); ) {
        const R = v(), U = R.key.toString("hex");
        if (N[U])
          throw new Error(
            "Format Error: Keys must be unique for each output: output index " + I + " key " + U
          );
        N[U] = 1, O.push(R);
      }
      j.push(O);
    }
    return s(E, {
      globalMapKeyVals: y,
      inputKeyVals: F,
      outputKeyVals: j
    });
  }
  It.psbtFromBuffer = o;
  function a(i, h, l) {
    if (!h.equals(J.from([l])))
      throw new Error(
        `Format Error: Invalid ${i} key: ${h.toString("hex")}`
      );
  }
  It.checkKeyBuffer = a;
  function s(i, { globalMapKeyVals: h, inputKeyVals: l, outputKeyVals: c }) {
    const w = {
      unsignedTx: i
    };
    let g = 0;
    for (const A of h)
      switch (A.key[0]) {
        case n.GlobalTypes.UNSIGNED_TX:
          if (a(
            "global",
            A.key,
            n.GlobalTypes.UNSIGNED_TX
          ), g > 0)
            throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");
          g++;
          break;
        case n.GlobalTypes.GLOBAL_XPUB:
          w.globalXpub === void 0 && (w.globalXpub = []), w.globalXpub.push(e.globals.globalXpub.decode(A));
          break;
        default:
          w.unknownKeyVals || (w.unknownKeyVals = []), w.unknownKeyVals.push(A);
      }
    const v = l.length, k = c.length, y = [], m = [];
    for (const A of t.range(v)) {
      const E = {};
      for (const x of l[A])
        switch (e.inputs.checkPubkey(x), x.key[0]) {
          case n.InputTypes.NON_WITNESS_UTXO:
            if (a(
              "input",
              x.key,
              n.InputTypes.NON_WITNESS_UTXO
            ), E.nonWitnessUtxo !== void 0)
              throw new Error(
                "Format Error: Input has multiple NON_WITNESS_UTXO"
              );
            E.nonWitnessUtxo = e.inputs.nonWitnessUtxo.decode(x);
            break;
          case n.InputTypes.WITNESS_UTXO:
            if (a(
              "input",
              x.key,
              n.InputTypes.WITNESS_UTXO
            ), E.witnessUtxo !== void 0)
              throw new Error("Format Error: Input has multiple WITNESS_UTXO");
            E.witnessUtxo = e.inputs.witnessUtxo.decode(x);
            break;
          case n.InputTypes.PARTIAL_SIG:
            E.partialSig === void 0 && (E.partialSig = []), E.partialSig.push(e.inputs.partialSig.decode(x));
            break;
          case n.InputTypes.SIGHASH_TYPE:
            if (a(
              "input",
              x.key,
              n.InputTypes.SIGHASH_TYPE
            ), E.sighashType !== void 0)
              throw new Error("Format Error: Input has multiple SIGHASH_TYPE");
            E.sighashType = e.inputs.sighashType.decode(x);
            break;
          case n.InputTypes.REDEEM_SCRIPT:
            if (a(
              "input",
              x.key,
              n.InputTypes.REDEEM_SCRIPT
            ), E.redeemScript !== void 0)
              throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");
            E.redeemScript = e.inputs.redeemScript.decode(x);
            break;
          case n.InputTypes.WITNESS_SCRIPT:
            if (a(
              "input",
              x.key,
              n.InputTypes.WITNESS_SCRIPT
            ), E.witnessScript !== void 0)
              throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");
            E.witnessScript = e.inputs.witnessScript.decode(x);
            break;
          case n.InputTypes.BIP32_DERIVATION:
            E.bip32Derivation === void 0 && (E.bip32Derivation = []), E.bip32Derivation.push(
              e.inputs.bip32Derivation.decode(x)
            );
            break;
          case n.InputTypes.FINAL_SCRIPTSIG:
            a(
              "input",
              x.key,
              n.InputTypes.FINAL_SCRIPTSIG
            ), E.finalScriptSig = e.inputs.finalScriptSig.decode(x);
            break;
          case n.InputTypes.FINAL_SCRIPTWITNESS:
            a(
              "input",
              x.key,
              n.InputTypes.FINAL_SCRIPTWITNESS
            ), E.finalScriptWitness = e.inputs.finalScriptWitness.decode(
              x
            );
            break;
          case n.InputTypes.POR_COMMITMENT:
            a(
              "input",
              x.key,
              n.InputTypes.POR_COMMITMENT
            ), E.porCommitment = e.inputs.porCommitment.decode(x);
            break;
          case n.InputTypes.TAP_KEY_SIG:
            a(
              "input",
              x.key,
              n.InputTypes.TAP_KEY_SIG
            ), E.tapKeySig = e.inputs.tapKeySig.decode(x);
            break;
          case n.InputTypes.TAP_SCRIPT_SIG:
            E.tapScriptSig === void 0 && (E.tapScriptSig = []), E.tapScriptSig.push(e.inputs.tapScriptSig.decode(x));
            break;
          case n.InputTypes.TAP_LEAF_SCRIPT:
            E.tapLeafScript === void 0 && (E.tapLeafScript = []), E.tapLeafScript.push(e.inputs.tapLeafScript.decode(x));
            break;
          case n.InputTypes.TAP_BIP32_DERIVATION:
            E.tapBip32Derivation === void 0 && (E.tapBip32Derivation = []), E.tapBip32Derivation.push(
              e.inputs.tapBip32Derivation.decode(x)
            );
            break;
          case n.InputTypes.TAP_INTERNAL_KEY:
            a(
              "input",
              x.key,
              n.InputTypes.TAP_INTERNAL_KEY
            ), E.tapInternalKey = e.inputs.tapInternalKey.decode(x);
            break;
          case n.InputTypes.TAP_MERKLE_ROOT:
            a(
              "input",
              x.key,
              n.InputTypes.TAP_MERKLE_ROOT
            ), E.tapMerkleRoot = e.inputs.tapMerkleRoot.decode(x);
            break;
          default:
            E.unknownKeyVals || (E.unknownKeyVals = []), E.unknownKeyVals.push(x);
        }
      y.push(E);
    }
    for (const A of t.range(k)) {
      const E = {};
      for (const x of c[A])
        switch (e.outputs.checkPubkey(x), x.key[0]) {
          case n.OutputTypes.REDEEM_SCRIPT:
            if (a(
              "output",
              x.key,
              n.OutputTypes.REDEEM_SCRIPT
            ), E.redeemScript !== void 0)
              throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");
            E.redeemScript = e.outputs.redeemScript.decode(x);
            break;
          case n.OutputTypes.WITNESS_SCRIPT:
            if (a(
              "output",
              x.key,
              n.OutputTypes.WITNESS_SCRIPT
            ), E.witnessScript !== void 0)
              throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");
            E.witnessScript = e.outputs.witnessScript.decode(x);
            break;
          case n.OutputTypes.BIP32_DERIVATION:
            E.bip32Derivation === void 0 && (E.bip32Derivation = []), E.bip32Derivation.push(
              e.outputs.bip32Derivation.decode(x)
            );
            break;
          case n.OutputTypes.TAP_INTERNAL_KEY:
            a(
              "output",
              x.key,
              n.OutputTypes.TAP_INTERNAL_KEY
            ), E.tapInternalKey = e.outputs.tapInternalKey.decode(x);
            break;
          case n.OutputTypes.TAP_TREE:
            a(
              "output",
              x.key,
              n.OutputTypes.TAP_TREE
            ), E.tapTree = e.outputs.tapTree.decode(x);
            break;
          case n.OutputTypes.TAP_BIP32_DERIVATION:
            E.tapBip32Derivation === void 0 && (E.tapBip32Derivation = []), E.tapBip32Derivation.push(
              e.outputs.tapBip32Derivation.decode(x)
            );
            break;
          default:
            E.unknownKeyVals || (E.unknownKeyVals = []), E.unknownKeyVals.push(x);
        }
      m.push(E);
    }
    return { globalMap: w, inputs: y, outputs: m };
  }
  return It.psbtFromKeyVals = s, It;
}
var Xt = {}, Yc;
function tb() {
  if (Yc) return Xt;
  Yc = 1, Object.defineProperty(Xt, "__esModule", { value: !0 });
  const e = bs(), t = gs();
  function r({ globalMap: s, inputs: i, outputs: h }) {
    const { globalKeyVals: l, inputKeyVals: c, outputKeyVals: w } = a({
      globalMap: s,
      inputs: i,
      outputs: h
    }), g = t.keyValsToBuffer(l), v = (A) => A.length === 0 ? [J.from([0])] : A.map(t.keyValsToBuffer), k = v(c), y = v(w), m = J.allocUnsafe(5);
    return m.writeUIntBE(482972169471, 0, 5), J.concat(
      [m, g].concat(k, y)
    );
  }
  Xt.psbtToBuffer = r;
  const n = (s, i) => s.key.compare(i.key);
  function o(s, i) {
    const h = /* @__PURE__ */ new Set(), l = Object.entries(s).reduce((w, [g, v]) => {
      if (g === "unknownKeyVals") return w;
      const k = i[g];
      if (k === void 0) return w;
      const y = (Array.isArray(v) ? v : [v]).map(
        k.encode
      );
      return y.map((A) => A.key.toString("hex")).forEach((A) => {
        if (h.has(A))
          throw new Error("Serialize Error: Duplicate key: " + A);
        h.add(A);
      }), w.concat(y);
    }, []), c = s.unknownKeyVals ? s.unknownKeyVals.filter((w) => !h.has(w.key.toString("hex"))) : [];
    return l.concat(c).sort(n);
  }
  function a({ globalMap: s, inputs: i, outputs: h }) {
    return {
      globalKeyVals: o(s, e.globals),
      inputKeyVals: i.map((l) => o(l, e.inputs)),
      outputKeyVals: h.map((l) => o(l, e.outputs))
    };
  }
  return Xt.psbtToKeyVals = a, Xt;
}
var Xc;
function rd() {
  return Xc || (Xc = 1, (function(e) {
    function t(r) {
      for (var n in r) e.hasOwnProperty(n) || (e[n] = r[n]);
    }
    Object.defineProperty(e, "__esModule", { value: !0 }), t(rb()), t(tb());
  })(Qa)), Qa;
}
var Jc;
function nb() {
  if (Jc) return qn;
  Jc = 1, Object.defineProperty(qn, "__esModule", { value: !0 });
  const e = rd();
  function t(a) {
    const s = a[0], i = e.psbtToKeyVals(s), h = a.slice(1);
    if (h.length === 0) throw new Error("Combine: Nothing to combine");
    const l = n(s);
    if (l === void 0)
      throw new Error("Combine: Self missing transaction");
    const c = o(i.globalKeyVals), w = i.inputKeyVals.map(o), g = i.outputKeyVals.map(o);
    for (const v of h) {
      const k = n(v);
      if (k === void 0 || !k.toBuffer().equals(l.toBuffer()))
        throw new Error(
          "Combine: One of the Psbts does not have the same transaction."
        );
      const y = e.psbtToKeyVals(v);
      o(y.globalKeyVals).forEach(
        r(
          c,
          i.globalKeyVals,
          y.globalKeyVals
        )
      ), y.inputKeyVals.map(o).forEach(
        (x, z) => x.forEach(
          r(
            w[z],
            i.inputKeyVals[z],
            y.inputKeyVals[z]
          )
        )
      ), y.outputKeyVals.map(o).forEach(
        (x, z) => x.forEach(
          r(
            g[z],
            i.outputKeyVals[z],
            y.outputKeyVals[z]
          )
        )
      );
    }
    return e.psbtFromKeyVals(l, {
      globalMapKeyVals: i.globalKeyVals,
      inputKeyVals: i.inputKeyVals,
      outputKeyVals: i.outputKeyVals
    });
  }
  qn.combine = t;
  function r(a, s, i) {
    return (h) => {
      if (a.has(h)) return;
      const l = i.filter((c) => c.key.toString("hex") === h)[0];
      s.push(l), a.add(h);
    };
  }
  function n(a) {
    return a.globalMap.unsignedTx;
  }
  function o(a) {
    const s = /* @__PURE__ */ new Set();
    return a.forEach((i) => {
      const h = i.key.toString("hex");
      if (s.has(h))
        throw new Error("Combine: KeyValue Map keys should be unique");
      s.add(h);
    }), s;
  }
  return qn;
}
var ro = {}, Qc;
function td() {
  return Qc || (Qc = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 });
    const t = bs();
    function r(v, k) {
      const y = v[k];
      if (y === void 0) throw new Error(`No input #${k}`);
      return y;
    }
    e.checkForInput = r;
    function n(v, k) {
      const y = v[k];
      if (y === void 0) throw new Error(`No output #${k}`);
      return y;
    }
    e.checkForOutput = n;
    function o(v, k, y) {
      if (v.key[0] < y)
        throw new Error(
          "Use the method for your specific key instead of addUnknownKeyVal*"
        );
      if (k && k.filter((m) => m.key.equals(v.key)).length !== 0)
        throw new Error(`Duplicate Key: ${v.key.toString("hex")}`);
    }
    e.checkHasKey = o;
    function a(v) {
      let k = 0;
      return Object.keys(v).forEach((y) => {
        Number(isNaN(Number(y))) && k++;
      }), k;
    }
    e.getEnumLength = a;
    function s(v, k) {
      let y = !1;
      if (k.nonWitnessUtxo || k.witnessUtxo) {
        const m = !!k.redeemScript, A = !!k.witnessScript, E = !m || !!k.finalScriptSig, x = !A || !!k.finalScriptWitness, z = !!k.finalScriptSig || !!k.finalScriptWitness;
        y = E && x && z;
      }
      if (y === !1)
        throw new Error(
          `Input #${v} has too much or too little data to clean`
        );
    }
    e.inputCheckUncleanFinalized = s;
    function i(v, k, y, m) {
      throw new Error(
        `Data for ${v} key ${k} is incorrect: Expected ${y} and got ${JSON.stringify(m)}`
      );
    }
    function h(v) {
      return (k, y) => {
        for (const m of Object.keys(k)) {
          const A = k[m], { canAdd: E, canAddToArray: x, check: z, expected: F } = (
            // @ts-ignore
            t[v + "s"][m] || {}
          ), j = !!x;
          if (z)
            if (j) {
              if (!Array.isArray(A) || // @ts-ignore
              y[m] && !Array.isArray(y[m]))
                throw new Error(`Key type ${m} must be an array`);
              A.every(z) || i(v, m, F, A);
              const I = y[m] || [], N = /* @__PURE__ */ new Set();
              if (!A.every((O) => x(I, O, N)))
                throw new Error("Can not add duplicate data to array");
              y[m] = I.concat(A);
            } else {
              if (z(A) || i(v, m, F, A), !E(y, A))
                throw new Error(`Can not add duplicate data to ${v}`);
              y[m] = A;
            }
        }
      };
    }
    e.updateGlobal = h("global"), e.updateInput = h("input"), e.updateOutput = h("output");
    function l(v, k) {
      const y = v.length - 1, m = r(v, y);
      e.updateInput(k, m);
    }
    e.addInputAttributes = l;
    function c(v, k) {
      const y = v.length - 1, m = n(v, y);
      e.updateOutput(k, m);
    }
    e.addOutputAttributes = c;
    function w(v, k) {
      if (!J.isBuffer(k) || k.length < 4)
        throw new Error("Set Version: Invalid Transaction");
      return k.writeUInt32LE(v, 0), k;
    }
    e.defaultVersionSetter = w;
    function g(v, k) {
      if (!J.isBuffer(k) || k.length < 4)
        throw new Error("Set Locktime: Invalid Transaction");
      return k.writeUInt32LE(v, k.length - 4), k;
    }
    e.defaultLocktimeSetter = g;
  })(ro)), ro;
}
var eu;
function ab() {
  if (eu) return Ln;
  eu = 1, Object.defineProperty(Ln, "__esModule", { value: !0 });
  const e = nb(), t = rd(), r = Ge(), n = td();
  class o {
    constructor(s) {
      this.inputs = [], this.outputs = [], this.globalMap = {
        unsignedTx: s
      };
    }
    static fromBase64(s, i) {
      const h = J.from(s, "base64");
      return this.fromBuffer(h, i);
    }
    static fromHex(s, i) {
      const h = J.from(s, "hex");
      return this.fromBuffer(h, i);
    }
    static fromBuffer(s, i) {
      const h = t.psbtFromBuffer(s, i), l = new this(h.globalMap.unsignedTx);
      return Object.assign(l, h), l;
    }
    toBase64() {
      return this.toBuffer().toString("base64");
    }
    toHex() {
      return this.toBuffer().toString("hex");
    }
    toBuffer() {
      return t.psbtToBuffer(this);
    }
    updateGlobal(s) {
      return n.updateGlobal(s, this.globalMap), this;
    }
    updateInput(s, i) {
      const h = n.checkForInput(this.inputs, s);
      return n.updateInput(i, h), this;
    }
    updateOutput(s, i) {
      const h = n.checkForOutput(this.outputs, s);
      return n.updateOutput(i, h), this;
    }
    addUnknownKeyValToGlobal(s) {
      return n.checkHasKey(
        s,
        this.globalMap.unknownKeyVals,
        n.getEnumLength(r.GlobalTypes)
      ), this.globalMap.unknownKeyVals || (this.globalMap.unknownKeyVals = []), this.globalMap.unknownKeyVals.push(s), this;
    }
    addUnknownKeyValToInput(s, i) {
      const h = n.checkForInput(this.inputs, s);
      return n.checkHasKey(
        i,
        h.unknownKeyVals,
        n.getEnumLength(r.InputTypes)
      ), h.unknownKeyVals || (h.unknownKeyVals = []), h.unknownKeyVals.push(i), this;
    }
    addUnknownKeyValToOutput(s, i) {
      const h = n.checkForOutput(this.outputs, s);
      return n.checkHasKey(
        i,
        h.unknownKeyVals,
        n.getEnumLength(r.OutputTypes)
      ), h.unknownKeyVals || (h.unknownKeyVals = []), h.unknownKeyVals.push(i), this;
    }
    addInput(s) {
      this.globalMap.unsignedTx.addInput(s), this.inputs.push({
        unknownKeyVals: []
      });
      const i = s.unknownKeyVals || [], h = this.inputs.length - 1;
      if (!Array.isArray(i))
        throw new Error("unknownKeyVals must be an Array");
      return i.forEach(
        (l) => this.addUnknownKeyValToInput(h, l)
      ), n.addInputAttributes(this.inputs, s), this;
    }
    addOutput(s) {
      this.globalMap.unsignedTx.addOutput(s), this.outputs.push({
        unknownKeyVals: []
      });
      const i = s.unknownKeyVals || [], h = this.outputs.length - 1;
      if (!Array.isArray(i))
        throw new Error("unknownKeyVals must be an Array");
      return i.forEach(
        (l) => this.addUnknownKeyValToOutput(h, l)
      ), n.addOutputAttributes(this.outputs, s), this;
    }
    clearFinalizedInput(s) {
      const i = n.checkForInput(this.inputs, s);
      n.inputCheckUncleanFinalized(s, i);
      for (const h of Object.keys(i))
        [
          "witnessUtxo",
          "nonWitnessUtxo",
          "finalScriptSig",
          "finalScriptWitness",
          "unknownKeyVals"
        ].includes(h) || delete i[h];
      return this;
    }
    combine(...s) {
      const i = e.combine([this].concat(s));
      return Object.assign(this, i), this;
    }
    getTransaction() {
      return this.globalMap.unsignedTx.toBuffer();
    }
  }
  return Ln.Psbt = o, Ln;
}
var hv = ab(), pv = Ht(), gv = td(), Le = {}, ru;
function ob() {
  if (ru) return Le;
  ru = 1;
  var e = /* @__PURE__ */ fh(), t = /* @__PURE__ */ hh(), r = /* @__PURE__ */ dh();
  function n(M) {
    var te = /* @__PURE__ */ Object.create(null);
    return M && Object.keys(M).forEach(function(b) {
      if (b !== "default") {
        var u = Object.getOwnPropertyDescriptor(M, b);
        Object.defineProperty(te, b, u.get ? u : {
          enumerable: !0,
          get: function() {
            return M[b];
          }
        });
      }
    }), te.default = M, Object.freeze(te);
  }
  var o = /* @__PURE__ */ n(t), a = /* @__PURE__ */ n(r);
  const s = e.secp256k1.ProjectivePoint, i = "Expected Private", h = "Expected Point", l = "Expected Tweak", c = "Expected Hash", w = "Expected Signature", g = "Expected Extra Data (32 bytes)", v = "Expected Scalar", k = "Bad Recovery Id", y = 32, m = 32, A = new Uint8Array([
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    255,
    254,
    186,
    174,
    220,
    230,
    175,
    72,
    160,
    59,
    191,
    210,
    94,
    140,
    208,
    54,
    65,
    65
  ]), E = 32, x = new Uint8Array(32), z = new Uint8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    69,
    81,
    35,
    25,
    80,
    183,
    95,
    196,
    64,
    45,
    161,
    114,
    47,
    201,
    186,
    238
  ]), F = BigInt(1);
  function j(M) {
    return M instanceof Uint8Array;
  }
  function I(M, te) {
    for (let b = 0; b < 32; ++b)
      if (M[b] !== te[b])
        return M[b] < te[b] ? -1 : 1;
    return 0;
  }
  function N(M) {
    return I(M, x) === 0;
  }
  function O(M) {
    return !(!(M instanceof Uint8Array) || M.length !== m || I(M, A) >= 0);
  }
  function R(M) {
    return M instanceof Uint8Array && M.length === 64 && I(M.subarray(0, 32), A) < 0 && I(M.subarray(32, 64), A) < 0;
  }
  function U(M) {
    return j(M) && M.length === 64 && I(M.subarray(0, 32), z) < 0;
  }
  function T(M) {
    return !(N(M.subarray(0, 32)) || N(M.subarray(32, 64)));
  }
  function Z(M) {
    return M instanceof Uint8Array && M.length === y;
  }
  function re(M) {
    return M === void 0 || M instanceof Uint8Array && M.length === E;
  }
  function oe(M) {
    let te;
    if (typeof M == "bigint")
      te = M;
    else if (typeof M == "number" && Number.isSafeInteger(M) && M >= 0)
      te = BigInt(M);
    else if (typeof M == "string") {
      if (M.length !== 64)
        throw new Error("Expected 32 bytes of private scalar");
      te = a.hexToNumber(M);
    } else if (M instanceof Uint8Array) {
      if (M.length !== 32)
        throw new Error("Expected 32 bytes of private scalar");
      te = a.bytesToNumberBE(M);
    } else
      throw new TypeError("Expected valid private scalar");
    if (te < 0) throw new Error("Expected private scalar >= 0");
    return te;
  }
  function ue(M) {
    return e.secp256k1.utils.normPrivateKeyToScalar(M);
  }
  function ie(M, te) {
    const b = ue(M), u = oe(te), d = a.numberToBytesBE(o.mod(b + u, e.secp256k1.CURVE.n), 32);
    return e.secp256k1.utils.isValidPrivateKey(d) ? d : null;
  }
  function de(M, te) {
    const b = ue(M), u = oe(te), d = a.numberToBytesBE(o.mod(b - u, e.secp256k1.CURVE.n), 32);
    return e.secp256k1.utils.isValidPrivateKey(d) ? d : null;
  }
  function me(M) {
    const te = ue(M), b = a.numberToBytesBE(e.secp256k1.CURVE.n - te, 32);
    return e.secp256k1.utils.isValidPrivateKey(b) ? b : null;
  }
  function Se(M, te, b) {
    const u = G(M), d = oe(te), S = s.BASE.multiplyAndAddUnsafe(u, d, F);
    if (!S) throw new Error("Tweaked point at infinity");
    return S.toRawBytes(b);
  }
  function De(M, te, b) {
    const u = G(M), d = typeof te == "string" ? te : a.bytesToHex(te), S = a.hexToNumber(d);
    return u.multiply(S).toRawBytes(b);
  }
  function q(M, te) {
    return M === void 0 ? te !== void 0 ? Q(te) : !0 : !!M;
  }
  function H(M) {
    try {
      return M();
    } catch {
      return null;
    }
  }
  function C(M) {
    return e.schnorr.utils.lift_x(a.bytesToNumberBE(M));
  }
  function G(M) {
    return M.length === 32 ? C(M) : s.fromHex(M);
  }
  function V(M, te) {
    if (M.length === 32 !== te) return !1;
    try {
      return te ? !!C(M) : !!s.fromHex(M);
    } catch {
      return !1;
    }
  }
  function X(M) {
    return V(M, !1);
  }
  function Q(M) {
    return V(M, !1) && M.length === 33;
  }
  function ee(M) {
    return e.secp256k1.utils.isValidPrivateKey(M);
  }
  function ne(M) {
    return V(M, !0);
  }
  function se(M, te) {
    if (!ne(M))
      throw new Error(h);
    if (!O(te))
      throw new Error(l);
    return H(() => {
      const b = Se(M, te, !0);
      return { parity: b[0] % 2 === 1 ? 1 : 0, xOnlyPubkey: b.slice(1) };
    });
  }
  function ce(M) {
    if (!X(M))
      throw new Error(h);
    return M.slice(1, 33);
  }
  function le(M, te) {
    if (!ee(M))
      throw new Error(i);
    return H(
      () => e.secp256k1.getPublicKey(M, q(te))
    );
  }
  function he(M) {
    if (!ee(M))
      throw new Error(i);
    return ce(le(M));
  }
  function ye(M, te) {
    if (!X(M))
      throw new Error(h);
    return G(M).toRawBytes(q(te, M));
  }
  function pe(M, te, b) {
    if (!X(M))
      throw new Error(h);
    if (!O(te))
      throw new Error(l);
    return H(
      () => De(M, te, q(b, M))
    );
  }
  function we(M, te, b) {
    if (!X(M) || !X(te))
      throw new Error(h);
    return H(() => {
      const u = G(M), d = G(te);
      return u.equals(d.negate()) ? null : u.add(d).toRawBytes(q(b, M));
    });
  }
  function Oe(M, te, b) {
    if (!X(M))
      throw new Error(h);
    if (!O(te))
      throw new Error(l);
    return H(
      () => Se(M, te, q(b, M))
    );
  }
  function $(M, te) {
    if (!ee(M))
      throw new Error(i);
    if (!O(te))
      throw new Error(l);
    return H(() => ie(M, te));
  }
  function Re(M, te) {
    if (!ee(M))
      throw new Error(i);
    if (!O(te))
      throw new Error(l);
    return H(() => de(M, te));
  }
  function ae(M) {
    if (!ee(M))
      throw new Error(i);
    return me(M);
  }
  function fe(M, te, b) {
    if (!ee(te))
      throw new Error(i);
    if (!Z(M))
      throw new Error(v);
    if (!re(b))
      throw new Error(g);
    return e.secp256k1.sign(M, te, { extraEntropy: b }).toCompactRawBytes();
  }
  function ge(M, te, b) {
    if (!ee(te))
      throw new Error(i);
    if (!Z(M))
      throw new Error(v);
    if (!re(b))
      throw new Error(g);
    const u = e.secp256k1.sign(M, te, { extraEntropy: b });
    return {
      signature: u.toCompactRawBytes(),
      recoveryId: u.recovery
    };
  }
  function xe(M, te, b) {
    if (!ee(te))
      throw new Error(i);
    if (!Z(M))
      throw new Error(v);
    if (!re(b))
      throw new Error(g);
    return e.schnorr.sign(M, te, b);
  }
  function Be(M, te, b, u) {
    if (!Z(M))
      throw new Error(c);
    if (!R(te) || !T(te))
      throw new Error(w);
    if (b & 2 && !U(te))
      throw new Error(k);
    if (!ne(te.subarray(0, 32)))
      throw new Error(w);
    const S = e.secp256k1.Signature.fromCompact(te).addRecoveryBit(b).recoverPublicKey(M);
    if (!S) throw new Error(w);
    return S.toRawBytes(q(u));
  }
  function Ye(M, te, b, u) {
    if (!X(te))
      throw new Error(h);
    if (!R(b))
      throw new Error(w);
    if (!Z(M))
      throw new Error(v);
    return e.secp256k1.verify(b, M, te, { lowS: u });
  }
  function fr(M, te, b) {
    if (!ne(te))
      throw new Error(h);
    if (!R(b))
      throw new Error(w);
    if (!Z(M))
      throw new Error(v);
    return e.schnorr.verify(b, M, te);
  }
  return Le.isPoint = X, Le.isPointCompressed = Q, Le.isPrivate = ee, Le.isXOnlyPoint = ne, Le.pointAdd = we, Le.pointAddScalar = Oe, Le.pointCompress = ye, Le.pointFromScalar = le, Le.pointMultiply = pe, Le.privateAdd = $, Le.privateNegate = ae, Le.privateSub = Re, Le.recover = Be, Le.sign = fe, Le.signRecoverable = ge, Le.signSchnorr = xe, Le.verify = Ye, Le.verifySchnorr = fr, Le.xOnlyPointAddTweak = se, Le.xOnlyPointFromPoint = ce, Le.xOnlyPointFromScalar = he, Le;
}
var nd = ob();
const ib = /* @__PURE__ */ Ea(nd), bv = /* @__PURE__ */ bh({
  __proto__: null,
  default: ib
}, [nd]);
var to = {}, gr = {}, zt = {}, tu;
function ad() {
  if (tu) return zt;
  tu = 1, Object.defineProperty(zt, "__esModule", { value: !0 }), zt.hash160 = o, zt.hash256 = a, zt.hmacSHA512 = s;
  const e = /* @__PURE__ */ nh(), t = /* @__PURE__ */ th(), r = /* @__PURE__ */ kn(), n = /* @__PURE__ */ hf();
  function o(i) {
    return (0, t.ripemd160)((0, r.sha256)(i));
  }
  function a(i) {
    return (0, r.sha256)(i);
  }
  function s(i, h) {
    return (0, e.hmac)(n.sha512, i, h);
  }
  return zt;
}
var br = {};
const ha = "0123456789abcdefABCDEF", pa = ha.split("").map((e) => e.codePointAt(0)), ga = Array(256).fill(!0).map((e, t) => {
  const r = String.fromCodePoint(t), n = ha.indexOf(r);
  return n < 0 ? void 0 : n < 16 ? n : n - 6;
}), od = new TextEncoder(), id = new TextDecoder();
function sb(e) {
  return id.decode(e);
}
function cb(e) {
  return od.encode(e);
}
function ub(e) {
  const t = e.reduce((o, a) => o + a.length, 0), r = new Uint8Array(t);
  let n = 0;
  for (const o of e)
    r.set(o, n), n += o.length;
  return r;
}
function lb(e) {
  const t = e || new Uint8Array();
  return t.length > 512 ? db(t) : fb(t);
}
function fb(e) {
  let t = "";
  for (let r = 0; r < e.length; ++r)
    t += ha[ga[pa[e[r] >> 4]]], t += ha[ga[pa[e[r] & 15]]];
  return t;
}
function db(e) {
  const t = new Uint8Array(e.length * 2);
  for (let r = 0; r < e.length; ++r)
    t[r * 2] = pa[e[r] >> 4], t[r * 2 + 1] = pa[e[r] & 15];
  return id.decode(t);
}
function hb(e) {
  const t = od.encode(e || ""), r = new Uint8Array(Math.floor(t.length / 2));
  let n;
  for (n = 0; n < r.length; n++) {
    const o = ga[t[n * 2]], a = ga[t[n * 2 + 1]];
    if (o === void 0 || a === void 0)
      break;
    r[n] = o << 4 | a;
  }
  return n === r.length ? r : r.slice(0, n);
}
function pb(e) {
  return btoa(String.fromCharCode(...e));
}
function gb(e) {
  const t = atob(e), r = new Uint8Array(t.length);
  for (let n = 0; n < t.length; n++)
    r[n] = t.charCodeAt(n);
  return r;
}
function bb(e, t) {
  const r = Math.min(e.length, t.length);
  for (let n = 0; n < r; ++n)
    if (e[n] !== t[n])
      return e[n] < t[n] ? -1 : 1;
  return e.length === t.length ? 0 : e.length > t.length ? 1 : -1;
}
function mb(e, t, r) {
  if (t + 1 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r > 255)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 255. Received ${r}`);
  return e[t] = r, t + 1;
}
function yb(e, t, r, n) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 65535)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 65535. Received ${r}`);
  return n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255) : (e[t] = r >> 8 & 255, e[t + 1] = r & 255), t + 2;
}
function vb(e, t, r, n) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 4294967295)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${4294967295}. Received ${r}`);
  return n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255, e[t + 2] = r >> 16 & 255, e[t + 3] = r >> 24 & 255) : (e[t] = r >> 24 & 255, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = r & 255), t + 4;
}
function wb(e, t, r, n) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 0xffffffffffffffffn)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffffffffffffffffn}. Received ${r}`);
  return n === "LE" ? (e[t] = Number(r & 0xffn), e[t + 1] = Number(r >> 8n & 0xffn), e[t + 2] = Number(r >> 16n & 0xffn), e[t + 3] = Number(r >> 24n & 0xffn), e[t + 4] = Number(r >> 32n & 0xffn), e[t + 5] = Number(r >> 40n & 0xffn), e[t + 6] = Number(r >> 48n & 0xffn), e[t + 7] = Number(r >> 56n & 0xffn)) : (e[t] = Number(r >> 56n & 0xffn), e[t + 1] = Number(r >> 48n & 0xffn), e[t + 2] = Number(r >> 40n & 0xffn), e[t + 3] = Number(r >> 32n & 0xffn), e[t + 4] = Number(r >> 24n & 0xffn), e[t + 5] = Number(r >> 16n & 0xffn), e[t + 6] = Number(r >> 8n & 0xffn), e[t + 7] = Number(r & 0xffn)), t + 8;
}
function _b(e, t) {
  if (t + 1 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  return e[t];
}
function kb(e, t, r) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0;
    return n = (n << 8) + e[t + 1], n = (n << 8) + e[t], n;
  } else {
    let n = 0;
    return n = (n << 8) + e[t], n = (n << 8) + e[t + 1], n;
  }
}
function Eb(e, t, r) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0;
    return n = (n << 8) + e[t + 3] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t] >>> 0, n;
  } else {
    let n = 0;
    return n = (n << 8) + e[t] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 3] >>> 0, n;
  }
}
function xb(e, t, r) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0n;
    return n = (n << 8n) + BigInt(e[t + 7]), n = (n << 8n) + BigInt(e[t + 6]), n = (n << 8n) + BigInt(e[t + 5]), n = (n << 8n) + BigInt(e[t + 4]), n = (n << 8n) + BigInt(e[t + 3]), n = (n << 8n) + BigInt(e[t + 2]), n = (n << 8n) + BigInt(e[t + 1]), n = (n << 8n) + BigInt(e[t]), n;
  } else {
    let n = 0n;
    return n = (n << 8n) + BigInt(e[t]), n = (n << 8n) + BigInt(e[t + 1]), n = (n << 8n) + BigInt(e[t + 2]), n = (n << 8n) + BigInt(e[t + 3]), n = (n << 8n) + BigInt(e[t + 4]), n = (n << 8n) + BigInt(e[t + 5]), n = (n << 8n) + BigInt(e[t + 6]), n = (n << 8n) + BigInt(e[t + 7]), n;
  }
}
function Ab(e, t, r) {
  if (t + 1 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r > 127 || r < -128)
    throw new Error(`The value of "value" is out of range. It must be >= -128 and <= 127. Received ${r}`);
  return e[t] = r, t + 1;
}
function Sb(e, t, r, n) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r > 32767 || r < -32768)
    throw new Error(`The value of "value" is out of range. It must be >= -32768 and <= 32767. Received ${r}`);
  return n = n.toUpperCase(), n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255) : (e[t] = r >> 8 & 255, e[t + 1] = r & 255), t + 2;
}
function Ib(e, t, r, n) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r > 2147483647 || r < -2147483648)
    throw new Error(`The value of "value" is out of range. It must be >= -2147483648 and <= 2147483647. Received ${r}`);
  return n = n.toUpperCase(), n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255, e[t + 2] = r >> 16 & 255, e[t + 3] = r >> 24 & 255) : (e[t] = r >> 24 & 255, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = r & 255), t + 4;
}
function Bb(e, t, r, n) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r > 0x7fffffffffffffffn || r < -0x8000000000000000n)
    throw new Error(`The value of "value" is out of range. It must be >= ${-0x8000000000000000n} and <= ${0x7fffffffffffffffn}. Received ${r}`);
  return n = n.toUpperCase(), n === "LE" ? (e[t] = Number(r & 0xffn), e[t + 1] = Number(r >> 8n & 0xffn), e[t + 2] = Number(r >> 16n & 0xffn), e[t + 3] = Number(r >> 24n & 0xffn), e[t + 4] = Number(r >> 32n & 0xffn), e[t + 5] = Number(r >> 40n & 0xffn), e[t + 6] = Number(r >> 48n & 0xffn), e[t + 7] = Number(r >> 56n & 0xffn)) : (e[t] = Number(r >> 56n & 0xffn), e[t + 1] = Number(r >> 48n & 0xffn), e[t + 2] = Number(r >> 40n & 0xffn), e[t + 3] = Number(r >> 32n & 0xffn), e[t + 4] = Number(r >> 24n & 0xffn), e[t + 5] = Number(r >> 16n & 0xffn), e[t + 6] = Number(r >> 8n & 0xffn), e[t + 7] = Number(r & 0xffn)), t + 8;
}
function Tb(e, t) {
  if (t + 1 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  const r = e[t];
  return r <= 127 ? r : r - 256;
}
function zb(e, t, r) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    const n = e[t] + (e[t + 1] << 8);
    return e[t + 1] <= 127 ? n : n - 65536;
  } else {
    const n = (e[t] << 8) + e[t + 1];
    return e[t] <= 127 ? n : n - 65536;
  }
}
function Ob(e, t, r) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    const n = e[t] + (e[t + 1] << 8) + (e[t + 2] << 16) + (e[t + 3] << 24 >>> 0);
    return e[t + 3] <= 127 ? n : n - 4294967296;
  } else {
    const n = (e[t] << 24 >>> 0) + (e[t + 1] << 16) + (e[t + 2] << 8) + e[t + 3];
    return e[t] <= 127 ? n : n - 4294967296;
  }
}
function Rb(e, t, r) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  r = r.toUpperCase();
  let n = 0n;
  if (r === "LE")
    return n = (n << 8n) + BigInt(e[t + 7]), n = (n << 8n) + BigInt(e[t + 6]), n = (n << 8n) + BigInt(e[t + 5]), n = (n << 8n) + BigInt(e[t + 4]), n = (n << 8n) + BigInt(e[t + 3]), n = (n << 8n) + BigInt(e[t + 2]), n = (n << 8n) + BigInt(e[t + 1]), n = (n << 8n) + BigInt(e[t]), e[t + 7] <= 127 ? n : n - 0x10000000000000000n;
  {
    let o = 0n;
    return o = (o << 8n) + BigInt(e[t]), o = (o << 8n) + BigInt(e[t + 1]), o = (o << 8n) + BigInt(e[t + 2]), o = (o << 8n) + BigInt(e[t + 3]), o = (o << 8n) + BigInt(e[t + 4]), o = (o << 8n) + BigInt(e[t + 5]), o = (o << 8n) + BigInt(e[t + 6]), o = (o << 8n) + BigInt(e[t + 7]), e[t] <= 127 ? o : o - 0x10000000000000000n;
  }
}
const jb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  compare: bb,
  concat: ub,
  fromBase64: gb,
  fromHex: hb,
  fromUtf8: cb,
  readInt16: zb,
  readInt32: Ob,
  readInt64: Rb,
  readInt8: Tb,
  readUInt16: kb,
  readUInt32: Eb,
  readUInt64: xb,
  readUInt8: _b,
  toBase64: pb,
  toHex: lb,
  toUtf8: sb,
  writeInt16: Sb,
  writeInt32: Ib,
  writeInt64: Bb,
  writeInt8: Ab,
  writeUInt16: yb,
  writeUInt32: vb,
  writeUInt64: wb,
  writeUInt8: mb
}, Symbol.toStringTag, { value: "Module" })), ms = /* @__PURE__ */ En(jb);
var nu;
function Pb() {
  if (nu) return br;
  nu = 1;
  var e = br && br.__createBinding || (Object.create ? (function(i, h, l, c) {
    c === void 0 && (c = l);
    var w = Object.getOwnPropertyDescriptor(h, l);
    (!w || ("get" in w ? !h.__esModule : w.writable || w.configurable)) && (w = { enumerable: !0, get: function() {
      return h[l];
    } }), Object.defineProperty(i, c, w);
  }) : (function(i, h, l, c) {
    c === void 0 && (c = l), i[c] = h[l];
  })), t = br && br.__setModuleDefault || (Object.create ? (function(i, h) {
    Object.defineProperty(i, "default", { enumerable: !0, value: h });
  }) : function(i, h) {
    i.default = h;
  }), r = br && br.__importStar || /* @__PURE__ */ (function() {
    var i = function(h) {
      return i = Object.getOwnPropertyNames || function(l) {
        var c = [];
        for (var w in l) Object.prototype.hasOwnProperty.call(l, w) && (c[c.length] = w);
        return c;
      }, i(h);
    };
    return function(h) {
      if (h && h.__esModule) return h;
      var l = {};
      if (h != null) for (var c = i(h), w = 0; w < c.length; w++) c[w] !== "default" && e(l, h, c[w]);
      return t(l, h), l;
    };
  })();
  Object.defineProperty(br, "__esModule", { value: !0 }), br.testEcc = a;
  const n = r(ms), o = (i) => n.fromHex(i);
  function a(i) {
    if (s(i.isPoint(o("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))), s(!i.isPoint(o("030000000000000000000000000000000000000000000000000000000000000005"))), s(i.isPrivate(o("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))), s(i.isPrivate(o("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140"))), s(!i.isPrivate(o("0000000000000000000000000000000000000000000000000000000000000000"))), s(!i.isPrivate(o("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"))), s(!i.isPrivate(o("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142"))), s(n.compare(i.pointFromScalar(o("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")), o("02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99")) === 0), i.xOnlyPointAddTweak) {
      s(i.xOnlyPointAddTweak(o("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), o("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === null);
      let h = i.xOnlyPointAddTweak(o("1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b"), o("a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac"));
      s(n.compare(h.xOnlyPubkey, o("e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf")) === 0 && h.parity === 1), h = i.xOnlyPointAddTweak(o("2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991"), o("823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47"));
    }
    s(n.compare(i.pointAddScalar(o("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), o("0000000000000000000000000000000000000000000000000000000000000003")), o("02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5")) === 0), s(n.compare(i.privateAdd(o("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"), o("0000000000000000000000000000000000000000000000000000000000000002")), o("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === 0), i.privateNegate && (s(n.compare(i.privateNegate(o("0000000000000000000000000000000000000000000000000000000000000001")), o("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === 0), s(n.compare(i.privateNegate(o("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e")), o("0000000000000000000000000000000000000000000000000000000000000003")) === 0), s(n.compare(i.privateNegate(o("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")), o("4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792")) === 0)), s(n.compare(i.sign(o("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), o("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")), o("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5")) === 0), s(i.verify(o("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), o("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), o("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"))), i.signSchnorr && s(n.compare(i.signSchnorr(o("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), o("c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9"), o("c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906")), o("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7")) === 0), i.verifySchnorr && s(i.verifySchnorr(o("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), o("dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8"), o("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7")));
  }
  function s(i) {
    if (!i)
      throw new Error("ecc library invalid");
  }
  return br;
}
function _t(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function ys(e) {
  if (!_t(e))
    throw new Error("Uint8Array expected");
}
function sd(e, t) {
  return Array.isArray(t) ? t.length === 0 ? !0 : e ? t.every((r) => typeof r == "string") : t.every((r) => Number.isSafeInteger(r)) : !1;
}
function vs(e) {
  if (typeof e != "function")
    throw new Error("function expected");
  return !0;
}
function st(e, t) {
  if (typeof t != "string")
    throw new Error(`${e}: string expected`);
  return !0;
}
function $t(e) {
  if (!Number.isSafeInteger(e))
    throw new Error(`invalid integer: ${e}`);
}
function ba(e) {
  if (!Array.isArray(e))
    throw new Error("array expected");
}
function ma(e, t) {
  if (!sd(!0, t))
    throw new Error(`${e}: array of strings expected`);
}
function ws(e, t) {
  if (!sd(!1, t))
    throw new Error(`${e}: array of numbers expected`);
}
// @__NO_SIDE_EFFECTS__
function Ze(...e) {
  const t = (a) => a, r = (a, s) => (i) => a(s(i)), n = e.map((a) => a.encode).reduceRight(r, t), o = e.map((a) => a.decode).reduce(r, t);
  return { encode: n, decode: o };
}
// @__NO_SIDE_EFFECTS__
function Je(e) {
  const t = typeof e == "string" ? e.split("") : e, r = t.length;
  ma("alphabet", t);
  const n = new Map(t.map((o, a) => [o, a]));
  return {
    encode: (o) => (ba(o), o.map((a) => {
      if (!Number.isSafeInteger(a) || a < 0 || a >= r)
        throw new Error(`alphabet.encode: digit index outside alphabet "${a}". Allowed: ${e}`);
      return t[a];
    })),
    decode: (o) => (ba(o), o.map((a) => {
      st("alphabet.decode", a);
      const s = n.get(a);
      if (s === void 0)
        throw new Error(`Unknown letter: "${a}". Allowed: ${e}`);
      return s;
    }))
  };
}
// @__NO_SIDE_EFFECTS__
function Qe(e = "") {
  return st("join", e), {
    encode: (t) => (ma("join.decode", t), t.join(e)),
    decode: (t) => (st("join.decode", t), t.split(e))
  };
}
// @__NO_SIDE_EFFECTS__
function Tn(e, t = "=") {
  return $t(e), st("padding", t), {
    encode(r) {
      for (ma("padding.encode", r); r.length * e % 8; )
        r.push(t);
      return r;
    },
    decode(r) {
      ma("padding.decode", r);
      let n = r.length;
      if (n * e % 8)
        throw new Error("padding: invalid, string should have whole number of bytes");
      for (; n > 0 && r[n - 1] === t; n--)
        if ((n - 1) * e % 8 === 0)
          throw new Error("padding: invalid, string has too much padding");
      return r.slice(0, n);
    }
  };
}
// @__NO_SIDE_EFFECTS__
function cd(e) {
  return vs(e), { encode: (t) => t, decode: (t) => e(t) };
}
function Ci(e, t, r) {
  if (t < 2)
    throw new Error(`convertRadix: invalid from=${t}, base cannot be less than 2`);
  if (r < 2)
    throw new Error(`convertRadix: invalid to=${r}, base cannot be less than 2`);
  if (ba(e), !e.length)
    return [];
  let n = 0;
  const o = [], a = Array.from(e, (i) => {
    if ($t(i), i < 0 || i >= t)
      throw new Error(`invalid integer: ${i}`);
    return i;
  }), s = a.length;
  for (; ; ) {
    let i = 0, h = !0;
    for (let l = n; l < s; l++) {
      const c = a[l], w = t * i, g = w + c;
      if (!Number.isSafeInteger(g) || w / t !== i || g - c !== w)
        throw new Error("convertRadix: carry overflow");
      const v = g / r;
      i = g % r;
      const k = Math.floor(v);
      if (a[l] = k, !Number.isSafeInteger(k) || k * r + i !== g)
        throw new Error("convertRadix: carry overflow");
      if (h)
        k ? h = !1 : n = l;
      else continue;
    }
    if (o.push(i), h)
      break;
  }
  for (let i = 0; i < e.length - 1 && e[i] === 0; i++)
    o.push(0);
  return o.reverse();
}
const ud = (e, t) => t === 0 ? e : ud(t, e % t), ya = /* @__NO_SIDE_EFFECTS__ */ (e, t) => e + (t - ud(e, t)), Qn = /* @__PURE__ */ (() => {
  let e = [];
  for (let t = 0; t < 40; t++)
    e.push(2 ** t);
  return e;
})();
function va(e, t, r, n) {
  if (ba(e), t <= 0 || t > 32)
    throw new Error(`convertRadix2: wrong from=${t}`);
  if (r <= 0 || r > 32)
    throw new Error(`convertRadix2: wrong to=${r}`);
  if (/* @__PURE__ */ ya(t, r) > 32)
    throw new Error(`convertRadix2: carry overflow from=${t} to=${r} carryBits=${/* @__PURE__ */ ya(t, r)}`);
  let o = 0, a = 0;
  const s = Qn[t], i = Qn[r] - 1, h = [];
  for (const l of e) {
    if ($t(l), l >= s)
      throw new Error(`convertRadix2: invalid data word=${l} from=${t}`);
    if (o = o << t | l, a + t > 32)
      throw new Error(`convertRadix2: carry overflow pos=${a} from=${t}`);
    for (a += t; a >= r; a -= r)
      h.push((o >> a - r & i) >>> 0);
    const c = Qn[a];
    if (c === void 0)
      throw new Error("invalid carry");
    o &= c - 1;
  }
  if (o = o << r - a & i, !n && a >= t)
    throw new Error("Excess padding");
  if (!n && o > 0)
    throw new Error(`Non-zero padding: ${o}`);
  return n && a > 0 && h.push(o >>> 0), h;
}
// @__NO_SIDE_EFFECTS__
function ld(e) {
  $t(e);
  const t = 2 ** 8;
  return {
    encode: (r) => {
      if (!_t(r))
        throw new Error("radix.encode input should be Uint8Array");
      return Ci(Array.from(r), t, e);
    },
    decode: (r) => (ws("radix.decode", r), Uint8Array.from(Ci(r, e, t)))
  };
}
// @__NO_SIDE_EFFECTS__
function or(e, t = !1) {
  if ($t(e), e <= 0 || e > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (/* @__PURE__ */ ya(8, e) > 32 || /* @__PURE__ */ ya(e, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (r) => {
      if (!_t(r))
        throw new Error("radix2.encode input should be Uint8Array");
      return va(Array.from(r), 8, e, !t);
    },
    decode: (r) => (ws("radix2.decode", r), Uint8Array.from(va(r, e, 8, t)))
  };
}
function au(e) {
  return vs(e), function(...t) {
    try {
      return e.apply(null, t);
    } catch {
    }
  };
}
function fd(e, t) {
  return $t(e), vs(t), {
    encode(r) {
      if (!_t(r))
        throw new Error("checksum.encode: input should be Uint8Array");
      const n = t(r).slice(0, e), o = new Uint8Array(r.length + e);
      return o.set(r), o.set(n, r.length), o;
    },
    decode(r) {
      if (!_t(r))
        throw new Error("checksum.decode: input should be Uint8Array");
      const n = r.slice(0, -e), o = r.slice(-e), a = t(n).slice(0, e);
      for (let s = 0; s < e; s++)
        if (a[s] !== o[s])
          throw new Error("Invalid checksum");
      return n;
    }
  };
}
const Ub = {
  alphabet: Je,
  chain: Ze,
  checksum: fd,
  convertRadix: Ci,
  convertRadix2: va,
  radix: ld,
  radix2: or,
  join: Qe,
  padding: Tn
}, dd = /* @__PURE__ */ Ze(/* @__PURE__ */ or(4), /* @__PURE__ */ Je("0123456789ABCDEF"), /* @__PURE__ */ Qe("")), hd = /* @__PURE__ */ Ze(/* @__PURE__ */ or(5), /* @__PURE__ */ Je("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), /* @__PURE__ */ Tn(5), /* @__PURE__ */ Qe("")), Nb = /* @__PURE__ */ Ze(/* @__PURE__ */ or(5), /* @__PURE__ */ Je("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), /* @__PURE__ */ Qe("")), Cb = /* @__PURE__ */ Ze(/* @__PURE__ */ or(5), /* @__PURE__ */ Je("0123456789ABCDEFGHIJKLMNOPQRSTUV"), /* @__PURE__ */ Tn(5), /* @__PURE__ */ Qe("")), Lb = /* @__PURE__ */ Ze(/* @__PURE__ */ or(5), /* @__PURE__ */ Je("0123456789ABCDEFGHIJKLMNOPQRSTUV"), /* @__PURE__ */ Qe("")), qb = /* @__PURE__ */ Ze(/* @__PURE__ */ or(5), /* @__PURE__ */ Je("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), /* @__PURE__ */ Qe(""), /* @__PURE__ */ cd((e) => e.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1"))), pd = typeof Uint8Array.from([]).toBase64 == "function" && typeof Uint8Array.fromBase64 == "function", gd = (e, t) => {
  st("base64", e);
  const r = t ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/, n = t ? "base64url" : "base64";
  if (e.length > 0 && !r.test(e))
    throw new Error("invalid base64");
  return Uint8Array.fromBase64(e, { alphabet: n, lastChunkHandling: "strict" });
}, bd = pd ? {
  encode(e) {
    return ys(e), e.toBase64();
  },
  decode(e) {
    return gd(e, !1);
  }
} : /* @__PURE__ */ Ze(/* @__PURE__ */ or(6), /* @__PURE__ */ Je("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ Tn(6), /* @__PURE__ */ Qe("")), Mb = /* @__PURE__ */ Ze(/* @__PURE__ */ or(6), /* @__PURE__ */ Je("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ Qe("")), md = pd ? {
  encode(e) {
    return ys(e), e.toBase64({ alphabet: "base64url" });
  },
  decode(e) {
    return gd(e, !0);
  }
} : /* @__PURE__ */ Ze(/* @__PURE__ */ or(6), /* @__PURE__ */ Je("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), /* @__PURE__ */ Tn(6), /* @__PURE__ */ Qe("")), Db = /* @__PURE__ */ Ze(/* @__PURE__ */ or(6), /* @__PURE__ */ Je("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), /* @__PURE__ */ Qe("")), _s = /* @__NO_SIDE_EFFECTS__ */ (e) => /* @__PURE__ */ Ze(/* @__PURE__ */ ld(58), /* @__PURE__ */ Je(e), /* @__PURE__ */ Qe("")), wn = /* @__PURE__ */ _s("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), Fb = /* @__PURE__ */ _s("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"), Kb = /* @__PURE__ */ _s("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz"), ou = [0, 2, 3, 5, 6, 7, 9, 10, 11], yd = {
  encode(e) {
    let t = "";
    for (let r = 0; r < e.length; r += 8) {
      const n = e.subarray(r, r + 8);
      t += wn.encode(n).padStart(ou[n.length], "1");
    }
    return t;
  },
  decode(e) {
    let t = [];
    for (let r = 0; r < e.length; r += 11) {
      const n = e.slice(r, r + 11), o = ou.indexOf(n.length), a = wn.decode(n);
      for (let s = 0; s < a.length - o; s++)
        if (a[s] !== 0)
          throw new Error("base58xmr: wrong padding");
      t = t.concat(Array.from(a.slice(a.length - o)));
    }
    return Uint8Array.from(t);
  }
}, vd = (e) => /* @__PURE__ */ Ze(fd(4, (t) => e(e(t))), wn), Hb = vd, Li = /* @__PURE__ */ Ze(/* @__PURE__ */ Je("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), /* @__PURE__ */ Qe("")), iu = [996825010, 642813549, 513874426, 1027748829, 705979059];
function Jt(e) {
  const t = e >> 25;
  let r = (e & 33554431) << 5;
  for (let n = 0; n < iu.length; n++)
    (t >> n & 1) === 1 && (r ^= iu[n]);
  return r;
}
function su(e, t, r = 1) {
  const n = e.length;
  let o = 1;
  for (let a = 0; a < n; a++) {
    const s = e.charCodeAt(a);
    if (s < 33 || s > 126)
      throw new Error(`Invalid prefix (${e})`);
    o = Jt(o) ^ s >> 5;
  }
  o = Jt(o);
  for (let a = 0; a < n; a++)
    o = Jt(o) ^ e.charCodeAt(a) & 31;
  for (let a of t)
    o = Jt(o) ^ a;
  for (let a = 0; a < 6; a++)
    o = Jt(o);
  return o ^= r, Li.encode(va([o % Qn[30]], 30, 5, !1));
}
// @__NO_SIDE_EFFECTS__
function wd(e) {
  const t = e === "bech32" ? 1 : 734539939, r = /* @__PURE__ */ or(5), n = r.decode, o = r.encode, a = au(n);
  function s(w, g, v = 90) {
    st("bech32.encode prefix", w), _t(g) && (g = Array.from(g)), ws("bech32.encode", g);
    const k = w.length;
    if (k === 0)
      throw new TypeError(`Invalid prefix length ${k}`);
    const y = k + 7 + g.length;
    if (v !== !1 && y > v)
      throw new TypeError(`Length ${y} exceeds limit ${v}`);
    const m = w.toLowerCase(), A = su(m, g, t);
    return `${m}1${Li.encode(g)}${A}`;
  }
  function i(w, g = 90) {
    st("bech32.decode input", w);
    const v = w.length;
    if (v < 8 || g !== !1 && v > g)
      throw new TypeError(`invalid string length: ${v} (${w}). Expected (8..${g})`);
    const k = w.toLowerCase();
    if (w !== k && w !== w.toUpperCase())
      throw new Error("String must be lowercase or uppercase");
    const y = k.lastIndexOf("1");
    if (y === 0 || y === -1)
      throw new Error('Letter "1" must be present between prefix and data only');
    const m = k.slice(0, y), A = k.slice(y + 1);
    if (A.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const E = Li.decode(A).slice(0, -6), x = su(m, E, t);
    if (!A.endsWith(x))
      throw new Error(`Invalid checksum in ${w}: expected "${x}"`);
    return { prefix: m, words: E };
  }
  const h = au(i);
  function l(w) {
    const { prefix: g, words: v } = i(w, !1);
    return { prefix: g, words: v, bytes: n(v) };
  }
  function c(w, g) {
    return s(w, o(g));
  }
  return {
    encode: s,
    decode: i,
    encodeFromBytes: c,
    decodeToBytes: l,
    decodeUnsafe: h,
    fromWords: n,
    fromWordsUnsafe: a,
    toWords: o
  };
}
const $b = /* @__PURE__ */ wd("bech32"), Gb = /* @__PURE__ */ wd("bech32m"), _d = {
  encode: (e) => new TextDecoder().decode(e),
  decode: (e) => new TextEncoder().encode(e)
}, Wb = typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function", Vb = {
  encode(e) {
    return ys(e), e.toHex();
  },
  decode(e) {
    return st("hex", e), Uint8Array.fromHex(e);
  }
}, kd = Wb ? Vb : /* @__PURE__ */ Ze(/* @__PURE__ */ or(4), /* @__PURE__ */ Je("0123456789abcdef"), /* @__PURE__ */ Qe(""), /* @__PURE__ */ cd((e) => {
  if (typeof e != "string" || e.length % 2 !== 0)
    throw new TypeError(`hex.decode: expected string, got ${typeof e} with length ${e.length}`);
  return e.toLowerCase();
})), wa = {
  utf8: _d,
  hex: kd,
  base16: dd,
  base32: hd,
  base64: bd,
  base64url: md,
  base58: wn,
  base58xmr: yd
}, Ed = "Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr", xd = (e, t) => {
  if (typeof e != "string" || !wa.hasOwnProperty(e))
    throw new TypeError(Ed);
  if (!_t(t))
    throw new TypeError("bytesToString() expects Uint8Array");
  return wa[e].encode(t);
}, Zb = xd, Ad = (e, t) => {
  if (!wa.hasOwnProperty(e))
    throw new TypeError(Ed);
  if (typeof t != "string")
    throw new TypeError("stringToBytes() expects string");
  return wa[e].decode(t);
}, Yb = Ad, Xb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16: dd,
  base32: hd,
  base32crockford: qb,
  base32hex: Cb,
  base32hexnopad: Lb,
  base32nopad: Nb,
  base58: wn,
  base58check: Hb,
  base58flickr: Fb,
  base58xmr: yd,
  base58xrp: Kb,
  base64: bd,
  base64nopad: Mb,
  base64url: md,
  base64urlnopad: Db,
  bech32: $b,
  bech32m: Gb,
  bytes: Yb,
  bytesToString: xd,
  createBase58check: vd,
  hex: kd,
  str: Zb,
  stringToBytes: Ad,
  utf8: _d,
  utils: Ub
}, Symbol.toStringTag, { value: "Module" })), Sd = /* @__PURE__ */ En(Xb);
var Tr = {}, cu;
function Id() {
  return cu || (cu = 1, (function(e) {
    var t = Tr && Tr.__createBinding || (Object.create ? (function(i, h, l, c) {
      c === void 0 && (c = l);
      var w = Object.getOwnPropertyDescriptor(h, l);
      (!w || ("get" in w ? !h.__esModule : w.writable || w.configurable)) && (w = { enumerable: !0, get: function() {
        return h[l];
      } }), Object.defineProperty(i, c, w);
    }) : (function(i, h, l, c) {
      c === void 0 && (c = l), i[c] = h[l];
    })), r = Tr && Tr.__setModuleDefault || (Object.create ? (function(i, h) {
      Object.defineProperty(i, "default", { enumerable: !0, value: h });
    }) : function(i, h) {
      i.default = h;
    }), n = Tr && Tr.__importStar || /* @__PURE__ */ (function() {
      var i = function(h) {
        return i = Object.getOwnPropertyNames || function(l) {
          var c = [];
          for (var w in l) Object.prototype.hasOwnProperty.call(l, w) && (c[c.length] = w);
          return c;
        }, i(h);
      };
      return function(h) {
        if (h && h.__esModule) return h;
        var l = {};
        if (h != null) for (var c = i(h), w = 0; w < c.length; w++) c[w] !== "default" && t(l, h, c[w]);
        return r(l, h), l;
      };
    })();
    Object.defineProperty(e, "__esModule", { value: !0 }), e.Bip32PathSchema = e.NetworkSchema = e.Buffer33Bytes = e.Buffer256Bit = e.Uint31Schema = e.Uint32Schema = void 0;
    const o = n(/* @__PURE__ */ as());
    e.Uint32Schema = o.pipe(o.number(), o.integer(), o.minValue(0), o.maxValue(4294967295)), e.Uint31Schema = o.pipe(o.number(), o.integer(), o.minValue(0), o.maxValue(2147483647));
    const a = o.pipe(o.number(), o.integer(), o.minValue(0), o.maxValue(255));
    e.Buffer256Bit = o.pipe(o.instance(Uint8Array), o.length(32)), e.Buffer33Bytes = o.pipe(o.instance(Uint8Array), o.length(33));
    const s = o.object({
      public: e.Uint32Schema,
      private: e.Uint32Schema
    });
    e.NetworkSchema = o.object({
      wif: a,
      bip32: s,
      messagePrefix: o.string(),
      bech32: o.string(),
      bech32Opnet: o.optional(o.string()),
      pubKeyHash: a,
      scriptHash: a
    }), e.Bip32PathSchema = o.pipe(o.string(), o.regex(/^(m\/)?(\d+'?\/)*\d+'?$/));
  })(Tr)), Tr;
}
var er = {}, Ot = {}, Rt = {}, jt = {}, Wn = {}, uu;
function Jb() {
  if (uu) return Wn;
  uu = 1, Object.defineProperty(Wn, "__esModule", { value: !0 });
  function e(t) {
    if (t.length >= 255)
      throw new TypeError("Alphabet too long");
    const r = new Uint8Array(256);
    for (let c = 0; c < r.length; c++)
      r[c] = 255;
    for (let c = 0; c < t.length; c++) {
      const w = t.charAt(c), g = w.charCodeAt(0);
      if (r[g] !== 255)
        throw new TypeError(w + " is ambiguous");
      r[g] = c;
    }
    const n = t.length, o = t.charAt(0), a = Math.log(n) / Math.log(256), s = Math.log(256) / Math.log(n);
    function i(c) {
      if (c instanceof Uint8Array || (ArrayBuffer.isView(c) ? c = new Uint8Array(c.buffer, c.byteOffset, c.byteLength) : Array.isArray(c) && (c = Uint8Array.from(c))), !(c instanceof Uint8Array))
        throw new TypeError("Expected Uint8Array");
      if (c.length === 0)
        return "";
      let w = 0, g = 0, v = 0;
      const k = c.length;
      for (; v !== k && c[v] === 0; )
        v++, w++;
      const y = (k - v) * s + 1 >>> 0, m = new Uint8Array(y);
      for (; v !== k; ) {
        let x = c[v], z = 0;
        for (let F = y - 1; (x !== 0 || z < g) && F !== -1; F--, z++)
          x += 256 * m[F] >>> 0, m[F] = x % n >>> 0, x = x / n >>> 0;
        if (x !== 0)
          throw new Error("Non-zero carry");
        g = z, v++;
      }
      let A = y - g;
      for (; A !== y && m[A] === 0; )
        A++;
      let E = o.repeat(w);
      for (; A < y; ++A)
        E += t.charAt(m[A]);
      return E;
    }
    function h(c) {
      if (typeof c != "string")
        throw new TypeError("Expected String");
      if (c.length === 0)
        return new Uint8Array();
      let w = 0, g = 0, v = 0;
      for (; c[w] === o; )
        g++, w++;
      const k = (c.length - w) * a + 1 >>> 0, y = new Uint8Array(k);
      for (; w < c.length; ) {
        const x = c.charCodeAt(w);
        if (x > 255)
          return;
        let z = r[x];
        if (z === 255)
          return;
        let F = 0;
        for (let j = k - 1; (z !== 0 || F < v) && j !== -1; j--, F++)
          z += n * y[j] >>> 0, y[j] = z % 256 >>> 0, z = z / 256 >>> 0;
        if (z !== 0)
          throw new Error("Non-zero carry");
        v = F, w++;
      }
      let m = k - v;
      for (; m !== k && y[m] === 0; )
        m++;
      const A = new Uint8Array(g + (k - m));
      let E = g;
      for (; m !== k; )
        A[E++] = y[m++];
      return A;
    }
    function l(c) {
      const w = h(c);
      if (w)
        return w;
      throw new Error("Non-base" + n + " character");
    }
    return {
      encode: i,
      decodeUnsafe: h,
      decode: l
    };
  }
  return Wn.default = e, Wn;
}
var lu;
function Qb() {
  if (lu) return jt;
  lu = 1;
  var e = jt && jt.__importDefault || function(n) {
    return n && n.__esModule ? n : { default: n };
  };
  Object.defineProperty(jt, "__esModule", { value: !0 });
  var t = e(Jb()), r = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  return jt.default = (0, t.default)(r), jt;
}
var fu;
function em() {
  if (fu) return Rt;
  fu = 1;
  var e = Rt && Rt.__importDefault || function(n) {
    return n && n.__esModule ? n : { default: n };
  };
  Object.defineProperty(Rt, "__esModule", { value: !0 }), Rt.default = r;
  var t = e(Qb());
  function r(n) {
    function o(h) {
      var l = Uint8Array.from(h), c = n(l), w = l.length + 4, g = new Uint8Array(w);
      return g.set(l, 0), g.set(c.subarray(0, 4), l.length), t.default.encode(g);
    }
    function a(h) {
      var l = h.slice(0, -4), c = h.slice(-4), w = n(l);
      if (!(c[0] ^ w[0] | c[1] ^ w[1] | c[2] ^ w[2] | c[3] ^ w[3]))
        return l;
    }
    function s(h) {
      var l = t.default.decodeUnsafe(h);
      if (l != null)
        return a(l);
    }
    function i(h) {
      var l = t.default.decode(h), c = a(l);
      if (c == null)
        throw new Error("Invalid checksum");
      return c;
    }
    return {
      encode: o,
      decode: i,
      decodeUnsafe: s
    };
  }
  return Rt;
}
var du;
function rm() {
  if (du) return Ot;
  du = 1;
  var e = Ot && Ot.__importDefault || function(o) {
    return o && o.__esModule ? o : { default: o };
  };
  Object.defineProperty(Ot, "__esModule", { value: !0 });
  var t = /* @__PURE__ */ kn(), r = e(em());
  function n(o) {
    return (0, t.sha256)((0, t.sha256)(o));
  }
  return Ot.default = (0, r.default)(n), Ot;
}
var hu;
function tm() {
  if (hu) return er;
  hu = 1;
  var e = er && er.__importDefault || function(s) {
    return s && s.__esModule ? s : { default: s };
  };
  Object.defineProperty(er, "__esModule", { value: !0 }), er.encode = er.decode = er.encodeRaw = er.decodeRaw = void 0;
  var t = e(rm());
  function r(s, i) {
    if (i !== void 0 && s[0] !== i)
      throw new Error("Invalid network version");
    if (s.length === 33)
      return {
        version: s[0],
        privateKey: s.slice(1, 33),
        compressed: !1
      };
    if (s.length !== 34)
      throw new Error("Invalid WIF length");
    if (s[33] !== 1)
      throw new Error("Invalid compression flag");
    return {
      version: s[0],
      privateKey: s.slice(1, 33),
      compressed: !0
    };
  }
  er.decodeRaw = r;
  function n(s, i, h) {
    if (i.length !== 32)
      throw new TypeError("Invalid privateKey length");
    var l = new Uint8Array(h ? 34 : 33), c = new DataView(l.buffer);
    return c.setUint8(0, s), l.set(i, 1), h && (l[33] = 1), l;
  }
  er.encodeRaw = n;
  function o(s, i) {
    return r(t.default.decode(s), i);
  }
  er.decode = o;
  function a(s) {
    return t.default.encode(n(s.version, s.privateKey, s.compressed));
  }
  return er.encode = a, er;
}
var zr = {}, pu;
function Ba() {
  return pu || (pu = 1, Object.defineProperty(zr, "__esModule", { value: !0 }), zr.REGTEST = zr.TESTNET = zr.BITCOIN = void 0, zr.BITCOIN = {
    messagePrefix: `Bitcoin Signed Message:
`,
    bech32: "bc",
    bip32: {
      public: 76067358,
      private: 76066276
    },
    pubKeyHash: 0,
    scriptHash: 5,
    wif: 128
  }, zr.TESTNET = {
    messagePrefix: `Bitcoin Signed Message:
`,
    bech32: "tb",
    bip32: {
      public: 70617039,
      private: 70615956
    },
    pubKeyHash: 111,
    scriptHash: 196,
    wif: 239
  }, zr.REGTEST = {
    messagePrefix: `Bitcoin Signed Message:
`,
    bech32: "bcrt",
    bip32: {
      public: 70617039,
      private: 70615956
    },
    pubKeyHash: 111,
    scriptHash: 196,
    wif: 239
  }), zr;
}
var gu;
function nm() {
  if (gu) return gr;
  gu = 1;
  var e = gr && gr.__createBinding || (Object.create ? (function(y, m, A, E) {
    E === void 0 && (E = A);
    var x = Object.getOwnPropertyDescriptor(m, A);
    (!x || ("get" in x ? !m.__esModule : x.writable || x.configurable)) && (x = { enumerable: !0, get: function() {
      return m[A];
    } }), Object.defineProperty(y, E, x);
  }) : (function(y, m, A, E) {
    E === void 0 && (E = A), y[E] = m[A];
  })), t = gr && gr.__setModuleDefault || (Object.create ? (function(y, m) {
    Object.defineProperty(y, "default", { enumerable: !0, value: m });
  }) : function(y, m) {
    y.default = m;
  }), r = gr && gr.__importStar || /* @__PURE__ */ (function() {
    var y = function(m) {
      return y = Object.getOwnPropertyNames || function(A) {
        var E = [];
        for (var x in A) Object.prototype.hasOwnProperty.call(A, x) && (E[E.length] = x);
        return E;
      }, y(m);
    };
    return function(m) {
      if (m && m.__esModule) return m;
      var A = {};
      if (m != null) for (var E = y(m), x = 0; x < E.length; x++) E[x] !== "default" && e(A, m, E[x]);
      return t(A, m), A;
    };
  })();
  Object.defineProperty(gr, "__esModule", { value: !0 }), gr.BIP32Factory = k;
  const n = r(ad()), o = Pb(), a = Sd, s = /* @__PURE__ */ kn(), i = r(/* @__PURE__ */ as()), h = Id(), l = r(tm()), c = r(ms), w = Ba(), g = (0, a.base58check)(s.sha256), v = {
    encode: (y) => g.encode(y),
    decode: (y) => g.decode(y)
  };
  function k(y) {
    (0, o.testEcc)(y);
    const m = 2147483648;
    function A(R) {
      return R.length === 32 ? R : R.slice(1, 33);
    }
    class E {
      __D;
      __Q;
      lowR = !1;
      constructor(U, T) {
        this.__D = U, this.__Q = T;
      }
      get publicKey() {
        return this.__Q === void 0 && (this.__Q = y.pointFromScalar(this.__D, !0)), this.__Q;
      }
      get privateKey() {
        return this.__D;
      }
      sign(U, T) {
        if (!this.privateKey)
          throw new Error("Missing private key");
        if (T === void 0 && (T = this.lowR), T) {
          let Z = y.sign(U, this.privateKey);
          const re = new Uint8Array(32);
          let oe = 0;
          for (; Z[0] > 127; )
            oe++, c.writeUInt32(re, 0, oe, "LE"), Z = y.sign(U, this.privateKey, re);
          return Z;
        } else
          return y.sign(U, this.privateKey);
      }
      signSchnorr(U) {
        if (!this.privateKey)
          throw new Error("Missing private key");
        if (!y.signSchnorr)
          throw new Error("signSchnorr not supported by ecc library");
        return y.signSchnorr(U, this.privateKey);
      }
      verify(U, T) {
        return y.verify(U, this.publicKey, T);
      }
      verifySchnorr(U, T) {
        if (!y.verifySchnorr)
          throw new Error("verifySchnorr not supported by ecc library");
        return y.verifySchnorr(U, this.publicKey.subarray(1, 33), T);
      }
    }
    class x extends E {
      chainCode;
      network;
      __DEPTH;
      __INDEX;
      __PARENT_FINGERPRINT;
      constructor(U, T, Z, re, oe = 0, ue = 0, ie = 0) {
        super(U, T), this.chainCode = Z, this.network = re, this.__DEPTH = oe, this.__INDEX = ue, this.__PARENT_FINGERPRINT = ie, i.parse(h.NetworkSchema, re);
      }
      get depth() {
        return this.__DEPTH;
      }
      get index() {
        return this.__INDEX;
      }
      get parentFingerprint() {
        return this.__PARENT_FINGERPRINT;
      }
      get identifier() {
        return n.hash160(this.publicKey);
      }
      get fingerprint() {
        return this.identifier.slice(0, 4);
      }
      get compressed() {
        return !0;
      }
      // Private === not neutered
      // Public === neutered
      isNeutered() {
        return this.__D === void 0;
      }
      neutered() {
        return N(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);
      }
      toBase58() {
        const U = this.network, T = this.isNeutered() ? U.bip32.public : U.bip32.private, Z = new Uint8Array(78);
        return c.writeUInt32(Z, 0, T, "BE"), c.writeUInt8(Z, 4, this.depth), c.writeUInt32(Z, 5, this.parentFingerprint, "BE"), c.writeUInt32(Z, 9, this.index, "BE"), Z.set(this.chainCode, 13), this.isNeutered() ? Z.set(this.publicKey, 45) : (c.writeUInt8(Z, 45, 0), Z.set(this.privateKey, 46)), v.encode(Z);
      }
      toWIF() {
        if (!this.privateKey)
          throw new TypeError("Missing private key");
        return l.encode({
          version: this.network.wif,
          privateKey: this.privateKey,
          compressed: !0
        });
      }
      // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions
      derive(U) {
        i.parse(h.Uint32Schema, U);
        const T = U >= m, Z = new Uint8Array(37);
        if (T) {
          if (this.isNeutered())
            throw new TypeError("Missing private key for hardened child key");
          Z[0] = 0, Z.set(this.privateKey, 1), c.writeUInt32(Z, 33, U, "BE");
        } else
          Z.set(this.publicKey, 0), c.writeUInt32(Z, 33, U, "BE");
        const re = n.hmacSHA512(this.chainCode, Z), oe = re.slice(0, 32), ue = re.slice(32);
        if (!y.isPrivate(oe))
          return this.derive(U + 1);
        let ie;
        if (this.isNeutered()) {
          const de = y.pointAddScalar(this.publicKey, oe, !0);
          if (de === null)
            return this.derive(U + 1);
          ie = N(de, ue, this.network, this.depth + 1, U, c.readUInt32(this.fingerprint, 0, "BE"));
        } else {
          const de = y.privateAdd(this.privateKey, oe);
          if (de == null)
            return this.derive(U + 1);
          ie = j(de, ue, this.network, this.depth + 1, U, c.readUInt32(this.fingerprint, 0, "BE"));
        }
        return ie;
      }
      deriveHardened(U) {
        if (typeof i.parse(h.Uint31Schema, U) == "number")
          return this.derive(U + m);
        throw new TypeError("Expected UInt31, got " + U);
      }
      derivePath(U) {
        i.parse(h.Bip32PathSchema, U);
        let T = U.split("/");
        if (T[0] === "m") {
          if (this.parentFingerprint)
            throw new TypeError("Expected master, got child");
          T = T.slice(1);
        }
        return T.reduce((Z, re) => {
          let oe;
          return re.slice(-1) === "'" ? (oe = parseInt(re.slice(0, -1), 10), Z.deriveHardened(oe)) : (oe = parseInt(re, 10), Z.derive(oe));
        }, this);
      }
      tweak(U) {
        return this.privateKey ? this.tweakFromPrivateKey(U) : this.tweakFromPublicKey(U);
      }
      tweakFromPublicKey(U) {
        const T = A(this.publicKey);
        if (!y.xOnlyPointAddTweak)
          throw new Error("xOnlyPointAddTweak not supported by ecc library");
        const Z = y.xOnlyPointAddTweak(T, U);
        if (!Z || Z.xOnlyPubkey === null)
          throw new Error("Cannot tweak public key!");
        const re = Uint8Array.from([
          Z.parity === 0 ? 2 : 3
        ]), oe = c.concat([
          re,
          Z.xOnlyPubkey
        ]);
        return new E(void 0, oe);
      }
      tweakFromPrivateKey(U) {
        const T = this.publicKey[0] === 3 || this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1, Z = (() => {
          if (T) {
            if (y.privateNegate)
              return y.privateNegate(this.privateKey);
            throw new Error("privateNegate not supported by ecc library");
          } else return this.privateKey;
        })(), re = y.privateAdd(Z, U);
        if (!re)
          throw new Error("Invalid tweaked private key!");
        return new E(re, void 0);
      }
    }
    function z(R, U) {
      const T = v.decode(R);
      if (T.length !== 78)
        throw new TypeError("Invalid buffer length");
      U = U || w.BITCOIN;
      const Z = c.readUInt32(T, 0, "BE");
      if (Z !== U.bip32.private && Z !== U.bip32.public)
        throw new TypeError("Invalid network version");
      const re = T[4], oe = c.readUInt32(T, 5, "BE");
      if (re === 0 && oe !== 0)
        throw new TypeError("Invalid parent fingerprint");
      const ue = c.readUInt32(T, 9, "BE");
      if (re === 0 && ue !== 0)
        throw new TypeError("Invalid index");
      const ie = T.slice(13, 45);
      let de;
      if (Z === U.bip32.private) {
        if (T[45] !== 0)
          throw new TypeError("Invalid private key");
        const me = T.slice(46, 78);
        de = j(me, ie, U, re, ue, oe);
      } else {
        const me = T.slice(45, 78);
        de = N(me, ie, U, re, ue, oe);
      }
      return de;
    }
    function F(R, U, T) {
      return j(R, U, T);
    }
    function j(R, U, T, Z, re, oe) {
      if (i.parse(h.Buffer256Bit, R), i.parse(h.Buffer256Bit, U), T = T || w.BITCOIN, !y.isPrivate(R))
        throw new TypeError("Private key not in range [1, n)");
      return new x(R, void 0, U, T, Z, re, oe);
    }
    function I(R, U, T) {
      return N(R, U, T);
    }
    function N(R, U, T, Z, re, oe) {
      if (i.parse(h.Buffer33Bytes, R), i.parse(h.Buffer256Bit, U), T = T || w.BITCOIN, !y.isPoint(R))
        throw new TypeError("Point is not on the curve");
      return new x(void 0, R, U, T, Z, re, oe);
    }
    function O(R, U) {
      if (i.parse(i.instance(Uint8Array), R), R.length < 16)
        throw new TypeError("Seed should be at least 128 bits");
      if (R.length > 64)
        throw new TypeError("Seed should be at most 512 bits");
      U = U || w.BITCOIN;
      const T = n.hmacSHA512(c.fromUtf8("Bitcoin seed"), R), Z = T.slice(0, 32), re = T.slice(32);
      return F(Z, re, U);
    }
    return {
      fromSeed: O,
      fromBase58: z,
      fromPublicKey: I,
      fromPrivateKey: F
    };
  }
  return gr;
}
var no = {}, dr = {};
const qi = ah;
function ks(e, t) {
  if (e.length !== t.length)
    return !1;
  let r = 0;
  for (let n = 0; n < e.length; n++)
    r |= e[n] ^ t[n];
  return r === 0;
}
function am(e) {
  return Uint8Array.from(e);
}
function Es(e) {
  if (typeof e != "object" || e === null || oh(e))
    throw new Error("expected opts to be an object");
}
function _a(e) {
  Es(e), e.context !== void 0 && ar(e.context, void 0, "opts.context");
}
function ea(e) {
  _a(e), e.extraEntropy !== !1 && e.extraEntropy !== void 0 && ar(e.extraEntropy, void 0, "opts.extraEntropy");
}
function an(e, ...t) {
  const r = (o) => typeof o == "number" ? o : o.bytesLen, n = t.reduce((o, a) => o + r(a), 0);
  return {
    bytesLen: n,
    encode: (o) => {
      const a = new Uint8Array(n);
      for (let s = 0, i = 0; s < t.length; s++) {
        const h = t[s], l = r(h), c = typeof h == "number" ? o[s] : h.encode(o[s]);
        ar(c, l, e), a.set(c, i), typeof h != "number" && c.fill(0), i += l;
      }
      return a;
    },
    decode: (o) => {
      ar(o, n, e);
      const a = [];
      for (const s of t) {
        const i = r(s), h = o.subarray(0, i);
        a.push(typeof s == "number" ? h : s.decode(h)), o = o.subarray(i);
      }
      return a;
    }
  };
}
function ft(e, t) {
  const r = t * e.bytesLen;
  return {
    bytesLen: r,
    encode: (n) => {
      if (n.length !== t)
        throw new Error(`vecCoder.encode: wrong length=${n.length}. Expected: ${t}`);
      const o = new Uint8Array(r);
      for (let a = 0, s = 0; a < n.length; a++) {
        const i = e.encode(n[a]);
        o.set(i, s), i.fill(0), s += i.length;
      }
      return o;
    },
    decode: (n) => {
      ar(n, r);
      const o = [];
      for (let a = 0; a < n.length; a += e.bytesLen)
        o.push(e.decode(n.subarray(a, a + e.bytesLen)));
      return o;
    }
  };
}
function jr(...e) {
  for (const t of e)
    if (Array.isArray(t))
      for (const r of t)
        r.fill(0);
    else
      t.fill(0);
}
function Mi(e) {
  return (1 << e) - 1;
}
const xs = Uint8Array.of();
function Di(e, t = xs) {
  if (ar(e), ar(t), t.length > 255)
    throw new Error("context should be less than 255 bytes");
  return ts(new Uint8Array([0, t.length]), t, e);
}
const om = /* @__PURE__ */ Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2]);
function Bd(e, t = 0) {
  if (!e.oid || !ks(e.oid.subarray(0, 10), om))
    throw new Error("hash.oid is invalid: expected NIST hash");
  const r = e.outputLen * 8 / 2;
  if (t > r)
    throw new Error("Pre-hash security strength too low: " + r + ", required: " + t);
}
function Fi(e, t, r = xs) {
  if (ar(t), ar(r), r.length > 255)
    throw new Error("context should be less than 255 bytes");
  const n = e(t);
  return ts(new Uint8Array([1, r.length]), r, e.oid, n);
}
const im = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  EMPTY: xs,
  abytes: ar,
  checkHash: Bd,
  cleanBytes: jr,
  concatBytes: ts,
  copyBytes: am,
  equalBytes: ks,
  getMask: Mi,
  getMessage: Di,
  getMessagePrehash: Fi,
  randomBytes: qi,
  splitCoder: an,
  validateOpts: Es,
  validateSigOpts: ea,
  validateVerOpts: _a,
  vecCoder: ft
}, Symbol.toStringTag, { value: "Module" })), sm = /* @__PURE__ */ En(im);
var Or = {};
const cm = (e) => {
  const { newPoly: t, N: r, Q: n, F: o, ROOT_OF_UNITY: a, brvBits: s } = e, i = (A, E = n) => {
    const x = A % E | 0;
    return (x >= 0 ? x | 0 : E + x | 0) | 0;
  }, h = (A, E = n) => {
    const x = i(A, E) | 0;
    return (x > E >> 1 ? x - E | 0 : x) | 0;
  };
  function l() {
    const A = t(r);
    for (let E = 0; E < r; E++) {
      const x = ph(E, s), z = BigInt(a) ** BigInt(x) % BigInt(n);
      A[E] = Number(z) | 0;
    }
    return A;
  }
  const c = l(), w = {
    add: (A, E) => i((A | 0) + (E | 0)) | 0,
    sub: (A, E) => i((A | 0) - (E | 0)) | 0,
    mul: (A, E) => i((A | 0) * (E | 0)) | 0,
    inv: (A) => {
      throw new Error("not implemented");
    }
  }, g = {
    N: r,
    roots: c,
    invertButterflies: !0,
    skipStages: 0,
    brp: !1
  }, v = js(w, { dit: !1, ...g }), k = js(w, { dit: !0, ...g });
  return { mod: i, smod: h, nttZetas: c, NTT: {
    encode: (A) => v(A),
    decode: (A) => {
      k(A);
      for (let E = 0; E < A.length; E++)
        A[E] = i(o * A[E]);
      return A;
    }
  }, bitsCoder: (A, E) => {
    const x = Mi(A), z = A * (r / 8);
    return {
      bytesLen: z,
      encode: (F) => {
        const j = new Uint8Array(z);
        for (let I = 0, N = 0, O = 0, R = 0; I < F.length; I++)
          for (N |= (E.encode(F[I]) & x) << O, O += A; O >= 8; O -= 8, N >>= 8)
            j[R++] = N & Mi(O);
        return j;
      },
      decode: (F) => {
        const j = t(r);
        for (let I = 0, N = 0, O = 0, R = 0; I < F.length; I++)
          for (N |= F[I] << O, O += 8; O >= A; O -= A, N >>= A)
            j[R++] = E.decode(N & x);
        return j;
      }
    };
  } };
}, Td = (e) => (t, r) => {
  r || (r = e.blockLen);
  const n = new Uint8Array(t.length + 2);
  n.set(t);
  const o = t.length, a = new Uint8Array(r);
  let s = e.create({}), i = 0, h = 0;
  return {
    stats: () => ({ calls: i, xofs: h }),
    get: (l, c) => (n[o + 0] = l, n[o + 1] = c, s.destroy(), s = e.create({}).update(n), i++, () => (h++, s.xofInto(a))),
    clean: () => {
      s.destroy(), jr(a, n);
    }
  };
}, As = /* @__PURE__ */ Td(ih), Ss = /* @__PURE__ */ Td(sr);
function bu(e) {
  Es(e), e.externalMu !== void 0 && gh(e.externalMu, "opts.externalMu");
}
const je = 256, nt = 8380417, um = 1753, lm = 8347681, mt = 13, Ki = Math.floor((nt - 1) / 88) | 0, Hi = Math.floor((nt - 1) / 32) | 0, Ta = {
  2: { K: 4, L: 4, D: mt, GAMMA1: 2 ** 17, GAMMA2: Ki, TAU: 39, ETA: 2, OMEGA: 80 },
  3: { K: 6, L: 5, D: mt, GAMMA1: 2 ** 19, GAMMA2: Hi, TAU: 49, ETA: 4, OMEGA: 55 },
  5: { K: 8, L: 7, D: mt, GAMMA1: 2 ** 19, GAMMA2: Hi, TAU: 60, ETA: 2, OMEGA: 75 }
}, tr = (e) => new Int32Array(e), { mod: gt, smod: ra, NTT: He, bitsCoder: fm } = cm({
  N: je,
  Q: nt,
  F: lm,
  ROOT_OF_UNITY: um,
  newPoly: tr,
  brvBits: 8
}), mu = (e) => e, Qt = (e, t = mu, r = mu) => fm(e, {
  encode: (n) => t(r(n)),
  decode: (n) => r(t(n))
}), Jr = (e, t) => {
  for (let r = 0; r < e.length; r++)
    e[r] = gt(e[r] + t[r]);
  return e;
}, yu = (e, t) => {
  for (let r = 0; r < e.length; r++)
    e[r] = gt(e[r] - t[r]);
  return e;
}, dm = (e) => {
  for (let t = 0; t < je; t++)
    e[t] <<= mt;
  return e;
}, en = (e, t) => {
  for (let r = 0; r < je; r++)
    if (Math.abs(ra(e[r])) >= t)
      return !0;
  return !1;
}, Qr = (e, t) => {
  const r = tr(je);
  for (let n = 0; n < e.length; n++)
    r[n] = gt(e[n] * t[n]);
  return r;
};
function Vn(e) {
  const t = tr(je);
  for (let r = 0; r < je; ) {
    const n = e();
    if (n.length % 3)
      throw new Error("RejNTTPoly: unaligned block");
    for (let o = 0; r < je && o <= n.length - 3; o += 3) {
      const a = (n[o + 0] | n[o + 1] << 8 | n[o + 2] << 16) & 8388607;
      a < nt && (t[r++] = a);
    }
  }
  return t;
}
function Is(e) {
  const { K: t, L: r, GAMMA1: n, GAMMA2: o, TAU: a, ETA: s, OMEGA: i } = e, { CRH_BYTES: h, TR_BYTES: l, C_TILDE_BYTES: c, XOF128: w, XOF256: g, securityLevel: v } = e;
  if (![2, 4].includes(s))
    throw new Error("Wrong ETA");
  if (![1 << 17, 1 << 19].includes(n))
    throw new Error("Wrong GAMMA1");
  if (![Ki, Hi].includes(o))
    throw new Error("Wrong GAMMA2");
  const k = a * s, y = (C) => {
    const G = gt(C), V = ra(G, 2 * o) | 0;
    return G - V === nt - 1 ? { r1: 0, r0: V - 1 | 0 } : { r1: Math.floor((G - V) / (2 * o)) | 0, r0: V };
  }, m = (C) => y(C).r1, A = (C) => y(C).r0, E = (C, G) => C <= o || C > nt - o || C === nt - o && G === 0 ? 0 : 1, x = (C, G) => {
    const V = Math.floor((nt - 1) / (2 * o)), { r1: X, r0: Q } = y(G);
    return C === 1 ? Q > 0 ? gt(X + 1, V) | 0 : gt(X - 1, V) | 0 : X | 0;
  }, z = (C) => {
    const G = gt(C), V = ra(G, 2 ** mt) | 0;
    return { r1: Math.floor((G - V) / 2 ** mt) | 0, r0: V };
  }, F = {
    bytesLen: i + t,
    encode: (C) => {
      if (C === !1)
        throw new Error("hint.encode: hint is false");
      const G = new Uint8Array(i + t);
      for (let V = 0, X = 0; V < t; V++) {
        for (let Q = 0; Q < je; Q++)
          C[V][Q] !== 0 && (G[X++] = Q);
        G[i + V] = X;
      }
      return G;
    },
    decode: (C) => {
      const G = [];
      let V = 0;
      for (let X = 0; X < t; X++) {
        const Q = tr(je);
        if (C[i + X] < V || C[i + X] > i)
          return !1;
        for (let ee = V; ee < C[i + X]; ee++) {
          if (ee > V && C[ee] <= C[ee - 1])
            return !1;
          Q[C[ee]] = 1;
        }
        V = C[i + X], G.push(Q);
      }
      for (let X = V; X < i; X++)
        if (C[X] !== 0)
          return !1;
      return G;
    }
  }, j = Qt(s === 2 ? 3 : 4, (C) => s - C, (C) => {
    if (!(-s <= C && C <= s))
      throw new Error(`malformed key s1/s3 ${C} outside of ETA range [${-s}, ${s}]`);
    return C;
  }), I = Qt(13, (C) => (1 << mt - 1) - C), N = Qt(10), O = Qt(n === 1 << 17 ? 18 : 20, (C) => ra(n - C)), R = Qt(o === Ki ? 6 : 4), U = ft(R, t), T = an("publicKey", 32, ft(N, t)), Z = an("secretKey", 32, 32, l, ft(j, r), ft(j, t), ft(I, t)), re = an("signature", c, ft(O, r), F), oe = s === 2 ? (C) => C < 15 ? 2 - C % 5 : !1 : (C) => C < 9 ? 4 - C : !1;
  function ue(C) {
    const G = tr(je);
    for (let V = 0; V < je; ) {
      const X = C();
      for (let Q = 0; V < je && Q < X.length; Q += 1) {
        const ee = oe(X[Q] & 15), ne = oe(X[Q] >> 4 & 15);
        ee !== !1 && (G[V++] = ee), V < je && ne !== !1 && (G[V++] = ne);
      }
    }
    return G;
  }
  const ie = (C) => {
    const G = tr(je), V = sr.create({}).update(C), X = new Uint8Array(sr.blockLen);
    V.xofInto(X);
    const Q = X.slice(0, 8);
    for (let ee = je - a, ne = 8, se = 0, ce = 0; ee < je; ee++) {
      let le = ee + 1;
      for (; le > ee; )
        le = X[ne++], !(ne < sr.blockLen) && (V.xofInto(X), ne = 0);
      G[ee] = G[le], G[le] = 1 - ((Q[se] >> ce++ & 1) << 1), ce >= 8 && (se++, ce = 0);
    }
    return G;
  }, de = (C) => {
    const G = tr(je), V = tr(je);
    for (let X = 0; X < C.length; X++) {
      const { r0: Q, r1: ee } = z(C[X]);
      G[X] = Q, V[X] = ee;
    }
    return { r0: G, r1: V };
  }, me = (C, G) => {
    for (let V = 0; V < je; V++)
      C[V] = x(G[V], C[V]);
    return C;
  }, Se = (C, G) => {
    const V = tr(je);
    let X = 0;
    for (let Q = 0; Q < je; Q++) {
      const ee = E(C[Q], G[Q]);
      V[Q] = ee, X += ee;
    }
    return { v: V, cnt: X };
  }, De = 32, q = an("seed", 32, 64, 32), H = {
    info: { type: "internal-ml-dsa" },
    lengths: {
      secretKey: Z.bytesLen,
      publicKey: T.bytesLen,
      seed: 32,
      signature: re.bytesLen,
      signRand: De
    },
    keygen: (C) => {
      const G = new Uint8Array(34), V = C === void 0;
      V && (C = qi(32)), ar(C, 32, "seed"), G.set(C), V && jr(C), G[32] = t, G[33] = r;
      const [X, Q, ee] = q.decode(sr(G, { dkLen: q.bytesLen })), ne = g(Q), se = [];
      for (let ae = 0; ae < r; ae++)
        se.push(ue(ne.get(ae & 255, ae >> 8 & 255)));
      const ce = [];
      for (let ae = r; ae < r + t; ae++)
        ce.push(ue(ne.get(ae & 255, ae >> 8 & 255)));
      const le = se.map((ae) => He.encode(ae.slice())), he = [], ye = [], pe = w(X), we = tr(je);
      for (let ae = 0; ae < t; ae++) {
        jr(we);
        for (let xe = 0; xe < r; xe++) {
          const Be = Vn(pe.get(xe, ae));
          Jr(we, Qr(Be, le[xe]));
        }
        He.decode(we);
        const { r0: fe, r1: ge } = de(Jr(we, ce[ae]));
        he.push(fe), ye.push(ge);
      }
      const Oe = T.encode([X, ye]), $ = sr(Oe, { dkLen: l }), Re = Z.encode([X, ee, $, se, ce, he]);
      return pe.clean(), ne.clean(), jr(X, Q, ee, se, ce, le, we, he, ye, $, G), { publicKey: Oe, secretKey: Re };
    },
    getPublicKey: (C) => {
      const [G, V, X, Q, ee, ne] = Z.decode(C), se = w(G), ce = Q.map((ye) => He.encode(ye.slice())), le = [], he = tr(je);
      for (let ye = 0; ye < t; ye++) {
        he.fill(0);
        for (let we = 0; we < r; we++) {
          const Oe = Vn(se.get(we, ye));
          Jr(he, Qr(Oe, ce[we]));
        }
        He.decode(he), Jr(he, ee[ye]);
        const { r1: pe } = de(he);
        le.push(pe);
      }
      return se.clean(), jr(he, ce, ne, Q, ee), T.encode([G, le]);
    },
    // NOTE: random is optional.
    sign: (C, G, V = {}) => {
      ea(V), bu(V);
      let { extraEntropy: X, externalMu: Q = !1 } = V;
      const [ee, ne, se, ce, le, he] = Z.decode(G), ye = [], pe = w(ee);
      for (let ae = 0; ae < t; ae++) {
        const fe = [];
        for (let ge = 0; ge < r; ge++)
          fe.push(Vn(pe.get(ge, ae)));
        ye.push(fe);
      }
      pe.clean();
      for (let ae = 0; ae < r; ae++)
        He.encode(ce[ae]);
      for (let ae = 0; ae < t; ae++)
        He.encode(le[ae]), He.encode(he[ae]);
      const we = Q ? C : sr.create({ dkLen: h }).update(se).update(C).digest(), Oe = X === !1 ? new Uint8Array(32) : X === void 0 ? qi(De) : X;
      ar(Oe, 32, "extraEntropy");
      const $ = sr.create({ dkLen: h }).update(ne).update(Oe).update(we).digest();
      ar($, h);
      const Re = g($, O.bytesLen);
      e: for (let ae = 0; ; ) {
        const fe = [];
        for (let d = 0; d < r; d++, ae++)
          fe.push(O.decode(Re.get(ae & 255, ae >> 8)()));
        const ge = fe.map((d) => He.encode(d.slice())), xe = [];
        for (let d = 0; d < t; d++) {
          const S = tr(je);
          for (let P = 0; P < r; P++)
            Jr(S, Qr(ye[d][P], ge[P]));
          He.decode(S), xe.push(S);
        }
        const Be = xe.map((d) => d.map(m)), Ye = sr.create({ dkLen: c }).update(we).update(U.encode(Be)).digest(), fr = He.encode(ie(Ye)), M = ce.map((d) => Qr(d, fr));
        for (let d = 0; d < r; d++)
          if (Jr(He.decode(M[d]), fe[d]), en(M[d], n - k))
            continue e;
        let te = 0;
        const b = [];
        for (let d = 0; d < t; d++) {
          const S = He.decode(Qr(le[d], fr)), P = yu(xe[d], S).map(A);
          if (en(P, o - k))
            continue e;
          const D = He.decode(Qr(he[d], fr));
          if (en(D, o))
            continue e;
          Jr(P, D);
          const W = Se(P, Be[d]);
          b.push(W.v), te += W.cnt;
        }
        if (te > i)
          continue;
        Re.clean();
        const u = re.encode([Ye, M, b]);
        return jr(Ye, M, b, fr, Be, xe, ge, fe, $, we, ce, le, he, ...ye), u;
      }
      throw new Error("Unreachable code path reached, report this error");
    },
    verify: (C, G, V, X = {}) => {
      bu(X);
      const { externalMu: Q = !1 } = X, [ee, ne] = T.decode(V), se = sr(V, { dkLen: l });
      if (C.length !== re.bytesLen)
        return !1;
      const [ce, le, he] = re.decode(C);
      if (he === !1)
        return !1;
      for (let ae = 0; ae < r; ae++)
        if (en(le[ae], n - k))
          return !1;
      const ye = Q ? G : sr.create({ dkLen: h }).update(se).update(G).digest(), pe = He.encode(ie(ce)), we = le.map((ae) => ae.slice());
      for (let ae = 0; ae < r; ae++)
        He.encode(we[ae]);
      const Oe = [], $ = w(ee);
      for (let ae = 0; ae < t; ae++) {
        const fe = Qr(He.encode(dm(ne[ae])), pe), ge = tr(je);
        for (let Be = 0; Be < r; Be++) {
          const Ye = Vn($.get(Be, ae));
          Jr(ge, Qr(Ye, we[Be]));
        }
        const xe = He.decode(yu(ge, fe));
        Oe.push(me(xe, he[ae]));
      }
      $.clean();
      const Re = sr.create({ dkLen: c }).update(ye).update(U.encode(Oe)).digest();
      for (const ae of he)
        if (!(ae.reduce((ge, xe) => ge + xe, 0) <= i))
          return !1;
      for (const ae of le)
        if (en(ae, n - k))
          return !1;
      return ks(ce, Re);
    }
  };
  return {
    info: { type: "ml-dsa" },
    internal: H,
    securityLevel: v,
    keygen: H.keygen,
    lengths: H.lengths,
    getPublicKey: H.getPublicKey,
    sign: (C, G, V = {}) => {
      ea(V);
      const X = Di(C, V.context), Q = H.sign(X, G, V);
      return jr(X), Q;
    },
    verify: (C, G, V, X = {}) => (_a(X), H.verify(C, Di(G, X.context), V)),
    prehash: (C) => (Bd(C, v), {
      info: { type: "hashml-dsa" },
      securityLevel: v,
      lengths: H.lengths,
      keygen: H.keygen,
      getPublicKey: H.getPublicKey,
      sign: (G, V, X = {}) => {
        ea(X);
        const Q = Fi(C, G, X.context), ee = H.sign(Q, V, X);
        return jr(Q), ee;
      },
      verify: (G, V, X, Q = {}) => (_a(Q), H.verify(G, Fi(C, V, Q.context), X))
    })
  };
}
const hm = /* @__PURE__ */ Is({
  ...Ta[2],
  CRH_BYTES: 64,
  TR_BYTES: 64,
  C_TILDE_BYTES: 32,
  XOF128: As,
  XOF256: Ss,
  securityLevel: 128
}), pm = /* @__PURE__ */ Is({
  ...Ta[3],
  CRH_BYTES: 64,
  TR_BYTES: 64,
  C_TILDE_BYTES: 48,
  XOF128: As,
  XOF256: Ss,
  securityLevel: 192
}), gm = /* @__PURE__ */ Is({
  ...Ta[5],
  CRH_BYTES: 64,
  TR_BYTES: 64,
  C_TILDE_BYTES: 64,
  XOF128: As,
  XOF256: Ss,
  securityLevel: 256
}), bm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  PARAMS: Ta,
  ml_dsa44: hm,
  ml_dsa65: pm,
  ml_dsa87: gm
}, Symbol.toStringTag, { value: "Module" })), mm = /* @__PURE__ */ En(bm);
var vu;
function zd() {
  if (vu) return Or;
  vu = 1, Object.defineProperty(Or, "__esModule", { value: !0 }), Or.DEFAULT_SECURITY_LEVEL = Or.MLDSASecurityLevel = void 0, Or.getMLDSAConfig = o, Or.findNetworkByVersion = a;
  const e = mm, t = Ba();
  var r;
  (function(s) {
    s[s.LEVEL2 = 44] = "LEVEL2", s[s.LEVEL3 = 65] = "LEVEL3", s[s.LEVEL5 = 87] = "LEVEL5";
  })(r || (Or.MLDSASecurityLevel = r = {}));
  const n = {
    [r.LEVEL2]: {
      level: r.LEVEL2,
      privateKeySize: 2560,
      publicKeySize: 1312,
      signatureSize: 2420,
      algorithm: e.ml_dsa44
    },
    [r.LEVEL3]: {
      level: r.LEVEL3,
      privateKeySize: 4032,
      publicKeySize: 1952,
      signatureSize: 3309,
      algorithm: e.ml_dsa65
    },
    [r.LEVEL5]: {
      level: r.LEVEL5,
      privateKeySize: 4896,
      publicKeySize: 2592,
      signatureSize: 4627,
      algorithm: e.ml_dsa87
    }
  };
  Or.DEFAULT_SECURITY_LEVEL = r.LEVEL2;
  function o(s, i) {
    const h = n[s];
    if (!h)
      throw new TypeError(`Invalid ML-DSA security level: ${s}. Must be MLDSASecurityLevel.LEVEL2 (44), LEVEL3 (65), or LEVEL5 (87)`);
    return {
      ...h,
      network: i
    };
  }
  function a(s) {
    const i = [t.BITCOIN, t.TESTNET, t.REGTEST];
    for (const h of i) {
      if (s === h.bip32.private)
        return { network: h, isPrivate: !0 };
      if (s === h.bip32.public)
        return { network: h, isPrivate: !1 };
    }
    return null;
  }
  return Or;
}
var wu;
function ym() {
  if (wu) return dr;
  wu = 1;
  var e = dr && dr.__createBinding || (Object.create ? (function(j, I, N, O) {
    O === void 0 && (O = N);
    var R = Object.getOwnPropertyDescriptor(I, N);
    (!R || ("get" in R ? !I.__esModule : R.writable || R.configurable)) && (R = { enumerable: !0, get: function() {
      return I[N];
    } }), Object.defineProperty(j, O, R);
  }) : (function(j, I, N, O) {
    O === void 0 && (O = N), j[O] = I[N];
  })), t = dr && dr.__setModuleDefault || (Object.create ? (function(j, I) {
    Object.defineProperty(j, "default", { enumerable: !0, value: I });
  }) : function(j, I) {
    j.default = I;
  }), r = dr && dr.__importStar || /* @__PURE__ */ (function() {
    var j = function(I) {
      return j = Object.getOwnPropertyNames || function(N) {
        var O = [];
        for (var R in N) Object.prototype.hasOwnProperty.call(N, R) && (O[O.length] = R);
        return O;
      }, j(I);
    };
    return function(I) {
      if (I && I.__esModule) return I;
      var N = {};
      if (I != null) for (var O = j(I), R = 0; R < O.length; R++) O[R] !== "default" && e(N, I, O[R]);
      return t(N, I), N;
    };
  })();
  Object.defineProperty(dr, "__esModule", { value: !0 }), dr.QuantumBIP32Factory = void 0;
  const n = sm, o = r(ad()), a = r(ms), s = r(/* @__PURE__ */ as()), i = Id(), h = Sd, l = /* @__PURE__ */ kn(), c = zd(), w = Ba(), g = (0, h.base58check)(l.sha256), v = {
    encode: (j) => g.encode(j),
    decode: (j) => g.decode(j)
  }, k = 32, y = 2147483648;
  class m {
    _privateKey;
    _publicKey;
    config;
    constructor(I, N, O) {
      this._privateKey = I, this._publicKey = N, this.config = O;
    }
    get publicKey() {
      if (!this._publicKey)
        throw new Error("Public key not available");
      return this._publicKey;
    }
    get privateKey() {
      return this._privateKey;
    }
    sign(I) {
      if (!this._privateKey)
        throw new Error("Missing private key");
      return this.config.algorithm.sign(I, this._privateKey, {
        extraEntropy: (0, n.randomBytes)(32)
      });
    }
    verify(I, N) {
      return this.config.algorithm.verify(N, I, this._publicKey);
    }
  }
  class A extends m {
    chainCode;
    _depth;
    _index;
    _parentFingerprint;
    constructor(I, N, O, R, U = 0, T = 0, Z = 0) {
      super(I, N, R), this.chainCode = O, this._depth = U, this._index = T, this._parentFingerprint = Z;
    }
    get depth() {
      return this._depth;
    }
    get index() {
      return this._index;
    }
    get parentFingerprint() {
      return this._parentFingerprint;
    }
    get identifier() {
      return o.hash160(this.publicKey);
    }
    get fingerprint() {
      return this.identifier.slice(0, 4);
    }
    get securityLevel() {
      return this.config.level;
    }
    get network() {
      return this.config.network;
    }
    isNeutered() {
      return this._privateKey === void 0;
    }
    neutered() {
      return new A(void 0, this.publicKey, this.chainCode, this.config, this.depth, this.index, this.parentFingerprint);
    }
    toBase58() {
      const I = this.isNeutered() ? this.config.network.bip32.public : this.config.network.bip32.private, N = !this.isNeutered(), R = 45 + (N ? this.config.privateKeySize : this.config.publicKeySize), U = new Uint8Array(R);
      let T = 0;
      return a.writeUInt32(U, T, I, "BE"), T += 4, a.writeUInt8(U, T, this.depth), T += 1, a.writeUInt32(U, T, this.parentFingerprint, "BE"), T += 4, a.writeUInt32(U, T, this.index, "BE"), T += 4, U.set(this.chainCode, T), T += 32, N ? U.set(this._privateKey, T) : U.set(this._publicKey, T), v.encode(U);
    }
    /**
     * Derive a child key using BIP32 HMAC chain for seed derivation,
     * then ML-DSA for key generation
     */
    derive(I) {
      if (s.parse(i.Uint32Schema, I), this.isNeutered())
        throw new TypeError("Cannot derive child keys without private key");
      const N = I >= y;
      let O;
      if (N) {
        const oe = o.hash256(this._privateKey);
        O = new Uint8Array(37), O[0] = 0, O.set(oe, 1), a.writeUInt32(O, 33, I, "BE");
      } else {
        const oe = o.hash256(this._privateKey);
        O = new Uint8Array(36), O.set(oe, 0), a.writeUInt32(O, 32, I, "BE");
      }
      const R = o.hmacSHA512(this.chainCode, O), U = R.slice(0, 32), T = R.slice(32), { secretKey: Z, publicKey: re } = this.config.algorithm.keygen(U);
      return new A(Z, re, T, this.config, this.depth + 1, I, a.readUInt32(this.fingerprint, 0, "BE"));
    }
    deriveHardened(I) {
      try {
        s.parse(i.Uint31Schema, I);
      } catch {
        throw new TypeError("Expected UInt31, got " + I);
      }
      return this.derive(I + y);
    }
    derivePath(I) {
      s.parse(i.Bip32PathSchema, I);
      let N = I.split("/");
      if (N[0] === "m") {
        if (this.parentFingerprint)
          throw new TypeError("Expected master, got child");
        N = N.slice(1);
      }
      return N.reduce((O, R) => {
        let U;
        return R.slice(-1) === "'" ? (U = parseInt(R.slice(0, -1), 10), O.deriveHardened(U)) : (U = parseInt(R, 10), O.derive(U));
      }, this);
    }
  }
  function E(j, I, N) {
    if (s.parse(s.instance(Uint8Array), j), j.length < 16)
      throw new TypeError("Seed should be at least 128 bits");
    if (j.length > 64)
      throw new TypeError("Seed should be at most 512 bits");
    const O = (0, c.getMLDSAConfig)(N || c.MLDSASecurityLevel.LEVEL2, I || w.BITCOIN), R = o.hmacSHA512(a.fromUtf8("Bitcoin seed"), j), U = R.slice(0, 32), T = R.slice(32), { secretKey: Z, publicKey: re } = O.algorithm.keygen(U);
    return new A(
      Z,
      re,
      T,
      // Chain code
      O,
      0,
      // depth
      0,
      // index
      0
    );
  }
  function x(j) {
    const I = v.decode(j), N = a.readUInt32(I, 0, "BE"), O = (0, c.findNetworkByVersion)(N);
    if (!O)
      throw new TypeError("Unknown network version");
    const { network: R, isPrivate: U } = O, Z = I.length - 45;
    let re;
    if (U)
      if (Z === 2560)
        re = c.MLDSASecurityLevel.LEVEL2;
      else if (Z === 4032)
        re = c.MLDSASecurityLevel.LEVEL3;
      else if (Z === 4896)
        re = c.MLDSASecurityLevel.LEVEL5;
      else
        throw new TypeError(`Invalid private key size: ${Z}`);
    else if (Z === 1312)
      re = c.MLDSASecurityLevel.LEVEL2;
    else if (Z === 1952)
      re = c.MLDSASecurityLevel.LEVEL3;
    else if (Z === 2592)
      re = c.MLDSASecurityLevel.LEVEL5;
    else
      throw new TypeError(`Invalid public key size: ${Z}`);
    const oe = (0, c.getMLDSAConfig)(re, R), ue = U ? 45 + oe.privateKeySize : 45 + oe.publicKeySize;
    if (I.length !== ue)
      throw new TypeError(`Invalid buffer length: expected ${ue}, got ${I.length}`);
    let ie = 4;
    const de = I[ie];
    ie += 1;
    const me = a.readUInt32(I, ie, "BE");
    if (de === 0 && me !== 0)
      throw new TypeError("Invalid parent fingerprint");
    ie += 4;
    const Se = a.readUInt32(I, ie, "BE");
    if (de === 0 && Se !== 0)
      throw new TypeError("Invalid index");
    ie += 4;
    const De = I.slice(ie, ie + 32);
    if (ie += 32, U) {
      const q = I.slice(ie, ie + oe.privateKeySize), H = oe.algorithm.getPublicKey(q);
      return new A(q, H, De, oe, de, Se, me);
    } else {
      const q = I.slice(ie, ie + oe.publicKeySize);
      return new A(void 0, q, De, oe, de, Se, me);
    }
  }
  function z(j, I, N, O) {
    const R = (0, c.getMLDSAConfig)(O || c.MLDSASecurityLevel.LEVEL2, N || w.BITCOIN);
    if (j.length !== R.publicKeySize)
      throw new TypeError(`Invalid public key length for ML-DSA-${O}: expected ${R.publicKeySize}, got ${j.length}`);
    if (I.length !== k)
      throw new TypeError(`Invalid chain code length: expected ${k}, got ${I.length}`);
    return new A(void 0, j, I, R, 0, 0, 0);
  }
  function F(j, I, N, O) {
    const R = (0, c.getMLDSAConfig)(O || c.MLDSASecurityLevel.LEVEL2, N || w.BITCOIN);
    if (j.length !== R.privateKeySize)
      throw new TypeError(`Invalid private key length for ML-DSA-${O}: expected ${R.privateKeySize}, got ${j.length}`);
    if (I.length !== k)
      throw new TypeError(`Invalid chain code length: expected ${k}, got ${I.length}`);
    const U = R.algorithm.getPublicKey(j);
    return new A(j, U, I, R, 0, 0, 0);
  }
  return dr.QuantumBIP32Factory = {
    fromSeed: E,
    fromBase58: x,
    fromPublicKey: z,
    fromPrivateKey: F
  }, dr;
}
var Rr = {}, _u;
function Od() {
  if (_u) return Rr;
  _u = 1, Object.defineProperty(Rr, "__esModule", { value: !0 }), Rr.QuantumDerivationPath = Rr.DerivationPath = void 0, Rr.getQuantumPath = r, Rr.getBitcoinPath = n;
  var e;
  (function(o) {
    o.BIP44 = "m/44'/0'/0'/0/0", o.BIP49 = "m/49'/0'/0'/0/0", o.BIP84 = "m/84'/0'/0'/0/0", o.BIP86 = "m/86'/0'/0'/0/0", o.BIP360 = "m/360'/0'/0'/0/0";
  })(e || (Rr.DerivationPath = e = {}));
  var t;
  (function(o) {
    o.STANDARD = "m/360'/0'/0'/0/0", o.CHANGE = "m/360'/0'/0'/1/0", o.ACCOUNT_0_ADDRESS_0 = "m/360'/0'/0'/0/0", o.ACCOUNT_0_ADDRESS_1 = "m/360'/0'/0'/0/1", o.ACCOUNT_1_ADDRESS_0 = "m/360'/1'/0'/0/0";
  })(t || (Rr.QuantumDerivationPath = t = {}));
  function r(o = 0, a = 0, s = !1) {
    return `m/360'/${o}'/${s ? 1 : 0}'/${a}`;
  }
  function n(o, a = 0, s = 0, i = !1) {
    return `m/${o}'/0'/${a}'/${i ? 1 : 0}/${s}`;
  }
  return Rr;
}
var ku;
function vm() {
  return ku || (ku = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.getBitcoinPath = e.getQuantumPath = e.QuantumDerivationPath = e.DerivationPath = e.getMLDSAConfig = e.DEFAULT_SECURITY_LEVEL = e.MLDSASecurityLevel = e.QuantumBIP32Factory = void 0;
    var t = ym();
    Object.defineProperty(e, "QuantumBIP32Factory", { enumerable: !0, get: function() {
      return t.QuantumBIP32Factory;
    } });
    var r = zd();
    Object.defineProperty(e, "MLDSASecurityLevel", { enumerable: !0, get: function() {
      return r.MLDSASecurityLevel;
    } }), Object.defineProperty(e, "DEFAULT_SECURITY_LEVEL", { enumerable: !0, get: function() {
      return r.DEFAULT_SECURITY_LEVEL;
    } }), Object.defineProperty(e, "getMLDSAConfig", { enumerable: !0, get: function() {
      return r.getMLDSAConfig;
    } });
    var n = Od();
    Object.defineProperty(e, "DerivationPath", { enumerable: !0, get: function() {
      return n.DerivationPath;
    } }), Object.defineProperty(e, "QuantumDerivationPath", { enumerable: !0, get: function() {
      return n.QuantumDerivationPath;
    } }), Object.defineProperty(e, "getQuantumPath", { enumerable: !0, get: function() {
      return n.getQuantumPath;
    } }), Object.defineProperty(e, "getBitcoinPath", { enumerable: !0, get: function() {
      return n.getBitcoinPath;
    } });
  })(no)), no;
}
var Eu;
function wm() {
  return Eu || (Eu = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.getBitcoinPath = e.getQuantumPath = e.QuantumDerivationPath = e.DerivationPath = e.getMLDSAConfig = e.DEFAULT_SECURITY_LEVEL = e.MLDSASecurityLevel = e.QuantumBIP32Factory = e.REGTEST = e.TESTNET = e.BITCOIN = e.BIP32Factory = e.default = void 0;
    var t = nm();
    Object.defineProperty(e, "default", { enumerable: !0, get: function() {
      return t.BIP32Factory;
    } }), Object.defineProperty(e, "BIP32Factory", { enumerable: !0, get: function() {
      return t.BIP32Factory;
    } });
    var r = Ba();
    Object.defineProperty(e, "BITCOIN", { enumerable: !0, get: function() {
      return r.BITCOIN;
    } }), Object.defineProperty(e, "TESTNET", { enumerable: !0, get: function() {
      return r.TESTNET;
    } }), Object.defineProperty(e, "REGTEST", { enumerable: !0, get: function() {
      return r.REGTEST;
    } });
    var n = vm();
    Object.defineProperty(e, "QuantumBIP32Factory", { enumerable: !0, get: function() {
      return n.QuantumBIP32Factory;
    } }), Object.defineProperty(e, "MLDSASecurityLevel", { enumerable: !0, get: function() {
      return n.MLDSASecurityLevel;
    } }), Object.defineProperty(e, "DEFAULT_SECURITY_LEVEL", { enumerable: !0, get: function() {
      return n.DEFAULT_SECURITY_LEVEL;
    } }), Object.defineProperty(e, "getMLDSAConfig", { enumerable: !0, get: function() {
      return n.getMLDSAConfig;
    } });
    var o = Od();
    Object.defineProperty(e, "DerivationPath", { enumerable: !0, get: function() {
      return o.DerivationPath;
    } }), Object.defineProperty(e, "QuantumDerivationPath", { enumerable: !0, get: function() {
      return o.QuantumDerivationPath;
    } }), Object.defineProperty(e, "getQuantumPath", { enumerable: !0, get: function() {
      return o.getQuantumPath;
    } }), Object.defineProperty(e, "getBitcoinPath", { enumerable: !0, get: function() {
      return o.getBitcoinPath;
    } });
  })(to)), to;
}
var _m = wm();
const mv = /* @__PURE__ */ Ea(_m);
var ao = {}, ut = {}, lt = {}, xu;
function km() {
  return xu || (xu = 1, Object.defineProperty(lt, "__esModule", { value: !0 }), lt.testnet = lt.bitcoin = void 0, lt.bitcoin = {
    messagePrefix: `Bitcoin Signed Message:
`,
    bech32: "bc",
    bip32: {
      public: 76067358,
      private: 76066276
    },
    pubKeyHash: 0,
    scriptHash: 5,
    wif: 128
  }, lt.testnet = {
    messagePrefix: `Bitcoin Signed Message:
`,
    bech32: "tb",
    bip32: {
      public: 70617039,
      private: 70615956
    },
    pubKeyHash: 111,
    scriptHash: 196,
    wif: 239
  }), lt;
}
var oo = {}, Au;
function Em() {
  return Au || (Au = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.maybe = e.Boolean = e.Array = e.Buffer256bit = e.Network = e.typeforce = void 0, e.typeforce = Xf(), e.Network = e.typeforce.compile({
      messagePrefix: e.typeforce.oneOf(
        e.typeforce.Buffer,
        e.typeforce.String
      ),
      bip32: {
        public: e.typeforce.UInt32,
        private: e.typeforce.UInt32
      },
      pubKeyHash: e.typeforce.UInt8,
      scriptHash: e.typeforce.UInt8,
      wif: e.typeforce.UInt8
    }), e.Buffer256bit = e.typeforce.BufferN(32), e.Array = e.typeforce.Array, e.Boolean = e.typeforce.Boolean, e.maybe = e.typeforce.maybe;
  })(oo)), oo;
}
function Bs(e, t, r, n) {
  if (!e)
    throw new Error(`${t} (${r}: ${n})`);
}
function xm() {
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof globalThis < "u")
    return globalThis;
  throw new Error("unable to locate global object");
}
const Su = xm(), Iu = Su.crypto || Su.msCrypto;
function Rd(e) {
  switch (e) {
    case "sha256":
      return fn.create();
    case "sha512":
      return ns.create();
  }
  Bs(!1, "invalid hashing algorithm name", "algorithm", e);
}
function jd(e, t) {
  const r = { sha256: fn, sha512: ns }[e];
  return Bs(r != null, "invalid hmac algorithm", "algorithm", e), sh.create(r, t);
}
function Pd(e, t, r, n, o) {
  const a = { sha256: fn, sha512: ns }[o];
  return Bs(a != null, "invalid pbkdf2 algorithm", "algorithm", o), ch(a, e, t, { c: r, dkLen: n });
}
function Ud(e) {
  if (Iu == null)
    throw new Error("platform does not support secure random numbers");
  if (!Number.isInteger(e) || e <= 0 || e > 1024)
    throw new Error(`invalid length: ${e}`);
  const t = new Uint8Array(e);
  return Iu.getRandomValues(t), t;
}
const Am = {
  createHash: Rd,
  createHmac: jd,
  pbkdf2Sync: Pd,
  randomBytes: Ud
}, Sm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createHash: Rd,
  createHmac: jd,
  default: Am,
  pbkdf2Sync: Pd,
  randomBytes: Ud
}, Symbol.toStringTag, { value: "Module" })), Nd = /* @__PURE__ */ En(Sm);
var io, Bu;
function Im() {
  return Bu || (Bu = 1, io = Nd.randomBytes), io;
}
var so, Tu;
function Bm() {
  return Tu || (Tu = 1, so = Nd.createHash), so;
}
var Zn = { exports: {} }, co = {}, zu;
function Tm() {
  return zu || (zu = 1, (function(e) {
    Object.defineProperties(e, { __esModule: { value: !0 }, [Symbol.toStringTag]: { value: "Module" } });
    var t = {}, r = {};
    r.byteLength = c, r.toByteArray = g, r.fromByteArray = y;
    for (var n = [], o = [], a = typeof Uint8Array < "u" ? Uint8Array : Array, s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i = 0, h = s.length; i < h; ++i)
      n[i] = s[i], o[s.charCodeAt(i)] = i;
    o[45] = 62, o[95] = 63;
    function l(E) {
      var x = E.length;
      if (x % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var z = E.indexOf("=");
      z === -1 && (z = x);
      var F = z === x ? 0 : 4 - z % 4;
      return [z, F];
    }
    function c(E) {
      var x = l(E), z = x[0], F = x[1];
      return (z + F) * 3 / 4 - F;
    }
    function w(E, x, z) {
      return (x + z) * 3 / 4 - z;
    }
    function g(E) {
      var x, z = l(E), F = z[0], j = z[1], I = new a(w(E, F, j)), N = 0, O = j > 0 ? F - 4 : F, R;
      for (R = 0; R < O; R += 4)
        x = o[E.charCodeAt(R)] << 18 | o[E.charCodeAt(R + 1)] << 12 | o[E.charCodeAt(R + 2)] << 6 | o[E.charCodeAt(R + 3)], I[N++] = x >> 16 & 255, I[N++] = x >> 8 & 255, I[N++] = x & 255;
      return j === 2 && (x = o[E.charCodeAt(R)] << 2 | o[E.charCodeAt(R + 1)] >> 4, I[N++] = x & 255), j === 1 && (x = o[E.charCodeAt(R)] << 10 | o[E.charCodeAt(R + 1)] << 4 | o[E.charCodeAt(R + 2)] >> 2, I[N++] = x >> 8 & 255, I[N++] = x & 255), I;
    }
    function v(E) {
      return n[E >> 18 & 63] + n[E >> 12 & 63] + n[E >> 6 & 63] + n[E & 63];
    }
    function k(E, x, z) {
      for (var F, j = [], I = x; I < z; I += 3)
        F = (E[I] << 16 & 16711680) + (E[I + 1] << 8 & 65280) + (E[I + 2] & 255), j.push(v(F));
      return j.join("");
    }
    function y(E) {
      for (var x, z = E.length, F = z % 3, j = [], I = 16383, N = 0, O = z - F; N < O; N += I)
        j.push(k(E, N, N + I > O ? O : N + I));
      return F === 1 ? (x = E[z - 1], j.push(
        n[x >> 2] + n[x << 4 & 63] + "=="
      )) : F === 2 && (x = (E[z - 2] << 8) + E[z - 1], j.push(
        n[x >> 10] + n[x >> 4 & 63] + n[x << 2 & 63] + "="
      )), j.join("");
    }
    var m = {};
    m.read = function(E, x, z, F, j) {
      var I, N, O = j * 8 - F - 1, R = (1 << O) - 1, U = R >> 1, T = -7, Z = z ? j - 1 : 0, re = z ? -1 : 1, oe = E[x + Z];
      for (Z += re, I = oe & (1 << -T) - 1, oe >>= -T, T += O; T > 0; I = I * 256 + E[x + Z], Z += re, T -= 8)
        ;
      for (N = I & (1 << -T) - 1, I >>= -T, T += F; T > 0; N = N * 256 + E[x + Z], Z += re, T -= 8)
        ;
      if (I === 0)
        I = 1 - U;
      else {
        if (I === R)
          return N ? NaN : (oe ? -1 : 1) * (1 / 0);
        N = N + Math.pow(2, F), I = I - U;
      }
      return (oe ? -1 : 1) * N * Math.pow(2, I - F);
    }, m.write = function(E, x, z, F, j, I) {
      var N, O, R, U = I * 8 - j - 1, T = (1 << U) - 1, Z = T >> 1, re = j === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, oe = F ? 0 : I - 1, ue = F ? 1 : -1, ie = x < 0 || x === 0 && 1 / x < 0 ? 1 : 0;
      for (x = Math.abs(x), isNaN(x) || x === 1 / 0 ? (O = isNaN(x) ? 1 : 0, N = T) : (N = Math.floor(Math.log(x) / Math.LN2), x * (R = Math.pow(2, -N)) < 1 && (N--, R *= 2), N + Z >= 1 ? x += re / R : x += re * Math.pow(2, 1 - Z), x * R >= 2 && (N++, R /= 2), N + Z >= T ? (O = 0, N = T) : N + Z >= 1 ? (O = (x * R - 1) * Math.pow(2, j), N = N + Z) : (O = x * Math.pow(2, Z - 1) * Math.pow(2, j), N = 0)); j >= 8; E[z + oe] = O & 255, oe += ue, O /= 256, j -= 8)
        ;
      for (N = N << j | O, U += j; U > 0; E[z + oe] = N & 255, oe += ue, N /= 256, U -= 8)
        ;
      E[z + oe - ue] |= ie * 128;
    };
    (function(E) {
      const x = r, z = m, F = typeof Symbol == "function" && typeof Symbol.for == "function" ? /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom") : null;
      E.Buffer = T, E.SlowBuffer = H, E.INSPECT_MAX_BYTES = 50;
      const j = 2147483647;
      E.kMaxLength = j;
      const { Uint8Array: I, ArrayBuffer: N, SharedArrayBuffer: O } = globalThis;
      T.TYPED_ARRAY_SUPPORT = R(), !T.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
      function R() {
        try {
          const _ = new I(1), f = { foo: function() {
            return 42;
          } };
          return Object.setPrototypeOf(f, I.prototype), Object.setPrototypeOf(_, f), _.foo() === 42;
        } catch {
          return !1;
        }
      }
      Object.defineProperty(T.prototype, "parent", {
        enumerable: !0,
        get: function() {
          if (T.isBuffer(this))
            return this.buffer;
        }
      }), Object.defineProperty(T.prototype, "offset", {
        enumerable: !0,
        get: function() {
          if (T.isBuffer(this))
            return this.byteOffset;
        }
      });
      function U(_) {
        if (_ > j)
          throw new RangeError('The value "' + _ + '" is invalid for option "size"');
        const f = new I(_);
        return Object.setPrototypeOf(f, T.prototype), f;
      }
      function T(_, f, p) {
        if (typeof _ == "number") {
          if (typeof f == "string")
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          return ue(_);
        }
        return Z(_, f, p);
      }
      T.poolSize = 8192;
      function Z(_, f, p) {
        if (typeof _ == "string")
          return ie(_, f);
        if (N.isView(_))
          return me(_);
        if (_ == null)
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof _
          );
        if (hr(_, N) || _ && hr(_.buffer, N) || typeof O < "u" && (hr(_, O) || _ && hr(_.buffer, O)))
          return Se(_, f, p);
        if (typeof _ == "number")
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        const B = _.valueOf && _.valueOf();
        if (B != null && B !== _)
          return T.from(B, f, p);
        const L = De(_);
        if (L) return L;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof _[Symbol.toPrimitive] == "function")
          return T.from(_[Symbol.toPrimitive]("string"), f, p);
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof _
        );
      }
      T.from = function(_, f, p) {
        return Z(_, f, p);
      }, Object.setPrototypeOf(T.prototype, I.prototype), Object.setPrototypeOf(T, I);
      function re(_) {
        if (typeof _ != "number")
          throw new TypeError('"size" argument must be of type number');
        if (_ < 0)
          throw new RangeError('The value "' + _ + '" is invalid for option "size"');
      }
      function oe(_, f, p) {
        return re(_), _ <= 0 ? U(_) : f !== void 0 ? typeof p == "string" ? U(_).fill(f, p) : U(_).fill(f) : U(_);
      }
      T.alloc = function(_, f, p) {
        return oe(_, f, p);
      };
      function ue(_) {
        return re(_), U(_ < 0 ? 0 : q(_) | 0);
      }
      T.allocUnsafe = function(_) {
        return ue(_);
      }, T.allocUnsafeSlow = function(_) {
        return ue(_);
      };
      function ie(_, f) {
        if ((typeof f != "string" || f === "") && (f = "utf8"), !T.isEncoding(f))
          throw new TypeError("Unknown encoding: " + f);
        const p = C(_, f) | 0;
        let B = U(p);
        const L = B.write(_, f);
        return L !== p && (B = B.slice(0, L)), B;
      }
      function de(_) {
        const f = _.length < 0 ? 0 : q(_.length) | 0, p = U(f);
        for (let B = 0; B < f; B += 1)
          p[B] = _[B] & 255;
        return p;
      }
      function me(_) {
        if (hr(_, I)) {
          const f = new I(_);
          return Se(f.buffer, f.byteOffset, f.byteLength);
        }
        return de(_);
      }
      function Se(_, f, p) {
        if (f < 0 || _.byteLength < f)
          throw new RangeError('"offset" is outside of buffer bounds');
        if (_.byteLength < f + (p || 0))
          throw new RangeError('"length" is outside of buffer bounds');
        let B;
        return f === void 0 && p === void 0 ? B = new I(_) : p === void 0 ? B = new I(_, f) : B = new I(_, f, p), Object.setPrototypeOf(B, T.prototype), B;
      }
      function De(_) {
        if (T.isBuffer(_)) {
          const f = q(_.length) | 0, p = U(f);
          return p.length === 0 || _.copy(p, 0, 0, f), p;
        }
        if (_.length !== void 0)
          return typeof _.length != "number" || Ra(_.length) ? U(0) : de(_);
        if (_.type === "Buffer" && Array.isArray(_.data))
          return de(_.data);
      }
      function q(_) {
        if (_ >= j)
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + j.toString(16) + " bytes");
        return _ | 0;
      }
      function H(_) {
        return +_ != _ && (_ = 0), T.alloc(+_);
      }
      T.isBuffer = function(f) {
        return f != null && f._isBuffer === !0 && f !== T.prototype;
      }, T.compare = function(f, p) {
        if (hr(f, I) && (f = T.from(f, f.offset, f.byteLength)), hr(p, I) && (p = T.from(p, p.offset, p.byteLength)), !T.isBuffer(f) || !T.isBuffer(p))
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        if (f === p) return 0;
        let B = f.length, L = p.length;
        for (let K = 0, Y = Math.min(B, L); K < Y; ++K)
          if (f[K] !== p[K]) {
            B = f[K], L = p[K];
            break;
          }
        return B < L ? -1 : L < B ? 1 : 0;
      }, T.isEncoding = function(f) {
        switch (String(f).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return !0;
          default:
            return !1;
        }
      }, T.concat = function(f, p) {
        if (!Array.isArray(f))
          throw new TypeError('"list" argument must be an Array of Buffers');
        if (f.length === 0)
          return T.alloc(0);
        let B;
        if (p === void 0)
          for (p = 0, B = 0; B < f.length; ++B)
            p += f[B].length;
        const L = T.allocUnsafe(p);
        let K = 0;
        for (B = 0; B < f.length; ++B) {
          let Y = f[B];
          if (hr(Y, I))
            K + Y.length > L.length ? (T.isBuffer(Y) || (Y = T.from(Y)), Y.copy(L, K)) : I.prototype.set.call(
              L,
              Y,
              K
            );
          else if (T.isBuffer(Y))
            Y.copy(L, K);
          else
            throw new TypeError('"list" argument must be an Array of Buffers');
          K += Y.length;
        }
        return L;
      };
      function C(_, f) {
        if (T.isBuffer(_))
          return _.length;
        if (N.isView(_) || hr(_, N))
          return _.byteLength;
        if (typeof _ != "string")
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof _
          );
        const p = _.length, B = arguments.length > 2 && arguments[2] === !0;
        if (!B && p === 0) return 0;
        let L = !1;
        for (; ; )
          switch (f) {
            case "ascii":
            case "latin1":
            case "binary":
              return p;
            case "utf8":
            case "utf-8":
              return Te(_).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return p * 2;
            case "hex":
              return p >>> 1;
            case "base64":
              return Ae(_).length;
            default:
              if (L)
                return B ? -1 : Te(_).length;
              f = ("" + f).toLowerCase(), L = !0;
          }
      }
      T.byteLength = C;
      function G(_, f, p) {
        let B = !1;
        if ((f === void 0 || f < 0) && (f = 0), f > this.length || ((p === void 0 || p > this.length) && (p = this.length), p <= 0) || (p >>>= 0, f >>>= 0, p <= f))
          return "";
        for (_ || (_ = "utf8"); ; )
          switch (_) {
            case "hex":
              return Re(this, f, p);
            case "utf8":
            case "utf-8":
              return ye(this, f, p);
            case "ascii":
              return Oe(this, f, p);
            case "latin1":
            case "binary":
              return $(this, f, p);
            case "base64":
              return he(this, f, p);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ae(this, f, p);
            default:
              if (B) throw new TypeError("Unknown encoding: " + _);
              _ = (_ + "").toLowerCase(), B = !0;
          }
      }
      T.prototype._isBuffer = !0;
      function V(_, f, p) {
        const B = _[f];
        _[f] = _[p], _[p] = B;
      }
      T.prototype.swap16 = function() {
        const f = this.length;
        if (f % 2 !== 0)
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let p = 0; p < f; p += 2)
          V(this, p, p + 1);
        return this;
      }, T.prototype.swap32 = function() {
        const f = this.length;
        if (f % 4 !== 0)
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let p = 0; p < f; p += 4)
          V(this, p, p + 3), V(this, p + 1, p + 2);
        return this;
      }, T.prototype.swap64 = function() {
        const f = this.length;
        if (f % 8 !== 0)
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let p = 0; p < f; p += 8)
          V(this, p, p + 7), V(this, p + 1, p + 6), V(this, p + 2, p + 5), V(this, p + 3, p + 4);
        return this;
      }, T.prototype.toString = function() {
        const f = this.length;
        return f === 0 ? "" : arguments.length === 0 ? ye(this, 0, f) : G.apply(this, arguments);
      }, T.prototype.toLocaleString = T.prototype.toString, T.prototype.equals = function(f) {
        if (!T.isBuffer(f)) throw new TypeError("Argument must be a Buffer");
        return this === f ? !0 : T.compare(this, f) === 0;
      }, T.prototype.inspect = function() {
        let f = "";
        const p = E.INSPECT_MAX_BYTES;
        return f = this.toString("hex", 0, p).replace(/(.{2})/g, "$1 ").trim(), this.length > p && (f += " ... "), "<Buffer " + f + ">";
      }, F && (T.prototype[F] = T.prototype.inspect), T.prototype.compare = function(f, p, B, L, K) {
        if (hr(f, I) && (f = T.from(f, f.offset, f.byteLength)), !T.isBuffer(f))
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof f
          );
        if (p === void 0 && (p = 0), B === void 0 && (B = f ? f.length : 0), L === void 0 && (L = 0), K === void 0 && (K = this.length), p < 0 || B > f.length || L < 0 || K > this.length)
          throw new RangeError("out of range index");
        if (L >= K && p >= B)
          return 0;
        if (L >= K)
          return -1;
        if (p >= B)
          return 1;
        if (p >>>= 0, B >>>= 0, L >>>= 0, K >>>= 0, this === f) return 0;
        let Y = K - L, ve = B - p;
        const qe = Math.min(Y, ve), Ue = this.slice(L, K), Me = f.slice(p, B);
        for (let Ie = 0; Ie < qe; ++Ie)
          if (Ue[Ie] !== Me[Ie]) {
            Y = Ue[Ie], ve = Me[Ie];
            break;
          }
        return Y < ve ? -1 : ve < Y ? 1 : 0;
      };
      function X(_, f, p, B, L) {
        if (_.length === 0) return -1;
        if (typeof p == "string" ? (B = p, p = 0) : p > 2147483647 ? p = 2147483647 : p < -2147483648 && (p = -2147483648), p = +p, Ra(p) && (p = L ? 0 : _.length - 1), p < 0 && (p = _.length + p), p >= _.length) {
          if (L) return -1;
          p = _.length - 1;
        } else if (p < 0)
          if (L) p = 0;
          else return -1;
        if (typeof f == "string" && (f = T.from(f, B)), T.isBuffer(f))
          return f.length === 0 ? -1 : Q(_, f, p, B, L);
        if (typeof f == "number")
          return f = f & 255, typeof I.prototype.indexOf == "function" ? L ? I.prototype.indexOf.call(_, f, p) : I.prototype.lastIndexOf.call(_, f, p) : Q(_, [f], p, B, L);
        throw new TypeError("val must be string, number or Buffer");
      }
      function Q(_, f, p, B, L) {
        let K = 1, Y = _.length, ve = f.length;
        if (B !== void 0 && (B = String(B).toLowerCase(), B === "ucs2" || B === "ucs-2" || B === "utf16le" || B === "utf-16le")) {
          if (_.length < 2 || f.length < 2)
            return -1;
          K = 2, Y /= 2, ve /= 2, p /= 2;
        }
        function qe(Me, Ie) {
          return K === 1 ? Me[Ie] : Me.readUInt16BE(Ie * K);
        }
        let Ue;
        if (L) {
          let Me = -1;
          for (Ue = p; Ue < Y; Ue++)
            if (qe(_, Ue) === qe(f, Me === -1 ? 0 : Ue - Me)) {
              if (Me === -1 && (Me = Ue), Ue - Me + 1 === ve) return Me * K;
            } else
              Me !== -1 && (Ue -= Ue - Me), Me = -1;
        } else
          for (p + ve > Y && (p = Y - ve), Ue = p; Ue >= 0; Ue--) {
            let Me = !0;
            for (let Ie = 0; Ie < ve; Ie++)
              if (qe(_, Ue + Ie) !== qe(f, Ie)) {
                Me = !1;
                break;
              }
            if (Me) return Ue;
          }
        return -1;
      }
      T.prototype.includes = function(f, p, B) {
        return this.indexOf(f, p, B) !== -1;
      }, T.prototype.indexOf = function(f, p, B) {
        return X(this, f, p, B, !0);
      }, T.prototype.lastIndexOf = function(f, p, B) {
        return X(this, f, p, B, !1);
      };
      function ee(_, f, p, B) {
        p = Number(p) || 0;
        const L = _.length - p;
        B ? (B = Number(B), B > L && (B = L)) : B = L;
        const K = f.length;
        B > K / 2 && (B = K / 2);
        let Y;
        for (Y = 0; Y < B; ++Y) {
          const ve = parseInt(f.substr(Y * 2, 2), 16);
          if (Ra(ve)) return Y;
          _[p + Y] = ve;
        }
        return Y;
      }
      function ne(_, f, p, B) {
        return Rn(Te(f, _.length - p), _, p, B);
      }
      function se(_, f, p, B) {
        return Rn(ze(f), _, p, B);
      }
      function ce(_, f, p, B) {
        return Rn(Ae(f), _, p, B);
      }
      function le(_, f, p, B) {
        return Rn(Pe(f, _.length - p), _, p, B);
      }
      T.prototype.write = function(f, p, B, L) {
        if (p === void 0)
          L = "utf8", B = this.length, p = 0;
        else if (B === void 0 && typeof p == "string")
          L = p, B = this.length, p = 0;
        else if (isFinite(p))
          p = p >>> 0, isFinite(B) ? (B = B >>> 0, L === void 0 && (L = "utf8")) : (L = B, B = void 0);
        else
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        const K = this.length - p;
        if ((B === void 0 || B > K) && (B = K), f.length > 0 && (B < 0 || p < 0) || p > this.length)
          throw new RangeError("Attempt to write outside buffer bounds");
        L || (L = "utf8");
        let Y = !1;
        for (; ; )
          switch (L) {
            case "hex":
              return ee(this, f, p, B);
            case "utf8":
            case "utf-8":
              return ne(this, f, p, B);
            case "ascii":
            case "latin1":
            case "binary":
              return se(this, f, p, B);
            case "base64":
              return ce(this, f, p, B);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return le(this, f, p, B);
            default:
              if (Y) throw new TypeError("Unknown encoding: " + L);
              L = ("" + L).toLowerCase(), Y = !0;
          }
      }, T.prototype.toJSON = function() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function he(_, f, p) {
        return f === 0 && p === _.length ? x.fromByteArray(_) : x.fromByteArray(_.slice(f, p));
      }
      function ye(_, f, p) {
        p = Math.min(_.length, p);
        const B = [];
        let L = f;
        for (; L < p; ) {
          const K = _[L];
          let Y = null, ve = K > 239 ? 4 : K > 223 ? 3 : K > 191 ? 2 : 1;
          if (L + ve <= p) {
            let qe, Ue, Me, Ie;
            switch (ve) {
              case 1:
                K < 128 && (Y = K);
                break;
              case 2:
                qe = _[L + 1], (qe & 192) === 128 && (Ie = (K & 31) << 6 | qe & 63, Ie > 127 && (Y = Ie));
                break;
              case 3:
                qe = _[L + 1], Ue = _[L + 2], (qe & 192) === 128 && (Ue & 192) === 128 && (Ie = (K & 15) << 12 | (qe & 63) << 6 | Ue & 63, Ie > 2047 && (Ie < 55296 || Ie > 57343) && (Y = Ie));
                break;
              case 4:
                qe = _[L + 1], Ue = _[L + 2], Me = _[L + 3], (qe & 192) === 128 && (Ue & 192) === 128 && (Me & 192) === 128 && (Ie = (K & 15) << 18 | (qe & 63) << 12 | (Ue & 63) << 6 | Me & 63, Ie > 65535 && Ie < 1114112 && (Y = Ie));
            }
          }
          Y === null ? (Y = 65533, ve = 1) : Y > 65535 && (Y -= 65536, B.push(Y >>> 10 & 1023 | 55296), Y = 56320 | Y & 1023), B.push(Y), L += ve;
        }
        return we(B);
      }
      const pe = 4096;
      function we(_) {
        const f = _.length;
        if (f <= pe)
          return String.fromCharCode.apply(String, _);
        let p = "", B = 0;
        for (; B < f; )
          p += String.fromCharCode.apply(
            String,
            _.slice(B, B += pe)
          );
        return p;
      }
      function Oe(_, f, p) {
        let B = "";
        p = Math.min(_.length, p);
        for (let L = f; L < p; ++L)
          B += String.fromCharCode(_[L] & 127);
        return B;
      }
      function $(_, f, p) {
        let B = "";
        p = Math.min(_.length, p);
        for (let L = f; L < p; ++L)
          B += String.fromCharCode(_[L]);
        return B;
      }
      function Re(_, f, p) {
        const B = _.length;
        (!f || f < 0) && (f = 0), (!p || p < 0 || p > B) && (p = B);
        let L = "";
        for (let K = f; K < p; ++K)
          L += eh[_[K]];
        return L;
      }
      function ae(_, f, p) {
        const B = _.slice(f, p);
        let L = "";
        for (let K = 0; K < B.length - 1; K += 2)
          L += String.fromCharCode(B[K] + B[K + 1] * 256);
        return L;
      }
      T.prototype.slice = function(f, p) {
        const B = this.length;
        f = ~~f, p = p === void 0 ? B : ~~p, f < 0 ? (f += B, f < 0 && (f = 0)) : f > B && (f = B), p < 0 ? (p += B, p < 0 && (p = 0)) : p > B && (p = B), p < f && (p = f);
        const L = this.subarray(f, p);
        return Object.setPrototypeOf(L, T.prototype), L;
      };
      function fe(_, f, p) {
        if (_ % 1 !== 0 || _ < 0) throw new RangeError("offset is not uint");
        if (_ + f > p) throw new RangeError("Trying to access beyond buffer length");
      }
      T.prototype.readUintLE = T.prototype.readUIntLE = function(f, p, B) {
        f = f >>> 0, p = p >>> 0, B || fe(f, p, this.length);
        let L = this[f], K = 1, Y = 0;
        for (; ++Y < p && (K *= 256); )
          L += this[f + Y] * K;
        return L;
      }, T.prototype.readUintBE = T.prototype.readUIntBE = function(f, p, B) {
        f = f >>> 0, p = p >>> 0, B || fe(f, p, this.length);
        let L = this[f + --p], K = 1;
        for (; p > 0 && (K *= 256); )
          L += this[f + --p] * K;
        return L;
      }, T.prototype.readUint8 = T.prototype.readUInt8 = function(f, p) {
        return f = f >>> 0, p || fe(f, 1, this.length), this[f];
      }, T.prototype.readUint16LE = T.prototype.readUInt16LE = function(f, p) {
        return f = f >>> 0, p || fe(f, 2, this.length), this[f] | this[f + 1] << 8;
      }, T.prototype.readUint16BE = T.prototype.readUInt16BE = function(f, p) {
        return f = f >>> 0, p || fe(f, 2, this.length), this[f] << 8 | this[f + 1];
      }, T.prototype.readUint32LE = T.prototype.readUInt32LE = function(f, p) {
        return f = f >>> 0, p || fe(f, 4, this.length), (this[f] | this[f + 1] << 8 | this[f + 2] << 16) + this[f + 3] * 16777216;
      }, T.prototype.readUint32BE = T.prototype.readUInt32BE = function(f, p) {
        return f = f >>> 0, p || fe(f, 4, this.length), this[f] * 16777216 + (this[f + 1] << 16 | this[f + 2] << 8 | this[f + 3]);
      }, T.prototype.readBigUInt64LE = Lr(function(f) {
        f = f >>> 0, P(f, "offset");
        const p = this[f], B = this[f + 7];
        (p === void 0 || B === void 0) && D(f, this.length - 8);
        const L = p + this[++f] * 2 ** 8 + this[++f] * 2 ** 16 + this[++f] * 2 ** 24, K = this[++f] + this[++f] * 2 ** 8 + this[++f] * 2 ** 16 + B * 2 ** 24;
        return BigInt(L) + (BigInt(K) << BigInt(32));
      }), T.prototype.readBigUInt64BE = Lr(function(f) {
        f = f >>> 0, P(f, "offset");
        const p = this[f], B = this[f + 7];
        (p === void 0 || B === void 0) && D(f, this.length - 8);
        const L = p * 2 ** 24 + this[++f] * 2 ** 16 + this[++f] * 2 ** 8 + this[++f], K = this[++f] * 2 ** 24 + this[++f] * 2 ** 16 + this[++f] * 2 ** 8 + B;
        return (BigInt(L) << BigInt(32)) + BigInt(K);
      }), T.prototype.readIntLE = function(f, p, B) {
        f = f >>> 0, p = p >>> 0, B || fe(f, p, this.length);
        let L = this[f], K = 1, Y = 0;
        for (; ++Y < p && (K *= 256); )
          L += this[f + Y] * K;
        return K *= 128, L >= K && (L -= Math.pow(2, 8 * p)), L;
      }, T.prototype.readIntBE = function(f, p, B) {
        f = f >>> 0, p = p >>> 0, B || fe(f, p, this.length);
        let L = p, K = 1, Y = this[f + --L];
        for (; L > 0 && (K *= 256); )
          Y += this[f + --L] * K;
        return K *= 128, Y >= K && (Y -= Math.pow(2, 8 * p)), Y;
      }, T.prototype.readInt8 = function(f, p) {
        return f = f >>> 0, p || fe(f, 1, this.length), this[f] & 128 ? (255 - this[f] + 1) * -1 : this[f];
      }, T.prototype.readInt16LE = function(f, p) {
        f = f >>> 0, p || fe(f, 2, this.length);
        const B = this[f] | this[f + 1] << 8;
        return B & 32768 ? B | 4294901760 : B;
      }, T.prototype.readInt16BE = function(f, p) {
        f = f >>> 0, p || fe(f, 2, this.length);
        const B = this[f + 1] | this[f] << 8;
        return B & 32768 ? B | 4294901760 : B;
      }, T.prototype.readInt32LE = function(f, p) {
        return f = f >>> 0, p || fe(f, 4, this.length), this[f] | this[f + 1] << 8 | this[f + 2] << 16 | this[f + 3] << 24;
      }, T.prototype.readInt32BE = function(f, p) {
        return f = f >>> 0, p || fe(f, 4, this.length), this[f] << 24 | this[f + 1] << 16 | this[f + 2] << 8 | this[f + 3];
      }, T.prototype.readBigInt64LE = Lr(function(f) {
        f = f >>> 0, P(f, "offset");
        const p = this[f], B = this[f + 7];
        (p === void 0 || B === void 0) && D(f, this.length - 8);
        const L = this[f + 4] + this[f + 5] * 2 ** 8 + this[f + 6] * 2 ** 16 + (B << 24);
        return (BigInt(L) << BigInt(32)) + BigInt(p + this[++f] * 2 ** 8 + this[++f] * 2 ** 16 + this[++f] * 2 ** 24);
      }), T.prototype.readBigInt64BE = Lr(function(f) {
        f = f >>> 0, P(f, "offset");
        const p = this[f], B = this[f + 7];
        (p === void 0 || B === void 0) && D(f, this.length - 8);
        const L = (p << 24) + // Overflow
        this[++f] * 2 ** 16 + this[++f] * 2 ** 8 + this[++f];
        return (BigInt(L) << BigInt(32)) + BigInt(this[++f] * 2 ** 24 + this[++f] * 2 ** 16 + this[++f] * 2 ** 8 + B);
      }), T.prototype.readFloatLE = function(f, p) {
        return f = f >>> 0, p || fe(f, 4, this.length), z.read(this, f, !0, 23, 4);
      }, T.prototype.readFloatBE = function(f, p) {
        return f = f >>> 0, p || fe(f, 4, this.length), z.read(this, f, !1, 23, 4);
      }, T.prototype.readDoubleLE = function(f, p) {
        return f = f >>> 0, p || fe(f, 8, this.length), z.read(this, f, !0, 52, 8);
      }, T.prototype.readDoubleBE = function(f, p) {
        return f = f >>> 0, p || fe(f, 8, this.length), z.read(this, f, !1, 52, 8);
      };
      function ge(_, f, p, B, L, K) {
        if (!T.isBuffer(_)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (f > L || f < K) throw new RangeError('"value" argument is out of bounds');
        if (p + B > _.length) throw new RangeError("Index out of range");
      }
      T.prototype.writeUintLE = T.prototype.writeUIntLE = function(f, p, B, L) {
        if (f = +f, p = p >>> 0, B = B >>> 0, !L) {
          const ve = Math.pow(2, 8 * B) - 1;
          ge(this, f, p, B, ve, 0);
        }
        let K = 1, Y = 0;
        for (this[p] = f & 255; ++Y < B && (K *= 256); )
          this[p + Y] = f / K & 255;
        return p + B;
      }, T.prototype.writeUintBE = T.prototype.writeUIntBE = function(f, p, B, L) {
        if (f = +f, p = p >>> 0, B = B >>> 0, !L) {
          const ve = Math.pow(2, 8 * B) - 1;
          ge(this, f, p, B, ve, 0);
        }
        let K = B - 1, Y = 1;
        for (this[p + K] = f & 255; --K >= 0 && (Y *= 256); )
          this[p + K] = f / Y & 255;
        return p + B;
      }, T.prototype.writeUint8 = T.prototype.writeUInt8 = function(f, p, B) {
        return f = +f, p = p >>> 0, B || ge(this, f, p, 1, 255, 0), this[p] = f & 255, p + 1;
      }, T.prototype.writeUint16LE = T.prototype.writeUInt16LE = function(f, p, B) {
        return f = +f, p = p >>> 0, B || ge(this, f, p, 2, 65535, 0), this[p] = f & 255, this[p + 1] = f >>> 8, p + 2;
      }, T.prototype.writeUint16BE = T.prototype.writeUInt16BE = function(f, p, B) {
        return f = +f, p = p >>> 0, B || ge(this, f, p, 2, 65535, 0), this[p] = f >>> 8, this[p + 1] = f & 255, p + 2;
      }, T.prototype.writeUint32LE = T.prototype.writeUInt32LE = function(f, p, B) {
        return f = +f, p = p >>> 0, B || ge(this, f, p, 4, 4294967295, 0), this[p + 3] = f >>> 24, this[p + 2] = f >>> 16, this[p + 1] = f >>> 8, this[p] = f & 255, p + 4;
      }, T.prototype.writeUint32BE = T.prototype.writeUInt32BE = function(f, p, B) {
        return f = +f, p = p >>> 0, B || ge(this, f, p, 4, 4294967295, 0), this[p] = f >>> 24, this[p + 1] = f >>> 16, this[p + 2] = f >>> 8, this[p + 3] = f & 255, p + 4;
      };
      function xe(_, f, p, B, L) {
        S(f, B, L, _, p, 7);
        let K = Number(f & BigInt(4294967295));
        _[p++] = K, K = K >> 8, _[p++] = K, K = K >> 8, _[p++] = K, K = K >> 8, _[p++] = K;
        let Y = Number(f >> BigInt(32) & BigInt(4294967295));
        return _[p++] = Y, Y = Y >> 8, _[p++] = Y, Y = Y >> 8, _[p++] = Y, Y = Y >> 8, _[p++] = Y, p;
      }
      function Be(_, f, p, B, L) {
        S(f, B, L, _, p, 7);
        let K = Number(f & BigInt(4294967295));
        _[p + 7] = K, K = K >> 8, _[p + 6] = K, K = K >> 8, _[p + 5] = K, K = K >> 8, _[p + 4] = K;
        let Y = Number(f >> BigInt(32) & BigInt(4294967295));
        return _[p + 3] = Y, Y = Y >> 8, _[p + 2] = Y, Y = Y >> 8, _[p + 1] = Y, Y = Y >> 8, _[p] = Y, p + 8;
      }
      T.prototype.writeBigUInt64LE = Lr(function(f, p = 0) {
        return xe(this, f, p, BigInt(0), BigInt("0xffffffffffffffff"));
      }), T.prototype.writeBigUInt64BE = Lr(function(f, p = 0) {
        return Be(this, f, p, BigInt(0), BigInt("0xffffffffffffffff"));
      }), T.prototype.writeIntLE = function(f, p, B, L) {
        if (f = +f, p = p >>> 0, !L) {
          const qe = Math.pow(2, 8 * B - 1);
          ge(this, f, p, B, qe - 1, -qe);
        }
        let K = 0, Y = 1, ve = 0;
        for (this[p] = f & 255; ++K < B && (Y *= 256); )
          f < 0 && ve === 0 && this[p + K - 1] !== 0 && (ve = 1), this[p + K] = (f / Y >> 0) - ve & 255;
        return p + B;
      }, T.prototype.writeIntBE = function(f, p, B, L) {
        if (f = +f, p = p >>> 0, !L) {
          const qe = Math.pow(2, 8 * B - 1);
          ge(this, f, p, B, qe - 1, -qe);
        }
        let K = B - 1, Y = 1, ve = 0;
        for (this[p + K] = f & 255; --K >= 0 && (Y *= 256); )
          f < 0 && ve === 0 && this[p + K + 1] !== 0 && (ve = 1), this[p + K] = (f / Y >> 0) - ve & 255;
        return p + B;
      }, T.prototype.writeInt8 = function(f, p, B) {
        return f = +f, p = p >>> 0, B || ge(this, f, p, 1, 127, -128), f < 0 && (f = 255 + f + 1), this[p] = f & 255, p + 1;
      }, T.prototype.writeInt16LE = function(f, p, B) {
        return f = +f, p = p >>> 0, B || ge(this, f, p, 2, 32767, -32768), this[p] = f & 255, this[p + 1] = f >>> 8, p + 2;
      }, T.prototype.writeInt16BE = function(f, p, B) {
        return f = +f, p = p >>> 0, B || ge(this, f, p, 2, 32767, -32768), this[p] = f >>> 8, this[p + 1] = f & 255, p + 2;
      }, T.prototype.writeInt32LE = function(f, p, B) {
        return f = +f, p = p >>> 0, B || ge(this, f, p, 4, 2147483647, -2147483648), this[p] = f & 255, this[p + 1] = f >>> 8, this[p + 2] = f >>> 16, this[p + 3] = f >>> 24, p + 4;
      }, T.prototype.writeInt32BE = function(f, p, B) {
        return f = +f, p = p >>> 0, B || ge(this, f, p, 4, 2147483647, -2147483648), f < 0 && (f = 4294967295 + f + 1), this[p] = f >>> 24, this[p + 1] = f >>> 16, this[p + 2] = f >>> 8, this[p + 3] = f & 255, p + 4;
      }, T.prototype.writeBigInt64LE = Lr(function(f, p = 0) {
        return xe(this, f, p, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      }), T.prototype.writeBigInt64BE = Lr(function(f, p = 0) {
        return Be(this, f, p, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function Ye(_, f, p, B, L, K) {
        if (p + B > _.length) throw new RangeError("Index out of range");
        if (p < 0) throw new RangeError("Index out of range");
      }
      function fr(_, f, p, B, L) {
        return f = +f, p = p >>> 0, L || Ye(_, f, p, 4), z.write(_, f, p, B, 23, 4), p + 4;
      }
      T.prototype.writeFloatLE = function(f, p, B) {
        return fr(this, f, p, !0, B);
      }, T.prototype.writeFloatBE = function(f, p, B) {
        return fr(this, f, p, !1, B);
      };
      function M(_, f, p, B, L) {
        return f = +f, p = p >>> 0, L || Ye(_, f, p, 8), z.write(_, f, p, B, 52, 8), p + 8;
      }
      T.prototype.writeDoubleLE = function(f, p, B) {
        return M(this, f, p, !0, B);
      }, T.prototype.writeDoubleBE = function(f, p, B) {
        return M(this, f, p, !1, B);
      }, T.prototype.copy = function(f, p, B, L) {
        if (!T.isBuffer(f)) throw new TypeError("argument should be a Buffer");
        if (B || (B = 0), !L && L !== 0 && (L = this.length), p >= f.length && (p = f.length), p || (p = 0), L > 0 && L < B && (L = B), L === B || f.length === 0 || this.length === 0) return 0;
        if (p < 0)
          throw new RangeError("targetStart out of bounds");
        if (B < 0 || B >= this.length) throw new RangeError("Index out of range");
        if (L < 0) throw new RangeError("sourceEnd out of bounds");
        L > this.length && (L = this.length), f.length - p < L - B && (L = f.length - p + B);
        const K = L - B;
        return this === f && typeof I.prototype.copyWithin == "function" ? this.copyWithin(p, B, L) : I.prototype.set.call(
          f,
          this.subarray(B, L),
          p
        ), K;
      }, T.prototype.fill = function(f, p, B, L) {
        if (typeof f == "string") {
          if (typeof p == "string" ? (L = p, p = 0, B = this.length) : typeof B == "string" && (L = B, B = this.length), L !== void 0 && typeof L != "string")
            throw new TypeError("encoding must be a string");
          if (typeof L == "string" && !T.isEncoding(L))
            throw new TypeError("Unknown encoding: " + L);
          if (f.length === 1) {
            const Y = f.charCodeAt(0);
            (L === "utf8" && Y < 128 || L === "latin1") && (f = Y);
          }
        } else typeof f == "number" ? f = f & 255 : typeof f == "boolean" && (f = Number(f));
        if (p < 0 || this.length < p || this.length < B)
          throw new RangeError("Out of range index");
        if (B <= p)
          return this;
        p = p >>> 0, B = B === void 0 ? this.length : B >>> 0, f || (f = 0);
        let K;
        if (typeof f == "number")
          for (K = p; K < B; ++K)
            this[K] = f;
        else {
          const Y = T.isBuffer(f) ? f : T.from(f, L), ve = Y.length;
          if (ve === 0)
            throw new TypeError('The value "' + f + '" is invalid for argument "value"');
          for (K = 0; K < B - p; ++K)
            this[K + p] = Y[K % ve];
        }
        return this;
      };
      const te = {};
      function b(_, f, p) {
        te[_] = class extends p {
          constructor() {
            super(), Object.defineProperty(this, "message", {
              value: f.apply(this, arguments),
              writable: !0,
              configurable: !0
            }), this.name = `${this.name} [${_}]`, this.stack, delete this.name;
          }
          get code() {
            return _;
          }
          set code(L) {
            Object.defineProperty(this, "code", {
              configurable: !0,
              enumerable: !0,
              value: L,
              writable: !0
            });
          }
          toString() {
            return `${this.name} [${_}]: ${this.message}`;
          }
        };
      }
      b(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(_) {
          return _ ? `${_} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
        },
        RangeError
      ), b(
        "ERR_INVALID_ARG_TYPE",
        function(_, f) {
          return `The "${_}" argument must be of type number. Received type ${typeof f}`;
        },
        TypeError
      ), b(
        "ERR_OUT_OF_RANGE",
        function(_, f, p) {
          let B = `The value of "${_}" is out of range.`, L = p;
          return Number.isInteger(p) && Math.abs(p) > 2 ** 32 ? L = u(String(p)) : typeof p == "bigint" && (L = String(p), (p > BigInt(2) ** BigInt(32) || p < -(BigInt(2) ** BigInt(32))) && (L = u(L)), L += "n"), B += ` It must be ${f}. Received ${L}`, B;
        },
        RangeError
      );
      function u(_) {
        let f = "", p = _.length;
        const B = _[0] === "-" ? 1 : 0;
        for (; p >= B + 4; p -= 3)
          f = `_${_.slice(p - 3, p)}${f}`;
        return `${_.slice(0, p)}${f}`;
      }
      function d(_, f, p) {
        P(f, "offset"), (_[f] === void 0 || _[f + p] === void 0) && D(f, _.length - (p + 1));
      }
      function S(_, f, p, B, L, K) {
        if (_ > p || _ < f) {
          const Y = typeof f == "bigint" ? "n" : "";
          let ve;
          throw f === 0 || f === BigInt(0) ? ve = `>= 0${Y} and < 2${Y} ** ${(K + 1) * 8}${Y}` : ve = `>= -(2${Y} ** ${(K + 1) * 8 - 1}${Y}) and < 2 ** ${(K + 1) * 8 - 1}${Y}`, new te.ERR_OUT_OF_RANGE("value", ve, _);
        }
        d(B, L, K);
      }
      function P(_, f) {
        if (typeof _ != "number")
          throw new te.ERR_INVALID_ARG_TYPE(f, "number", _);
      }
      function D(_, f, p) {
        throw Math.floor(_) !== _ ? (P(_, p), new te.ERR_OUT_OF_RANGE("offset", "an integer", _)) : f < 0 ? new te.ERR_BUFFER_OUT_OF_BOUNDS() : new te.ERR_OUT_OF_RANGE(
          "offset",
          `>= 0 and <= ${f}`,
          _
        );
      }
      const W = /[^+/0-9A-Za-z-_]/g;
      function be(_) {
        if (_ = _.split("=")[0], _ = _.trim().replace(W, ""), _.length < 2) return "";
        for (; _.length % 4 !== 0; )
          _ = _ + "=";
        return _;
      }
      function Te(_, f) {
        f = f || 1 / 0;
        let p;
        const B = _.length;
        let L = null;
        const K = [];
        for (let Y = 0; Y < B; ++Y) {
          if (p = _.charCodeAt(Y), p > 55295 && p < 57344) {
            if (!L) {
              if (p > 56319) {
                (f -= 3) > -1 && K.push(239, 191, 189);
                continue;
              } else if (Y + 1 === B) {
                (f -= 3) > -1 && K.push(239, 191, 189);
                continue;
              }
              L = p;
              continue;
            }
            if (p < 56320) {
              (f -= 3) > -1 && K.push(239, 191, 189), L = p;
              continue;
            }
            p = (L - 55296 << 10 | p - 56320) + 65536;
          } else L && (f -= 3) > -1 && K.push(239, 191, 189);
          if (L = null, p < 128) {
            if ((f -= 1) < 0) break;
            K.push(p);
          } else if (p < 2048) {
            if ((f -= 2) < 0) break;
            K.push(
              p >> 6 | 192,
              p & 63 | 128
            );
          } else if (p < 65536) {
            if ((f -= 3) < 0) break;
            K.push(
              p >> 12 | 224,
              p >> 6 & 63 | 128,
              p & 63 | 128
            );
          } else if (p < 1114112) {
            if ((f -= 4) < 0) break;
            K.push(
              p >> 18 | 240,
              p >> 12 & 63 | 128,
              p >> 6 & 63 | 128,
              p & 63 | 128
            );
          } else
            throw new Error("Invalid code point");
        }
        return K;
      }
      function ze(_) {
        const f = [];
        for (let p = 0; p < _.length; ++p)
          f.push(_.charCodeAt(p) & 255);
        return f;
      }
      function Pe(_, f) {
        let p, B, L;
        const K = [];
        for (let Y = 0; Y < _.length && !((f -= 2) < 0); ++Y)
          p = _.charCodeAt(Y), B = p >> 8, L = p % 256, K.push(L), K.push(B);
        return K;
      }
      function Ae(_) {
        return x.toByteArray(be(_));
      }
      function Rn(_, f, p, B) {
        let L;
        for (L = 0; L < B && !(L + p >= f.length || L >= _.length); ++L)
          f[L + p] = _[L];
        return L;
      }
      function hr(_, f) {
        return _ instanceof f || _ != null && _.constructor != null && _.constructor.name != null && _.constructor.name === f.name;
      }
      function Ra(_) {
        return _ !== _;
      }
      const eh = (function() {
        const _ = "0123456789abcdef", f = new Array(256);
        for (let p = 0; p < 16; ++p) {
          const B = p * 16;
          for (let L = 0; L < 16; ++L)
            f[B + L] = _[p] + _[L];
        }
        return f;
      })();
      function Lr(_) {
        return typeof BigInt > "u" ? rh : _;
      }
      function rh() {
        throw new Error("BigInt not supported");
      }
    })(t);
    const A = t.Buffer;
    e.Blob = t.Blob, e.BlobOptions = t.BlobOptions, e.Buffer = t.Buffer, e.File = t.File, e.FileOptions = t.FileOptions, e.INSPECT_MAX_BYTES = t.INSPECT_MAX_BYTES, e.SlowBuffer = t.SlowBuffer, e.TranscodeEncoding = t.TranscodeEncoding, e.atob = t.atob, e.btoa = t.btoa, e.constants = t.constants, e.default = A, e.isAscii = t.isAscii, e.isUtf8 = t.isUtf8, e.kMaxLength = t.kMaxLength, e.kStringMaxLength = t.kStringMaxLength, e.resolveObjectURL = t.resolveObjectURL, e.transcode = t.transcode;
  })(co)), co;
}
var Ou;
function Sr() {
  return Ou || (Ou = 1, (function(e, t) {
    var r = Tm(), n = r.Buffer;
    function o(s, i) {
      for (var h in s)
        i[h] = s[h];
    }
    n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? e.exports = r : (o(r, t), t.Buffer = a);
    function a(s, i, h) {
      return n(s, i, h);
    }
    a.prototype = Object.create(n.prototype), o(n, a), a.from = function(s, i, h) {
      if (typeof s == "number")
        throw new TypeError("Argument must not be a number");
      return n(s, i, h);
    }, a.alloc = function(s, i, h) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      var l = n(s);
      return i !== void 0 ? typeof h == "string" ? l.fill(i, h) : l.fill(i) : l.fill(0), l;
    }, a.allocUnsafe = function(s) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      return n(s);
    }, a.allocUnsafeSlow = function(s) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      return r.SlowBuffer(s);
    };
  })(Zn, Zn.exports)), Zn.exports;
}
var uo, Ru;
function zm() {
  if (Ru) return uo;
  Ru = 1;
  var e = Sr().Buffer;
  function t(r) {
    if (r.length >= 255)
      throw new TypeError("Alphabet too long");
    for (var n = new Uint8Array(256), o = 0; o < n.length; o++)
      n[o] = 255;
    for (var a = 0; a < r.length; a++) {
      var s = r.charAt(a), i = s.charCodeAt(0);
      if (n[i] !== 255)
        throw new TypeError(s + " is ambiguous");
      n[i] = a;
    }
    var h = r.length, l = r.charAt(0), c = Math.log(h) / Math.log(256), w = Math.log(256) / Math.log(h);
    function g(y) {
      if ((Array.isArray(y) || y instanceof Uint8Array) && (y = e.from(y)), !e.isBuffer(y))
        throw new TypeError("Expected Buffer");
      if (y.length === 0)
        return "";
      for (var m = 0, A = 0, E = 0, x = y.length; E !== x && y[E] === 0; )
        E++, m++;
      for (var z = (x - E) * w + 1 >>> 0, F = new Uint8Array(z); E !== x; ) {
        for (var j = y[E], I = 0, N = z - 1; (j !== 0 || I < A) && N !== -1; N--, I++)
          j += 256 * F[N] >>> 0, F[N] = j % h >>> 0, j = j / h >>> 0;
        if (j !== 0)
          throw new Error("Non-zero carry");
        A = I, E++;
      }
      for (var O = z - A; O !== z && F[O] === 0; )
        O++;
      for (var R = l.repeat(m); O < z; ++O)
        R += r.charAt(F[O]);
      return R;
    }
    function v(y) {
      if (typeof y != "string")
        throw new TypeError("Expected String");
      if (y.length === 0)
        return e.alloc(0);
      for (var m = 0, A = 0, E = 0; y[m] === l; )
        A++, m++;
      for (var x = (y.length - m) * c + 1 >>> 0, z = new Uint8Array(x); m < y.length; ) {
        var F = y.charCodeAt(m);
        if (F > 255)
          return;
        var j = n[F];
        if (j === 255)
          return;
        for (var I = 0, N = x - 1; (j !== 0 || I < E) && N !== -1; N--, I++)
          j += h * z[N] >>> 0, z[N] = j % 256 >>> 0, j = j / 256 >>> 0;
        if (j !== 0)
          throw new Error("Non-zero carry");
        E = I, m++;
      }
      for (var O = x - E; O !== x && z[O] === 0; )
        O++;
      var R = e.allocUnsafe(A + (x - O));
      R.fill(0, 0, A);
      for (var U = A; O !== x; )
        R[U++] = z[O++];
      return R;
    }
    function k(y) {
      var m = v(y);
      if (m)
        return m;
      throw new Error("Non-base" + h + " character");
    }
    return {
      encode: g,
      decodeUnsafe: v,
      decode: k
    };
  }
  return uo = t, uo;
}
var lo, ju;
function Om() {
  if (ju) return lo;
  ju = 1;
  var e = zm(), t = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  return lo = e(t), lo;
}
var fo, Pu;
function Rm() {
  if (Pu) return fo;
  Pu = 1;
  var e = Om(), t = Sr().Buffer;
  return fo = function(r) {
    function n(i) {
      var h = r(i);
      return e.encode(t.concat([
        i,
        h
      ], i.length + 4));
    }
    function o(i) {
      var h = i.slice(0, -4), l = i.slice(-4), c = r(h);
      if (!(l[0] ^ c[0] | l[1] ^ c[1] | l[2] ^ c[2] | l[3] ^ c[3]))
        return h;
    }
    function a(i) {
      var h = e.decodeUnsafe(i);
      if (h)
        return o(h);
    }
    function s(i) {
      var h = e.decode(i), l = o(h);
      if (!l) throw new Error("Invalid checksum");
      return l;
    }
    return {
      encode: n,
      decode: s,
      decodeUnsafe: a
    };
  }, fo;
}
var ho, Uu;
function jm() {
  if (Uu) return ho;
  Uu = 1;
  var e = Bm(), t = Rm();
  function r(n) {
    var o = e("sha256").update(n).digest();
    return e("sha256").update(o).digest();
  }
  return ho = t(r), ho;
}
var po, Nu;
function Pm() {
  if (Nu) return po;
  Nu = 1;
  var e = jm();
  function t(a, s) {
    if (s !== void 0 && a[0] !== s) throw new Error("Invalid network version");
    if (a.length === 33)
      return {
        version: a[0],
        privateKey: a.slice(1, 33),
        compressed: !1
      };
    if (a.length !== 34) throw new Error("Invalid WIF length");
    if (a[33] !== 1) throw new Error("Invalid compression flag");
    return {
      version: a[0],
      privateKey: a.slice(1, 33),
      compressed: !0
    };
  }
  function r(a, s, i) {
    var h = new J(i ? 34 : 33);
    return h.writeUInt8(a, 0), s.copy(h, 1), i && (h[33] = 1), h;
  }
  function n(a, s) {
    return t(e.decode(a), s);
  }
  function o(a, s, i) {
    return typeof a == "number" ? e.encode(r(a, s, i)) : e.encode(
      r(
        a.version,
        a.privateKey,
        a.compressed
      )
    );
  }
  return po = {
    decode: n,
    decodeRaw: t,
    encode: o,
    encodeRaw: r
  }, po;
}
var rn = {}, Cu;
function Um() {
  if (Cu) return rn;
  Cu = 1, Object.defineProperty(rn, "__esModule", { value: !0 }), rn.testEcc = void 0;
  const e = (n) => J.from(n, "hex");
  function t(n) {
    r(
      n.isPoint(
        e("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
      )
    ), r(
      !n.isPoint(
        e("030000000000000000000000000000000000000000000000000000000000000005")
      )
    ), r(
      n.isPrivate(
        e("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
      )
    ), r(
      n.isPrivate(
        e("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
      )
    ), r(
      !n.isPrivate(
        e("0000000000000000000000000000000000000000000000000000000000000000")
      )
    ), r(
      !n.isPrivate(
        e("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141")
      )
    ), r(
      !n.isPrivate(
        e("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142")
      )
    ), r(
      J.from(
        n.privateAdd(
          e("0000000000000000000000000000000000000000000000000000000000000001"),
          e("0000000000000000000000000000000000000000000000000000000000000000")
        )
      ).equals(
        e("0000000000000000000000000000000000000000000000000000000000000001")
      )
    ), r(
      n.privateAdd(
        e("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"),
        e("0000000000000000000000000000000000000000000000000000000000000003")
      ) === null
    ), r(
      J.from(
        n.privateAdd(
          e("e211078564db65c3ce7704f08262b1f38f1ef412ad15b5ac2d76657a63b2c500"),
          e("b51fbb69051255d1becbd683de5848242a89c229348dd72896a87ada94ae8665")
        )
      ).equals(
        e("9730c2ee69edbb958d42db7460bafa18fef9d955325aec99044c81c8282b0a24")
      )
    ), r(
      J.from(
        n.privateNegate(
          e("0000000000000000000000000000000000000000000000000000000000000001")
        )
      ).equals(
        e("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
      )
    ), r(
      J.from(
        n.privateNegate(
          e("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e")
        )
      ).equals(
        e("0000000000000000000000000000000000000000000000000000000000000003")
      )
    ), r(
      J.from(
        n.privateNegate(
          e("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")
        )
      ).equals(
        e("4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792")
      )
    ), r(
      J.from(
        n.pointCompress(
          e(
            "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
          ),
          !0
        )
      ).equals(
        e("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
      )
    ), r(
      J.from(
        n.pointCompress(
          e(
            "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
          ),
          !1
        )
      ).equals(
        e(
          "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
        )
      )
    ), r(
      J.from(
        n.pointCompress(
          e("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
          !0
        )
      ).equals(
        e("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
      )
    ), r(
      J.from(
        n.pointCompress(
          e("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
          !1
        )
      ).equals(
        e(
          "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
        )
      )
    ), r(
      J.from(
        n.pointFromScalar(
          e("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")
        )
      ).equals(
        e("02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99")
      )
    ), r(
      n.xOnlyPointAddTweak(
        e("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
        e("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
      ) === null
    );
    let o = n.xOnlyPointAddTweak(
      e("1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b"),
      e("a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac")
    );
    r(
      J.from(o.xOnlyPubkey).equals(
        e("e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf")
      ) && o.parity === 1
    ), o = n.xOnlyPointAddTweak(
      e("2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991"),
      e("823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47")
    ), r(
      J.from(o.xOnlyPubkey).equals(
        e("9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c")
      ) && o.parity === 0
    ), r(
      J.from(
        n.sign(
          e("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"),
          e("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
        )
      ).equals(
        e(
          "54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"
        )
      )
    ), r(
      n.verify(
        e("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"),
        e("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
        e(
          "54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"
        )
      )
    ), n.signSchnorr && r(
      J.from(
        n.signSchnorr(
          e("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"),
          e("c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9"),
          e("c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906")
        )
      ).equals(
        e(
          "5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7"
        )
      )
    ), n.verifySchnorr && r(
      n.verifySchnorr(
        e("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"),
        e("dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8"),
        e(
          "5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7"
        )
      )
    );
  }
  rn.testEcc = t;
  function r(n) {
    if (!n) throw new Error("ecc library invalid");
  }
  return rn;
}
var Lu;
function Nm() {
  if (Lu) return ut;
  Lu = 1, Object.defineProperty(ut, "__esModule", { value: !0 }), ut.ECPairFactory = ut.networks = void 0;
  const e = km();
  ut.networks = e;
  const t = Em(), r = Im(), n = Pm(), o = Um(), a = t.typeforce.maybe(
    t.typeforce.compile({
      compressed: t.maybe(t.Boolean),
      network: t.maybe(t.Network)
    })
  ), s = (h) => h.length === 32 ? h : h.slice(1, 33);
  function i(h) {
    (0, o.testEcc)(h);
    function l(y) {
      return h.isPoint(y);
    }
    function c(y, m) {
      if (t.typeforce(t.Buffer256bit, y), !h.isPrivate(y))
        throw new TypeError("Private key not in range [1, n)");
      return t.typeforce(a, m), new k(y, void 0, m);
    }
    function w(y, m) {
      return t.typeforce(h.isPoint, y), t.typeforce(a, m), new k(void 0, y, m);
    }
    function g(y, m) {
      const A = n.decode(y), E = A.version;
      if (t.Array(m)) {
        if (m = m.filter((x) => E === x.wif).pop(), !m) throw new Error("Unknown network version");
      } else if (m = m || e.bitcoin, E !== m.wif) throw new Error("Invalid network version");
      return c(A.privateKey, {
        compressed: A.compressed,
        network: m
      });
    }
    function v(y) {
      t.typeforce(a, y), y === void 0 && (y = {});
      const m = y.rng || r;
      let A;
      do
        A = m(32), t.typeforce(t.Buffer256bit, A);
      while (!h.isPrivate(A));
      return c(A, y);
    }
    class k {
      __D;
      __Q;
      compressed;
      network;
      lowR;
      constructor(m, A, E) {
        this.__D = m, this.__Q = A, this.lowR = !1, E === void 0 && (E = {}), this.compressed = E.compressed === void 0 ? !0 : E.compressed, this.network = E.network || e.bitcoin, A !== void 0 && (this.__Q = J.from(h.pointCompress(A, this.compressed)));
      }
      get privateKey() {
        return this.__D;
      }
      get publicKey() {
        if (!this.__Q) {
          const m = h.pointFromScalar(this.__D, this.compressed);
          this.__Q = J.from(m);
        }
        return this.__Q;
      }
      toWIF() {
        if (!this.__D) throw new Error("Missing private key");
        return n.encode(this.network.wif, this.__D, this.compressed);
      }
      tweak(m) {
        return this.privateKey ? this.tweakFromPrivateKey(m) : this.tweakFromPublicKey(m);
      }
      sign(m, A) {
        if (!this.__D) throw new Error("Missing private key");
        if (A === void 0 && (A = this.lowR), A === !1)
          return J.from(h.sign(m, this.__D));
        {
          let E = h.sign(m, this.__D);
          const x = J.alloc(32, 0);
          let z = 0;
          for (; E[0] > 127; )
            z++, x.writeUIntLE(z, 0, 6), E = h.sign(m, this.__D, x);
          return J.from(E);
        }
      }
      signSchnorr(m) {
        if (!this.privateKey) throw new Error("Missing private key");
        if (!h.signSchnorr)
          throw new Error("signSchnorr not supported by ecc library");
        return J.from(h.signSchnorr(m, this.privateKey));
      }
      verify(m, A) {
        return h.verify(m, this.publicKey, A);
      }
      verifySchnorr(m, A) {
        if (!h.verifySchnorr)
          throw new Error("verifySchnorr not supported by ecc library");
        return h.verifySchnorr(m, this.publicKey.subarray(1, 33), A);
      }
      tweakFromPublicKey(m) {
        const A = s(this.publicKey), E = h.xOnlyPointAddTweak(A, m);
        if (!E || E.xOnlyPubkey === null)
          throw new Error("Cannot tweak public key!");
        const x = J.from([
          E.parity === 0 ? 2 : 3
        ]);
        return w(
          J.concat([x, E.xOnlyPubkey]),
          { network: this.network, compressed: this.compressed }
        );
      }
      tweakFromPrivateKey(m) {
        const E = this.publicKey[0] === 3 || this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1 ? h.privateNegate(this.privateKey) : this.privateKey, x = h.privateAdd(E, m);
        if (!x) throw new Error("Invalid tweaked private key!");
        return c(J.from(x), {
          network: this.network,
          compressed: this.compressed
        });
      }
    }
    return {
      isPoint: l,
      fromPrivateKey: c,
      fromPublicKey: w,
      fromWIF: g,
      makeRandom: v
    };
  }
  return ut.ECPairFactory = i, ut;
}
var qu;
function Cm() {
  return qu || (qu = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.networks = e.ECPairFactory = e.default = void 0;
    var t = Nm();
    Object.defineProperty(e, "default", {
      enumerable: !0,
      get: function() {
        return t.ECPairFactory;
      }
    }), Object.defineProperty(e, "ECPairFactory", {
      enumerable: !0,
      get: function() {
        return t.ECPairFactory;
      }
    }), Object.defineProperty(e, "networks", {
      enumerable: !0,
      get: function() {
        return t.networks;
      }
    });
  })(ao)), ao;
}
var vv = Cm();
function mr(e, t) {
  e = e.replace("#", "");
  const r = parseInt(e, 16), n = Math.round(2.55 * t), o = (r >> 16) + n, a = (r >> 8 & 255) + n, s = (r & 255) + n;
  return (16777216 + (o < 255 ? o < 1 ? 0 : o : 255) * 65536 + (a < 255 ? a < 1 ? 0 : a : 255) * 256 + (s < 255 ? s < 1 ? 0 : s : 255)).toString(16).slice(1);
}
const go = 10, Mu = (e = 0) => (t) => `\x1B[${t + e}m`, Du = (e = 0) => (t) => `\x1B[${38 + e};5;${t}m`, Fu = (e = 0) => (t, r, n) => `\x1B[${38 + e};2;${t};${r};${n}m`, Ce = {
  modifier: {
    reset: [0, 0],
    // 21 isn't widely supported and 22 does the same thing
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    // Bright color
    blackBright: [90, 39],
    gray: [90, 39],
    // Alias of `blackBright`
    grey: [90, 39],
    // Alias of `blackBright`
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    // Bright color
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    // Alias of `bgBlackBright`
    bgGrey: [100, 49],
    // Alias of `bgBlackBright`
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
};
Object.keys(Ce.modifier);
const Lm = Object.keys(Ce.color), qm = Object.keys(Ce.bgColor);
[...Lm, ...qm];
function Mm() {
  const e = /* @__PURE__ */ new Map();
  for (const [t, r] of Object.entries(Ce)) {
    for (const [n, o] of Object.entries(r))
      Ce[n] = {
        open: `\x1B[${o[0]}m`,
        close: `\x1B[${o[1]}m`
      }, r[n] = Ce[n], e.set(o[0], o[1]);
    Object.defineProperty(Ce, t, {
      value: r,
      enumerable: !1
    });
  }
  return Object.defineProperty(Ce, "codes", {
    value: e,
    enumerable: !1
  }), Ce.color.close = "\x1B[39m", Ce.bgColor.close = "\x1B[49m", Ce.color.ansi = Mu(), Ce.color.ansi256 = Du(), Ce.color.ansi16m = Fu(), Ce.bgColor.ansi = Mu(go), Ce.bgColor.ansi256 = Du(go), Ce.bgColor.ansi16m = Fu(go), Object.defineProperties(Ce, {
    rgbToAnsi256: {
      value(t, r, n) {
        return t === r && r === n ? t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t / 255 * 5) + 6 * Math.round(r / 255 * 5) + Math.round(n / 255 * 5);
      },
      enumerable: !1
    },
    hexToRgb: {
      value(t) {
        const r = /[a-f\d]{6}|[a-f\d]{3}/i.exec(t.toString(16));
        if (!r)
          return [0, 0, 0];
        let [n] = r;
        n.length === 3 && (n = [...n].map((a) => a + a).join(""));
        const o = Number.parseInt(n, 16);
        return [
          /* eslint-disable no-bitwise */
          o >> 16 & 255,
          o >> 8 & 255,
          o & 255
          /* eslint-enable no-bitwise */
        ];
      },
      enumerable: !1
    },
    hexToAnsi256: {
      value: (t) => Ce.rgbToAnsi256(...Ce.hexToRgb(t)),
      enumerable: !1
    },
    ansi256ToAnsi: {
      value(t) {
        if (t < 8)
          return 30 + t;
        if (t < 16)
          return 90 + (t - 8);
        let r, n, o;
        if (t >= 232)
          r = ((t - 232) * 10 + 8) / 255, n = r, o = r;
        else {
          t -= 16;
          const i = t % 36;
          r = Math.floor(t / 36) / 5, n = Math.floor(i / 6) / 5, o = i % 6 / 5;
        }
        const a = Math.max(r, n, o) * 2;
        if (a === 0)
          return 30;
        let s = 30 + (Math.round(o) << 2 | Math.round(n) << 1 | Math.round(r));
        return a === 2 && (s += 60), s;
      },
      enumerable: !1
    },
    rgbToAnsi: {
      value: (t, r, n) => Ce.ansi256ToAnsi(Ce.rgbToAnsi256(t, r, n)),
      enumerable: !1
    },
    hexToAnsi: {
      value: (t) => Ce.ansi256ToAnsi(Ce.hexToAnsi256(t)),
      enumerable: !1
    }
  }), Ce;
}
const vr = Mm(), Ku = (() => {
  if (!("navigator" in globalThis))
    return 0;
  if (globalThis.navigator.userAgentData) {
    const e = navigator.userAgentData.brands.find(({ brand: t }) => t === "Chromium");
    if (e && e.version > 93)
      return 3;
  }
  return /\b(Chrome|Chromium)\//.test(globalThis.navigator.userAgent) ? 1 : 0;
})(), Hu = Ku !== 0 && {
  level: Ku
}, Dm = {
  stdout: Hu,
  stderr: Hu
};
function Fm(e, t, r) {
  let n = e.indexOf(t);
  if (n === -1)
    return e;
  const o = t.length;
  let a = 0, s = "";
  do
    s += e.slice(a, n) + t + r, a = n + o, n = e.indexOf(t, a);
  while (n !== -1);
  return s += e.slice(a), s;
}
function Km(e, t, r, n) {
  let o = 0, a = "";
  do {
    const s = e[n - 1] === "\r";
    a += e.slice(o, s ? n - 1 : n) + t + (s ? `\r
` : `
`) + r, o = n + 1, n = e.indexOf(`
`, o);
  } while (n !== -1);
  return a += e.slice(o), a;
}
const { stdout: $u, stderr: Gu } = Dm, $i = /* @__PURE__ */ Symbol("GENERATOR"), qt = /* @__PURE__ */ Symbol("STYLER"), _n = /* @__PURE__ */ Symbol("IS_EMPTY"), Wu = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
], Mt = /* @__PURE__ */ Object.create(null), Hm = (e, t = {}) => {
  if (t.level && !(Number.isInteger(t.level) && t.level >= 0 && t.level <= 3))
    throw new Error("The `level` option should be an integer from 0 to 3");
  const r = $u ? $u.level : 0;
  e.level = t.level === void 0 ? r : t.level;
};
class $m {
  constructor(t) {
    return Cd(t);
  }
}
const Cd = (e) => {
  const t = (...r) => r.join(" ");
  return Hm(t, e), Object.setPrototypeOf(t, zn.prototype), t;
};
function zn(e) {
  return Cd(e);
}
Object.setPrototypeOf(zn.prototype, Function.prototype);
for (const [e, t] of Object.entries(vr))
  Mt[e] = {
    get() {
      const r = ka(this, Wi(t.open, t.close, this[qt]), this[_n]);
      return Object.defineProperty(this, e, { value: r }), r;
    }
  };
Mt.visible = {
  get() {
    const e = ka(this, this[qt], !0);
    return Object.defineProperty(this, "visible", { value: e }), e;
  }
};
const Gi = (e, t, r, ...n) => e === "rgb" ? t === "ansi16m" ? vr[r].ansi16m(...n) : t === "ansi256" ? vr[r].ansi256(vr.rgbToAnsi256(...n)) : vr[r].ansi(vr.rgbToAnsi(...n)) : e === "hex" ? Gi("rgb", t, r, ...vr.hexToRgb(...n)) : vr[r][e](...n), Gm = ["rgb", "hex", "ansi256"];
for (const e of Gm) {
  Mt[e] = {
    get() {
      const { level: r } = this;
      return function(...n) {
        const o = Wi(Gi(e, Wu[r], "color", ...n), vr.color.close, this[qt]);
        return ka(this, o, this[_n]);
      };
    }
  };
  const t = "bg" + e[0].toUpperCase() + e.slice(1);
  Mt[t] = {
    get() {
      const { level: r } = this;
      return function(...n) {
        const o = Wi(Gi(e, Wu[r], "bgColor", ...n), vr.bgColor.close, this[qt]);
        return ka(this, o, this[_n]);
      };
    }
  };
}
const Wm = Object.defineProperties(() => {
}, {
  ...Mt,
  level: {
    enumerable: !0,
    get() {
      return this[$i].level;
    },
    set(e) {
      this[$i].level = e;
    }
  }
}), Wi = (e, t, r) => {
  let n, o;
  return r === void 0 ? (n = e, o = t) : (n = r.openAll + e, o = t + r.closeAll), {
    open: e,
    close: t,
    openAll: n,
    closeAll: o,
    parent: r
  };
}, ka = (e, t, r) => {
  const n = (...o) => Vm(n, o.length === 1 ? "" + o[0] : o.join(" "));
  return Object.setPrototypeOf(n, Wm), n[$i] = e, n[qt] = t, n[_n] = r, n;
}, Vm = (e, t) => {
  if (e.level <= 0 || !t)
    return e[_n] ? "" : t;
  let r = e[qt];
  if (r === void 0)
    return t;
  const { openAll: n, closeAll: o } = r;
  if (t.includes("\x1B"))
    for (; r !== void 0; )
      t = Fm(t, r.close, r.open), r = r.parent;
  const a = t.indexOf(`
`);
  return a !== -1 && (t = Km(t, o, n, a)), n + t + o;
};
Object.defineProperties(zn.prototype, Mt);
zn();
zn({ level: Gu ? Gu.level : 0 });
var _e = function(e, t, r, n) {
  if (r === "a" && !n) throw new TypeError("Private accessor was defined without a getter");
  if (typeof t == "function" ? e !== t || !n : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return r === "m" ? n : r === "a" ? n.call(e) : n ? n.value : t.get(e);
}, Pt, Vi, ta, na, Zi, aa, Yi, oa, Xi, ia, on, sn, sa, et, Ji, ca, Qi;
class Zm {
  constructor(t = new $m()) {
    this.chalk = t, this.moduleName = "", this.logColor = "#00bfff", this.enableLogs = !0, this.hideLogs = !1, Pt.set(this, "#ff00ff"), Vi.set(this, mr(_e(this, Pt, "f"), 75)), ta.set(this, "#9400d3"), na.set(this, mr(_e(this, ta, "f"), 15)), Zi.set(this, mr(_e(this, na, "f"), 15)), aa.set(this, "#7cfc00"), Yi.set(this, mr(_e(this, aa, "f"), 15)), oa.set(this, "#ffdead"), Xi.set(this, mr(_e(this, oa, "f"), 15)), ia.set(this, "#ff8c00"), on.set(this, mr(_e(this, ia, "f"), 15)), sn.set(this, "#ff4500"), sa.set(this, mr(_e(this, sn, "f"), 15)), et.set(this, "#ffffff"), Ji.set(this, mr(_e(this, et, "f"), 15)), ca.set(this, "#8b0000"), Qi.set(this, mr(_e(this, ca, "f"), 15)), this.prefix = "", this.moduleName = this.constructor.name;
  }
  setLogPrefix(t) {
    this.prefix = t;
  }
  getStartPrefix() {
    return this.prefix;
  }
  disable() {
    this.enableLogs = !1;
  }
  enable() {
    this.enableLogs = !0;
  }
  fancyLog(t, r, n, o, a) {
    this.enableLogs && console.log(this.chalk.hex(_e(this, Pt, "f"))(`${this.getStartPrefix()}[${this.moduleName} INFO]: `) + this.chalk.hex(_e(this, et, "f"))(t) + " " + this.chalk.hex(_e(this, on, "f"))(r) + " " + this.chalk.hex(_e(this, et, "f"))(n) + " " + this.chalk.hex(_e(this, Zi, "f"))(o) + " " + this.chalk.hex(_e(this, et, "f"))(a));
  }
  log(...t) {
    if (this.enableLogs && !this.hideLogs) {
      const r = mr(this.logColor, 15);
      console.log(this.chalk.hex(this.logColor)(`${this.getStartPrefix()}[${this.moduleName} LOG]: `) + this.chalk.hex(r)(...t));
    }
  }
  lightOrangeLog(...t) {
    this.enableLogs && (this.hideLogs || console.log(this.chalk.hex(_e(this, on, "f"))(`${this.getStartPrefix()}[${this.moduleName} LOG]: `) + this.chalk.hex(_e(this, et, "f"))(...t)));
  }
  error(...t) {
    this.enableLogs && console.log(this.chalk.hex(_e(this, sn, "f"))(`${this.getStartPrefix()}[${this.moduleName} ERROR]: `) + this.chalk.hex(_e(this, sa, "f"))(...t));
  }
  warn(...t) {
    this.enableLogs && console.log(this.chalk.hex(_e(this, ia, "f"))(`${this.getStartPrefix()}[${this.moduleName} WARN]: `) + this.chalk.hex(_e(this, on, "f"))(...t));
  }
  debug(...t) {
    this.enableLogs && (this.hideLogs || console.log(this.chalk.hex(_e(this, oa, "f"))(`${this.getStartPrefix()}[${this.moduleName} DEBUG]: `) + this.chalk.hex(_e(this, Xi, "f"))(...t)));
  }
  success(...t) {
    this.enableLogs && (this.hideLogs || console.log(this.chalk.hex(_e(this, aa, "f"))(`${this.getStartPrefix()}[${this.moduleName} SUCCESS]: `) + this.chalk.hex(_e(this, Yi, "f"))(...t)));
  }
  fail(...t) {
    this.enableLogs && (this.hideLogs || console.log(this.chalk.hex(_e(this, sn, "f"))(`${this.getStartPrefix()}[${this.moduleName} FAIL]: `) + this.chalk.hex(_e(this, sa, "f"))(...t)));
  }
  debugBright(...t) {
    this.enableLogs && (this.hideLogs || console.log(this.chalk.hex(_e(this, ta, "f"))(`${this.getStartPrefix()}[${this.moduleName} DEBUG]: `) + this.chalk.hex(_e(this, na, "f"))(...t)));
  }
  important(...t) {
    this.enableLogs && console.log(this.chalk.hex(_e(this, Pt, "f"))(`${this.getStartPrefix()}[${this.moduleName} IMPORTANT]: `) + this.chalk.hex(_e(this, Vi, "f"))(...t));
  }
  panic(...t) {
    this.enableLogs && console.log(this.chalk.hex(_e(this, ca, "f"))(`${this.getStartPrefix()}[${this.moduleName} HELP PANIC]: `) + this.chalk.hex(_e(this, Qi, "f"))(...t));
  }
  info(...t) {
    this.enableLogs && console.log(this.chalk.hex(_e(this, Pt, "f"))(`${this.getStartPrefix()}[${this.moduleName} INFO]: `) + this.chalk.hex(_e(this, et, "f"))(...t));
  }
  securityNotice(...t) {
    this.enableLogs && console.log(this.chalk.hex("#22d8e6")(`${this.getStartPrefix()}[${this.moduleName} SECURITY NOTICE]: `) + this.chalk.hex("#22e3e6")(...t));
  }
  traceLog(...t) {
    this.enableLogs && console.log(this.chalk.hex("#ffffff")(`${this.getStartPrefix()}[${this.moduleName} TRACE LOG]: `) + this.chalk.hex(_e(this, Ji, "f"))(...t));
  }
}
Pt = /* @__PURE__ */ new WeakMap(), Vi = /* @__PURE__ */ new WeakMap(), ta = /* @__PURE__ */ new WeakMap(), na = /* @__PURE__ */ new WeakMap(), Zi = /* @__PURE__ */ new WeakMap(), aa = /* @__PURE__ */ new WeakMap(), Yi = /* @__PURE__ */ new WeakMap(), oa = /* @__PURE__ */ new WeakMap(), Xi = /* @__PURE__ */ new WeakMap(), ia = /* @__PURE__ */ new WeakMap(), on = /* @__PURE__ */ new WeakMap(), sn = /* @__PURE__ */ new WeakMap(), sa = /* @__PURE__ */ new WeakMap(), et = /* @__PURE__ */ new WeakMap(), Ji = /* @__PURE__ */ new WeakMap(), ca = /* @__PURE__ */ new WeakMap(), Qi = /* @__PURE__ */ new WeakMap();
class wv extends Zm {
  constructor() {
    super();
  }
}
var Vu;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.ERROR = 1] = "ERROR", e[e.WARN = 2] = "WARN", e[e.INFO = 3] = "INFO", e[e.DEBUG = 4] = "DEBUG", e[e.TRACE = 5] = "TRACE", e[e.ALL = 6] = "ALL";
})(Vu || (Vu = {}));
var ir = {}, We = {};
const Ym = /* @__PURE__ */ JSON.parse('["abdikace","abeceda","adresa","agrese","akce","aktovka","alej","alkohol","amputace","ananas","andulka","anekdota","anketa","antika","anulovat","archa","arogance","asfalt","asistent","aspirace","astma","astronom","atlas","atletika","atol","autobus","azyl","babka","bachor","bacil","baculka","badatel","bageta","bagr","bahno","bakterie","balada","baletka","balkon","balonek","balvan","balza","bambus","bankomat","barbar","baret","barman","baroko","barva","baterka","batoh","bavlna","bazalka","bazilika","bazuka","bedna","beran","beseda","bestie","beton","bezinka","bezmoc","beztak","bicykl","bidlo","biftek","bikiny","bilance","biograf","biolog","bitva","bizon","blahobyt","blatouch","blecha","bledule","blesk","blikat","blizna","blokovat","bloudit","blud","bobek","bobr","bodlina","bodnout","bohatost","bojkot","bojovat","bokorys","bolest","borec","borovice","bota","boubel","bouchat","bouda","boule","bourat","boxer","bradavka","brambora","branka","bratr","brepta","briketa","brko","brloh","bronz","broskev","brunetka","brusinka","brzda","brzy","bublina","bubnovat","buchta","buditel","budka","budova","bufet","bujarost","bukvice","buldok","bulva","bunda","bunkr","burza","butik","buvol","buzola","bydlet","bylina","bytovka","bzukot","capart","carevna","cedr","cedule","cejch","cejn","cela","celer","celkem","celnice","cenina","cennost","cenovka","centrum","cenzor","cestopis","cetka","chalupa","chapadlo","charita","chata","chechtat","chemie","chichot","chirurg","chlad","chleba","chlubit","chmel","chmura","chobot","chochol","chodba","cholera","chomout","chopit","choroba","chov","chrapot","chrlit","chrt","chrup","chtivost","chudina","chutnat","chvat","chvilka","chvost","chyba","chystat","chytit","cibule","cigareta","cihelna","cihla","cinkot","cirkus","cisterna","citace","citrus","cizinec","cizost","clona","cokoliv","couvat","ctitel","ctnost","cudnost","cuketa","cukr","cupot","cvaknout","cval","cvik","cvrkot","cyklista","daleko","dareba","datel","datum","dcera","debata","dechovka","decibel","deficit","deflace","dekl","dekret","demokrat","deprese","derby","deska","detektiv","dikobraz","diktovat","dioda","diplom","disk","displej","divadlo","divoch","dlaha","dlouho","dluhopis","dnes","dobro","dobytek","docent","dochutit","dodnes","dohled","dohoda","dohra","dojem","dojnice","doklad","dokola","doktor","dokument","dolar","doleva","dolina","doma","dominant","domluvit","domov","donutit","dopad","dopis","doplnit","doposud","doprovod","dopustit","dorazit","dorost","dort","dosah","doslov","dostatek","dosud","dosyta","dotaz","dotek","dotknout","doufat","doutnat","dovozce","dozadu","doznat","dozorce","drahota","drak","dramatik","dravec","draze","drdol","drobnost","drogerie","drozd","drsnost","drtit","drzost","duben","duchovno","dudek","duha","duhovka","dusit","dusno","dutost","dvojice","dvorec","dynamit","ekolog","ekonomie","elektron","elipsa","email","emise","emoce","empatie","epizoda","epocha","epopej","epos","esej","esence","eskorta","eskymo","etiketa","euforie","evoluce","exekuce","exkurze","expedice","exploze","export","extrakt","facka","fajfka","fakulta","fanatik","fantazie","farmacie","favorit","fazole","federace","fejeton","fenka","fialka","figurant","filozof","filtr","finance","finta","fixace","fjord","flanel","flirt","flotila","fond","fosfor","fotbal","fotka","foton","frakce","freska","fronta","fukar","funkce","fyzika","galeje","garant","genetika","geolog","gilotina","glazura","glejt","golem","golfista","gotika","graf","gramofon","granule","grep","gril","grog","groteska","guma","hadice","hadr","hala","halenka","hanba","hanopis","harfa","harpuna","havran","hebkost","hejkal","hejno","hejtman","hektar","helma","hematom","herec","herna","heslo","hezky","historik","hladovka","hlasivky","hlava","hledat","hlen","hlodavec","hloh","hloupost","hltat","hlubina","hluchota","hmat","hmota","hmyz","hnis","hnojivo","hnout","hoblina","hoboj","hoch","hodiny","hodlat","hodnota","hodovat","hojnost","hokej","holinka","holka","holub","homole","honitba","honorace","horal","horda","horizont","horko","horlivec","hormon","hornina","horoskop","horstvo","hospoda","hostina","hotovost","houba","houf","houpat","houska","hovor","hradba","hranice","hravost","hrazda","hrbolek","hrdina","hrdlo","hrdost","hrnek","hrobka","hromada","hrot","hrouda","hrozen","hrstka","hrubost","hryzat","hubenost","hubnout","hudba","hukot","humr","husita","hustota","hvozd","hybnost","hydrant","hygiena","hymna","hysterik","idylka","ihned","ikona","iluze","imunita","infekce","inflace","inkaso","inovace","inspekce","internet","invalida","investor","inzerce","ironie","jablko","jachta","jahoda","jakmile","jakost","jalovec","jantar","jarmark","jaro","jasan","jasno","jatka","javor","jazyk","jedinec","jedle","jednatel","jehlan","jekot","jelen","jelito","jemnost","jenom","jepice","jeseter","jevit","jezdec","jezero","jinak","jindy","jinoch","jiskra","jistota","jitrnice","jizva","jmenovat","jogurt","jurta","kabaret","kabel","kabinet","kachna","kadet","kadidlo","kahan","kajak","kajuta","kakao","kaktus","kalamita","kalhoty","kalibr","kalnost","kamera","kamkoliv","kamna","kanibal","kanoe","kantor","kapalina","kapela","kapitola","kapka","kaple","kapota","kapr","kapusta","kapybara","karamel","karotka","karton","kasa","katalog","katedra","kauce","kauza","kavalec","kazajka","kazeta","kazivost","kdekoliv","kdesi","kedluben","kemp","keramika","kino","klacek","kladivo","klam","klapot","klasika","klaun","klec","klenba","klepat","klesnout","klid","klima","klisna","klobouk","klokan","klopa","kloub","klubovna","klusat","kluzkost","kmen","kmitat","kmotr","kniha","knot","koalice","koberec","kobka","kobliha","kobyla","kocour","kohout","kojenec","kokos","koktejl","kolaps","koleda","kolize","kolo","komando","kometa","komik","komnata","komora","kompas","komunita","konat","koncept","kondice","konec","konfese","kongres","konina","konkurs","kontakt","konzerva","kopanec","kopie","kopnout","koprovka","korbel","korektor","kormidlo","koroptev","korpus","koruna","koryto","korzet","kosatec","kostka","kotel","kotleta","kotoul","koukat","koupelna","kousek","kouzlo","kovboj","koza","kozoroh","krabice","krach","krajina","kralovat","krasopis","kravata","kredit","krejcar","kresba","kreveta","kriket","kritik","krize","krkavec","krmelec","krmivo","krocan","krok","kronika","kropit","kroupa","krovka","krtek","kruhadlo","krupice","krutost","krvinka","krychle","krypta","krystal","kryt","kudlanka","kufr","kujnost","kukla","kulajda","kulich","kulka","kulomet","kultura","kuna","kupodivu","kurt","kurzor","kutil","kvalita","kvasinka","kvestor","kynolog","kyselina","kytara","kytice","kytka","kytovec","kyvadlo","labrador","lachtan","ladnost","laik","lakomec","lamela","lampa","lanovka","lasice","laso","lastura","latinka","lavina","lebka","leckdy","leden","lednice","ledovka","ledvina","legenda","legie","legrace","lehce","lehkost","lehnout","lektvar","lenochod","lentilka","lepenka","lepidlo","letadlo","letec","letmo","letokruh","levhart","levitace","levobok","libra","lichotka","lidojed","lidskost","lihovina","lijavec","lilek","limetka","linie","linka","linoleum","listopad","litina","litovat","lobista","lodivod","logika","logoped","lokalita","loket","lomcovat","lopata","lopuch","lord","losos","lotr","loudal","louh","louka","louskat","lovec","lstivost","lucerna","lucifer","lump","lusk","lustrace","lvice","lyra","lyrika","lysina","madam","madlo","magistr","mahagon","majetek","majitel","majorita","makak","makovice","makrela","malba","malina","malovat","malvice","maminka","mandle","manko","marnost","masakr","maskot","masopust","matice","matrika","maturita","mazanec","mazivo","mazlit","mazurka","mdloba","mechanik","meditace","medovina","melasa","meloun","mentolka","metla","metoda","metr","mezera","migrace","mihnout","mihule","mikina","mikrofon","milenec","milimetr","milost","mimika","mincovna","minibar","minomet","minulost","miska","mistr","mixovat","mladost","mlha","mlhovina","mlok","mlsat","mluvit","mnich","mnohem","mobil","mocnost","modelka","modlitba","mohyla","mokro","molekula","momentka","monarcha","monokl","monstrum","montovat","monzun","mosaz","moskyt","most","motivace","motorka","motyka","moucha","moudrost","mozaika","mozek","mozol","mramor","mravenec","mrkev","mrtvola","mrzet","mrzutost","mstitel","mudrc","muflon","mulat","mumie","munice","muset","mutace","muzeum","muzikant","myslivec","mzda","nabourat","nachytat","nadace","nadbytek","nadhoz","nadobro","nadpis","nahlas","nahnat","nahodile","nahradit","naivita","najednou","najisto","najmout","naklonit","nakonec","nakrmit","nalevo","namazat","namluvit","nanometr","naoko","naopak","naostro","napadat","napevno","naplnit","napnout","naposled","naprosto","narodit","naruby","narychlo","nasadit","nasekat","naslepo","nastat","natolik","navenek","navrch","navzdory","nazvat","nebe","nechat","necky","nedaleko","nedbat","neduh","negace","nehet","nehoda","nejen","nejprve","neklid","nelibost","nemilost","nemoc","neochota","neonka","nepokoj","nerost","nerv","nesmysl","nesoulad","netvor","neuron","nevina","nezvykle","nicota","nijak","nikam","nikdy","nikl","nikterak","nitro","nocleh","nohavice","nominace","nora","norek","nositel","nosnost","nouze","noviny","novota","nozdra","nuda","nudle","nuget","nutit","nutnost","nutrie","nymfa","obal","obarvit","obava","obdiv","obec","obehnat","obejmout","obezita","obhajoba","obilnice","objasnit","objekt","obklopit","oblast","oblek","obliba","obloha","obluda","obnos","obohatit","obojek","obout","obrazec","obrna","obruba","obrys","obsah","obsluha","obstarat","obuv","obvaz","obvinit","obvod","obvykle","obyvatel","obzor","ocas","ocel","ocenit","ochladit","ochota","ochrana","ocitnout","odboj","odbyt","odchod","odcizit","odebrat","odeslat","odevzdat","odezva","odhadce","odhodit","odjet","odjinud","odkaz","odkoupit","odliv","odluka","odmlka","odolnost","odpad","odpis","odplout","odpor","odpustit","odpykat","odrazka","odsoudit","odstup","odsun","odtok","odtud","odvaha","odveta","odvolat","odvracet","odznak","ofina","ofsajd","ohlas","ohnisko","ohrada","ohrozit","ohryzek","okap","okenice","oklika","okno","okouzlit","okovy","okrasa","okres","okrsek","okruh","okupant","okurka","okusit","olejnina","olizovat","omak","omeleta","omezit","omladina","omlouvat","omluva","omyl","onehdy","opakovat","opasek","operace","opice","opilost","opisovat","opora","opozice","opravdu","oproti","orbital","orchestr","orgie","orlice","orloj","ortel","osada","oschnout","osika","osivo","oslava","oslepit","oslnit","oslovit","osnova","osoba","osolit","ospalec","osten","ostraha","ostuda","ostych","osvojit","oteplit","otisk","otop","otrhat","otrlost","otrok","otruby","otvor","ovanout","ovar","oves","ovlivnit","ovoce","oxid","ozdoba","pachatel","pacient","padouch","pahorek","pakt","palanda","palec","palivo","paluba","pamflet","pamlsek","panenka","panika","panna","panovat","panstvo","pantofle","paprika","parketa","parodie","parta","paruka","paryba","paseka","pasivita","pastelka","patent","patrona","pavouk","pazneht","pazourek","pecka","pedagog","pejsek","peklo","peloton","penalta","pendrek","penze","periskop","pero","pestrost","petarda","petice","petrolej","pevnina","pexeso","pianista","piha","pijavice","pikle","piknik","pilina","pilnost","pilulka","pinzeta","pipeta","pisatel","pistole","pitevna","pivnice","pivovar","placenta","plakat","plamen","planeta","plastika","platit","plavidlo","plaz","plech","plemeno","plenta","ples","pletivo","plevel","plivat","plnit","plno","plocha","plodina","plomba","plout","pluk","plyn","pobavit","pobyt","pochod","pocit","poctivec","podat","podcenit","podepsat","podhled","podivit","podklad","podmanit","podnik","podoba","podpora","podraz","podstata","podvod","podzim","poezie","pohanka","pohnutka","pohovor","pohroma","pohyb","pointa","pojistka","pojmout","pokazit","pokles","pokoj","pokrok","pokuta","pokyn","poledne","polibek","polknout","poloha","polynom","pomalu","pominout","pomlka","pomoc","pomsta","pomyslet","ponechat","ponorka","ponurost","popadat","popel","popisek","poplach","poprosit","popsat","popud","poradce","porce","porod","porucha","poryv","posadit","posed","posila","poskok","poslanec","posoudit","pospolu","postava","posudek","posyp","potah","potkan","potlesk","potomek","potrava","potupa","potvora","poukaz","pouto","pouzdro","povaha","povidla","povlak","povoz","povrch","povstat","povyk","povzdech","pozdrav","pozemek","poznatek","pozor","pozvat","pracovat","prahory","praktika","prales","praotec","praporek","prase","pravda","princip","prkno","probudit","procento","prodej","profese","prohra","projekt","prolomit","promile","pronikat","propad","prorok","prosba","proton","proutek","provaz","prskavka","prsten","prudkost","prut","prvek","prvohory","psanec","psovod","pstruh","ptactvo","puberta","puch","pudl","pukavec","puklina","pukrle","pult","pumpa","punc","pupen","pusa","pusinka","pustina","putovat","putyka","pyramida","pysk","pytel","racek","rachot","radiace","radnice","radon","raft","ragby","raketa","rakovina","rameno","rampouch","rande","rarach","rarita","rasovna","rastr","ratolest","razance","razidlo","reagovat","reakce","recept","redaktor","referent","reflex","rejnok","reklama","rekord","rekrut","rektor","reputace","revize","revma","revolver","rezerva","riskovat","riziko","robotika","rodokmen","rohovka","rokle","rokoko","romaneto","ropovod","ropucha","rorejs","rosol","rostlina","rotmistr","rotoped","rotunda","roubenka","roucho","roup","roura","rovina","rovnice","rozbor","rozchod","rozdat","rozeznat","rozhodce","rozinka","rozjezd","rozkaz","rozloha","rozmar","rozpad","rozruch","rozsah","roztok","rozum","rozvod","rubrika","ruchadlo","rukavice","rukopis","ryba","rybolov","rychlost","rydlo","rypadlo","rytina","ryzost","sadista","sahat","sako","samec","samizdat","samota","sanitka","sardinka","sasanka","satelit","sazba","sazenice","sbor","schovat","sebranka","secese","sedadlo","sediment","sedlo","sehnat","sejmout","sekera","sekta","sekunda","sekvoje","semeno","seno","servis","sesadit","seshora","seskok","seslat","sestra","sesuv","sesypat","setba","setina","setkat","setnout","setrvat","sever","seznam","shoda","shrnout","sifon","silnice","sirka","sirotek","sirup","situace","skafandr","skalisko","skanzen","skaut","skeptik","skica","skladba","sklenice","sklo","skluz","skoba","skokan","skoro","skripta","skrz","skupina","skvost","skvrna","slabika","sladidlo","slanina","slast","slavnost","sledovat","slepec","sleva","slezina","slib","slina","sliznice","slon","sloupek","slovo","sluch","sluha","slunce","slupka","slza","smaragd","smetana","smilstvo","smlouva","smog","smrad","smrk","smrtka","smutek","smysl","snad","snaha","snob","sobota","socha","sodovka","sokol","sopka","sotva","souboj","soucit","soudce","souhlas","soulad","soumrak","souprava","soused","soutok","souviset","spalovna","spasitel","spis","splav","spodek","spojenec","spolu","sponzor","spornost","spousta","sprcha","spustit","sranda","sraz","srdce","srna","srnec","srovnat","srpen","srst","srub","stanice","starosta","statika","stavba","stehno","stezka","stodola","stolek","stopa","storno","stoupat","strach","stres","strhnout","strom","struna","studna","stupnice","stvol","styk","subjekt","subtropy","suchar","sudost","sukno","sundat","sunout","surikata","surovina","svah","svalstvo","svetr","svatba","svazek","svisle","svitek","svoboda","svodidlo","svorka","svrab","sykavka","sykot","synek","synovec","sypat","sypkost","syrovost","sysel","sytost","tabletka","tabule","tahoun","tajemno","tajfun","tajga","tajit","tajnost","taktika","tamhle","tampon","tancovat","tanec","tanker","tapeta","tavenina","tazatel","technika","tehdy","tekutina","telefon","temnota","tendence","tenista","tenor","teplota","tepna","teprve","terapie","termoska","textil","ticho","tiskopis","titulek","tkadlec","tkanina","tlapka","tleskat","tlukot","tlupa","tmel","toaleta","topinka","topol","torzo","touha","toulec","tradice","traktor","tramp","trasa","traverza","trefit","trest","trezor","trhavina","trhlina","trochu","trojice","troska","trouba","trpce","trpitel","trpkost","trubec","truchlit","truhlice","trus","trvat","tudy","tuhnout","tuhost","tundra","turista","turnaj","tuzemsko","tvaroh","tvorba","tvrdost","tvrz","tygr","tykev","ubohost","uboze","ubrat","ubrousek","ubrus","ubytovna","ucho","uctivost","udivit","uhradit","ujednat","ujistit","ujmout","ukazatel","uklidnit","uklonit","ukotvit","ukrojit","ulice","ulita","ulovit","umyvadlo","unavit","uniforma","uniknout","upadnout","uplatnit","uplynout","upoutat","upravit","uran","urazit","usednout","usilovat","usmrtit","usnadnit","usnout","usoudit","ustlat","ustrnout","utahovat","utkat","utlumit","utonout","utopenec","utrousit","uvalit","uvolnit","uvozovka","uzdravit","uzel","uzenina","uzlina","uznat","vagon","valcha","valoun","vana","vandal","vanilka","varan","varhany","varovat","vcelku","vchod","vdova","vedro","vegetace","vejce","velbloud","veletrh","velitel","velmoc","velryba","venkov","veranda","verze","veselka","veskrze","vesnice","vespodu","vesta","veterina","veverka","vibrace","vichr","videohra","vidina","vidle","vila","vinice","viset","vitalita","vize","vizitka","vjezd","vklad","vkus","vlajka","vlak","vlasec","vlevo","vlhkost","vliv","vlnovka","vloupat","vnucovat","vnuk","voda","vodivost","vodoznak","vodstvo","vojensky","vojna","vojsko","volant","volba","volit","volno","voskovka","vozidlo","vozovna","vpravo","vrabec","vracet","vrah","vrata","vrba","vrcholek","vrhat","vrstva","vrtule","vsadit","vstoupit","vstup","vtip","vybavit","vybrat","vychovat","vydat","vydra","vyfotit","vyhledat","vyhnout","vyhodit","vyhradit","vyhubit","vyjasnit","vyjet","vyjmout","vyklopit","vykonat","vylekat","vymazat","vymezit","vymizet","vymyslet","vynechat","vynikat","vynutit","vypadat","vyplatit","vypravit","vypustit","vyrazit","vyrovnat","vyrvat","vyslovit","vysoko","vystavit","vysunout","vysypat","vytasit","vytesat","vytratit","vyvinout","vyvolat","vyvrhel","vyzdobit","vyznat","vzadu","vzbudit","vzchopit","vzdor","vzduch","vzdychat","vzestup","vzhledem","vzkaz","vzlykat","vznik","vzorek","vzpoura","vztah","vztek","xylofon","zabrat","zabydlet","zachovat","zadarmo","zadusit","zafoukat","zahltit","zahodit","zahrada","zahynout","zajatec","zajet","zajistit","zaklepat","zakoupit","zalepit","zamezit","zamotat","zamyslet","zanechat","zanikat","zaplatit","zapojit","zapsat","zarazit","zastavit","zasunout","zatajit","zatemnit","zatknout","zaujmout","zavalit","zavelet","zavinit","zavolat","zavrtat","zazvonit","zbavit","zbrusu","zbudovat","zbytek","zdaleka","zdarma","zdatnost","zdivo","zdobit","zdroj","zdvih","zdymadlo","zelenina","zeman","zemina","zeptat","zezadu","zezdola","zhatit","zhltnout","zhluboka","zhotovit","zhruba","zima","zimnice","zjemnit","zklamat","zkoumat","zkratka","zkumavka","zlato","zlehka","zloba","zlom","zlost","zlozvyk","zmapovat","zmar","zmatek","zmije","zmizet","zmocnit","zmodrat","zmrzlina","zmutovat","znak","znalost","znamenat","znovu","zobrazit","zotavit","zoubek","zoufale","zplodit","zpomalit","zprava","zprostit","zprudka","zprvu","zrada","zranit","zrcadlo","zrnitost","zrno","zrovna","zrychlit","zrzavost","zticha","ztratit","zubovina","zubr","zvednout","zvenku","zvesela","zvon","zvrat","zvukovod","zvyk"]'), Xm = /* @__PURE__ */ JSON.parse('["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""]'), Jm = /* @__PURE__ */ JSON.parse('["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""]'), Qm = /* @__PURE__ */ JSON.parse('["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""]'), ey = /* @__PURE__ */ JSON.parse('["abaisser","abandon","abdiquer","abeille","abolir","aborder","aboutir","aboyer","abrasif","abreuver","abriter","abroger","abrupt","absence","absolu","absurde","abusif","abyssal","academie","acajou","acarien","accabler","accepter","acclamer","accolade","accroche","accuser","acerbe","achat","acheter","aciduler","acier","acompte","acquerir","acronyme","acteur","actif","actuel","adepte","adequat","adhesif","adjectif","adjuger","admettre","admirer","adopter","adorer","adoucir","adresse","adroit","adulte","adverbe","aerer","aeronef","affaire","affecter","affiche","affreux","affubler","agacer","agencer","agile","agiter","agrafer","agreable","agrume","aider","aiguille","ailier","aimable","aisance","ajouter","ajuster","alarmer","alchimie","alerte","algebre","algue","aliener","aliment","alleger","alliage","allouer","allumer","alourdir","alpaga","altesse","alveole","amateur","ambigu","ambre","amenager","amertume","amidon","amiral","amorcer","amour","amovible","amphibie","ampleur","amusant","analyse","anaphore","anarchie","anatomie","ancien","aneantir","angle","angoisse","anguleux","animal","annexer","annonce","annuel","anodin","anomalie","anonyme","anormal","antenne","antidote","anxieux","apaiser","aperitif","aplanir","apologie","appareil","appeler","apporter","appuyer","aquarium","aqueduc","arbitre","arbuste","ardeur","ardoise","argent","arlequin","armature","armement","armoire","armure","arpenter","arracher","arriver","arroser","arsenic","arteriel","article","aspect","asphalte","aspirer","assaut","asservir","assiette","associer","assurer","asticot","astre","astuce","atelier","atome","atrium","atroce","attaque","attentif","attirer","attraper","aubaine","auberge","audace","audible","augurer","aurore","automne","autruche","avaler","avancer","avarice","avenir","averse","aveugle","aviateur","avide","avion","aviser","avoine","avouer","avril","axial","axiome","badge","bafouer","bagage","baguette","baignade","balancer","balcon","baleine","balisage","bambin","bancaire","bandage","banlieue","banniere","banquier","barbier","baril","baron","barque","barrage","bassin","bastion","bataille","bateau","batterie","baudrier","bavarder","belette","belier","belote","benefice","berceau","berger","berline","bermuda","besace","besogne","betail","beurre","biberon","bicycle","bidule","bijou","bilan","bilingue","billard","binaire","biologie","biopsie","biotype","biscuit","bison","bistouri","bitume","bizarre","blafard","blague","blanchir","blessant","blinder","blond","bloquer","blouson","bobard","bobine","boire","boiser","bolide","bonbon","bondir","bonheur","bonifier","bonus","bordure","borne","botte","boucle","boueux","bougie","boulon","bouquin","bourse","boussole","boutique","boxeur","branche","brasier","brave","brebis","breche","breuvage","bricoler","brigade","brillant","brioche","brique","brochure","broder","bronzer","brousse","broyeur","brume","brusque","brutal","bruyant","buffle","buisson","bulletin","bureau","burin","bustier","butiner","butoir","buvable","buvette","cabanon","cabine","cachette","cadeau","cadre","cafeine","caillou","caisson","calculer","calepin","calibre","calmer","calomnie","calvaire","camarade","camera","camion","campagne","canal","caneton","canon","cantine","canular","capable","caporal","caprice","capsule","capter","capuche","carabine","carbone","caresser","caribou","carnage","carotte","carreau","carton","cascade","casier","casque","cassure","causer","caution","cavalier","caverne","caviar","cedille","ceinture","celeste","cellule","cendrier","censurer","central","cercle","cerebral","cerise","cerner","cerveau","cesser","chagrin","chaise","chaleur","chambre","chance","chapitre","charbon","chasseur","chaton","chausson","chavirer","chemise","chenille","chequier","chercher","cheval","chien","chiffre","chignon","chimere","chiot","chlorure","chocolat","choisir","chose","chouette","chrome","chute","cigare","cigogne","cimenter","cinema","cintrer","circuler","cirer","cirque","citerne","citoyen","citron","civil","clairon","clameur","claquer","classe","clavier","client","cligner","climat","clivage","cloche","clonage","cloporte","cobalt","cobra","cocasse","cocotier","coder","codifier","coffre","cogner","cohesion","coiffer","coincer","colere","colibri","colline","colmater","colonel","combat","comedie","commande","compact","concert","conduire","confier","congeler","connoter","consonne","contact","convexe","copain","copie","corail","corbeau","cordage","corniche","corpus","correct","cortege","cosmique","costume","coton","coude","coupure","courage","couteau","couvrir","coyote","crabe","crainte","cravate","crayon","creature","crediter","cremeux","creuser","crevette","cribler","crier","cristal","critere","croire","croquer","crotale","crucial","cruel","crypter","cubique","cueillir","cuillere","cuisine","cuivre","culminer","cultiver","cumuler","cupide","curatif","curseur","cyanure","cycle","cylindre","cynique","daigner","damier","danger","danseur","dauphin","debattre","debiter","deborder","debrider","debutant","decaler","decembre","dechirer","decider","declarer","decorer","decrire","decupler","dedale","deductif","deesse","defensif","defiler","defrayer","degager","degivrer","deglutir","degrafer","dejeuner","delice","deloger","demander","demeurer","demolir","denicher","denouer","dentelle","denuder","depart","depenser","dephaser","deplacer","deposer","deranger","derober","desastre","descente","desert","designer","desobeir","dessiner","destrier","detacher","detester","detourer","detresse","devancer","devenir","deviner","devoir","diable","dialogue","diamant","dicter","differer","digerer","digital","digne","diluer","dimanche","diminuer","dioxyde","directif","diriger","discuter","disposer","dissiper","distance","divertir","diviser","docile","docteur","dogme","doigt","domaine","domicile","dompter","donateur","donjon","donner","dopamine","dortoir","dorure","dosage","doseur","dossier","dotation","douanier","double","douceur","douter","doyen","dragon","draper","dresser","dribbler","droiture","duperie","duplexe","durable","durcir","dynastie","eblouir","ecarter","echarpe","echelle","eclairer","eclipse","eclore","ecluse","ecole","economie","ecorce","ecouter","ecraser","ecremer","ecrivain","ecrou","ecume","ecureuil","edifier","eduquer","effacer","effectif","effigie","effort","effrayer","effusion","egaliser","egarer","ejecter","elaborer","elargir","electron","elegant","elephant","eleve","eligible","elitisme","eloge","elucider","eluder","emballer","embellir","embryon","emeraude","emission","emmener","emotion","emouvoir","empereur","employer","emporter","emprise","emulsion","encadrer","enchere","enclave","encoche","endiguer","endosser","endroit","enduire","energie","enfance","enfermer","enfouir","engager","engin","englober","enigme","enjamber","enjeu","enlever","ennemi","ennuyeux","enrichir","enrobage","enseigne","entasser","entendre","entier","entourer","entraver","enumerer","envahir","enviable","envoyer","enzyme","eolien","epaissir","epargne","epatant","epaule","epicerie","epidemie","epier","epilogue","epine","episode","epitaphe","epoque","epreuve","eprouver","epuisant","equerre","equipe","eriger","erosion","erreur","eruption","escalier","espadon","espece","espiegle","espoir","esprit","esquiver","essayer","essence","essieu","essorer","estime","estomac","estrade","etagere","etaler","etanche","etatique","eteindre","etendoir","eternel","ethanol","ethique","ethnie","etirer","etoffer","etoile","etonnant","etourdir","etrange","etroit","etude","euphorie","evaluer","evasion","eventail","evidence","eviter","evolutif","evoquer","exact","exagerer","exaucer","exceller","excitant","exclusif","excuse","executer","exemple","exercer","exhaler","exhorter","exigence","exiler","exister","exotique","expedier","explorer","exposer","exprimer","exquis","extensif","extraire","exulter","fable","fabuleux","facette","facile","facture","faiblir","falaise","fameux","famille","farceur","farfelu","farine","farouche","fasciner","fatal","fatigue","faucon","fautif","faveur","favori","febrile","feconder","federer","felin","femme","femur","fendoir","feodal","fermer","feroce","ferveur","festival","feuille","feutre","fevrier","fiasco","ficeler","fictif","fidele","figure","filature","filetage","filiere","filleul","filmer","filou","filtrer","financer","finir","fiole","firme","fissure","fixer","flairer","flamme","flasque","flatteur","fleau","fleche","fleur","flexion","flocon","flore","fluctuer","fluide","fluvial","folie","fonderie","fongible","fontaine","forcer","forgeron","formuler","fortune","fossile","foudre","fougere","fouiller","foulure","fourmi","fragile","fraise","franchir","frapper","frayeur","fregate","freiner","frelon","fremir","frenesie","frere","friable","friction","frisson","frivole","froid","fromage","frontal","frotter","fruit","fugitif","fuite","fureur","furieux","furtif","fusion","futur","gagner","galaxie","galerie","gambader","garantir","gardien","garnir","garrigue","gazelle","gazon","geant","gelatine","gelule","gendarme","general","genie","genou","gentil","geologie","geometre","geranium","germe","gestuel","geyser","gibier","gicler","girafe","givre","glace","glaive","glisser","globe","gloire","glorieux","golfeur","gomme","gonfler","gorge","gorille","goudron","gouffre","goulot","goupille","gourmand","goutte","graduel","graffiti","graine","grand","grappin","gratuit","gravir","grenat","griffure","griller","grimper","grogner","gronder","grotte","groupe","gruger","grutier","gruyere","guepard","guerrier","guide","guimauve","guitare","gustatif","gymnaste","gyrostat","habitude","hachoir","halte","hameau","hangar","hanneton","haricot","harmonie","harpon","hasard","helium","hematome","herbe","herisson","hermine","heron","hesiter","heureux","hiberner","hibou","hilarant","histoire","hiver","homard","hommage","homogene","honneur","honorer","honteux","horde","horizon","horloge","hormone","horrible","houleux","housse","hublot","huileux","humain","humble","humide","humour","hurler","hydromel","hygiene","hymne","hypnose","idylle","ignorer","iguane","illicite","illusion","image","imbiber","imiter","immense","immobile","immuable","impact","imperial","implorer","imposer","imprimer","imputer","incarner","incendie","incident","incliner","incolore","indexer","indice","inductif","inedit","ineptie","inexact","infini","infliger","informer","infusion","ingerer","inhaler","inhiber","injecter","injure","innocent","inoculer","inonder","inscrire","insecte","insigne","insolite","inspirer","instinct","insulter","intact","intense","intime","intrigue","intuitif","inutile","invasion","inventer","inviter","invoquer","ironique","irradier","irreel","irriter","isoler","ivoire","ivresse","jaguar","jaillir","jambe","janvier","jardin","jauger","jaune","javelot","jetable","jeton","jeudi","jeunesse","joindre","joncher","jongler","joueur","jouissif","journal","jovial","joyau","joyeux","jubiler","jugement","junior","jupon","juriste","justice","juteux","juvenile","kayak","kimono","kiosque","label","labial","labourer","lacerer","lactose","lagune","laine","laisser","laitier","lambeau","lamelle","lampe","lanceur","langage","lanterne","lapin","largeur","larme","laurier","lavabo","lavoir","lecture","legal","leger","legume","lessive","lettre","levier","lexique","lezard","liasse","liberer","libre","licence","licorne","liege","lievre","ligature","ligoter","ligue","limer","limite","limonade","limpide","lineaire","lingot","lionceau","liquide","lisiere","lister","lithium","litige","littoral","livreur","logique","lointain","loisir","lombric","loterie","louer","lourd","loutre","louve","loyal","lubie","lucide","lucratif","lueur","lugubre","luisant","lumiere","lunaire","lundi","luron","lutter","luxueux","machine","magasin","magenta","magique","maigre","maillon","maintien","mairie","maison","majorer","malaxer","malefice","malheur","malice","mallette","mammouth","mandater","maniable","manquant","manteau","manuel","marathon","marbre","marchand","mardi","maritime","marqueur","marron","marteler","mascotte","massif","materiel","matiere","matraque","maudire","maussade","mauve","maximal","mechant","meconnu","medaille","medecin","mediter","meduse","meilleur","melange","melodie","membre","memoire","menacer","mener","menhir","mensonge","mentor","mercredi","merite","merle","messager","mesure","metal","meteore","methode","metier","meuble","miauler","microbe","miette","mignon","migrer","milieu","million","mimique","mince","mineral","minimal","minorer","minute","miracle","miroiter","missile","mixte","mobile","moderne","moelleux","mondial","moniteur","monnaie","monotone","monstre","montagne","monument","moqueur","morceau","morsure","mortier","moteur","motif","mouche","moufle","moulin","mousson","mouton","mouvant","multiple","munition","muraille","murene","murmure","muscle","museum","musicien","mutation","muter","mutuel","myriade","myrtille","mystere","mythique","nageur","nappe","narquois","narrer","natation","nation","nature","naufrage","nautique","navire","nebuleux","nectar","nefaste","negation","negliger","negocier","neige","nerveux","nettoyer","neurone","neutron","neveu","niche","nickel","nitrate","niveau","noble","nocif","nocturne","noirceur","noisette","nomade","nombreux","nommer","normatif","notable","notifier","notoire","nourrir","nouveau","novateur","novembre","novice","nuage","nuancer","nuire","nuisible","numero","nuptial","nuque","nutritif","obeir","objectif","obliger","obscur","observer","obstacle","obtenir","obturer","occasion","occuper","ocean","octobre","octroyer","octupler","oculaire","odeur","odorant","offenser","officier","offrir","ogive","oiseau","oisillon","olfactif","olivier","ombrage","omettre","onctueux","onduler","onereux","onirique","opale","opaque","operer","opinion","opportun","opprimer","opter","optique","orageux","orange","orbite","ordonner","oreille","organe","orgueil","orifice","ornement","orque","ortie","osciller","osmose","ossature","otarie","ouragan","ourson","outil","outrager","ouvrage","ovation","oxyde","oxygene","ozone","paisible","palace","palmares","palourde","palper","panache","panda","pangolin","paniquer","panneau","panorama","pantalon","papaye","papier","papoter","papyrus","paradoxe","parcelle","paresse","parfumer","parler","parole","parrain","parsemer","partager","parure","parvenir","passion","pasteque","paternel","patience","patron","pavillon","pavoiser","payer","paysage","peigne","peintre","pelage","pelican","pelle","pelouse","peluche","pendule","penetrer","penible","pensif","penurie","pepite","peplum","perdrix","perforer","periode","permuter","perplexe","persil","perte","peser","petale","petit","petrir","peuple","pharaon","phobie","phoque","photon","phrase","physique","piano","pictural","piece","pierre","pieuvre","pilote","pinceau","pipette","piquer","pirogue","piscine","piston","pivoter","pixel","pizza","placard","plafond","plaisir","planer","plaque","plastron","plateau","pleurer","plexus","pliage","plomb","plonger","pluie","plumage","pochette","poesie","poete","pointe","poirier","poisson","poivre","polaire","policier","pollen","polygone","pommade","pompier","ponctuel","ponderer","poney","portique","position","posseder","posture","potager","poteau","potion","pouce","poulain","poumon","pourpre","poussin","pouvoir","prairie","pratique","precieux","predire","prefixe","prelude","prenom","presence","pretexte","prevoir","primitif","prince","prison","priver","probleme","proceder","prodige","profond","progres","proie","projeter","prologue","promener","propre","prospere","proteger","prouesse","proverbe","prudence","pruneau","psychose","public","puceron","puiser","pulpe","pulsar","punaise","punitif","pupitre","purifier","puzzle","pyramide","quasar","querelle","question","quietude","quitter","quotient","racine","raconter","radieux","ragondin","raideur","raisin","ralentir","rallonge","ramasser","rapide","rasage","ratisser","ravager","ravin","rayonner","reactif","reagir","realiser","reanimer","recevoir","reciter","reclamer","recolter","recruter","reculer","recycler","rediger","redouter","refaire","reflexe","reformer","refrain","refuge","regalien","region","reglage","regulier","reiterer","rejeter","rejouer","relatif","relever","relief","remarque","remede","remise","remonter","remplir","remuer","renard","renfort","renifler","renoncer","rentrer","renvoi","replier","reporter","reprise","reptile","requin","reserve","resineux","resoudre","respect","rester","resultat","retablir","retenir","reticule","retomber","retracer","reunion","reussir","revanche","revivre","revolte","revulsif","richesse","rideau","rieur","rigide","rigoler","rincer","riposter","risible","risque","rituel","rival","riviere","rocheux","romance","rompre","ronce","rondin","roseau","rosier","rotatif","rotor","rotule","rouge","rouille","rouleau","routine","royaume","ruban","rubis","ruche","ruelle","rugueux","ruiner","ruisseau","ruser","rustique","rythme","sabler","saboter","sabre","sacoche","safari","sagesse","saisir","salade","salive","salon","saluer","samedi","sanction","sanglier","sarcasme","sardine","saturer","saugrenu","saumon","sauter","sauvage","savant","savonner","scalpel","scandale","scelerat","scenario","sceptre","schema","science","scinder","score","scrutin","sculpter","seance","secable","secher","secouer","secreter","sedatif","seduire","seigneur","sejour","selectif","semaine","sembler","semence","seminal","senateur","sensible","sentence","separer","sequence","serein","sergent","serieux","serrure","serum","service","sesame","sevir","sevrage","sextuple","sideral","siecle","sieger","siffler","sigle","signal","silence","silicium","simple","sincere","sinistre","siphon","sirop","sismique","situer","skier","social","socle","sodium","soigneux","soldat","soleil","solitude","soluble","sombre","sommeil","somnoler","sonde","songeur","sonnette","sonore","sorcier","sortir","sosie","sottise","soucieux","soudure","souffle","soulever","soupape","source","soutirer","souvenir","spacieux","spatial","special","sphere","spiral","stable","station","sternum","stimulus","stipuler","strict","studieux","stupeur","styliste","sublime","substrat","subtil","subvenir","succes","sucre","suffixe","suggerer","suiveur","sulfate","superbe","supplier","surface","suricate","surmener","surprise","sursaut","survie","suspect","syllabe","symbole","symetrie","synapse","syntaxe","systeme","tabac","tablier","tactile","tailler","talent","talisman","talonner","tambour","tamiser","tangible","tapis","taquiner","tarder","tarif","tartine","tasse","tatami","tatouage","taupe","taureau","taxer","temoin","temporel","tenaille","tendre","teneur","tenir","tension","terminer","terne","terrible","tetine","texte","theme","theorie","therapie","thorax","tibia","tiede","timide","tirelire","tiroir","tissu","titane","titre","tituber","toboggan","tolerant","tomate","tonique","tonneau","toponyme","torche","tordre","tornade","torpille","torrent","torse","tortue","totem","toucher","tournage","tousser","toxine","traction","trafic","tragique","trahir","train","trancher","travail","trefle","tremper","tresor","treuil","triage","tribunal","tricoter","trilogie","triomphe","tripler","triturer","trivial","trombone","tronc","tropical","troupeau","tuile","tulipe","tumulte","tunnel","turbine","tuteur","tutoyer","tuyau","tympan","typhon","typique","tyran","ubuesque","ultime","ultrason","unanime","unifier","union","unique","unitaire","univers","uranium","urbain","urticant","usage","usine","usuel","usure","utile","utopie","vacarme","vaccin","vagabond","vague","vaillant","vaincre","vaisseau","valable","valise","vallon","valve","vampire","vanille","vapeur","varier","vaseux","vassal","vaste","vecteur","vedette","vegetal","vehicule","veinard","veloce","vendredi","venerer","venger","venimeux","ventouse","verdure","verin","vernir","verrou","verser","vertu","veston","veteran","vetuste","vexant","vexer","viaduc","viande","victoire","vidange","video","vignette","vigueur","vilain","village","vinaigre","violon","vipere","virement","virtuose","virus","visage","viseur","vision","visqueux","visuel","vital","vitesse","viticole","vitrine","vivace","vivipare","vocation","voguer","voile","voisin","voiture","volaille","volcan","voltiger","volume","vorace","vortex","voter","vouloir","voyage","voyelle","wagon","xenon","yacht","zebre","zenith","zeste","zoologie"]'), ry = /* @__PURE__ */ JSON.parse('["abaco","abbaglio","abbinato","abete","abisso","abolire","abrasivo","abrogato","accadere","accenno","accusato","acetone","achille","acido","acqua","acre","acrilico","acrobata","acuto","adagio","addebito","addome","adeguato","aderire","adipe","adottare","adulare","affabile","affetto","affisso","affranto","aforisma","afoso","africano","agave","agente","agevole","aggancio","agire","agitare","agonismo","agricolo","agrumeto","aguzzo","alabarda","alato","albatro","alberato","albo","albume","alce","alcolico","alettone","alfa","algebra","aliante","alibi","alimento","allagato","allegro","allievo","allodola","allusivo","almeno","alogeno","alpaca","alpestre","altalena","alterno","alticcio","altrove","alunno","alveolo","alzare","amalgama","amanita","amarena","ambito","ambrato","ameba","america","ametista","amico","ammasso","ammenda","ammirare","ammonito","amore","ampio","ampliare","amuleto","anacardo","anagrafe","analista","anarchia","anatra","anca","ancella","ancora","andare","andrea","anello","angelo","angolare","angusto","anima","annegare","annidato","anno","annuncio","anonimo","anticipo","anzi","apatico","apertura","apode","apparire","appetito","appoggio","approdo","appunto","aprile","arabica","arachide","aragosta","araldica","arancio","aratura","arazzo","arbitro","archivio","ardito","arenile","argento","argine","arguto","aria","armonia","arnese","arredato","arringa","arrosto","arsenico","arso","artefice","arzillo","asciutto","ascolto","asepsi","asettico","asfalto","asino","asola","aspirato","aspro","assaggio","asse","assoluto","assurdo","asta","astenuto","astice","astratto","atavico","ateismo","atomico","atono","attesa","attivare","attorno","attrito","attuale","ausilio","austria","autista","autonomo","autunno","avanzato","avere","avvenire","avviso","avvolgere","azione","azoto","azzimo","azzurro","babele","baccano","bacino","baco","badessa","badilata","bagnato","baita","balcone","baldo","balena","ballata","balzano","bambino","bandire","baraonda","barbaro","barca","baritono","barlume","barocco","basilico","basso","batosta","battuto","baule","bava","bavosa","becco","beffa","belgio","belva","benda","benevole","benigno","benzina","bere","berlina","beta","bibita","bici","bidone","bifido","biga","bilancia","bimbo","binocolo","biologo","bipede","bipolare","birbante","birra","biscotto","bisesto","bisnonno","bisonte","bisturi","bizzarro","blando","blatta","bollito","bonifico","bordo","bosco","botanico","bottino","bozzolo","braccio","bradipo","brama","branca","bravura","bretella","brevetto","brezza","briglia","brillante","brindare","broccolo","brodo","bronzina","brullo","bruno","bubbone","buca","budino","buffone","buio","bulbo","buono","burlone","burrasca","bussola","busta","cadetto","caduco","calamaro","calcolo","calesse","calibro","calmo","caloria","cambusa","camerata","camicia","cammino","camola","campale","canapa","candela","cane","canino","canotto","cantina","capace","capello","capitolo","capogiro","cappero","capra","capsula","carapace","carcassa","cardo","carisma","carovana","carretto","cartolina","casaccio","cascata","caserma","caso","cassone","castello","casuale","catasta","catena","catrame","cauto","cavillo","cedibile","cedrata","cefalo","celebre","cellulare","cena","cenone","centesimo","ceramica","cercare","certo","cerume","cervello","cesoia","cespo","ceto","chela","chiaro","chicca","chiedere","chimera","china","chirurgo","chitarra","ciao","ciclismo","cifrare","cigno","cilindro","ciottolo","circa","cirrosi","citrico","cittadino","ciuffo","civetta","civile","classico","clinica","cloro","cocco","codardo","codice","coerente","cognome","collare","colmato","colore","colposo","coltivato","colza","coma","cometa","commando","comodo","computer","comune","conciso","condurre","conferma","congelare","coniuge","connesso","conoscere","consumo","continuo","convegno","coperto","copione","coppia","copricapo","corazza","cordata","coricato","cornice","corolla","corpo","corredo","corsia","cortese","cosmico","costante","cottura","covato","cratere","cravatta","creato","credere","cremoso","crescita","creta","criceto","crinale","crisi","critico","croce","cronaca","crostata","cruciale","crusca","cucire","cuculo","cugino","cullato","cupola","curatore","cursore","curvo","cuscino","custode","dado","daino","dalmata","damerino","daniela","dannoso","danzare","datato","davanti","davvero","debutto","decennio","deciso","declino","decollo","decreto","dedicato","definito","deforme","degno","delegare","delfino","delirio","delta","demenza","denotato","dentro","deposito","derapata","derivare","deroga","descritto","deserto","desiderio","desumere","detersivo","devoto","diametro","dicembre","diedro","difeso","diffuso","digerire","digitale","diluvio","dinamico","dinnanzi","dipinto","diploma","dipolo","diradare","dire","dirotto","dirupo","disagio","discreto","disfare","disgelo","disposto","distanza","disumano","dito","divano","divelto","dividere","divorato","doblone","docente","doganale","dogma","dolce","domato","domenica","dominare","dondolo","dono","dormire","dote","dottore","dovuto","dozzina","drago","druido","dubbio","dubitare","ducale","duna","duomo","duplice","duraturo","ebano","eccesso","ecco","eclissi","economia","edera","edicola","edile","editoria","educare","egemonia","egli","egoismo","egregio","elaborato","elargire","elegante","elencato","eletto","elevare","elfico","elica","elmo","elsa","eluso","emanato","emblema","emesso","emiro","emotivo","emozione","empirico","emulo","endemico","enduro","energia","enfasi","enoteca","entrare","enzima","epatite","epilogo","episodio","epocale","eppure","equatore","erario","erba","erboso","erede","eremita","erigere","ermetico","eroe","erosivo","errante","esagono","esame","esanime","esaudire","esca","esempio","esercito","esibito","esigente","esistere","esito","esofago","esortato","esoso","espanso","espresso","essenza","esso","esteso","estimare","estonia","estroso","esultare","etilico","etnico","etrusco","etto","euclideo","europa","evaso","evidenza","evitato","evoluto","evviva","fabbrica","faccenda","fachiro","falco","famiglia","fanale","fanfara","fango","fantasma","fare","farfalla","farinoso","farmaco","fascia","fastoso","fasullo","faticare","fato","favoloso","febbre","fecola","fede","fegato","felpa","feltro","femmina","fendere","fenomeno","fermento","ferro","fertile","fessura","festivo","fetta","feudo","fiaba","fiducia","fifa","figurato","filo","finanza","finestra","finire","fiore","fiscale","fisico","fiume","flacone","flamenco","flebo","flemma","florido","fluente","fluoro","fobico","focaccia","focoso","foderato","foglio","folata","folclore","folgore","fondente","fonetico","fonia","fontana","forbito","forchetta","foresta","formica","fornaio","foro","fortezza","forzare","fosfato","fosso","fracasso","frana","frassino","fratello","freccetta","frenata","fresco","frigo","frollino","fronde","frugale","frutta","fucilata","fucsia","fuggente","fulmine","fulvo","fumante","fumetto","fumoso","fune","funzione","fuoco","furbo","furgone","furore","fuso","futile","gabbiano","gaffe","galateo","gallina","galoppo","gambero","gamma","garanzia","garbo","garofano","garzone","gasdotto","gasolio","gastrico","gatto","gaudio","gazebo","gazzella","geco","gelatina","gelso","gemello","gemmato","gene","genitore","gennaio","genotipo","gergo","ghepardo","ghiaccio","ghisa","giallo","gilda","ginepro","giocare","gioiello","giorno","giove","girato","girone","gittata","giudizio","giurato","giusto","globulo","glutine","gnomo","gobba","golf","gomito","gommone","gonfio","gonna","governo","gracile","grado","grafico","grammo","grande","grattare","gravoso","grazia","greca","gregge","grifone","grigio","grinza","grotta","gruppo","guadagno","guaio","guanto","guardare","gufo","guidare","ibernato","icona","identico","idillio","idolo","idra","idrico","idrogeno","igiene","ignaro","ignorato","ilare","illeso","illogico","illudere","imballo","imbevuto","imbocco","imbuto","immane","immerso","immolato","impacco","impeto","impiego","importo","impronta","inalare","inarcare","inattivo","incanto","incendio","inchino","incisivo","incluso","incontro","incrocio","incubo","indagine","india","indole","inedito","infatti","infilare","inflitto","ingaggio","ingegno","inglese","ingordo","ingrosso","innesco","inodore","inoltrare","inondato","insano","insetto","insieme","insonnia","insulina","intasato","intero","intonaco","intuito","inumidire","invalido","invece","invito","iperbole","ipnotico","ipotesi","ippica","iride","irlanda","ironico","irrigato","irrorare","isolato","isotopo","isterico","istituto","istrice","italia","iterare","labbro","labirinto","lacca","lacerato","lacrima","lacuna","laddove","lago","lampo","lancetta","lanterna","lardoso","larga","laringe","lastra","latenza","latino","lattuga","lavagna","lavoro","legale","leggero","lembo","lentezza","lenza","leone","lepre","lesivo","lessato","lesto","letterale","leva","levigato","libero","lido","lievito","lilla","limatura","limitare","limpido","lineare","lingua","liquido","lira","lirica","lisca","lite","litigio","livrea","locanda","lode","logica","lombare","londra","longevo","loquace","lorenzo","loto","lotteria","luce","lucidato","lumaca","luminoso","lungo","lupo","luppolo","lusinga","lusso","lutto","macabro","macchina","macero","macinato","madama","magico","maglia","magnete","magro","maiolica","malafede","malgrado","malinteso","malsano","malto","malumore","mana","mancia","mandorla","mangiare","manifesto","mannaro","manovra","mansarda","mantide","manubrio","mappa","maratona","marcire","maretta","marmo","marsupio","maschera","massaia","mastino","materasso","matricola","mattone","maturo","mazurca","meandro","meccanico","mecenate","medesimo","meditare","mega","melassa","melis","melodia","meninge","meno","mensola","mercurio","merenda","merlo","meschino","mese","messere","mestolo","metallo","metodo","mettere","miagolare","mica","micelio","michele","microbo","midollo","miele","migliore","milano","milite","mimosa","minerale","mini","minore","mirino","mirtillo","miscela","missiva","misto","misurare","mitezza","mitigare","mitra","mittente","mnemonico","modello","modifica","modulo","mogano","mogio","mole","molosso","monastero","monco","mondina","monetario","monile","monotono","monsone","montato","monviso","mora","mordere","morsicato","mostro","motivato","motosega","motto","movenza","movimento","mozzo","mucca","mucosa","muffa","mughetto","mugnaio","mulatto","mulinello","multiplo","mummia","munto","muovere","murale","musa","muscolo","musica","mutevole","muto","nababbo","nafta","nanometro","narciso","narice","narrato","nascere","nastrare","naturale","nautica","naviglio","nebulosa","necrosi","negativo","negozio","nemmeno","neofita","neretto","nervo","nessuno","nettuno","neutrale","neve","nevrotico","nicchia","ninfa","nitido","nobile","nocivo","nodo","nome","nomina","nordico","normale","norvegese","nostrano","notare","notizia","notturno","novella","nucleo","nulla","numero","nuovo","nutrire","nuvola","nuziale","oasi","obbedire","obbligo","obelisco","oblio","obolo","obsoleto","occasione","occhio","occidente","occorrere","occultare","ocra","oculato","odierno","odorare","offerta","offrire","offuscato","oggetto","oggi","ognuno","olandese","olfatto","oliato","oliva","ologramma","oltre","omaggio","ombelico","ombra","omega","omissione","ondoso","onere","onice","onnivoro","onorevole","onta","operato","opinione","opposto","oracolo","orafo","ordine","orecchino","orefice","orfano","organico","origine","orizzonte","orma","ormeggio","ornativo","orologio","orrendo","orribile","ortensia","ortica","orzata","orzo","osare","oscurare","osmosi","ospedale","ospite","ossa","ossidare","ostacolo","oste","otite","otre","ottagono","ottimo","ottobre","ovale","ovest","ovino","oviparo","ovocito","ovunque","ovviare","ozio","pacchetto","pace","pacifico","padella","padrone","paese","paga","pagina","palazzina","palesare","pallido","palo","palude","pandoro","pannello","paolo","paonazzo","paprica","parabola","parcella","parere","pargolo","pari","parlato","parola","partire","parvenza","parziale","passivo","pasticca","patacca","patologia","pattume","pavone","peccato","pedalare","pedonale","peggio","peloso","penare","pendice","penisola","pennuto","penombra","pensare","pentola","pepe","pepita","perbene","percorso","perdonato","perforare","pergamena","periodo","permesso","perno","perplesso","persuaso","pertugio","pervaso","pesatore","pesista","peso","pestifero","petalo","pettine","petulante","pezzo","piacere","pianta","piattino","piccino","picozza","piega","pietra","piffero","pigiama","pigolio","pigro","pila","pilifero","pillola","pilota","pimpante","pineta","pinna","pinolo","pioggia","piombo","piramide","piretico","pirite","pirolisi","pitone","pizzico","placebo","planare","plasma","platano","plenario","pochezza","poderoso","podismo","poesia","poggiare","polenta","poligono","pollice","polmonite","polpetta","polso","poltrona","polvere","pomice","pomodoro","ponte","popoloso","porfido","poroso","porpora","porre","portata","posa","positivo","possesso","postulato","potassio","potere","pranzo","prassi","pratica","precluso","predica","prefisso","pregiato","prelievo","premere","prenotare","preparato","presenza","pretesto","prevalso","prima","principe","privato","problema","procura","produrre","profumo","progetto","prolunga","promessa","pronome","proposta","proroga","proteso","prova","prudente","prugna","prurito","psiche","pubblico","pudica","pugilato","pugno","pulce","pulito","pulsante","puntare","pupazzo","pupilla","puro","quadro","qualcosa","quasi","querela","quota","raccolto","raddoppio","radicale","radunato","raffica","ragazzo","ragione","ragno","ramarro","ramingo","ramo","randagio","rantolare","rapato","rapina","rappreso","rasatura","raschiato","rasente","rassegna","rastrello","rata","ravveduto","reale","recepire","recinto","recluta","recondito","recupero","reddito","redimere","regalato","registro","regola","regresso","relazione","remare","remoto","renna","replica","reprimere","reputare","resa","residente","responso","restauro","rete","retina","retorica","rettifica","revocato","riassunto","ribadire","ribelle","ribrezzo","ricarica","ricco","ricevere","riciclato","ricordo","ricreduto","ridicolo","ridurre","rifasare","riflesso","riforma","rifugio","rigare","rigettato","righello","rilassato","rilevato","rimanere","rimbalzo","rimedio","rimorchio","rinascita","rincaro","rinforzo","rinnovo","rinomato","rinsavito","rintocco","rinuncia","rinvenire","riparato","ripetuto","ripieno","riportare","ripresa","ripulire","risata","rischio","riserva","risibile","riso","rispetto","ristoro","risultato","risvolto","ritardo","ritegno","ritmico","ritrovo","riunione","riva","riverso","rivincita","rivolto","rizoma","roba","robotico","robusto","roccia","roco","rodaggio","rodere","roditore","rogito","rollio","romantico","rompere","ronzio","rosolare","rospo","rotante","rotondo","rotula","rovescio","rubizzo","rubrica","ruga","rullino","rumine","rumoroso","ruolo","rupe","russare","rustico","sabato","sabbiare","sabotato","sagoma","salasso","saldatura","salgemma","salivare","salmone","salone","saltare","saluto","salvo","sapere","sapido","saporito","saraceno","sarcasmo","sarto","sassoso","satellite","satira","satollo","saturno","savana","savio","saziato","sbadiglio","sbalzo","sbancato","sbarra","sbattere","sbavare","sbendare","sbirciare","sbloccato","sbocciato","sbrinare","sbruffone","sbuffare","scabroso","scadenza","scala","scambiare","scandalo","scapola","scarso","scatenare","scavato","scelto","scenico","scettro","scheda","schiena","sciarpa","scienza","scindere","scippo","sciroppo","scivolo","sclerare","scodella","scolpito","scomparto","sconforto","scoprire","scorta","scossone","scozzese","scriba","scrollare","scrutinio","scuderia","scultore","scuola","scuro","scusare","sdebitare","sdoganare","seccatura","secondo","sedano","seggiola","segnalato","segregato","seguito","selciato","selettivo","sella","selvaggio","semaforo","sembrare","seme","seminato","sempre","senso","sentire","sepolto","sequenza","serata","serbato","sereno","serio","serpente","serraglio","servire","sestina","setola","settimana","sfacelo","sfaldare","sfamato","sfarzoso","sfaticato","sfera","sfida","sfilato","sfinge","sfocato","sfoderare","sfogo","sfoltire","sforzato","sfratto","sfruttato","sfuggito","sfumare","sfuso","sgabello","sgarbato","sgonfiare","sgorbio","sgrassato","sguardo","sibilo","siccome","sierra","sigla","signore","silenzio","sillaba","simbolo","simpatico","simulato","sinfonia","singolo","sinistro","sino","sintesi","sinusoide","sipario","sisma","sistole","situato","slitta","slogatura","sloveno","smarrito","smemorato","smentito","smeraldo","smilzo","smontare","smottato","smussato","snellire","snervato","snodo","sobbalzo","sobrio","soccorso","sociale","sodale","soffitto","sogno","soldato","solenne","solido","sollazzo","solo","solubile","solvente","somatico","somma","sonda","sonetto","sonnifero","sopire","soppeso","sopra","sorgere","sorpasso","sorriso","sorso","sorteggio","sorvolato","sospiro","sosta","sottile","spada","spalla","spargere","spatola","spavento","spazzola","specie","spedire","spegnere","spelatura","speranza","spessore","spettrale","spezzato","spia","spigoloso","spillato","spinoso","spirale","splendido","sportivo","sposo","spranga","sprecare","spronato","spruzzo","spuntino","squillo","sradicare","srotolato","stabile","stacco","staffa","stagnare","stampato","stantio","starnuto","stasera","statuto","stelo","steppa","sterzo","stiletto","stima","stirpe","stivale","stizzoso","stonato","storico","strappo","stregato","stridulo","strozzare","strutto","stuccare","stufo","stupendo","subentro","succoso","sudore","suggerito","sugo","sultano","suonare","superbo","supporto","surgelato","surrogato","sussurro","sutura","svagare","svedese","sveglio","svelare","svenuto","svezia","sviluppo","svista","svizzera","svolta","svuotare","tabacco","tabulato","tacciare","taciturno","tale","talismano","tampone","tannino","tara","tardivo","targato","tariffa","tarpare","tartaruga","tasto","tattico","taverna","tavolata","tazza","teca","tecnico","telefono","temerario","tempo","temuto","tendone","tenero","tensione","tentacolo","teorema","terme","terrazzo","terzetto","tesi","tesserato","testato","tetro","tettoia","tifare","tigella","timbro","tinto","tipico","tipografo","tiraggio","tiro","titanio","titolo","titubante","tizio","tizzone","toccare","tollerare","tolto","tombola","tomo","tonfo","tonsilla","topazio","topologia","toppa","torba","tornare","torrone","tortora","toscano","tossire","tostatura","totano","trabocco","trachea","trafila","tragedia","tralcio","tramonto","transito","trapano","trarre","trasloco","trattato","trave","treccia","tremolio","trespolo","tributo","tricheco","trifoglio","trillo","trincea","trio","tristezza","triturato","trivella","tromba","trono","troppo","trottola","trovare","truccato","tubatura","tuffato","tulipano","tumulto","tunisia","turbare","turchino","tuta","tutela","ubicato","uccello","uccisore","udire","uditivo","uffa","ufficio","uguale","ulisse","ultimato","umano","umile","umorismo","uncinetto","ungere","ungherese","unicorno","unificato","unisono","unitario","unte","uovo","upupa","uragano","urgenza","urlo","usanza","usato","uscito","usignolo","usuraio","utensile","utilizzo","utopia","vacante","vaccinato","vagabondo","vagliato","valanga","valgo","valico","valletta","valoroso","valutare","valvola","vampata","vangare","vanitoso","vano","vantaggio","vanvera","vapore","varano","varcato","variante","vasca","vedetta","vedova","veduto","vegetale","veicolo","velcro","velina","velluto","veloce","venato","vendemmia","vento","verace","verbale","vergogna","verifica","vero","verruca","verticale","vescica","vessillo","vestale","veterano","vetrina","vetusto","viandante","vibrante","vicenda","vichingo","vicinanza","vidimare","vigilia","vigneto","vigore","vile","villano","vimini","vincitore","viola","vipera","virgola","virologo","virulento","viscoso","visione","vispo","vissuto","visura","vita","vitello","vittima","vivanda","vivido","viziare","voce","voga","volatile","volere","volpe","voragine","vulcano","zampogna","zanna","zappato","zattera","zavorra","zefiro","zelante","zelo","zenzero","zerbino","zibetto","zinco","zircone","zitto","zolla","zotico","zucchero","zufolo","zulu","zuppa"]'), ty = /* @__PURE__ */ JSON.parse('["abaco","abdomen","abeja","abierto","abogado","abono","aborto","abrazo","abrir","abuelo","abuso","acabar","academia","acceso","accion","aceite","acelga","acento","aceptar","acido","aclarar","acne","acoger","acoso","activo","acto","actriz","actuar","acudir","acuerdo","acusar","adicto","admitir","adoptar","adorno","aduana","adulto","aereo","afectar","aficion","afinar","afirmar","agil","agitar","agonia","agosto","agotar","agregar","agrio","agua","agudo","aguila","aguja","ahogo","ahorro","aire","aislar","ajedrez","ajeno","ajuste","alacran","alambre","alarma","alba","album","alcalde","aldea","alegre","alejar","alerta","aleta","alfiler","alga","algodon","aliado","aliento","alivio","alma","almeja","almibar","altar","alteza","altivo","alto","altura","alumno","alzar","amable","amante","amapola","amargo","amasar","ambar","ambito","ameno","amigo","amistad","amor","amparo","amplio","ancho","anciano","ancla","andar","anden","anemia","angulo","anillo","animo","anis","anotar","antena","antiguo","antojo","anual","anular","anuncio","anadir","anejo","ano","apagar","aparato","apetito","apio","aplicar","apodo","aporte","apoyo","aprender","aprobar","apuesta","apuro","arado","arana","arar","arbitro","arbol","arbusto","archivo","arco","arder","ardilla","arduo","area","arido","aries","armonia","arnes","aroma","arpa","arpon","arreglo","arroz","arruga","arte","artista","asa","asado","asalto","ascenso","asegurar","aseo","asesor","asiento","asilo","asistir","asno","asombro","aspero","astilla","astro","astuto","asumir","asunto","atajo","ataque","atar","atento","ateo","atico","atleta","atomo","atraer","atroz","atun","audaz","audio","auge","aula","aumento","ausente","autor","aval","avance","avaro","ave","avellana","avena","avestruz","avion","aviso","ayer","ayuda","ayuno","azafran","azar","azote","azucar","azufre","azul","baba","babor","bache","bahia","baile","bajar","balanza","balcon","balde","bambu","banco","banda","bano","barba","barco","barniz","barro","bascula","baston","basura","batalla","bateria","batir","batuta","baul","bazar","bebe","bebida","bello","besar","beso","bestia","bicho","bien","bingo","blanco","bloque","blusa","boa","bobina","bobo","boca","bocina","boda","bodega","boina","bola","bolero","bolsa","bomba","bondad","bonito","bono","bonsai","borde","borrar","bosque","bote","botin","boveda","bozal","bravo","brazo","brecha","breve","brillo","brinco","brisa","broca","broma","bronce","brote","bruja","brusco","bruto","buceo","bucle","bueno","buey","bufanda","bufon","buho","buitre","bulto","burbuja","burla","burro","buscar","butaca","buzon","caballo","cabeza","cabina","cabra","cacao","cadaver","cadena","caer","cafe","caida","caiman","caja","cajon","cal","calamar","calcio","caldo","calidad","calle","calma","calor","calvo","cama","cambio","camello","camino","campo","cancer","candil","canela","canguro","canica","canto","cana","canon","caoba","caos","capaz","capitan","capote","captar","capucha","cara","carbon","carcel","careta","carga","carino","carne","carpeta","carro","carta","casa","casco","casero","caspa","castor","catorce","catre","caudal","causa","cazo","cebolla","ceder","cedro","celda","celebre","celoso","celula","cemento","ceniza","centro","cerca","cerdo","cereza","cero","cerrar","certeza","cesped","cetro","chacal","chaleco","champu","chancla","chapa","charla","chico","chiste","chivo","choque","choza","chuleta","chupar","ciclon","ciego","cielo","cien","cierto","cifra","cigarro","cima","cinco","cine","cinta","cipres","circo","ciruela","cisne","cita","ciudad","clamor","clan","claro","clase","clave","cliente","clima","clinica","cobre","coccion","cochino","cocina","coco","codigo","codo","cofre","coger","cohete","cojin","cojo","cola","colcha","colegio","colgar","colina","collar","colmo","columna","combate","comer","comida","comodo","compra","conde","conejo","conga","conocer","consejo","contar","copa","copia","corazon","corbata","corcho","cordon","corona","correr","coser","cosmos","costa","craneo","crater","crear","crecer","creido","crema","cria","crimen","cripta","crisis","cromo","cronica","croqueta","crudo","cruz","cuadro","cuarto","cuatro","cubo","cubrir","cuchara","cuello","cuento","cuerda","cuesta","cueva","cuidar","culebra","culpa","culto","cumbre","cumplir","cuna","cuneta","cuota","cupon","cupula","curar","curioso","curso","curva","cutis","dama","danza","dar","dardo","datil","deber","debil","decada","decir","dedo","defensa","definir","dejar","delfin","delgado","delito","demora","denso","dental","deporte","derecho","derrota","desayuno","deseo","desfile","desnudo","destino","desvio","detalle","detener","deuda","dia","diablo","diadema","diamante","diana","diario","dibujo","dictar","diente","dieta","diez","dificil","digno","dilema","diluir","dinero","directo","dirigir","disco","diseno","disfraz","diva","divino","doble","doce","dolor","domingo","don","donar","dorado","dormir","dorso","dos","dosis","dragon","droga","ducha","duda","duelo","dueno","dulce","duo","duque","durar","dureza","duro","ebano","ebrio","echar","eco","ecuador","edad","edicion","edificio","editor","educar","efecto","eficaz","eje","ejemplo","elefante","elegir","elemento","elevar","elipse","elite","elixir","elogio","eludir","embudo","emitir","emocion","empate","empeno","empleo","empresa","enano","encargo","enchufe","encia","enemigo","enero","enfado","enfermo","engano","enigma","enlace","enorme","enredo","ensayo","ensenar","entero","entrar","envase","envio","epoca","equipo","erizo","escala","escena","escolar","escribir","escudo","esencia","esfera","esfuerzo","espada","espejo","espia","esposa","espuma","esqui","estar","este","estilo","estufa","etapa","eterno","etica","etnia","evadir","evaluar","evento","evitar","exacto","examen","exceso","excusa","exento","exigir","exilio","existir","exito","experto","explicar","exponer","extremo","fabrica","fabula","fachada","facil","factor","faena","faja","falda","fallo","falso","faltar","fama","familia","famoso","faraon","farmacia","farol","farsa","fase","fatiga","fauna","favor","fax","febrero","fecha","feliz","feo","feria","feroz","fertil","fervor","festin","fiable","fianza","fiar","fibra","ficcion","ficha","fideo","fiebre","fiel","fiera","fiesta","figura","fijar","fijo","fila","filete","filial","filtro","fin","finca","fingir","finito","firma","flaco","flauta","flecha","flor","flota","fluir","flujo","fluor","fobia","foca","fogata","fogon","folio","folleto","fondo","forma","forro","fortuna","forzar","fosa","foto","fracaso","fragil","franja","frase","fraude","freir","freno","fresa","frio","frito","fruta","fuego","fuente","fuerza","fuga","fumar","funcion","funda","furgon","furia","fusil","futbol","futuro","gacela","gafas","gaita","gajo","gala","galeria","gallo","gamba","ganar","gancho","ganga","ganso","garaje","garza","gasolina","gastar","gato","gavilan","gemelo","gemir","gen","genero","genio","gente","geranio","gerente","germen","gesto","gigante","gimnasio","girar","giro","glaciar","globo","gloria","gol","golfo","goloso","golpe","goma","gordo","gorila","gorra","gota","goteo","gozar","grada","grafico","grano","grasa","gratis","grave","grieta","grillo","gripe","gris","grito","grosor","grua","grueso","grumo","grupo","guante","guapo","guardia","guerra","guia","guino","guion","guiso","guitarra","gusano","gustar","haber","habil","hablar","hacer","hacha","hada","hallar","hamaca","harina","haz","hazana","hebilla","hebra","hecho","helado","helio","hembra","herir","hermano","heroe","hervir","hielo","hierro","higado","higiene","hijo","himno","historia","hocico","hogar","hoguera","hoja","hombre","hongo","honor","honra","hora","hormiga","horno","hostil","hoyo","hueco","huelga","huerta","hueso","huevo","huida","huir","humano","humedo","humilde","humo","hundir","huracan","hurto","icono","ideal","idioma","idolo","iglesia","iglu","igual","ilegal","ilusion","imagen","iman","imitar","impar","imperio","imponer","impulso","incapaz","indice","inerte","infiel","informe","ingenio","inicio","inmenso","inmune","innato","insecto","instante","interes","intimo","intuir","inutil","invierno","ira","iris","ironia","isla","islote","jabali","jabon","jamon","jarabe","jardin","jarra","jaula","jazmin","jefe","jeringa","jinete","jornada","joroba","joven","joya","juerga","jueves","juez","jugador","jugo","juguete","juicio","junco","jungla","junio","juntar","jupiter","jurar","justo","juvenil","juzgar","kilo","koala","labio","lacio","lacra","lado","ladron","lagarto","lagrima","laguna","laico","lamer","lamina","lampara","lana","lancha","langosta","lanza","lapiz","largo","larva","lastima","lata","latex","latir","laurel","lavar","lazo","leal","leccion","leche","lector","leer","legion","legumbre","lejano","lengua","lento","lena","leon","leopardo","lesion","letal","letra","leve","leyenda","libertad","libro","licor","lider","lidiar","lienzo","liga","ligero","lima","limite","limon","limpio","lince","lindo","linea","lingote","lino","linterna","liquido","liso","lista","litera","litio","litro","llaga","llama","llanto","llave","llegar","llenar","llevar","llorar","llover","lluvia","lobo","locion","loco","locura","logica","logro","lombriz","lomo","lonja","lote","lucha","lucir","lugar","lujo","luna","lunes","lupa","lustro","luto","luz","maceta","macho","madera","madre","maduro","maestro","mafia","magia","mago","maiz","maldad","maleta","malla","malo","mama","mambo","mamut","manco","mando","manejar","manga","maniqui","manjar","mano","manso","manta","manana","mapa","maquina","mar","marco","marea","marfil","margen","marido","marmol","marron","martes","marzo","masa","mascara","masivo","matar","materia","matiz","matriz","maximo","mayor","mazorca","mecha","medalla","medio","medula","mejilla","mejor","melena","melon","memoria","menor","mensaje","mente","menu","mercado","merengue","merito","mes","meson","meta","meter","metodo","metro","mezcla","miedo","miel","miembro","miga","mil","milagro","militar","millon","mimo","mina","minero","minimo","minuto","miope","mirar","misa","miseria","misil","mismo","mitad","mito","mochila","mocion","moda","modelo","moho","mojar","molde","moler","molino","momento","momia","monarca","moneda","monja","monto","mono","morada","morder","moreno","morir","morro","morsa","mortal","mosca","mostrar","motivo","mover","movil","mozo","mucho","mudar","mueble","muela","muerte","muestra","mugre","mujer","mula","muleta","multa","mundo","muneca","mural","muro","musculo","museo","musgo","musica","muslo","nacar","nacion","nadar","naipe","naranja","nariz","narrar","nasal","natal","nativo","natural","nausea","naval","nave","navidad","necio","nectar","negar","negocio","negro","neon","nervio","neto","neutro","nevar","nevera","nicho","nido","niebla","nieto","ninez","nino","nitido","nivel","nobleza","noche","nomina","noria","norma","norte","nota","noticia","novato","novela","novio","nube","nuca","nucleo","nudillo","nudo","nuera","nueve","nuez","nulo","numero","nutria","oasis","obeso","obispo","objeto","obra","obrero","observar","obtener","obvio","oca","ocaso","oceano","ochenta","ocho","ocio","ocre","octavo","octubre","oculto","ocupar","ocurrir","odiar","odio","odisea","oeste","ofensa","oferta","oficio","ofrecer","ogro","oido","oir","ojo","ola","oleada","olfato","olivo","olla","olmo","olor","olvido","ombligo","onda","onza","opaco","opcion","opera","opinar","oponer","optar","optica","opuesto","oracion","orador","oral","orbita","orca","orden","oreja","organo","orgia","orgullo","oriente","origen","orilla","oro","orquesta","oruga","osadia","oscuro","osezno","oso","ostra","otono","otro","oveja","ovulo","oxido","oxigeno","oyente","ozono","pacto","padre","paella","pagina","pago","pais","pajaro","palabra","palco","paleta","palido","palma","paloma","palpar","pan","panal","panico","pantera","panuelo","papa","papel","papilla","paquete","parar","parcela","pared","parir","paro","parpado","parque","parrafo","parte","pasar","paseo","pasion","paso","pasta","pata","patio","patria","pausa","pauta","pavo","payaso","peaton","pecado","pecera","pecho","pedal","pedir","pegar","peine","pelar","peldano","pelea","peligro","pellejo","pelo","peluca","pena","pensar","penon","peon","peor","pepino","pequeno","pera","percha","perder","pereza","perfil","perico","perla","permiso","perro","persona","pesa","pesca","pesimo","pestana","petalo","petroleo","pez","pezuna","picar","pichon","pie","piedra","pierna","pieza","pijama","pilar","piloto","pimienta","pino","pintor","pinza","pina","piojo","pipa","pirata","pisar","piscina","piso","pista","piton","pizca","placa","plan","plata","playa","plaza","pleito","pleno","plomo","pluma","plural","pobre","poco","poder","podio","poema","poesia","poeta","polen","policia","pollo","polvo","pomada","pomelo","pomo","pompa","poner","porcion","portal","posada","poseer","posible","poste","potencia","potro","pozo","prado","precoz","pregunta","premio","prensa","preso","previo","primo","principe","prision","privar","proa","probar","proceso","producto","proeza","profesor","programa","prole","promesa","pronto","propio","proximo","prueba","publico","puchero","pudor","pueblo","puerta","puesto","pulga","pulir","pulmon","pulpo","pulso","puma","punto","punal","puno","pupa","pupila","pure","quedar","queja","quemar","querer","queso","quieto","quimica","quince","quitar","rabano","rabia","rabo","racion","radical","raiz","rama","rampa","rancho","rango","rapaz","rapido","rapto","rasgo","raspa","rato","rayo","raza","razon","reaccion","realidad","rebano","rebote","recaer","receta","rechazo","recoger","recreo","recto","recurso","red","redondo","reducir","reflejo","reforma","refran","refugio","regalo","regir","regla","regreso","rehen","reino","reir","reja","relato","relevo","relieve","relleno","reloj","remar","remedio","remo","rencor","rendir","renta","reparto","repetir","reposo","reptil","res","rescate","resina","respeto","resto","resumen","retiro","retorno","retrato","reunir","reves","revista","rey","rezar","rico","riego","rienda","riesgo","rifa","rigido","rigor","rincon","rinon","rio","riqueza","risa","ritmo","rito","rizo","roble","roce","rociar","rodar","rodeo","rodilla","roer","rojizo","rojo","romero","romper","ron","ronco","ronda","ropa","ropero","rosa","rosca","rostro","rotar","rubi","rubor","rudo","rueda","rugir","ruido","ruina","ruleta","rulo","rumbo","rumor","ruptura","ruta","rutina","sabado","saber","sabio","sable","sacar","sagaz","sagrado","sala","saldo","salero","salir","salmon","salon","salsa","salto","salud","salvar","samba","sancion","sandia","sanear","sangre","sanidad","sano","santo","sapo","saque","sardina","sarten","sastre","satan","sauna","saxofon","seccion","seco","secreto","secta","sed","seguir","seis","sello","selva","semana","semilla","senda","sensor","senal","senor","separar","sepia","sequia","ser","serie","sermon","servir","sesenta","sesion","seta","setenta","severo","sexo","sexto","sidra","siesta","siete","siglo","signo","silaba","silbar","silencio","silla","simbolo","simio","sirena","sistema","sitio","situar","sobre","socio","sodio","sol","solapa","soldado","soledad","solido","soltar","solucion","sombra","sondeo","sonido","sonoro","sonrisa","sopa","soplar","soporte","sordo","sorpresa","sorteo","sosten","sotano","suave","subir","suceso","sudor","suegra","suelo","sueno","suerte","sufrir","sujeto","sultan","sumar","superar","suplir","suponer","supremo","sur","surco","sureno","surgir","susto","sutil","tabaco","tabique","tabla","tabu","taco","tacto","tajo","talar","talco","talento","talla","talon","tamano","tambor","tango","tanque","tapa","tapete","tapia","tapon","taquilla","tarde","tarea","tarifa","tarjeta","tarot","tarro","tarta","tatuaje","tauro","taza","tazon","teatro","techo","tecla","tecnica","tejado","tejer","tejido","tela","telefono","tema","temor","templo","tenaz","tender","tener","tenis","tenso","teoria","terapia","terco","termino","ternura","terror","tesis","tesoro","testigo","tetera","texto","tez","tibio","tiburon","tiempo","tienda","tierra","tieso","tigre","tijera","tilde","timbre","timido","timo","tinta","tio","tipico","tipo","tira","tiron","titan","titere","titulo","tiza","toalla","tobillo","tocar","tocino","todo","toga","toldo","tomar","tono","tonto","topar","tope","toque","torax","torero","tormenta","torneo","toro","torpedo","torre","torso","tortuga","tos","tosco","toser","toxico","trabajo","tractor","traer","trafico","trago","traje","tramo","trance","trato","trauma","trazar","trebol","tregua","treinta","tren","trepar","tres","tribu","trigo","tripa","triste","triunfo","trofeo","trompa","tronco","tropa","trote","trozo","truco","trueno","trufa","tuberia","tubo","tuerto","tumba","tumor","tunel","tunica","turbina","turismo","turno","tutor","ubicar","ulcera","umbral","unidad","unir","universo","uno","untar","una","urbano","urbe","urgente","urna","usar","usuario","util","utopia","uva","vaca","vacio","vacuna","vagar","vago","vaina","vajilla","vale","valido","valle","valor","valvula","vampiro","vara","variar","varon","vaso","vecino","vector","vehiculo","veinte","vejez","vela","velero","veloz","vena","vencer","venda","veneno","vengar","venir","venta","venus","ver","verano","verbo","verde","vereda","verja","verso","verter","via","viaje","vibrar","vicio","victima","vida","video","vidrio","viejo","viernes","vigor","vil","villa","vinagre","vino","vinedo","violin","viral","virgo","virtud","visor","vispera","vista","vitamina","viudo","vivaz","vivero","vivir","vivo","volcan","volumen","volver","voraz","votar","voto","voz","vuelo","vulgar","yacer","yate","yegua","yema","yerno","yeso","yodo","yoga","yogur","zafiro","zanja","zapato","zarza","zona","zorro","zumo","zurdo"]'), ny = /* @__PURE__ */ JSON.parse('["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""]'), ay = /* @__PURE__ */ JSON.parse('["abacate","abaixo","abalar","abater","abduzir","abelha","aberto","abismo","abotoar","abranger","abreviar","abrigar","abrupto","absinto","absoluto","absurdo","abutre","acabado","acalmar","acampar","acanhar","acaso","aceitar","acelerar","acenar","acervo","acessar","acetona","achatar","acidez","acima","acionado","acirrar","aclamar","aclive","acolhida","acomodar","acoplar","acordar","acumular","acusador","adaptar","adega","adentro","adepto","adequar","aderente","adesivo","adeus","adiante","aditivo","adjetivo","adjunto","admirar","adorar","adquirir","adubo","adverso","advogado","aeronave","afastar","aferir","afetivo","afinador","afivelar","aflito","afluente","afrontar","agachar","agarrar","agasalho","agenciar","agilizar","agiota","agitado","agora","agradar","agreste","agrupar","aguardar","agulha","ajoelhar","ajudar","ajustar","alameda","alarme","alastrar","alavanca","albergue","albino","alcatra","aldeia","alecrim","alegria","alertar","alface","alfinete","algum","alheio","aliar","alicate","alienar","alinhar","aliviar","almofada","alocar","alpiste","alterar","altitude","alucinar","alugar","aluno","alusivo","alvo","amaciar","amador","amarelo","amassar","ambas","ambiente","ameixa","amenizar","amido","amistoso","amizade","amolador","amontoar","amoroso","amostra","amparar","ampliar","ampola","anagrama","analisar","anarquia","anatomia","andaime","anel","anexo","angular","animar","anjo","anomalia","anotado","ansioso","anterior","anuidade","anunciar","anzol","apagador","apalpar","apanhado","apego","apelido","apertada","apesar","apetite","apito","aplauso","aplicada","apoio","apontar","aposta","aprendiz","aprovar","aquecer","arame","aranha","arara","arcada","ardente","areia","arejar","arenito","aresta","argiloso","argola","arma","arquivo","arraial","arrebate","arriscar","arroba","arrumar","arsenal","arterial","artigo","arvoredo","asfaltar","asilado","aspirar","assador","assinar","assoalho","assunto","astral","atacado","atadura","atalho","atarefar","atear","atender","aterro","ateu","atingir","atirador","ativo","atoleiro","atracar","atrevido","atriz","atual","atum","auditor","aumentar","aura","aurora","autismo","autoria","autuar","avaliar","avante","avaria","avental","avesso","aviador","avisar","avulso","axila","azarar","azedo","azeite","azulejo","babar","babosa","bacalhau","bacharel","bacia","bagagem","baiano","bailar","baioneta","bairro","baixista","bajular","baleia","baliza","balsa","banal","bandeira","banho","banir","banquete","barato","barbado","baronesa","barraca","barulho","baseado","bastante","batata","batedor","batida","batom","batucar","baunilha","beber","beijo","beirada","beisebol","beldade","beleza","belga","beliscar","bendito","bengala","benzer","berimbau","berlinda","berro","besouro","bexiga","bezerro","bico","bicudo","bienal","bifocal","bifurcar","bigorna","bilhete","bimestre","bimotor","biologia","biombo","biosfera","bipolar","birrento","biscoito","bisneto","bispo","bissexto","bitola","bizarro","blindado","bloco","bloquear","boato","bobagem","bocado","bocejo","bochecha","boicotar","bolada","boletim","bolha","bolo","bombeiro","bonde","boneco","bonita","borbulha","borda","boreal","borracha","bovino","boxeador","branco","brasa","braveza","breu","briga","brilho","brincar","broa","brochura","bronzear","broto","bruxo","bucha","budismo","bufar","bule","buraco","busca","busto","buzina","cabana","cabelo","cabide","cabo","cabrito","cacau","cacetada","cachorro","cacique","cadastro","cadeado","cafezal","caiaque","caipira","caixote","cajado","caju","calafrio","calcular","caldeira","calibrar","calmante","calota","camada","cambista","camisa","camomila","campanha","camuflar","canavial","cancelar","caneta","canguru","canhoto","canivete","canoa","cansado","cantar","canudo","capacho","capela","capinar","capotar","capricho","captador","capuz","caracol","carbono","cardeal","careca","carimbar","carneiro","carpete","carreira","cartaz","carvalho","casaco","casca","casebre","castelo","casulo","catarata","cativar","caule","causador","cautelar","cavalo","caverna","cebola","cedilha","cegonha","celebrar","celular","cenoura","censo","centeio","cercar","cerrado","certeiro","cerveja","cetim","cevada","chacota","chaleira","chamado","chapada","charme","chatice","chave","chefe","chegada","cheiro","cheque","chicote","chifre","chinelo","chocalho","chover","chumbo","chutar","chuva","cicatriz","ciclone","cidade","cidreira","ciente","cigana","cimento","cinto","cinza","ciranda","circuito","cirurgia","citar","clareza","clero","clicar","clone","clube","coado","coagir","cobaia","cobertor","cobrar","cocada","coelho","coentro","coeso","cogumelo","coibir","coifa","coiote","colar","coleira","colher","colidir","colmeia","colono","coluna","comando","combinar","comentar","comitiva","comover","complexo","comum","concha","condor","conectar","confuso","congelar","conhecer","conjugar","consumir","contrato","convite","cooperar","copeiro","copiador","copo","coquetel","coragem","cordial","corneta","coronha","corporal","correio","cortejo","coruja","corvo","cosseno","costela","cotonete","couro","couve","covil","cozinha","cratera","cravo","creche","credor","creme","crer","crespo","criada","criminal","crioulo","crise","criticar","crosta","crua","cruzeiro","cubano","cueca","cuidado","cujo","culatra","culminar","culpar","cultura","cumprir","cunhado","cupido","curativo","curral","cursar","curto","cuspir","custear","cutelo","damasco","datar","debater","debitar","deboche","debulhar","decalque","decimal","declive","decote","decretar","dedal","dedicado","deduzir","defesa","defumar","degelo","degrau","degustar","deitado","deixar","delator","delegado","delinear","delonga","demanda","demitir","demolido","dentista","depenado","depilar","depois","depressa","depurar","deriva","derramar","desafio","desbotar","descanso","desenho","desfiado","desgaste","desigual","deslize","desmamar","desova","despesa","destaque","desviar","detalhar","detentor","detonar","detrito","deusa","dever","devido","devotado","dezena","diagrama","dialeto","didata","difuso","digitar","dilatado","diluente","diminuir","dinastia","dinheiro","diocese","direto","discreta","disfarce","disparo","disquete","dissipar","distante","ditador","diurno","diverso","divisor","divulgar","dizer","dobrador","dolorido","domador","dominado","donativo","donzela","dormente","dorsal","dosagem","dourado","doutor","drenagem","drible","drogaria","duelar","duende","dueto","duplo","duquesa","durante","duvidoso","eclodir","ecoar","ecologia","edificar","edital","educado","efeito","efetivar","ejetar","elaborar","eleger","eleitor","elenco","elevador","eliminar","elogiar","embargo","embolado","embrulho","embutido","emenda","emergir","emissor","empatia","empenho","empinado","empolgar","emprego","empurrar","emulador","encaixe","encenado","enchente","encontro","endeusar","endossar","enfaixar","enfeite","enfim","engajado","engenho","englobar","engomado","engraxar","enguia","enjoar","enlatar","enquanto","enraizar","enrolado","enrugar","ensaio","enseada","ensino","ensopado","entanto","enteado","entidade","entortar","entrada","entulho","envergar","enviado","envolver","enxame","enxerto","enxofre","enxuto","epiderme","equipar","ereto","erguido","errata","erva","ervilha","esbanjar","esbelto","escama","escola","escrita","escuta","esfinge","esfolar","esfregar","esfumado","esgrima","esmalte","espanto","espelho","espiga","esponja","espreita","espumar","esquerda","estaca","esteira","esticar","estofado","estrela","estudo","esvaziar","etanol","etiqueta","euforia","europeu","evacuar","evaporar","evasivo","eventual","evidente","evoluir","exagero","exalar","examinar","exato","exausto","excesso","excitar","exclamar","executar","exemplo","exibir","exigente","exonerar","expandir","expelir","expirar","explanar","exposto","expresso","expulsar","externo","extinto","extrato","fabricar","fabuloso","faceta","facial","fada","fadiga","faixa","falar","falta","familiar","fandango","fanfarra","fantoche","fardado","farelo","farinha","farofa","farpa","fartura","fatia","fator","favorita","faxina","fazenda","fechado","feijoada","feirante","felino","feminino","fenda","feno","fera","feriado","ferrugem","ferver","festejar","fetal","feudal","fiapo","fibrose","ficar","ficheiro","figurado","fileira","filho","filme","filtrar","firmeza","fisgada","fissura","fita","fivela","fixador","fixo","flacidez","flamingo","flanela","flechada","flora","flutuar","fluxo","focal","focinho","fofocar","fogo","foguete","foice","folgado","folheto","forjar","formiga","forno","forte","fosco","fossa","fragata","fralda","frango","frasco","fraterno","freira","frente","fretar","frieza","friso","fritura","fronha","frustrar","fruteira","fugir","fulano","fuligem","fundar","fungo","funil","furador","furioso","futebol","gabarito","gabinete","gado","gaiato","gaiola","gaivota","galega","galho","galinha","galocha","ganhar","garagem","garfo","gargalo","garimpo","garoupa","garrafa","gasoduto","gasto","gata","gatilho","gaveta","gazela","gelado","geleia","gelo","gemada","gemer","gemido","generoso","gengiva","genial","genoma","genro","geologia","gerador","germinar","gesso","gestor","ginasta","gincana","gingado","girafa","girino","glacial","glicose","global","glorioso","goela","goiaba","golfe","golpear","gordura","gorjeta","gorro","gostoso","goteira","governar","gracejo","gradual","grafite","gralha","grampo","granada","gratuito","graveto","graxa","grego","grelhar","greve","grilo","grisalho","gritaria","grosso","grotesco","grudado","grunhido","gruta","guache","guarani","guaxinim","guerrear","guiar","guincho","guisado","gula","guloso","guru","habitar","harmonia","haste","haver","hectare","herdar","heresia","hesitar","hiato","hibernar","hidratar","hiena","hino","hipismo","hipnose","hipoteca","hoje","holofote","homem","honesto","honrado","hormonal","hospedar","humorado","iate","ideia","idoso","ignorado","igreja","iguana","ileso","ilha","iludido","iluminar","ilustrar","imagem","imediato","imenso","imersivo","iminente","imitador","imortal","impacto","impedir","implante","impor","imprensa","impune","imunizar","inalador","inapto","inativo","incenso","inchar","incidir","incluir","incolor","indeciso","indireto","indutor","ineficaz","inerente","infantil","infestar","infinito","inflamar","informal","infrator","ingerir","inibido","inicial","inimigo","injetar","inocente","inodoro","inovador","inox","inquieto","inscrito","inseto","insistir","inspetor","instalar","insulto","intacto","integral","intimar","intocado","intriga","invasor","inverno","invicto","invocar","iogurte","iraniano","ironizar","irreal","irritado","isca","isento","isolado","isqueiro","italiano","janeiro","jangada","janta","jararaca","jardim","jarro","jasmim","jato","javali","jazida","jejum","joaninha","joelhada","jogador","joia","jornal","jorrar","jovem","juba","judeu","judoca","juiz","julgador","julho","jurado","jurista","juro","justa","labareda","laboral","lacre","lactante","ladrilho","lagarta","lagoa","laje","lamber","lamentar","laminar","lampejo","lanche","lapidar","lapso","laranja","lareira","largura","lasanha","lastro","lateral","latido","lavanda","lavoura","lavrador","laxante","lazer","lealdade","lebre","legado","legendar","legista","leigo","leiloar","leitura","lembrete","leme","lenhador","lentilha","leoa","lesma","leste","letivo","letreiro","levar","leveza","levitar","liberal","libido","liderar","ligar","ligeiro","limitar","limoeiro","limpador","linda","linear","linhagem","liquidez","listagem","lisura","litoral","livro","lixa","lixeira","locador","locutor","lojista","lombo","lona","longe","lontra","lorde","lotado","loteria","loucura","lousa","louvar","luar","lucidez","lucro","luneta","lustre","lutador","luva","macaco","macete","machado","macio","madeira","madrinha","magnata","magreza","maior","mais","malandro","malha","malote","maluco","mamilo","mamoeiro","mamute","manada","mancha","mandato","manequim","manhoso","manivela","manobrar","mansa","manter","manusear","mapeado","maquinar","marcador","maresia","marfim","margem","marinho","marmita","maroto","marquise","marreco","martelo","marujo","mascote","masmorra","massagem","mastigar","matagal","materno","matinal","matutar","maxilar","medalha","medida","medusa","megafone","meiga","melancia","melhor","membro","memorial","menino","menos","mensagem","mental","merecer","mergulho","mesada","mesclar","mesmo","mesquita","mestre","metade","meteoro","metragem","mexer","mexicano","micro","migalha","migrar","milagre","milenar","milhar","mimado","minerar","minhoca","ministro","minoria","miolo","mirante","mirtilo","misturar","mocidade","moderno","modular","moeda","moer","moinho","moita","moldura","moleza","molho","molinete","molusco","montanha","moqueca","morango","morcego","mordomo","morena","mosaico","mosquete","mostarda","motel","motim","moto","motriz","muda","muito","mulata","mulher","multar","mundial","munido","muralha","murcho","muscular","museu","musical","nacional","nadador","naja","namoro","narina","narrado","nascer","nativa","natureza","navalha","navegar","navio","neblina","nebuloso","negativa","negociar","negrito","nervoso","neta","neural","nevasca","nevoeiro","ninar","ninho","nitidez","nivelar","nobreza","noite","noiva","nomear","nominal","nordeste","nortear","notar","noticiar","noturno","novelo","novilho","novo","nublado","nudez","numeral","nupcial","nutrir","nuvem","obcecado","obedecer","objetivo","obrigado","obscuro","obstetra","obter","obturar","ocidente","ocioso","ocorrer","oculista","ocupado","ofegante","ofensiva","oferenda","oficina","ofuscado","ogiva","olaria","oleoso","olhar","oliveira","ombro","omelete","omisso","omitir","ondulado","oneroso","ontem","opcional","operador","oponente","oportuno","oposto","orar","orbitar","ordem","ordinal","orfanato","orgasmo","orgulho","oriental","origem","oriundo","orla","ortodoxo","orvalho","oscilar","ossada","osso","ostentar","otimismo","ousadia","outono","outubro","ouvido","ovelha","ovular","oxidar","oxigenar","pacato","paciente","pacote","pactuar","padaria","padrinho","pagar","pagode","painel","pairar","paisagem","palavra","palestra","palheta","palito","palmada","palpitar","pancada","panela","panfleto","panqueca","pantanal","papagaio","papelada","papiro","parafina","parcial","pardal","parede","partida","pasmo","passado","pastel","patamar","patente","patinar","patrono","paulada","pausar","peculiar","pedalar","pedestre","pediatra","pedra","pegada","peitoral","peixe","pele","pelicano","penca","pendurar","peneira","penhasco","pensador","pente","perceber","perfeito","pergunta","perito","permitir","perna","perplexo","persiana","pertence","peruca","pescado","pesquisa","pessoa","petiscar","piada","picado","piedade","pigmento","pilastra","pilhado","pilotar","pimenta","pincel","pinguim","pinha","pinote","pintar","pioneiro","pipoca","piquete","piranha","pires","pirueta","piscar","pistola","pitanga","pivete","planta","plaqueta","platina","plebeu","plumagem","pluvial","pneu","poda","poeira","poetisa","polegada","policiar","poluente","polvilho","pomar","pomba","ponderar","pontaria","populoso","porta","possuir","postal","pote","poupar","pouso","povoar","praia","prancha","prato","praxe","prece","predador","prefeito","premiar","prensar","preparar","presilha","pretexto","prevenir","prezar","primata","princesa","prisma","privado","processo","produto","profeta","proibido","projeto","prometer","propagar","prosa","protetor","provador","publicar","pudim","pular","pulmonar","pulseira","punhal","punir","pupilo","pureza","puxador","quadra","quantia","quarto","quase","quebrar","queda","queijo","quente","querido","quimono","quina","quiosque","rabanada","rabisco","rachar","racionar","radial","raiar","rainha","raio","raiva","rajada","ralado","ramal","ranger","ranhura","rapadura","rapel","rapidez","raposa","raquete","raridade","rasante","rascunho","rasgar","raspador","rasteira","rasurar","ratazana","ratoeira","realeza","reanimar","reaver","rebaixar","rebelde","rebolar","recado","recente","recheio","recibo","recordar","recrutar","recuar","rede","redimir","redonda","reduzida","reenvio","refinar","refletir","refogar","refresco","refugiar","regalia","regime","regra","reinado","reitor","rejeitar","relativo","remador","remendo","remorso","renovado","reparo","repelir","repleto","repolho","represa","repudiar","requerer","resenha","resfriar","resgatar","residir","resolver","respeito","ressaca","restante","resumir","retalho","reter","retirar","retomada","retratar","revelar","revisor","revolta","riacho","rica","rigidez","rigoroso","rimar","ringue","risada","risco","risonho","robalo","rochedo","rodada","rodeio","rodovia","roedor","roleta","romano","roncar","rosado","roseira","rosto","rota","roteiro","rotina","rotular","rouco","roupa","roxo","rubro","rugido","rugoso","ruivo","rumo","rupestre","russo","sabor","saciar","sacola","sacudir","sadio","safira","saga","sagrada","saibro","salada","saleiro","salgado","saliva","salpicar","salsicha","saltar","salvador","sambar","samurai","sanar","sanfona","sangue","sanidade","sapato","sarda","sargento","sarjeta","saturar","saudade","saxofone","sazonal","secar","secular","seda","sedento","sediado","sedoso","sedutor","segmento","segredo","segundo","seiva","seleto","selvagem","semanal","semente","senador","senhor","sensual","sentado","separado","sereia","seringa","serra","servo","setembro","setor","sigilo","silhueta","silicone","simetria","simpatia","simular","sinal","sincero","singular","sinopse","sintonia","sirene","siri","situado","soberano","sobra","socorro","sogro","soja","solda","soletrar","solteiro","sombrio","sonata","sondar","sonegar","sonhador","sono","soprano","soquete","sorrir","sorteio","sossego","sotaque","soterrar","sovado","sozinho","suavizar","subida","submerso","subsolo","subtrair","sucata","sucesso","suco","sudeste","sufixo","sugador","sugerir","sujeito","sulfato","sumir","suor","superior","suplicar","suposto","suprimir","surdina","surfista","surpresa","surreal","surtir","suspiro","sustento","tabela","tablete","tabuada","tacho","tagarela","talher","talo","talvez","tamanho","tamborim","tampa","tangente","tanto","tapar","tapioca","tardio","tarefa","tarja","tarraxa","tatuagem","taurino","taxativo","taxista","teatral","tecer","tecido","teclado","tedioso","teia","teimar","telefone","telhado","tempero","tenente","tensor","tentar","termal","terno","terreno","tese","tesoura","testado","teto","textura","texugo","tiara","tigela","tijolo","timbrar","timidez","tingido","tinteiro","tiragem","titular","toalha","tocha","tolerar","tolice","tomada","tomilho","tonel","tontura","topete","tora","torcido","torneio","torque","torrada","torto","tostar","touca","toupeira","toxina","trabalho","tracejar","tradutor","trafegar","trajeto","trama","trancar","trapo","traseiro","tratador","travar","treino","tremer","trepidar","trevo","triagem","tribo","triciclo","tridente","trilogia","trindade","triplo","triturar","triunfal","trocar","trombeta","trova","trunfo","truque","tubular","tucano","tudo","tulipa","tupi","turbo","turma","turquesa","tutelar","tutorial","uivar","umbigo","unha","unidade","uniforme","urologia","urso","urtiga","urubu","usado","usina","usufruir","vacina","vadiar","vagaroso","vaidoso","vala","valente","validade","valores","vantagem","vaqueiro","varanda","vareta","varrer","vascular","vasilha","vassoura","vazar","vazio","veado","vedar","vegetar","veicular","veleiro","velhice","veludo","vencedor","vendaval","venerar","ventre","verbal","verdade","vereador","vergonha","vermelho","verniz","versar","vertente","vespa","vestido","vetorial","viaduto","viagem","viajar","viatura","vibrador","videira","vidraria","viela","viga","vigente","vigiar","vigorar","vilarejo","vinco","vinheta","vinil","violeta","virada","virtude","visitar","visto","vitral","viveiro","vizinho","voador","voar","vogal","volante","voleibol","voltagem","volumoso","vontade","vulto","vuvuzela","xadrez","xarope","xeque","xeretar","xerife","xingar","zangado","zarpar","zebu","zelador","zombar","zoologia","zumbido"]'), oy = /* @__PURE__ */ JSON.parse('["abandon","ability","able","about","above","absent","absorb","abstract","absurd","abuse","access","accident","account","accuse","achieve","acid","acoustic","acquire","across","act","action","actor","actress","actual","adapt","add","addict","address","adjust","admit","adult","advance","advice","aerobic","affair","afford","afraid","again","age","agent","agree","ahead","aim","air","airport","aisle","alarm","album","alcohol","alert","alien","all","alley","allow","almost","alone","alpha","already","also","alter","always","amateur","amazing","among","amount","amused","analyst","anchor","ancient","anger","angle","angry","animal","ankle","announce","annual","another","answer","antenna","antique","anxiety","any","apart","apology","appear","apple","approve","april","arch","arctic","area","arena","argue","arm","armed","armor","army","around","arrange","arrest","arrive","arrow","art","artefact","artist","artwork","ask","aspect","assault","asset","assist","assume","asthma","athlete","atom","attack","attend","attitude","attract","auction","audit","august","aunt","author","auto","autumn","average","avocado","avoid","awake","aware","away","awesome","awful","awkward","axis","baby","bachelor","bacon","badge","bag","balance","balcony","ball","bamboo","banana","banner","bar","barely","bargain","barrel","base","basic","basket","battle","beach","bean","beauty","because","become","beef","before","begin","behave","behind","believe","below","belt","bench","benefit","best","betray","better","between","beyond","bicycle","bid","bike","bind","biology","bird","birth","bitter","black","blade","blame","blanket","blast","bleak","bless","blind","blood","blossom","blouse","blue","blur","blush","board","boat","body","boil","bomb","bone","bonus","book","boost","border","boring","borrow","boss","bottom","bounce","box","boy","bracket","brain","brand","brass","brave","bread","breeze","brick","bridge","brief","bright","bring","brisk","broccoli","broken","bronze","broom","brother","brown","brush","bubble","buddy","budget","buffalo","build","bulb","bulk","bullet","bundle","bunker","burden","burger","burst","bus","business","busy","butter","buyer","buzz","cabbage","cabin","cable","cactus","cage","cake","call","calm","camera","camp","can","canal","cancel","candy","cannon","canoe","canvas","canyon","capable","capital","captain","car","carbon","card","cargo","carpet","carry","cart","case","cash","casino","castle","casual","cat","catalog","catch","category","cattle","caught","cause","caution","cave","ceiling","celery","cement","census","century","cereal","certain","chair","chalk","champion","change","chaos","chapter","charge","chase","chat","cheap","check","cheese","chef","cherry","chest","chicken","chief","child","chimney","choice","choose","chronic","chuckle","chunk","churn","cigar","cinnamon","circle","citizen","city","civil","claim","clap","clarify","claw","clay","clean","clerk","clever","click","client","cliff","climb","clinic","clip","clock","clog","close","cloth","cloud","clown","club","clump","cluster","clutch","coach","coast","coconut","code","coffee","coil","coin","collect","color","column","combine","come","comfort","comic","common","company","concert","conduct","confirm","congress","connect","consider","control","convince","cook","cool","copper","copy","coral","core","corn","correct","cost","cotton","couch","country","couple","course","cousin","cover","coyote","crack","cradle","craft","cram","crane","crash","crater","crawl","crazy","cream","credit","creek","crew","cricket","crime","crisp","critic","crop","cross","crouch","crowd","crucial","cruel","cruise","crumble","crunch","crush","cry","crystal","cube","culture","cup","cupboard","curious","current","curtain","curve","cushion","custom","cute","cycle","dad","damage","damp","dance","danger","daring","dash","daughter","dawn","day","deal","debate","debris","decade","december","decide","decline","decorate","decrease","deer","defense","define","defy","degree","delay","deliver","demand","demise","denial","dentist","deny","depart","depend","deposit","depth","deputy","derive","describe","desert","design","desk","despair","destroy","detail","detect","develop","device","devote","diagram","dial","diamond","diary","dice","diesel","diet","differ","digital","dignity","dilemma","dinner","dinosaur","direct","dirt","disagree","discover","disease","dish","dismiss","disorder","display","distance","divert","divide","divorce","dizzy","doctor","document","dog","doll","dolphin","domain","donate","donkey","donor","door","dose","double","dove","draft","dragon","drama","drastic","draw","dream","dress","drift","drill","drink","drip","drive","drop","drum","dry","duck","dumb","dune","during","dust","dutch","duty","dwarf","dynamic","eager","eagle","early","earn","earth","easily","east","easy","echo","ecology","economy","edge","edit","educate","effort","egg","eight","either","elbow","elder","electric","elegant","element","elephant","elevator","elite","else","embark","embody","embrace","emerge","emotion","employ","empower","empty","enable","enact","end","endless","endorse","enemy","energy","enforce","engage","engine","enhance","enjoy","enlist","enough","enrich","enroll","ensure","enter","entire","entry","envelope","episode","equal","equip","era","erase","erode","erosion","error","erupt","escape","essay","essence","estate","eternal","ethics","evidence","evil","evoke","evolve","exact","example","excess","exchange","excite","exclude","excuse","execute","exercise","exhaust","exhibit","exile","exist","exit","exotic","expand","expect","expire","explain","expose","express","extend","extra","eye","eyebrow","fabric","face","faculty","fade","faint","faith","fall","false","fame","family","famous","fan","fancy","fantasy","farm","fashion","fat","fatal","father","fatigue","fault","favorite","feature","february","federal","fee","feed","feel","female","fence","festival","fetch","fever","few","fiber","fiction","field","figure","file","film","filter","final","find","fine","finger","finish","fire","firm","first","fiscal","fish","fit","fitness","fix","flag","flame","flash","flat","flavor","flee","flight","flip","float","flock","floor","flower","fluid","flush","fly","foam","focus","fog","foil","fold","follow","food","foot","force","forest","forget","fork","fortune","forum","forward","fossil","foster","found","fox","fragile","frame","frequent","fresh","friend","fringe","frog","front","frost","frown","frozen","fruit","fuel","fun","funny","furnace","fury","future","gadget","gain","galaxy","gallery","game","gap","garage","garbage","garden","garlic","garment","gas","gasp","gate","gather","gauge","gaze","general","genius","genre","gentle","genuine","gesture","ghost","giant","gift","giggle","ginger","giraffe","girl","give","glad","glance","glare","glass","glide","glimpse","globe","gloom","glory","glove","glow","glue","goat","goddess","gold","good","goose","gorilla","gospel","gossip","govern","gown","grab","grace","grain","grant","grape","grass","gravity","great","green","grid","grief","grit","grocery","group","grow","grunt","guard","guess","guide","guilt","guitar","gun","gym","habit","hair","half","hammer","hamster","hand","happy","harbor","hard","harsh","harvest","hat","have","hawk","hazard","head","health","heart","heavy","hedgehog","height","hello","helmet","help","hen","hero","hidden","high","hill","hint","hip","hire","history","hobby","hockey","hold","hole","holiday","hollow","home","honey","hood","hope","horn","horror","horse","hospital","host","hotel","hour","hover","hub","huge","human","humble","humor","hundred","hungry","hunt","hurdle","hurry","hurt","husband","hybrid","ice","icon","idea","identify","idle","ignore","ill","illegal","illness","image","imitate","immense","immune","impact","impose","improve","impulse","inch","include","income","increase","index","indicate","indoor","industry","infant","inflict","inform","inhale","inherit","initial","inject","injury","inmate","inner","innocent","input","inquiry","insane","insect","inside","inspire","install","intact","interest","into","invest","invite","involve","iron","island","isolate","issue","item","ivory","jacket","jaguar","jar","jazz","jealous","jeans","jelly","jewel","job","join","joke","journey","joy","judge","juice","jump","jungle","junior","junk","just","kangaroo","keen","keep","ketchup","key","kick","kid","kidney","kind","kingdom","kiss","kit","kitchen","kite","kitten","kiwi","knee","knife","knock","know","lab","label","labor","ladder","lady","lake","lamp","language","laptop","large","later","latin","laugh","laundry","lava","law","lawn","lawsuit","layer","lazy","leader","leaf","learn","leave","lecture","left","leg","legal","legend","leisure","lemon","lend","length","lens","leopard","lesson","letter","level","liar","liberty","library","license","life","lift","light","like","limb","limit","link","lion","liquid","list","little","live","lizard","load","loan","lobster","local","lock","logic","lonely","long","loop","lottery","loud","lounge","love","loyal","lucky","luggage","lumber","lunar","lunch","luxury","lyrics","machine","mad","magic","magnet","maid","mail","main","major","make","mammal","man","manage","mandate","mango","mansion","manual","maple","marble","march","margin","marine","market","marriage","mask","mass","master","match","material","math","matrix","matter","maximum","maze","meadow","mean","measure","meat","mechanic","medal","media","melody","melt","member","memory","mention","menu","mercy","merge","merit","merry","mesh","message","metal","method","middle","midnight","milk","million","mimic","mind","minimum","minor","minute","miracle","mirror","misery","miss","mistake","mix","mixed","mixture","mobile","model","modify","mom","moment","monitor","monkey","monster","month","moon","moral","more","morning","mosquito","mother","motion","motor","mountain","mouse","move","movie","much","muffin","mule","multiply","muscle","museum","mushroom","music","must","mutual","myself","mystery","myth","naive","name","napkin","narrow","nasty","nation","nature","near","neck","need","negative","neglect","neither","nephew","nerve","nest","net","network","neutral","never","news","next","nice","night","noble","noise","nominee","noodle","normal","north","nose","notable","note","nothing","notice","novel","now","nuclear","number","nurse","nut","oak","obey","object","oblige","obscure","observe","obtain","obvious","occur","ocean","october","odor","off","offer","office","often","oil","okay","old","olive","olympic","omit","once","one","onion","online","only","open","opera","opinion","oppose","option","orange","orbit","orchard","order","ordinary","organ","orient","original","orphan","ostrich","other","outdoor","outer","output","outside","oval","oven","over","own","owner","oxygen","oyster","ozone","pact","paddle","page","pair","palace","palm","panda","panel","panic","panther","paper","parade","parent","park","parrot","party","pass","patch","path","patient","patrol","pattern","pause","pave","payment","peace","peanut","pear","peasant","pelican","pen","penalty","pencil","people","pepper","perfect","permit","person","pet","phone","photo","phrase","physical","piano","picnic","picture","piece","pig","pigeon","pill","pilot","pink","pioneer","pipe","pistol","pitch","pizza","place","planet","plastic","plate","play","please","pledge","pluck","plug","plunge","poem","poet","point","polar","pole","police","pond","pony","pool","popular","portion","position","possible","post","potato","pottery","poverty","powder","power","practice","praise","predict","prefer","prepare","present","pretty","prevent","price","pride","primary","print","priority","prison","private","prize","problem","process","produce","profit","program","project","promote","proof","property","prosper","protect","proud","provide","public","pudding","pull","pulp","pulse","pumpkin","punch","pupil","puppy","purchase","purity","purpose","purse","push","put","puzzle","pyramid","quality","quantum","quarter","question","quick","quit","quiz","quote","rabbit","raccoon","race","rack","radar","radio","rail","rain","raise","rally","ramp","ranch","random","range","rapid","rare","rate","rather","raven","raw","razor","ready","real","reason","rebel","rebuild","recall","receive","recipe","record","recycle","reduce","reflect","reform","refuse","region","regret","regular","reject","relax","release","relief","rely","remain","remember","remind","remove","render","renew","rent","reopen","repair","repeat","replace","report","require","rescue","resemble","resist","resource","response","result","retire","retreat","return","reunion","reveal","review","reward","rhythm","rib","ribbon","rice","rich","ride","ridge","rifle","right","rigid","ring","riot","ripple","risk","ritual","rival","river","road","roast","robot","robust","rocket","romance","roof","rookie","room","rose","rotate","rough","round","route","royal","rubber","rude","rug","rule","run","runway","rural","sad","saddle","sadness","safe","sail","salad","salmon","salon","salt","salute","same","sample","sand","satisfy","satoshi","sauce","sausage","save","say","scale","scan","scare","scatter","scene","scheme","school","science","scissors","scorpion","scout","scrap","screen","script","scrub","sea","search","season","seat","second","secret","section","security","seed","seek","segment","select","sell","seminar","senior","sense","sentence","series","service","session","settle","setup","seven","shadow","shaft","shallow","share","shed","shell","sheriff","shield","shift","shine","ship","shiver","shock","shoe","shoot","shop","short","shoulder","shove","shrimp","shrug","shuffle","shy","sibling","sick","side","siege","sight","sign","silent","silk","silly","silver","similar","simple","since","sing","siren","sister","situate","six","size","skate","sketch","ski","skill","skin","skirt","skull","slab","slam","sleep","slender","slice","slide","slight","slim","slogan","slot","slow","slush","small","smart","smile","smoke","smooth","snack","snake","snap","sniff","snow","soap","soccer","social","sock","soda","soft","solar","soldier","solid","solution","solve","someone","song","soon","sorry","sort","soul","sound","soup","source","south","space","spare","spatial","spawn","speak","special","speed","spell","spend","sphere","spice","spider","spike","spin","spirit","split","spoil","sponsor","spoon","sport","spot","spray","spread","spring","spy","square","squeeze","squirrel","stable","stadium","staff","stage","stairs","stamp","stand","start","state","stay","steak","steel","stem","step","stereo","stick","still","sting","stock","stomach","stone","stool","story","stove","strategy","street","strike","strong","struggle","student","stuff","stumble","style","subject","submit","subway","success","such","sudden","suffer","sugar","suggest","suit","summer","sun","sunny","sunset","super","supply","supreme","sure","surface","surge","surprise","surround","survey","suspect","sustain","swallow","swamp","swap","swarm","swear","sweet","swift","swim","swing","switch","sword","symbol","symptom","syrup","system","table","tackle","tag","tail","talent","talk","tank","tape","target","task","taste","tattoo","taxi","teach","team","tell","ten","tenant","tennis","tent","term","test","text","thank","that","theme","then","theory","there","they","thing","this","thought","three","thrive","throw","thumb","thunder","ticket","tide","tiger","tilt","timber","time","tiny","tip","tired","tissue","title","toast","tobacco","today","toddler","toe","together","toilet","token","tomato","tomorrow","tone","tongue","tonight","tool","tooth","top","topic","topple","torch","tornado","tortoise","toss","total","tourist","toward","tower","town","toy","track","trade","traffic","tragic","train","transfer","trap","trash","travel","tray","treat","tree","trend","trial","tribe","trick","trigger","trim","trip","trophy","trouble","truck","true","truly","trumpet","trust","truth","try","tube","tuition","tumble","tuna","tunnel","turkey","turn","turtle","twelve","twenty","twice","twin","twist","two","type","typical","ugly","umbrella","unable","unaware","uncle","uncover","under","undo","unfair","unfold","unhappy","uniform","unique","unit","universe","unknown","unlock","until","unusual","unveil","update","upgrade","uphold","upon","upper","upset","urban","urge","usage","use","used","useful","useless","usual","utility","vacant","vacuum","vague","valid","valley","valve","van","vanish","vapor","various","vast","vault","vehicle","velvet","vendor","venture","venue","verb","verify","version","very","vessel","veteran","viable","vibrant","vicious","victory","video","view","village","vintage","violin","virtual","virus","visa","visit","visual","vital","vivid","vocal","voice","void","volcano","volume","vote","voyage","wage","wagon","wait","walk","wall","walnut","want","warfare","warm","warrior","wash","wasp","waste","water","wave","way","wealth","weapon","wear","weasel","weather","web","wedding","weekend","weird","welcome","west","wet","whale","what","wheat","wheel","when","where","whip","whisper","wide","width","wife","wild","will","win","window","wine","wing","wink","winner","winter","wire","wisdom","wise","wish","witness","wolf","woman","wonder","wood","wool","word","work","world","worry","worth","wrap","wreck","wrestle","wrist","write","wrong","yard","year","yellow","you","young","youth","zebra","zero","zone","zoo"]');
var Zu;
function Yu() {
  if (Zu) return We;
  Zu = 1, Object.defineProperty(We, "__esModule", { value: !0 });
  const e = {};
  We.wordlists = e;
  let t;
  We._default = t;
  try {
    We._default = t = Ym, e.czech = t;
  } catch {
  }
  try {
    We._default = t = Xm, e.chinese_simplified = t;
  } catch {
  }
  try {
    We._default = t = Jm, e.chinese_traditional = t;
  } catch {
  }
  try {
    We._default = t = Qm, e.korean = t;
  } catch {
  }
  try {
    We._default = t = ey, e.french = t;
  } catch {
  }
  try {
    We._default = t = ry, e.italian = t;
  } catch {
  }
  try {
    We._default = t = ty, e.spanish = t;
  } catch {
  }
  try {
    We._default = t = ny, e.japanese = t, e.JA = t;
  } catch {
  }
  try {
    We._default = t = ay, e.portuguese = t;
  } catch {
  }
  try {
    We._default = t = oy, e.english = t, e.EN = t;
  } catch {
  }
  return We;
}
var Xu;
function iy() {
  if (Xu) return ir;
  Xu = 1, Object.defineProperty(ir, "__esModule", { value: !0 });
  const e = /* @__PURE__ */ kn(), t = /* @__PURE__ */ hf(), r = /* @__PURE__ */ uh(), n = /* @__PURE__ */ lh(), o = Yu();
  let a = o._default;
  const s = "Invalid mnemonic", i = "Invalid entropy", h = "Invalid mnemonic checksum", l = `A wordlist is required but a default could not be found.
Please pass a 2048 word array explicitly.`;
  function c(O) {
    return (O || "").normalize("NFKD");
  }
  function w(O, R, U) {
    for (; O.length < U; )
      O = R + O;
    return O;
  }
  function g(O) {
    return parseInt(O, 2);
  }
  function v(O) {
    return O.map((R) => w(R.toString(2), "0", 8)).join("");
  }
  function k(O) {
    const U = O.length * 8 / 32, T = e.sha256(Uint8Array.from(O));
    return v(Array.from(T)).slice(0, U);
  }
  function y(O) {
    return "mnemonic" + (O || "");
  }
  function m(O, R) {
    const U = Uint8Array.from(J.from(c(O), "utf8")), T = Uint8Array.from(J.from(y(c(R)), "utf8")), Z = r.pbkdf2(t.sha512, U, T, {
      c: 2048,
      dkLen: 64
    });
    return J.from(Z);
  }
  ir.mnemonicToSeedSync = m;
  function A(O, R) {
    const U = Uint8Array.from(J.from(c(O), "utf8")), T = Uint8Array.from(J.from(y(c(R)), "utf8"));
    return r.pbkdf2Async(t.sha512, U, T, {
      c: 2048,
      dkLen: 64
    }).then((Z) => J.from(Z));
  }
  ir.mnemonicToSeed = A;
  function E(O, R) {
    if (R = R || a, !R)
      throw new Error(l);
    const U = c(O).split(" ");
    if (U.length % 3 !== 0)
      throw new Error(s);
    const T = U.map((me) => {
      const Se = R.indexOf(me);
      if (Se === -1)
        throw new Error(s);
      return w(Se.toString(2), "0", 11);
    }).join(""), Z = Math.floor(T.length / 33) * 32, re = T.slice(0, Z), oe = T.slice(Z), ue = re.match(/(.{1,8})/g).map(g);
    if (ue.length < 16)
      throw new Error(i);
    if (ue.length > 32)
      throw new Error(i);
    if (ue.length % 4 !== 0)
      throw new Error(i);
    const ie = J.from(ue);
    if (k(ie) !== oe)
      throw new Error(h);
    return ie.toString("hex");
  }
  ir.mnemonicToEntropy = E;
  function x(O, R) {
    if (J.isBuffer(O) || (O = J.from(O, "hex")), R = R || a, !R)
      throw new Error(l);
    if (O.length < 16)
      throw new TypeError(i);
    if (O.length > 32)
      throw new TypeError(i);
    if (O.length % 4 !== 0)
      throw new TypeError(i);
    const U = v(Array.from(O)), T = k(O), oe = (U + T).match(/(.{1,11})/g).map((ue) => {
      const ie = g(ue);
      return R[ie];
    });
    return R[0] === "" ? oe.join("") : oe.join(" ");
  }
  ir.entropyToMnemonic = x;
  function z(O, R, U) {
    if (O = O || 128, O % 32 !== 0)
      throw new TypeError(i);
    return R = R || ((T) => J.from(n.randomBytes(T))), x(R(O / 8), U);
  }
  ir.generateMnemonic = z;
  function F(O, R) {
    try {
      E(O, R);
    } catch {
      return !1;
    }
    return !0;
  }
  ir.validateMnemonic = F;
  function j(O) {
    const R = o.wordlists[O];
    if (R)
      a = R;
    else
      throw new Error('Could not find wordlist for language "' + O + '"');
  }
  ir.setDefaultWordlist = j;
  function I() {
    if (!a)
      throw new Error("No Default Wordlist set");
    return Object.keys(o.wordlists).filter((O) => O === "JA" || O === "EN" ? !1 : o.wordlists[O].every((R, U) => R === a[U]))[0];
  }
  ir.getDefaultWordlist = I;
  var N = Yu();
  return ir.wordlists = N.wordlists, ir;
}
var _v = iy(), bo = { exports: {} }, Yn = { exports: {} };
function sy(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Ld = { exports: {} }, Fe = Ld.exports = {}, wr, _r;
function es() {
  throw new Error("setTimeout has not been defined");
}
function rs() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? wr = setTimeout : wr = es;
  } catch {
    wr = es;
  }
  try {
    typeof clearTimeout == "function" ? _r = clearTimeout : _r = rs;
  } catch {
    _r = rs;
  }
})();
function qd(e) {
  if (wr === setTimeout)
    return setTimeout(e, 0);
  if ((wr === es || !wr) && setTimeout)
    return wr = setTimeout, setTimeout(e, 0);
  try {
    return wr(e, 0);
  } catch {
    try {
      return wr.call(null, e, 0);
    } catch {
      return wr.call(this, e, 0);
    }
  }
}
function cy(e) {
  if (_r === clearTimeout)
    return clearTimeout(e);
  if ((_r === rs || !_r) && clearTimeout)
    return _r = clearTimeout, clearTimeout(e);
  try {
    return _r(e);
  } catch {
    try {
      return _r.call(null, e);
    } catch {
      return _r.call(this, e);
    }
  }
}
var Nr = [], Nt = !1, bt, ua = -1;
function uy() {
  !Nt || !bt || (Nt = !1, bt.length ? Nr = bt.concat(Nr) : ua = -1, Nr.length && Md());
}
function Md() {
  if (!Nt) {
    var e = qd(uy);
    Nt = !0;
    for (var t = Nr.length; t; ) {
      for (bt = Nr, Nr = []; ++ua < t; )
        bt && bt[ua].run();
      ua = -1, t = Nr.length;
    }
    bt = null, Nt = !1, cy(e);
  }
}
Fe.nextTick = function(e) {
  var t = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var r = 1; r < arguments.length; r++)
      t[r - 1] = arguments[r];
  Nr.push(new Dd(e, t)), Nr.length === 1 && !Nt && qd(Md);
};
function Dd(e, t) {
  this.fun = e, this.array = t;
}
Dd.prototype.run = function() {
  this.fun.apply(null, this.array);
};
Fe.title = "browser";
Fe.browser = !0;
Fe.env = {};
Fe.argv = [];
Fe.version = "";
Fe.versions = {};
function Cr() {
}
Fe.on = Cr;
Fe.addListener = Cr;
Fe.once = Cr;
Fe.off = Cr;
Fe.removeListener = Cr;
Fe.removeAllListeners = Cr;
Fe.emit = Cr;
Fe.prependListener = Cr;
Fe.prependOnceListener = Cr;
Fe.listeners = function(e) {
  return [];
};
Fe.binding = function(e) {
  throw new Error("process.binding is not supported");
};
Fe.cwd = function() {
  return "/";
};
Fe.chdir = function(e) {
  throw new Error("process.chdir is not supported");
};
Fe.umask = function() {
  return 0;
};
var ly = Ld.exports;
const yr = /* @__PURE__ */ sy(ly);
var mo = {}, yo = {}, vo, Ju;
function Fd() {
  return Ju || (Ju = 1, vo = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var t = {}, r = /* @__PURE__ */ Symbol("test"), n = Object(r);
    if (typeof r == "string" || Object.prototype.toString.call(r) !== "[object Symbol]" || Object.prototype.toString.call(n) !== "[object Symbol]")
      return !1;
    var o = 42;
    t[r] = o;
    for (var a in t)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
      return !1;
    var s = Object.getOwnPropertySymbols(t);
    if (s.length !== 1 || s[0] !== r || !Object.prototype.propertyIsEnumerable.call(t, r))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var i = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(t, r)
      );
      if (i.value !== o || i.enumerable !== !0)
        return !1;
    }
    return !0;
  }), vo;
}
var wo, Qu;
function za() {
  if (Qu) return wo;
  Qu = 1;
  var e = Fd();
  return wo = function() {
    return e() && !!Symbol.toStringTag;
  }, wo;
}
var _o, el;
function Kd() {
  return el || (el = 1, _o = Object), _o;
}
var ko, rl;
function fy() {
  return rl || (rl = 1, ko = Error), ko;
}
var Eo, tl;
function dy() {
  return tl || (tl = 1, Eo = EvalError), Eo;
}
var xo, nl;
function hy() {
  return nl || (nl = 1, xo = RangeError), xo;
}
var Ao, al;
function py() {
  return al || (al = 1, Ao = ReferenceError), Ao;
}
var So, ol;
function Hd() {
  return ol || (ol = 1, So = SyntaxError), So;
}
var Io, il;
function Gt() {
  return il || (il = 1, Io = TypeError), Io;
}
var Bo, sl;
function gy() {
  return sl || (sl = 1, Bo = URIError), Bo;
}
var To, cl;
function by() {
  return cl || (cl = 1, To = Math.abs), To;
}
var zo, ul;
function my() {
  return ul || (ul = 1, zo = Math.floor), zo;
}
var Oo, ll;
function yy() {
  return ll || (ll = 1, Oo = Math.max), Oo;
}
var Ro, fl;
function vy() {
  return fl || (fl = 1, Ro = Math.min), Ro;
}
var jo, dl;
function wy() {
  return dl || (dl = 1, jo = Math.pow), jo;
}
var Po, hl;
function _y() {
  return hl || (hl = 1, Po = Math.round), Po;
}
var Uo, pl;
function ky() {
  return pl || (pl = 1, Uo = Number.isNaN || function(t) {
    return t !== t;
  }), Uo;
}
var No, gl;
function Ey() {
  if (gl) return No;
  gl = 1;
  var e = /* @__PURE__ */ ky();
  return No = function(r) {
    return e(r) || r === 0 ? r : r < 0 ? -1 : 1;
  }, No;
}
var Co, bl;
function xy() {
  return bl || (bl = 1, Co = Object.getOwnPropertyDescriptor), Co;
}
var Lo, ml;
function Wt() {
  if (ml) return Lo;
  ml = 1;
  var e = /* @__PURE__ */ xy();
  if (e)
    try {
      e([], "length");
    } catch {
      e = null;
    }
  return Lo = e, Lo;
}
var qo, yl;
function Oa() {
  if (yl) return qo;
  yl = 1;
  var e = Object.defineProperty || !1;
  if (e)
    try {
      e({}, "a", { value: 1 });
    } catch {
      e = !1;
    }
  return qo = e, qo;
}
var Mo, vl;
function Ay() {
  if (vl) return Mo;
  vl = 1;
  var e = typeof Symbol < "u" && Symbol, t = Fd();
  return Mo = function() {
    return typeof e != "function" || typeof Symbol != "function" || typeof e("foo") != "symbol" || typeof /* @__PURE__ */ Symbol("bar") != "symbol" ? !1 : t();
  }, Mo;
}
var Do, wl;
function $d() {
  return wl || (wl = 1, Do = typeof Reflect < "u" && Reflect.getPrototypeOf || null), Do;
}
var Fo, _l;
function Gd() {
  if (_l) return Fo;
  _l = 1;
  var e = /* @__PURE__ */ Kd();
  return Fo = e.getPrototypeOf || null, Fo;
}
var Ko, kl;
function Sy() {
  if (kl) return Ko;
  kl = 1;
  var e = "Function.prototype.bind called on incompatible ", t = Object.prototype.toString, r = Math.max, n = "[object Function]", o = function(h, l) {
    for (var c = [], w = 0; w < h.length; w += 1)
      c[w] = h[w];
    for (var g = 0; g < l.length; g += 1)
      c[g + h.length] = l[g];
    return c;
  }, a = function(h, l) {
    for (var c = [], w = l, g = 0; w < h.length; w += 1, g += 1)
      c[g] = h[w];
    return c;
  }, s = function(i, h) {
    for (var l = "", c = 0; c < i.length; c += 1)
      l += i[c], c + 1 < i.length && (l += h);
    return l;
  };
  return Ko = function(h) {
    var l = this;
    if (typeof l != "function" || t.apply(l) !== n)
      throw new TypeError(e + l);
    for (var c = a(arguments, 1), w, g = function() {
      if (this instanceof w) {
        var A = l.apply(
          this,
          o(c, arguments)
        );
        return Object(A) === A ? A : this;
      }
      return l.apply(
        h,
        o(c, arguments)
      );
    }, v = r(0, l.length - c.length), k = [], y = 0; y < v; y++)
      k[y] = "$" + y;
    if (w = Function("binder", "return function (" + s(k, ",") + "){ return binder.apply(this,arguments); }")(g), l.prototype) {
      var m = function() {
      };
      m.prototype = l.prototype, w.prototype = new m(), m.prototype = null;
    }
    return w;
  }, Ko;
}
var Ho, El;
function On() {
  if (El) return Ho;
  El = 1;
  var e = Sy();
  return Ho = Function.prototype.bind || e, Ho;
}
var $o, xl;
function Ts() {
  return xl || (xl = 1, $o = Function.prototype.call), $o;
}
var Go, Al;
function zs() {
  return Al || (Al = 1, Go = Function.prototype.apply), Go;
}
var Wo, Sl;
function Iy() {
  return Sl || (Sl = 1, Wo = typeof Reflect < "u" && Reflect && Reflect.apply), Wo;
}
var Vo, Il;
function Wd() {
  if (Il) return Vo;
  Il = 1;
  var e = On(), t = zs(), r = Ts(), n = Iy();
  return Vo = n || e.call(r, t), Vo;
}
var Zo, Bl;
function Os() {
  if (Bl) return Zo;
  Bl = 1;
  var e = On(), t = /* @__PURE__ */ Gt(), r = Ts(), n = Wd();
  return Zo = function(a) {
    if (a.length < 1 || typeof a[0] != "function")
      throw new t("a function is required");
    return n(e, r, a);
  }, Zo;
}
var Yo, Tl;
function By() {
  if (Tl) return Yo;
  Tl = 1;
  var e = Os(), t = /* @__PURE__ */ Wt(), r;
  try {
    r = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (s) {
    if (!s || typeof s != "object" || !("code" in s) || s.code !== "ERR_PROTO_ACCESS")
      throw s;
  }
  var n = !!r && t && t(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  ), o = Object, a = o.getPrototypeOf;
  return Yo = n && typeof n.get == "function" ? e([n.get]) : typeof a == "function" ? (
    /** @type {import('./get')} */
    function(i) {
      return a(i == null ? i : o(i));
    }
  ) : !1, Yo;
}
var Xo, zl;
function Rs() {
  if (zl) return Xo;
  zl = 1;
  var e = $d(), t = Gd(), r = /* @__PURE__ */ By();
  return Xo = e ? function(o) {
    return e(o);
  } : t ? function(o) {
    if (!o || typeof o != "object" && typeof o != "function")
      throw new TypeError("getProto: not an object");
    return t(o);
  } : r ? function(o) {
    return r(o);
  } : null, Xo;
}
var Jo, Ol;
function Vd() {
  if (Ol) return Jo;
  Ol = 1;
  var e = Function.prototype.call, t = Object.prototype.hasOwnProperty, r = On();
  return Jo = r.call(e, t), Jo;
}
var Qo, Rl;
function Zd() {
  if (Rl) return Qo;
  Rl = 1;
  var e, t = /* @__PURE__ */ Kd(), r = /* @__PURE__ */ fy(), n = /* @__PURE__ */ dy(), o = /* @__PURE__ */ hy(), a = /* @__PURE__ */ py(), s = /* @__PURE__ */ Hd(), i = /* @__PURE__ */ Gt(), h = /* @__PURE__ */ gy(), l = /* @__PURE__ */ by(), c = /* @__PURE__ */ my(), w = /* @__PURE__ */ yy(), g = /* @__PURE__ */ vy(), v = /* @__PURE__ */ wy(), k = /* @__PURE__ */ _y(), y = /* @__PURE__ */ Ey(), m = Function, A = function(ee) {
    try {
      return m('"use strict"; return (' + ee + ").constructor;")();
    } catch {
    }
  }, E = /* @__PURE__ */ Wt(), x = /* @__PURE__ */ Oa(), z = function() {
    throw new i();
  }, F = E ? (function() {
    try {
      return arguments.callee, z;
    } catch {
      try {
        return E(arguments, "callee").get;
      } catch {
        return z;
      }
    }
  })() : z, j = Ay()(), I = Rs(), N = Gd(), O = $d(), R = zs(), U = Ts(), T = {}, Z = typeof Uint8Array > "u" || !I ? e : I(Uint8Array), re = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError > "u" ? e : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? e : ArrayBuffer,
    "%ArrayIteratorPrototype%": j && I ? I([][Symbol.iterator]()) : e,
    "%AsyncFromSyncIteratorPrototype%": e,
    "%AsyncFunction%": T,
    "%AsyncGenerator%": T,
    "%AsyncGeneratorFunction%": T,
    "%AsyncIteratorPrototype%": T,
    "%Atomics%": typeof Atomics > "u" ? e : Atomics,
    "%BigInt%": typeof BigInt > "u" ? e : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? e : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? e : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? e : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": r,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": n,
    "%Float16Array%": typeof Float16Array > "u" ? e : Float16Array,
    "%Float32Array%": typeof Float32Array > "u" ? e : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? e : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? e : FinalizationRegistry,
    "%Function%": m,
    "%GeneratorFunction%": T,
    "%Int8Array%": typeof Int8Array > "u" ? e : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? e : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? e : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": j && I ? I(I([][Symbol.iterator]())) : e,
    "%JSON%": typeof JSON == "object" ? JSON : e,
    "%Map%": typeof Map > "u" ? e : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !j || !I ? e : I((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": t,
    "%Object.getOwnPropertyDescriptor%": E,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? e : Promise,
    "%Proxy%": typeof Proxy > "u" ? e : Proxy,
    "%RangeError%": o,
    "%ReferenceError%": a,
    "%Reflect%": typeof Reflect > "u" ? e : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? e : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !j || !I ? e : I((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? e : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": j && I ? I(""[Symbol.iterator]()) : e,
    "%Symbol%": j ? Symbol : e,
    "%SyntaxError%": s,
    "%ThrowTypeError%": F,
    "%TypedArray%": Z,
    "%TypeError%": i,
    "%Uint8Array%": typeof Uint8Array > "u" ? e : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? e : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? e : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? e : Uint32Array,
    "%URIError%": h,
    "%WeakMap%": typeof WeakMap > "u" ? e : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? e : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? e : WeakSet,
    "%Function.prototype.call%": U,
    "%Function.prototype.apply%": R,
    "%Object.defineProperty%": x,
    "%Object.getPrototypeOf%": N,
    "%Math.abs%": l,
    "%Math.floor%": c,
    "%Math.max%": w,
    "%Math.min%": g,
    "%Math.pow%": v,
    "%Math.round%": k,
    "%Math.sign%": y,
    "%Reflect.getPrototypeOf%": O
  };
  if (I)
    try {
      null.error;
    } catch (ee) {
      var oe = I(I(ee));
      re["%Error.prototype%"] = oe;
    }
  var ue = function ee(ne) {
    var se;
    if (ne === "%AsyncFunction%")
      se = A("async function () {}");
    else if (ne === "%GeneratorFunction%")
      se = A("function* () {}");
    else if (ne === "%AsyncGeneratorFunction%")
      se = A("async function* () {}");
    else if (ne === "%AsyncGenerator%") {
      var ce = ee("%AsyncGeneratorFunction%");
      ce && (se = ce.prototype);
    } else if (ne === "%AsyncIteratorPrototype%") {
      var le = ee("%AsyncGenerator%");
      le && I && (se = I(le.prototype));
    }
    return re[ne] = se, se;
  }, ie = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  }, de = On(), me = /* @__PURE__ */ Vd(), Se = de.call(U, Array.prototype.concat), De = de.call(R, Array.prototype.splice), q = de.call(U, String.prototype.replace), H = de.call(U, String.prototype.slice), C = de.call(U, RegExp.prototype.exec), G = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, V = /\\(\\)?/g, X = function(ne) {
    var se = H(ne, 0, 1), ce = H(ne, -1);
    if (se === "%" && ce !== "%")
      throw new s("invalid intrinsic syntax, expected closing `%`");
    if (ce === "%" && se !== "%")
      throw new s("invalid intrinsic syntax, expected opening `%`");
    var le = [];
    return q(ne, G, function(he, ye, pe, we) {
      le[le.length] = pe ? q(we, V, "$1") : ye || he;
    }), le;
  }, Q = function(ne, se) {
    var ce = ne, le;
    if (me(ie, ce) && (le = ie[ce], ce = "%" + le[0] + "%"), me(re, ce)) {
      var he = re[ce];
      if (he === T && (he = ue(ce)), typeof he > "u" && !se)
        throw new i("intrinsic " + ne + " exists, but is not available. Please file an issue!");
      return {
        alias: le,
        name: ce,
        value: he
      };
    }
    throw new s("intrinsic " + ne + " does not exist!");
  };
  return Qo = function(ne, se) {
    if (typeof ne != "string" || ne.length === 0)
      throw new i("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof se != "boolean")
      throw new i('"allowMissing" argument must be a boolean');
    if (C(/^%?[^%]*%?$/, ne) === null)
      throw new s("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var ce = X(ne), le = ce.length > 0 ? ce[0] : "", he = Q("%" + le + "%", se), ye = he.name, pe = he.value, we = !1, Oe = he.alias;
    Oe && (le = Oe[0], De(ce, Se([0, 1], Oe)));
    for (var $ = 1, Re = !0; $ < ce.length; $ += 1) {
      var ae = ce[$], fe = H(ae, 0, 1), ge = H(ae, -1);
      if ((fe === '"' || fe === "'" || fe === "`" || ge === '"' || ge === "'" || ge === "`") && fe !== ge)
        throw new s("property names with quotes must have matching quotes");
      if ((ae === "constructor" || !Re) && (we = !0), le += "." + ae, ye = "%" + le + "%", me(re, ye))
        pe = re[ye];
      else if (pe != null) {
        if (!(ae in pe)) {
          if (!se)
            throw new i("base intrinsic for " + ne + " exists, but the property is not available.");
          return;
        }
        if (E && $ + 1 >= ce.length) {
          var xe = E(pe, ae);
          Re = !!xe, Re && "get" in xe && !("originalValue" in xe.get) ? pe = xe.get : pe = pe[ae];
        } else
          Re = me(pe, ae), pe = pe[ae];
        Re && !we && (re[ye] = pe);
      }
    }
    return pe;
  }, Qo;
}
var ei, jl;
function Vt() {
  if (jl) return ei;
  jl = 1;
  var e = /* @__PURE__ */ Zd(), t = Os(), r = t([e("%String.prototype.indexOf%")]);
  return ei = function(o, a) {
    var s = (
      /** @type {(this: unknown, ...args: unknown[]) => unknown} */
      e(o, !!a)
    );
    return typeof s == "function" && r(o, ".prototype.") > -1 ? t(
      /** @type {const} */
      [s]
    ) : s;
  }, ei;
}
var ri, Pl;
function Ty() {
  if (Pl) return ri;
  Pl = 1;
  var e = za()(), t = /* @__PURE__ */ Vt(), r = t("Object.prototype.toString"), n = function(i) {
    return e && i && typeof i == "object" && Symbol.toStringTag in i ? !1 : r(i) === "[object Arguments]";
  }, o = function(i) {
    return n(i) ? !0 : i !== null && typeof i == "object" && "length" in i && typeof i.length == "number" && i.length >= 0 && r(i) !== "[object Array]" && "callee" in i && r(i.callee) === "[object Function]";
  }, a = (function() {
    return n(arguments);
  })();
  return n.isLegacyArguments = o, ri = a ? n : o, ri;
}
var ti, Ul;
function zy() {
  if (Ul) return ti;
  Ul = 1;
  var e = /* @__PURE__ */ Vt(), t = za()(), r = /* @__PURE__ */ Vd(), n = /* @__PURE__ */ Wt(), o;
  if (t) {
    var a = e("RegExp.prototype.exec"), s = {}, i = function() {
      throw s;
    }, h = {
      toString: i,
      valueOf: i
    };
    typeof Symbol.toPrimitive == "symbol" && (h[Symbol.toPrimitive] = i), o = function(g) {
      if (!g || typeof g != "object")
        return !1;
      var v = (
        /** @type {NonNullable<typeof gOPD>} */
        n(
          /** @type {{ lastIndex?: unknown }} */
          g,
          "lastIndex"
        )
      ), k = v && r(v, "value");
      if (!k)
        return !1;
      try {
        a(
          g,
          /** @type {string} */
          /** @type {unknown} */
          h
        );
      } catch (y) {
        return y === s;
      }
    };
  } else {
    var l = e("Object.prototype.toString"), c = "[object RegExp]";
    o = function(g) {
      return !g || typeof g != "object" && typeof g != "function" ? !1 : l(g) === c;
    };
  }
  return ti = o, ti;
}
var ni, Nl;
function Oy() {
  if (Nl) return ni;
  Nl = 1;
  var e = /* @__PURE__ */ Vt(), t = zy(), r = e("RegExp.prototype.exec"), n = /* @__PURE__ */ Gt();
  return ni = function(a) {
    if (!t(a))
      throw new n("`regex` must be a RegExp");
    return function(i) {
      return r(a, i) !== null;
    };
  }, ni;
}
var ai, Cl;
function Ry() {
  if (Cl) return ai;
  Cl = 1;
  const e = (
    /** @type {GeneratorFunctionConstructor} */
    function* () {
    }.constructor
  );
  return ai = () => e, ai;
}
var oi, Ll;
function jy() {
  if (Ll) return oi;
  Ll = 1;
  var e = /* @__PURE__ */ Vt(), t = /* @__PURE__ */ Oy(), r = t(/^\s*(?:function)?\*/), n = za()(), o = Rs(), a = e("Object.prototype.toString"), s = e("Function.prototype.toString"), i = /* @__PURE__ */ Ry();
  return oi = function(l) {
    if (typeof l != "function")
      return !1;
    if (r(s(l)))
      return !0;
    if (!n) {
      var c = a(l);
      return c === "[object GeneratorFunction]";
    }
    if (!o)
      return !1;
    var w = i();
    return w && o(l) === w.prototype;
  }, oi;
}
var ii, ql;
function Py() {
  if (ql) return ii;
  ql = 1;
  var e = Function.prototype.toString, t = typeof Reflect == "object" && Reflect !== null && Reflect.apply, r, n;
  if (typeof t == "function" && typeof Object.defineProperty == "function")
    try {
      r = Object.defineProperty({}, "length", {
        get: function() {
          throw n;
        }
      }), n = {}, t(function() {
        throw 42;
      }, null, r);
    } catch (E) {
      E !== n && (t = null);
    }
  else
    t = null;
  var o = /^\s*class\b/, a = function(x) {
    try {
      var z = e.call(x);
      return o.test(z);
    } catch {
      return !1;
    }
  }, s = function(x) {
    try {
      return a(x) ? !1 : (e.call(x), !0);
    } catch {
      return !1;
    }
  }, i = Object.prototype.toString, h = "[object Object]", l = "[object Function]", c = "[object GeneratorFunction]", w = "[object HTMLAllCollection]", g = "[object HTML document.all class]", v = "[object HTMLCollection]", k = typeof Symbol == "function" && !!Symbol.toStringTag, y = !(0 in [,]), m = function() {
    return !1;
  };
  if (typeof document == "object") {
    var A = document.all;
    i.call(A) === i.call(document.all) && (m = function(x) {
      if ((y || !x) && (typeof x > "u" || typeof x == "object"))
        try {
          var z = i.call(x);
          return (z === w || z === g || z === v || z === h) && x("") == null;
        } catch {
        }
      return !1;
    });
  }
  return ii = t ? function(x) {
    if (m(x))
      return !0;
    if (!x || typeof x != "function" && typeof x != "object")
      return !1;
    try {
      t(x, null, r);
    } catch (z) {
      if (z !== n)
        return !1;
    }
    return !a(x) && s(x);
  } : function(x) {
    if (m(x))
      return !0;
    if (!x || typeof x != "function" && typeof x != "object")
      return !1;
    if (k)
      return s(x);
    if (a(x))
      return !1;
    var z = i.call(x);
    return z !== l && z !== c && !/^\[object HTML/.test(z) ? !1 : s(x);
  }, ii;
}
var si, Ml;
function Uy() {
  if (Ml) return si;
  Ml = 1;
  var e = Py(), t = Object.prototype.toString, r = Object.prototype.hasOwnProperty, n = function(h, l, c) {
    for (var w = 0, g = h.length; w < g; w++)
      r.call(h, w) && (c == null ? l(h[w], w, h) : l.call(c, h[w], w, h));
  }, o = function(h, l, c) {
    for (var w = 0, g = h.length; w < g; w++)
      c == null ? l(h.charAt(w), w, h) : l.call(c, h.charAt(w), w, h);
  }, a = function(h, l, c) {
    for (var w in h)
      r.call(h, w) && (c == null ? l(h[w], w, h) : l.call(c, h[w], w, h));
  };
  function s(i) {
    return t.call(i) === "[object Array]";
  }
  return si = function(h, l, c) {
    if (!e(l))
      throw new TypeError("iterator must be a function");
    var w;
    arguments.length >= 3 && (w = c), s(h) ? n(h, l, w) : typeof h == "string" ? o(h, l, w) : a(h, l, w);
  }, si;
}
var ci, Dl;
function Ny() {
  return Dl || (Dl = 1, ci = [
    "Float16Array",
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Int16Array",
    "Int32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array"
  ]), ci;
}
var ui, Fl;
function Cy() {
  if (Fl) return ui;
  Fl = 1;
  var e = /* @__PURE__ */ Ny(), t = globalThis;
  return ui = function() {
    for (var n = [], o = 0; o < e.length; o++)
      typeof t[e[o]] == "function" && (n[n.length] = e[o]);
    return n;
  }, ui;
}
var li = { exports: {} }, fi, Kl;
function Ly() {
  if (Kl) return fi;
  Kl = 1;
  var e = /* @__PURE__ */ Oa(), t = /* @__PURE__ */ Hd(), r = /* @__PURE__ */ Gt(), n = /* @__PURE__ */ Wt();
  return fi = function(a, s, i) {
    if (!a || typeof a != "object" && typeof a != "function")
      throw new r("`obj` must be an object or a function`");
    if (typeof s != "string" && typeof s != "symbol")
      throw new r("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
      throw new r("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
      throw new r("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
      throw new r("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean")
      throw new r("`loose`, if provided, must be a boolean");
    var h = arguments.length > 3 ? arguments[3] : null, l = arguments.length > 4 ? arguments[4] : null, c = arguments.length > 5 ? arguments[5] : null, w = arguments.length > 6 ? arguments[6] : !1, g = !!n && n(a, s);
    if (e)
      e(a, s, {
        configurable: c === null && g ? g.configurable : !c,
        enumerable: h === null && g ? g.enumerable : !h,
        value: i,
        writable: l === null && g ? g.writable : !l
      });
    else if (w || !h && !l && !c)
      a[s] = i;
    else
      throw new t("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }, fi;
}
var di, Hl;
function qy() {
  if (Hl) return di;
  Hl = 1;
  var e = /* @__PURE__ */ Oa(), t = function() {
    return !!e;
  };
  return t.hasArrayLengthDefineBug = function() {
    if (!e)
      return null;
    try {
      return e([], "length", { value: 1 }).length !== 1;
    } catch {
      return !0;
    }
  }, di = t, di;
}
var hi, $l;
function My() {
  if ($l) return hi;
  $l = 1;
  var e = /* @__PURE__ */ Zd(), t = /* @__PURE__ */ Ly(), r = /* @__PURE__ */ qy()(), n = /* @__PURE__ */ Wt(), o = /* @__PURE__ */ Gt(), a = e("%Math.floor%");
  return hi = function(i, h) {
    if (typeof i != "function")
      throw new o("`fn` is not a function");
    if (typeof h != "number" || h < 0 || h > 4294967295 || a(h) !== h)
      throw new o("`length` must be a positive 32-bit integer");
    var l = arguments.length > 2 && !!arguments[2], c = !0, w = !0;
    if ("length" in i && n) {
      var g = n(i, "length");
      g && !g.configurable && (c = !1), g && !g.writable && (w = !1);
    }
    return (c || w || !l) && (r ? t(
      /** @type {Parameters<define>[0]} */
      i,
      "length",
      h,
      !0,
      !0
    ) : t(
      /** @type {Parameters<define>[0]} */
      i,
      "length",
      h
    )), i;
  }, hi;
}
var pi, Gl;
function Dy() {
  if (Gl) return pi;
  Gl = 1;
  var e = On(), t = zs(), r = Wd();
  return pi = function() {
    return r(e, t, arguments);
  }, pi;
}
var Wl;
function Fy() {
  return Wl || (Wl = 1, (function(e) {
    var t = /* @__PURE__ */ My(), r = /* @__PURE__ */ Oa(), n = Os(), o = Dy();
    e.exports = function(s) {
      var i = n(arguments), h = s.length - (arguments.length - 1);
      return t(
        i,
        1 + (h > 0 ? h : 0),
        !0
      );
    }, r ? r(e.exports, "apply", { value: o }) : e.exports.apply = o;
  })(li)), li.exports;
}
var gi, Vl;
function Yd() {
  if (Vl) return gi;
  Vl = 1;
  var e = Uy(), t = /* @__PURE__ */ Cy(), r = Fy(), n = /* @__PURE__ */ Vt(), o = /* @__PURE__ */ Wt(), a = Rs(), s = n("Object.prototype.toString"), i = za()(), h = globalThis, l = t(), c = n("String.prototype.slice"), w = n("Array.prototype.indexOf", !0) || function(m, A) {
    for (var E = 0; E < m.length; E += 1)
      if (m[E] === A)
        return E;
    return -1;
  }, g = { __proto__: null };
  i && o && a ? e(l, function(y) {
    var m = new h[y]();
    if (Symbol.toStringTag in m && a) {
      var A = a(m), E = o(A, Symbol.toStringTag);
      if (!E && A) {
        var x = a(A);
        E = o(x, Symbol.toStringTag);
      }
      g["$" + y] = r(E.get);
    }
  }) : e(l, function(y) {
    var m = new h[y](), A = m.slice || m.set;
    A && (g[
      /** @type {`$${import('.').TypedArrayName}`} */
      "$" + y
    ] = /** @type {import('./types').BoundSlice | import('./types').BoundSet} */
    // @ts-expect-error TODO FIXME
    r(A));
  });
  var v = function(m) {
    var A = !1;
    return e(
      /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
      g,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(E, x) {
        if (!A)
          try {
            "$" + E(m) === x && (A = /** @type {import('.').TypedArrayName} */
            c(x, 1));
          } catch {
          }
      }
    ), A;
  }, k = function(m) {
    var A = !1;
    return e(
      /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
      g,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(E, x) {
        if (!A)
          try {
            E(m), A = /** @type {import('.').TypedArrayName} */
            c(x, 1);
          } catch {
          }
      }
    ), A;
  };
  return gi = function(m) {
    if (!m || typeof m != "object")
      return !1;
    if (!i) {
      var A = c(s(m), 8, -1);
      return w(l, A) > -1 ? A : A !== "Object" ? !1 : k(m);
    }
    return o ? v(m) : null;
  }, gi;
}
var bi, Zl;
function Xd() {
  if (Zl) return bi;
  Zl = 1;
  var e = /* @__PURE__ */ Yd();
  return bi = function(r) {
    return !!e(r);
  }, bi;
}
var Yl;
function Ky() {
  return Yl || (Yl = 1, (function(e) {
    var t = /* @__PURE__ */ Ty(), r = jy(), n = /* @__PURE__ */ Yd(), o = /* @__PURE__ */ Xd();
    function a($) {
      return $.call.bind($);
    }
    var s = typeof BigInt < "u", i = typeof Symbol < "u", h = a(Object.prototype.toString), l = a(Number.prototype.valueOf), c = a(String.prototype.valueOf), w = a(Boolean.prototype.valueOf);
    if (s)
      var g = a(BigInt.prototype.valueOf);
    if (i)
      var v = a(Symbol.prototype.valueOf);
    function k($, Re) {
      if (typeof $ != "object")
        return !1;
      try {
        return Re($), !0;
      } catch {
        return !1;
      }
    }
    e.isArgumentsObject = t, e.isGeneratorFunction = r, e.isTypedArray = o;
    function y($) {
      return typeof Promise < "u" && $ instanceof Promise || $ !== null && typeof $ == "object" && typeof $.then == "function" && typeof $.catch == "function";
    }
    e.isPromise = y;
    function m($) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView($) : o($) || H($);
    }
    e.isArrayBufferView = m;
    function A($) {
      return n($) === "Uint8Array";
    }
    e.isUint8Array = A;
    function E($) {
      return n($) === "Uint8ClampedArray";
    }
    e.isUint8ClampedArray = E;
    function x($) {
      return n($) === "Uint16Array";
    }
    e.isUint16Array = x;
    function z($) {
      return n($) === "Uint32Array";
    }
    e.isUint32Array = z;
    function F($) {
      return n($) === "Int8Array";
    }
    e.isInt8Array = F;
    function j($) {
      return n($) === "Int16Array";
    }
    e.isInt16Array = j;
    function I($) {
      return n($) === "Int32Array";
    }
    e.isInt32Array = I;
    function N($) {
      return n($) === "Float32Array";
    }
    e.isFloat32Array = N;
    function O($) {
      return n($) === "Float64Array";
    }
    e.isFloat64Array = O;
    function R($) {
      return n($) === "BigInt64Array";
    }
    e.isBigInt64Array = R;
    function U($) {
      return n($) === "BigUint64Array";
    }
    e.isBigUint64Array = U;
    function T($) {
      return h($) === "[object Map]";
    }
    T.working = typeof Map < "u" && T(/* @__PURE__ */ new Map());
    function Z($) {
      return typeof Map > "u" ? !1 : T.working ? T($) : $ instanceof Map;
    }
    e.isMap = Z;
    function re($) {
      return h($) === "[object Set]";
    }
    re.working = typeof Set < "u" && re(/* @__PURE__ */ new Set());
    function oe($) {
      return typeof Set > "u" ? !1 : re.working ? re($) : $ instanceof Set;
    }
    e.isSet = oe;
    function ue($) {
      return h($) === "[object WeakMap]";
    }
    ue.working = typeof WeakMap < "u" && ue(/* @__PURE__ */ new WeakMap());
    function ie($) {
      return typeof WeakMap > "u" ? !1 : ue.working ? ue($) : $ instanceof WeakMap;
    }
    e.isWeakMap = ie;
    function de($) {
      return h($) === "[object WeakSet]";
    }
    de.working = typeof WeakSet < "u" && de(/* @__PURE__ */ new WeakSet());
    function me($) {
      return de($);
    }
    e.isWeakSet = me;
    function Se($) {
      return h($) === "[object ArrayBuffer]";
    }
    Se.working = typeof ArrayBuffer < "u" && Se(new ArrayBuffer());
    function De($) {
      return typeof ArrayBuffer > "u" ? !1 : Se.working ? Se($) : $ instanceof ArrayBuffer;
    }
    e.isArrayBuffer = De;
    function q($) {
      return h($) === "[object DataView]";
    }
    q.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && q(new DataView(new ArrayBuffer(1), 0, 1));
    function H($) {
      return typeof DataView > "u" ? !1 : q.working ? q($) : $ instanceof DataView;
    }
    e.isDataView = H;
    var C = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
    function G($) {
      return h($) === "[object SharedArrayBuffer]";
    }
    function V($) {
      return typeof C > "u" ? !1 : (typeof G.working > "u" && (G.working = G(new C())), G.working ? G($) : $ instanceof C);
    }
    e.isSharedArrayBuffer = V;
    function X($) {
      return h($) === "[object AsyncFunction]";
    }
    e.isAsyncFunction = X;
    function Q($) {
      return h($) === "[object Map Iterator]";
    }
    e.isMapIterator = Q;
    function ee($) {
      return h($) === "[object Set Iterator]";
    }
    e.isSetIterator = ee;
    function ne($) {
      return h($) === "[object Generator]";
    }
    e.isGeneratorObject = ne;
    function se($) {
      return h($) === "[object WebAssembly.Module]";
    }
    e.isWebAssemblyCompiledModule = se;
    function ce($) {
      return k($, l);
    }
    e.isNumberObject = ce;
    function le($) {
      return k($, c);
    }
    e.isStringObject = le;
    function he($) {
      return k($, w);
    }
    e.isBooleanObject = he;
    function ye($) {
      return s && k($, g);
    }
    e.isBigIntObject = ye;
    function pe($) {
      return i && k($, v);
    }
    e.isSymbolObject = pe;
    function we($) {
      return ce($) || le($) || he($) || ye($) || pe($);
    }
    e.isBoxedPrimitive = we;
    function Oe($) {
      return typeof Uint8Array < "u" && (De($) || V($));
    }
    e.isAnyArrayBuffer = Oe, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function($) {
      Object.defineProperty(e, $, {
        enumerable: !1,
        value: function() {
          throw new Error($ + " is not supported in userland");
        }
      });
    });
  })(yo)), yo;
}
var mi, Xl;
function Hy() {
  return Xl || (Xl = 1, mi = function(t) {
    return t instanceof J;
  }), mi;
}
var Jl;
function $y() {
  return Jl || (Jl = 1, (function(e) {
    var t = Object.getOwnPropertyDescriptors || function(H) {
      for (var C = Object.keys(H), G = {}, V = 0; V < C.length; V++)
        G[C[V]] = Object.getOwnPropertyDescriptor(H, C[V]);
      return G;
    }, r = /%[sdj%]/g;
    e.format = function(q) {
      if (!F(q)) {
        for (var H = [], C = 0; C < arguments.length; C++)
          H.push(s(arguments[C]));
        return H.join(" ");
      }
      for (var C = 1, G = arguments, V = G.length, X = String(q).replace(r, function(ee) {
        if (ee === "%%") return "%";
        if (C >= V) return ee;
        switch (ee) {
          case "%s":
            return String(G[C++]);
          case "%d":
            return Number(G[C++]);
          case "%j":
            try {
              return JSON.stringify(G[C++]);
            } catch {
              return "[Circular]";
            }
          default:
            return ee;
        }
      }), Q = G[C]; C < V; Q = G[++C])
        E(Q) || !O(Q) ? X += " " + Q : X += " " + s(Q);
      return X;
    }, e.deprecate = function(q, H) {
      if (typeof yr < "u" && yr.noDeprecation === !0)
        return q;
      if (typeof yr > "u")
        return function() {
          return e.deprecate(q, H).apply(this, arguments);
        };
      var C = !1;
      function G() {
        if (!C) {
          if (yr.throwDeprecation)
            throw new Error(H);
          yr.traceDeprecation ? console.trace(H) : console.error(H), C = !0;
        }
        return q.apply(this, arguments);
      }
      return G;
    };
    var n = {}, o = /^$/;
    if (yr.env.NODE_DEBUG) {
      var a = yr.env.NODE_DEBUG;
      a = a.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), o = new RegExp("^" + a + "$", "i");
    }
    e.debuglog = function(q) {
      if (q = q.toUpperCase(), !n[q])
        if (o.test(q)) {
          var H = yr.pid;
          n[q] = function() {
            var C = e.format.apply(e, arguments);
            console.error("%s %d: %s", q, H, C);
          };
        } else
          n[q] = function() {
          };
      return n[q];
    };
    function s(q, H) {
      var C = {
        seen: [],
        stylize: h
      };
      return arguments.length >= 3 && (C.depth = arguments[2]), arguments.length >= 4 && (C.colors = arguments[3]), A(H) ? C.showHidden = H : H && e._extend(C, H), I(C.showHidden) && (C.showHidden = !1), I(C.depth) && (C.depth = 2), I(C.colors) && (C.colors = !1), I(C.customInspect) && (C.customInspect = !0), C.colors && (C.stylize = i), c(C, q, C.depth);
    }
    e.inspect = s, s.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    }, s.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      // "name": intentionally not styling
      regexp: "red"
    };
    function i(q, H) {
      var C = s.styles[H];
      return C ? "\x1B[" + s.colors[C][0] + "m" + q + "\x1B[" + s.colors[C][1] + "m" : q;
    }
    function h(q, H) {
      return q;
    }
    function l(q) {
      var H = {};
      return q.forEach(function(C, G) {
        H[C] = !0;
      }), H;
    }
    function c(q, H, C) {
      if (q.customInspect && H && T(H.inspect) && // Filter out the util module, it's inspect function is special
      H.inspect !== e.inspect && // Also filter out any prototype objects using the circular check.
      !(H.constructor && H.constructor.prototype === H)) {
        var G = H.inspect(C, q);
        return F(G) || (G = c(q, G, C)), G;
      }
      var V = w(q, H);
      if (V)
        return V;
      var X = Object.keys(H), Q = l(X);
      if (q.showHidden && (X = Object.getOwnPropertyNames(H)), U(H) && (X.indexOf("message") >= 0 || X.indexOf("description") >= 0))
        return g(H);
      if (X.length === 0) {
        if (T(H)) {
          var ee = H.name ? ": " + H.name : "";
          return q.stylize("[Function" + ee + "]", "special");
        }
        if (N(H))
          return q.stylize(RegExp.prototype.toString.call(H), "regexp");
        if (R(H))
          return q.stylize(Date.prototype.toString.call(H), "date");
        if (U(H))
          return g(H);
      }
      var ne = "", se = !1, ce = ["{", "}"];
      if (m(H) && (se = !0, ce = ["[", "]"]), T(H)) {
        var le = H.name ? ": " + H.name : "";
        ne = " [Function" + le + "]";
      }
      if (N(H) && (ne = " " + RegExp.prototype.toString.call(H)), R(H) && (ne = " " + Date.prototype.toUTCString.call(H)), U(H) && (ne = " " + g(H)), X.length === 0 && (!se || H.length == 0))
        return ce[0] + ne + ce[1];
      if (C < 0)
        return N(H) ? q.stylize(RegExp.prototype.toString.call(H), "regexp") : q.stylize("[Object]", "special");
      q.seen.push(H);
      var he;
      return se ? he = v(q, H, C, Q, X) : he = X.map(function(ye) {
        return k(q, H, C, Q, ye, se);
      }), q.seen.pop(), y(he, ne, ce);
    }
    function w(q, H) {
      if (I(H))
        return q.stylize("undefined", "undefined");
      if (F(H)) {
        var C = "'" + JSON.stringify(H).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return q.stylize(C, "string");
      }
      if (z(H))
        return q.stylize("" + H, "number");
      if (A(H))
        return q.stylize("" + H, "boolean");
      if (E(H))
        return q.stylize("null", "null");
    }
    function g(q) {
      return "[" + Error.prototype.toString.call(q) + "]";
    }
    function v(q, H, C, G, V) {
      for (var X = [], Q = 0, ee = H.length; Q < ee; ++Q)
        de(H, String(Q)) ? X.push(k(
          q,
          H,
          C,
          G,
          String(Q),
          !0
        )) : X.push("");
      return V.forEach(function(ne) {
        ne.match(/^\d+$/) || X.push(k(
          q,
          H,
          C,
          G,
          ne,
          !0
        ));
      }), X;
    }
    function k(q, H, C, G, V, X) {
      var Q, ee, ne;
      if (ne = Object.getOwnPropertyDescriptor(H, V) || { value: H[V] }, ne.get ? ne.set ? ee = q.stylize("[Getter/Setter]", "special") : ee = q.stylize("[Getter]", "special") : ne.set && (ee = q.stylize("[Setter]", "special")), de(G, V) || (Q = "[" + V + "]"), ee || (q.seen.indexOf(ne.value) < 0 ? (E(C) ? ee = c(q, ne.value, null) : ee = c(q, ne.value, C - 1), ee.indexOf(`
`) > -1 && (X ? ee = ee.split(`
`).map(function(se) {
        return "  " + se;
      }).join(`
`).slice(2) : ee = `
` + ee.split(`
`).map(function(se) {
        return "   " + se;
      }).join(`
`))) : ee = q.stylize("[Circular]", "special")), I(Q)) {
        if (X && V.match(/^\d+$/))
          return ee;
        Q = JSON.stringify("" + V), Q.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (Q = Q.slice(1, -1), Q = q.stylize(Q, "name")) : (Q = Q.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), Q = q.stylize(Q, "string"));
      }
      return Q + ": " + ee;
    }
    function y(q, H, C) {
      var G = q.reduce(function(V, X) {
        return X.indexOf(`
`) >= 0, V + X.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return G > 60 ? C[0] + (H === "" ? "" : H + `
 `) + " " + q.join(`,
  `) + " " + C[1] : C[0] + H + " " + q.join(", ") + " " + C[1];
    }
    e.types = Ky();
    function m(q) {
      return Array.isArray(q);
    }
    e.isArray = m;
    function A(q) {
      return typeof q == "boolean";
    }
    e.isBoolean = A;
    function E(q) {
      return q === null;
    }
    e.isNull = E;
    function x(q) {
      return q == null;
    }
    e.isNullOrUndefined = x;
    function z(q) {
      return typeof q == "number";
    }
    e.isNumber = z;
    function F(q) {
      return typeof q == "string";
    }
    e.isString = F;
    function j(q) {
      return typeof q == "symbol";
    }
    e.isSymbol = j;
    function I(q) {
      return q === void 0;
    }
    e.isUndefined = I;
    function N(q) {
      return O(q) && re(q) === "[object RegExp]";
    }
    e.isRegExp = N, e.types.isRegExp = N;
    function O(q) {
      return typeof q == "object" && q !== null;
    }
    e.isObject = O;
    function R(q) {
      return O(q) && re(q) === "[object Date]";
    }
    e.isDate = R, e.types.isDate = R;
    function U(q) {
      return O(q) && (re(q) === "[object Error]" || q instanceof Error);
    }
    e.isError = U, e.types.isNativeError = U;
    function T(q) {
      return typeof q == "function";
    }
    e.isFunction = T;
    function Z(q) {
      return q === null || typeof q == "boolean" || typeof q == "number" || typeof q == "string" || typeof q == "symbol" || // ES6 symbol
      typeof q > "u";
    }
    e.isPrimitive = Z, e.isBuffer = Hy();
    function re(q) {
      return Object.prototype.toString.call(q);
    }
    function oe(q) {
      return q < 10 ? "0" + q.toString(10) : q.toString(10);
    }
    var ue = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function ie() {
      var q = /* @__PURE__ */ new Date(), H = [
        oe(q.getHours()),
        oe(q.getMinutes()),
        oe(q.getSeconds())
      ].join(":");
      return [q.getDate(), ue[q.getMonth()], H].join(" ");
    }
    e.log = function() {
      console.log("%s - %s", ie(), e.format.apply(e, arguments));
    }, e.inherits = Et(), e._extend = function(q, H) {
      if (!H || !O(H)) return q;
      for (var C = Object.keys(H), G = C.length; G--; )
        q[C[G]] = H[C[G]];
      return q;
    };
    function de(q, H) {
      return Object.prototype.hasOwnProperty.call(q, H);
    }
    var me = typeof Symbol < "u" ? /* @__PURE__ */ Symbol("util.promisify.custom") : void 0;
    e.promisify = function(H) {
      if (typeof H != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (me && H[me]) {
        var C = H[me];
        if (typeof C != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(C, me, {
          value: C,
          enumerable: !1,
          writable: !1,
          configurable: !0
        }), C;
      }
      function C() {
        for (var G, V, X = new Promise(function(ne, se) {
          G = ne, V = se;
        }), Q = [], ee = 0; ee < arguments.length; ee++)
          Q.push(arguments[ee]);
        Q.push(function(ne, se) {
          ne ? V(ne) : G(se);
        });
        try {
          H.apply(this, Q);
        } catch (ne) {
          V(ne);
        }
        return X;
      }
      return Object.setPrototypeOf(C, Object.getPrototypeOf(H)), me && Object.defineProperty(C, me, {
        value: C,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Object.defineProperties(
        C,
        t(H)
      );
    }, e.promisify.custom = me;
    function Se(q, H) {
      if (!q) {
        var C = new Error("Promise was rejected with a falsy value");
        C.reason = q, q = C;
      }
      return H(q);
    }
    function De(q) {
      if (typeof q != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function H() {
        for (var C = [], G = 0; G < arguments.length; G++)
          C.push(arguments[G]);
        var V = C.pop();
        if (typeof V != "function")
          throw new TypeError("The last argument must be of type Function");
        var X = this, Q = function() {
          return V.apply(X, arguments);
        };
        q.apply(this, C).then(
          function(ee) {
            yr.nextTick(Q.bind(null, null, ee));
          },
          function(ee) {
            yr.nextTick(Se.bind(null, ee, Q));
          }
        );
      }
      return Object.setPrototypeOf(H, Object.getPrototypeOf(q)), Object.defineProperties(
        H,
        t(q)
      ), H;
    }
    e.callbackify = De;
  })(mo)), mo;
}
var Xn = { exports: {} }, Ql;
function Gy() {
  return Ql || (Ql = 1, typeof Object.create == "function" ? Xn.exports = function(t, r) {
    r && (t.super_ = r, t.prototype = Object.create(r.prototype, {
      constructor: {
        value: t,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : Xn.exports = function(t, r) {
    if (r) {
      t.super_ = r;
      var n = function() {
      };
      n.prototype = r.prototype, t.prototype = new n(), t.prototype.constructor = t;
    }
  }), Xn.exports;
}
var ef;
function Et() {
  if (ef) return Yn.exports;
  ef = 1;
  try {
    var e = $y();
    if (typeof e.inherits != "function") throw "";
    Yn.exports = e.inherits;
  } catch {
    Yn.exports = Gy();
  }
  return Yn.exports;
}
var yi, rf;
function Wy() {
  if (rf) return yi;
  rf = 1;
  var e = {}.toString;
  return yi = Array.isArray || function(t) {
    return e.call(t) == "[object Array]";
  }, yi;
}
var vi, tf;
function Vy() {
  if (tf) return vi;
  tf = 1;
  var e = /* @__PURE__ */ Gt(), t = /* @__PURE__ */ Vt(), r = t("TypedArray.prototype.buffer", !0), n = /* @__PURE__ */ Xd();
  return vi = r || function(a) {
    if (!n(a))
      throw new e("Not a Typed Array");
    return a.buffer;
  }, vi;
}
var wi, nf;
function Zy() {
  if (nf) return wi;
  nf = 1;
  var e = Sr().Buffer, t = Wy(), r = /* @__PURE__ */ Vy(), n = ArrayBuffer.isView || function(h) {
    try {
      return r(h), !0;
    } catch {
      return !1;
    }
  }, o = typeof Uint8Array < "u", a = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", s = a && (e.prototype instanceof Uint8Array || e.TYPED_ARRAY_SUPPORT);
  return wi = function(h, l) {
    if (e.isBuffer(h))
      return h.constructor && !("isBuffer" in h) ? e.from(h) : h;
    if (typeof h == "string")
      return e.from(h, l);
    if (a && n(h)) {
      if (h.byteLength === 0)
        return e.alloc(0);
      if (s) {
        var c = e.from(h.buffer, h.byteOffset, h.byteLength);
        if (c.byteLength === h.byteLength)
          return c;
      }
      var w = h instanceof Uint8Array ? h : new Uint8Array(h.buffer, h.byteOffset, h.byteLength), g = e.from(w);
      if (g.length === h.byteLength)
        return g;
    }
    if (o && h instanceof Uint8Array)
      return e.from(h);
    var v = t(h);
    if (v)
      for (var k = 0; k < h.length; k += 1) {
        var y = h[k];
        if (typeof y != "number" || y < 0 || y > 255 || ~~y !== y)
          throw new RangeError("Array items must be numbers in the range 0-255.");
      }
    if (v || e.isBuffer(h) && h.constructor && typeof h.constructor.isBuffer == "function" && h.constructor.isBuffer(h))
      return e.from(h);
    throw new TypeError('The "data" argument must be a string, an Array, a Buffer, a Uint8Array, or a DataView.');
  }, wi;
}
var _i, af;
function Zt() {
  if (af) return _i;
  af = 1;
  var e = Sr().Buffer, t = /* @__PURE__ */ Zy();
  function r(n, o) {
    this._block = e.alloc(n), this._finalSize = o, this._blockSize = n, this._len = 0;
  }
  return r.prototype.update = function(n, o) {
    n = t(n, o || "utf8");
    for (var a = this._block, s = this._blockSize, i = n.length, h = this._len, l = 0; l < i; ) {
      for (var c = h % s, w = Math.min(i - l, s - c), g = 0; g < w; g++)
        a[c + g] = n[l + g];
      h += w, l += w, h % s === 0 && this._update(a);
    }
    return this._len += i, this;
  }, r.prototype.digest = function(n) {
    var o = this._len % this._blockSize;
    this._block[o] = 128, this._block.fill(0, o + 1), o >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var a = this._len * 8;
    if (a <= 4294967295)
      this._block.writeUInt32BE(a, this._blockSize - 4);
    else {
      var s = (a & 4294967295) >>> 0, i = (a - s) / 4294967296;
      this._block.writeUInt32BE(i, this._blockSize - 8), this._block.writeUInt32BE(s, this._blockSize - 4);
    }
    this._update(this._block);
    var h = this._hash();
    return n ? h.toString(n) : h;
  }, r.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  }, _i = r, _i;
}
var ki, of;
function Yy() {
  if (of) return ki;
  of = 1;
  var e = Et(), t = Zt(), r = Sr().Buffer, n = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], o = new Array(80);
  function a() {
    this.init(), this._w = o, t.call(this, 64, 56);
  }
  e(a, t), a.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function s(l) {
    return l << 5 | l >>> 27;
  }
  function i(l) {
    return l << 30 | l >>> 2;
  }
  function h(l, c, w, g) {
    return l === 0 ? c & w | ~c & g : l === 2 ? c & w | c & g | w & g : c ^ w ^ g;
  }
  return a.prototype._update = function(l) {
    for (var c = this._w, w = this._a | 0, g = this._b | 0, v = this._c | 0, k = this._d | 0, y = this._e | 0, m = 0; m < 16; ++m)
      c[m] = l.readInt32BE(m * 4);
    for (; m < 80; ++m)
      c[m] = c[m - 3] ^ c[m - 8] ^ c[m - 14] ^ c[m - 16];
    for (var A = 0; A < 80; ++A) {
      var E = ~~(A / 20), x = s(w) + h(E, g, v, k) + y + c[A] + n[E] | 0;
      y = k, k = v, v = i(g), g = w, w = x;
    }
    this._a = w + this._a | 0, this._b = g + this._b | 0, this._c = v + this._c | 0, this._d = k + this._d | 0, this._e = y + this._e | 0;
  }, a.prototype._hash = function() {
    var l = r.allocUnsafe(20);
    return l.writeInt32BE(this._a | 0, 0), l.writeInt32BE(this._b | 0, 4), l.writeInt32BE(this._c | 0, 8), l.writeInt32BE(this._d | 0, 12), l.writeInt32BE(this._e | 0, 16), l;
  }, ki = a, ki;
}
var Ei, sf;
function Xy() {
  if (sf) return Ei;
  sf = 1;
  var e = Et(), t = Zt(), r = Sr().Buffer, n = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], o = new Array(80);
  function a() {
    this.init(), this._w = o, t.call(this, 64, 56);
  }
  e(a, t), a.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function s(c) {
    return c << 1 | c >>> 31;
  }
  function i(c) {
    return c << 5 | c >>> 27;
  }
  function h(c) {
    return c << 30 | c >>> 2;
  }
  function l(c, w, g, v) {
    return c === 0 ? w & g | ~w & v : c === 2 ? w & g | w & v | g & v : w ^ g ^ v;
  }
  return a.prototype._update = function(c) {
    for (var w = this._w, g = this._a | 0, v = this._b | 0, k = this._c | 0, y = this._d | 0, m = this._e | 0, A = 0; A < 16; ++A)
      w[A] = c.readInt32BE(A * 4);
    for (; A < 80; ++A)
      w[A] = s(w[A - 3] ^ w[A - 8] ^ w[A - 14] ^ w[A - 16]);
    for (var E = 0; E < 80; ++E) {
      var x = ~~(E / 20), z = i(g) + l(x, v, k, y) + m + w[E] + n[x] | 0;
      m = y, y = k, k = h(v), v = g, g = z;
    }
    this._a = g + this._a | 0, this._b = v + this._b | 0, this._c = k + this._c | 0, this._d = y + this._d | 0, this._e = m + this._e | 0;
  }, a.prototype._hash = function() {
    var c = r.allocUnsafe(20);
    return c.writeInt32BE(this._a | 0, 0), c.writeInt32BE(this._b | 0, 4), c.writeInt32BE(this._c | 0, 8), c.writeInt32BE(this._d | 0, 12), c.writeInt32BE(this._e | 0, 16), c;
  }, Ei = a, Ei;
}
var xi, cf;
function Jd() {
  if (cf) return xi;
  cf = 1;
  var e = Et(), t = Zt(), r = Sr().Buffer, n = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ], o = new Array(64);
  function a() {
    this.init(), this._w = o, t.call(this, 64, 56);
  }
  e(a, t), a.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
  };
  function s(g, v, k) {
    return k ^ g & (v ^ k);
  }
  function i(g, v, k) {
    return g & v | k & (g | v);
  }
  function h(g) {
    return (g >>> 2 | g << 30) ^ (g >>> 13 | g << 19) ^ (g >>> 22 | g << 10);
  }
  function l(g) {
    return (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7);
  }
  function c(g) {
    return (g >>> 7 | g << 25) ^ (g >>> 18 | g << 14) ^ g >>> 3;
  }
  function w(g) {
    return (g >>> 17 | g << 15) ^ (g >>> 19 | g << 13) ^ g >>> 10;
  }
  return a.prototype._update = function(g) {
    for (var v = this._w, k = this._a | 0, y = this._b | 0, m = this._c | 0, A = this._d | 0, E = this._e | 0, x = this._f | 0, z = this._g | 0, F = this._h | 0, j = 0; j < 16; ++j)
      v[j] = g.readInt32BE(j * 4);
    for (; j < 64; ++j)
      v[j] = w(v[j - 2]) + v[j - 7] + c(v[j - 15]) + v[j - 16] | 0;
    for (var I = 0; I < 64; ++I) {
      var N = F + l(E) + s(E, x, z) + n[I] + v[I] | 0, O = h(k) + i(k, y, m) | 0;
      F = z, z = x, x = E, E = A + N | 0, A = m, m = y, y = k, k = N + O | 0;
    }
    this._a = k + this._a | 0, this._b = y + this._b | 0, this._c = m + this._c | 0, this._d = A + this._d | 0, this._e = E + this._e | 0, this._f = x + this._f | 0, this._g = z + this._g | 0, this._h = F + this._h | 0;
  }, a.prototype._hash = function() {
    var g = r.allocUnsafe(32);
    return g.writeInt32BE(this._a, 0), g.writeInt32BE(this._b, 4), g.writeInt32BE(this._c, 8), g.writeInt32BE(this._d, 12), g.writeInt32BE(this._e, 16), g.writeInt32BE(this._f, 20), g.writeInt32BE(this._g, 24), g.writeInt32BE(this._h, 28), g;
  }, xi = a, xi;
}
var Ai, uf;
function Jy() {
  if (uf) return Ai;
  uf = 1;
  var e = Et(), t = Jd(), r = Zt(), n = Sr().Buffer, o = new Array(64);
  function a() {
    this.init(), this._w = o, r.call(this, 64, 56);
  }
  return e(a, t), a.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
  }, a.prototype._hash = function() {
    var s = n.allocUnsafe(28);
    return s.writeInt32BE(this._a, 0), s.writeInt32BE(this._b, 4), s.writeInt32BE(this._c, 8), s.writeInt32BE(this._d, 12), s.writeInt32BE(this._e, 16), s.writeInt32BE(this._f, 20), s.writeInt32BE(this._g, 24), s;
  }, Ai = a, Ai;
}
var Si, lf;
function Qd() {
  if (lf) return Si;
  lf = 1;
  var e = Et(), t = Zt(), r = Sr().Buffer, n = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ], o = new Array(160);
  function a() {
    this.init(), this._w = o, t.call(this, 128, 112);
  }
  e(a, t), a.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
  };
  function s(y, m, A) {
    return A ^ y & (m ^ A);
  }
  function i(y, m, A) {
    return y & m | A & (y | m);
  }
  function h(y, m) {
    return (y >>> 28 | m << 4) ^ (m >>> 2 | y << 30) ^ (m >>> 7 | y << 25);
  }
  function l(y, m) {
    return (y >>> 14 | m << 18) ^ (y >>> 18 | m << 14) ^ (m >>> 9 | y << 23);
  }
  function c(y, m) {
    return (y >>> 1 | m << 31) ^ (y >>> 8 | m << 24) ^ y >>> 7;
  }
  function w(y, m) {
    return (y >>> 1 | m << 31) ^ (y >>> 8 | m << 24) ^ (y >>> 7 | m << 25);
  }
  function g(y, m) {
    return (y >>> 19 | m << 13) ^ (m >>> 29 | y << 3) ^ y >>> 6;
  }
  function v(y, m) {
    return (y >>> 19 | m << 13) ^ (m >>> 29 | y << 3) ^ (y >>> 6 | m << 26);
  }
  function k(y, m) {
    return y >>> 0 < m >>> 0 ? 1 : 0;
  }
  return a.prototype._update = function(y) {
    for (var m = this._w, A = this._ah | 0, E = this._bh | 0, x = this._ch | 0, z = this._dh | 0, F = this._eh | 0, j = this._fh | 0, I = this._gh | 0, N = this._hh | 0, O = this._al | 0, R = this._bl | 0, U = this._cl | 0, T = this._dl | 0, Z = this._el | 0, re = this._fl | 0, oe = this._gl | 0, ue = this._hl | 0, ie = 0; ie < 32; ie += 2)
      m[ie] = y.readInt32BE(ie * 4), m[ie + 1] = y.readInt32BE(ie * 4 + 4);
    for (; ie < 160; ie += 2) {
      var de = m[ie - 30], me = m[ie - 30 + 1], Se = c(de, me), De = w(me, de);
      de = m[ie - 4], me = m[ie - 4 + 1];
      var q = g(de, me), H = v(me, de), C = m[ie - 14], G = m[ie - 14 + 1], V = m[ie - 32], X = m[ie - 32 + 1], Q = De + G | 0, ee = Se + C + k(Q, De) | 0;
      Q = Q + H | 0, ee = ee + q + k(Q, H) | 0, Q = Q + X | 0, ee = ee + V + k(Q, X) | 0, m[ie] = ee, m[ie + 1] = Q;
    }
    for (var ne = 0; ne < 160; ne += 2) {
      ee = m[ne], Q = m[ne + 1];
      var se = i(A, E, x), ce = i(O, R, U), le = h(A, O), he = h(O, A), ye = l(F, Z), pe = l(Z, F), we = n[ne], Oe = n[ne + 1], $ = s(F, j, I), Re = s(Z, re, oe), ae = ue + pe | 0, fe = N + ye + k(ae, ue) | 0;
      ae = ae + Re | 0, fe = fe + $ + k(ae, Re) | 0, ae = ae + Oe | 0, fe = fe + we + k(ae, Oe) | 0, ae = ae + Q | 0, fe = fe + ee + k(ae, Q) | 0;
      var ge = he + ce | 0, xe = le + se + k(ge, he) | 0;
      N = I, ue = oe, I = j, oe = re, j = F, re = Z, Z = T + ae | 0, F = z + fe + k(Z, T) | 0, z = x, T = U, x = E, U = R, E = A, R = O, O = ae + ge | 0, A = fe + xe + k(O, ae) | 0;
    }
    this._al = this._al + O | 0, this._bl = this._bl + R | 0, this._cl = this._cl + U | 0, this._dl = this._dl + T | 0, this._el = this._el + Z | 0, this._fl = this._fl + re | 0, this._gl = this._gl + oe | 0, this._hl = this._hl + ue | 0, this._ah = this._ah + A + k(this._al, O) | 0, this._bh = this._bh + E + k(this._bl, R) | 0, this._ch = this._ch + x + k(this._cl, U) | 0, this._dh = this._dh + z + k(this._dl, T) | 0, this._eh = this._eh + F + k(this._el, Z) | 0, this._fh = this._fh + j + k(this._fl, re) | 0, this._gh = this._gh + I + k(this._gl, oe) | 0, this._hh = this._hh + N + k(this._hl, ue) | 0;
  }, a.prototype._hash = function() {
    var y = r.allocUnsafe(64);
    function m(A, E, x) {
      y.writeInt32BE(A, x), y.writeInt32BE(E, x + 4);
    }
    return m(this._ah, this._al, 0), m(this._bh, this._bl, 8), m(this._ch, this._cl, 16), m(this._dh, this._dl, 24), m(this._eh, this._el, 32), m(this._fh, this._fl, 40), m(this._gh, this._gl, 48), m(this._hh, this._hl, 56), y;
  }, Si = a, Si;
}
var Ii, ff;
function Qy() {
  if (ff) return Ii;
  ff = 1;
  var e = Et(), t = Qd(), r = Zt(), n = Sr().Buffer, o = new Array(160);
  function a() {
    this.init(), this._w = o, r.call(this, 128, 112);
  }
  return e(a, t), a.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
  }, a.prototype._hash = function() {
    var s = n.allocUnsafe(48);
    function i(h, l, c) {
      s.writeInt32BE(h, c), s.writeInt32BE(l, c + 4);
    }
    return i(this._ah, this._al, 0), i(this._bh, this._bl, 8), i(this._ch, this._cl, 16), i(this._dh, this._dl, 24), i(this._eh, this._el, 32), i(this._fh, this._fl, 40), s;
  }, Ii = a, Ii;
}
var df;
function ev() {
  return df || (df = 1, (function(e) {
    e.exports = function(r) {
      var n = r.toLowerCase(), o = e.exports[n];
      if (!o)
        throw new Error(n + " is not supported (we accept pull requests)");
      return new o();
    }, e.exports.sha = Yy(), e.exports.sha1 = Xy(), e.exports.sha224 = Jy(), e.exports.sha256 = Jd(), e.exports.sha384 = Qy(), e.exports.sha512 = Qd();
  })(bo)), bo.exports;
}
var rv = ev();
const kv = /* @__PURE__ */ Ea(rv);
export {
  J as B,
  wv as L,
  iv as a,
  dv as b,
  Ug as c,
  cv as d,
  fv as e,
  sv as f,
  mv as g,
  _m as h,
  uv as i,
  bv as j,
  Rd as k,
  nd as l,
  _v as m,
  kv as n,
  hv as p,
  vv as s,
  lv as t,
  gv as u,
  pv as v
};
